var z3 = Object.defineProperty;
var lG = Object.getPrototypeOf;
var rG = Reflect.get;
var H3 = (i) => {
  throw TypeError(i);
};
var oG = (i, e, t) => e in i ? z3(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var u = (i, e) => z3(i, "name", { value: e, configurable: !0 });
var qe = (i, e, t) => oG(i, typeof e != "symbol" ? e + "" : e, t), Ig = (i, e, t) => e.has(i) || H3("Cannot " + t);
var P = (i, e, t) => (Ig(i, e, "read from private field"), t ? t.call(i) : e.get(i)), x = (i, e, t) => e.has(i) ? H3("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, t), Ae = (i, e, t, s) => (Ig(i, e, "write to private field"), s ? s.call(i, t) : e.set(i, t), t), X = (i, e, t) => (Ig(i, e, "access private method"), t);
var Pg = (i, e, t, s) => ({
  set _(n) {
    Ae(i, e, n, t);
  },
  get _() {
    return P(i, e, s);
  }
}), Mg = (i, e, t) => rG(lG(i), t, e);
function U3(i, e, t) {
  typeof t.value == "object" && (t.value = gr(t.value)), !t.enumerable || t.get || t.set || !t.configurable || !t.writable || e === "__proto__" ? Object.defineProperty(i, e, t) : i[e] = t.value;
}
u(U3, "set");
function gr(i) {
  if (typeof i != "object") return i;
  var e = 0, t, s, n, l = Object.prototype.toString.call(i);
  if (l === "[object Object]" ? n = Object.create(i.__proto__ || null) : l === "[object Array]" ? n = Array(i.length) : l === "[object Set]" ? (n = /* @__PURE__ */ new Set(), i.forEach(function(r) {
    n.add(gr(r));
  })) : l === "[object Map]" ? (n = /* @__PURE__ */ new Map(), i.forEach(function(r, o) {
    n.set(gr(o), gr(r));
  })) : l === "[object Date]" ? n = /* @__PURE__ */ new Date(+i) : l === "[object RegExp]" ? n = new RegExp(i.source, i.flags) : l === "[object DataView]" ? n = new i.constructor(gr(i.buffer)) : l === "[object ArrayBuffer]" ? n = i.slice(0) : l.slice(-6) === "Array]" && (n = new i.constructor(i)), n) {
    for (s = Object.getOwnPropertySymbols(i); e < s.length; e++)
      U3(n, s[e], Object.getOwnPropertyDescriptor(i, s[e]));
    for (e = 0, s = Object.getOwnPropertyNames(i); e < s.length; e++)
      Object.hasOwnProperty.call(n, t = s[e]) && n[t] === i[t] || U3(n, t, Object.getOwnPropertyDescriptor(i, t));
  }
  return n || i;
}
u(gr, "klona");
const Kg = "[object Object]";
function tl(i = {}, ...e) {
  if (Object.prototype.toString.call(i) !== Kg)
    throw new TypeError("deepMerge error: 'target' is not an 'object'.");
  for (let t = 0; t < e.length; t++)
    if (Object.prototype.toString.call(e[t]) !== Kg)
      throw new TypeError(`deepMerge error: 'sourceObj[${t}]' is not an 'object'.`);
  return Y7(i, ...e);
}
u(tl, "deepMerge");
function ad(i, e) {
  if (typeof i != "object" || i === null || i === void 0)
    return !1;
  const t = Object.getOwnPropertyDescriptor(i, e);
  if (t !== void 0 && t.get !== void 0)
    return !0;
  for (let s = Object.getPrototypeOf(i); s; s = Object.getPrototypeOf(s)) {
    const n = Object.getOwnPropertyDescriptor(s, e);
    if (n !== void 0 && n.get !== void 0)
      return !0;
  }
  return !1;
}
u(ad, "hasGetter");
function V3(i, e) {
  if (typeof i != "function")
    return !1;
  if (i === e)
    return !0;
  for (let t = Object.getPrototypeOf(i); t; t = Object.getPrototypeOf(t))
    if (t === e)
      return !0;
  return !1;
}
u(V3, "hasPrototype");
function Nt(i) {
  return i == null || typeof i != "object" ? !1 : Symbol.iterator in i;
}
u(Nt, "isIterable");
function he(i) {
  return i !== null && typeof i == "object" && !Array.isArray(i);
}
u(he, "isObject");
function W7(i) {
  if (Object.prototype.toString.call(i) !== Kg)
    return !1;
  const e = Object.getPrototypeOf(i);
  return e === null || e === Object.prototype;
}
u(W7, "isPlainObject");
function cu(i, e, t) {
  if (typeof i != "object" || typeof e != "string")
    return t;
  const s = e.split(".");
  for (let n = 0; n < s.length; n++) {
    if (typeof i[s[n]] > "u" || i[s[n]] === null)
      return t;
    i = i[s[n]];
  }
  return i;
}
u(cu, "safeAccess");
function K7(i, e, t, s = "set", n = !0) {
  if (typeof i != "object")
    throw new TypeError("safeSet error: 'data' is not an 'object'.");
  if (typeof e != "string")
    throw new TypeError("safeSet error: 'accessor' is not a 'string'.");
  const l = e.split(".");
  for (let r = 0; r < l.length; r++) {
    if (Array.isArray(i)) {
      const o = +l[r];
      if (!Number.isInteger(o) || o < 0)
        return !1;
    }
    if (r === l.length - 1)
      switch (s) {
        case "add":
          i[l[r]] += t;
          break;
        case "div":
          i[l[r]] /= t;
          break;
        case "mult":
          i[l[r]] *= t;
          break;
        case "set":
          i[l[r]] = t;
          break;
        case "set-undefined":
          typeof i[l[r]] > "u" && (i[l[r]] = t);
          break;
        case "sub":
          i[l[r]] -= t;
          break;
      }
    else {
      if (n && typeof i[l[r]] > "u" && (i[l[r]] = {}), i[l[r]] === null || typeof i[l[r]] != "object")
        return !1;
      i = i[l[r]];
    }
  }
  return !0;
}
u(K7, "safeSet");
function Y7(i = {}, ...e) {
  var t, s;
  for (let n = 0; n < e.length; n++) {
    const l = e[n];
    for (const r in l)
      if (Object.prototype.hasOwnProperty.call(l, r)) {
        if (r.startsWith("-=")) {
          delete i[r.slice(2)];
          continue;
        }
        i[r] = Object.prototype.hasOwnProperty.call(i, r) && ((t = i[r]) == null ? void 0 : t.constructor) === Object && ((s = l[r]) == null ? void 0 : s.constructor) === Object ? Y7({}, i[r], l[r]) : l[r];
      }
  }
  return i;
}
u(Y7, "_deepMerge");
function K(i, e) {
  const t = he(e) ? globalThis.game.i18n.format(i, e) : globalThis.game.i18n.localize(i);
  return t !== void 0 ? t : "";
}
u(K, "localize");
const Q5 = class Q5 extends TokenHUD {
  /** @override */
  getData() {
    var n, l, r, o;
    const e = foundry.utils.mergeObject(super.getData(), {
      AC: ((o = (r = (l = (n = this.object.actor) == null ? void 0 : n.system) == null ? void 0 : l.attributes) == null ? void 0 : r.ac) == null ? void 0 : o.value) ?? 10
    }), [t, s] = Object.entries(e.statusEffects).reduce(
      (a, [c, f]) => (f.id.includes("generic") ? a[0][c] = f : a[1][c] = f, a),
      [{}, {}]
    );
    return e.statusEffects = s, e.genericConditions = t, e;
  }
  /** @override */
  get template() {
    return "systems/a5e/templates/hud/token-hud.hbs";
  }
  /** @override */
  activateListeners(e) {
    super.activateListeners(e), e.find(".clear-all-conditions").click(this._clearAllConditions.bind(this));
  }
  /** @override */
  _getStatusEffectChoices() {
    return CONFIG.statusEffects = CONFIG.statusEffects.sort((e, t) => {
      const s = e.label !== void 0 ? K(e.label) : e.id || e, n = t.label !== void 0 ? K(t.label) : t.id || t;
      return s > n ? 1 : s < n ? -1 : 0;
    }), super._getStatusEffectChoices();
  }
  /**
   * Removes all conditions on the current object
   * @param {*} event
   */
  async _clearAllConditions(e) {
    e.preventDefault(), e.stopPropagation();
    const t = [], s = CONFIG.statusEffects;
    for (const n of s) {
      const l = this.object.actor.effects.reduce((r, o) => (o.statuses.size === 1 && o.statuses.has(n.id) && r.push(o.id), r), []);
      l.length && t.push(...l);
    }
    this.object.actor.deleteEmbeddedDocuments("ActiveEffect", t), this.object.actor.update({
      "system.attributes.fatigue": 0,
      "system.attributes.strife": 0,
      "flags.a5e.autoApplyFSConditions": !1
    });
  }
  /**
   * Destroy svelte components when the HUD is closed
   */
  clear() {
    var e;
    super.clear(), (e = this == null ? void 0 : this._svelteComponent) != null && e.$destroy && (this._svelteComponent.$destroy(), this._svelteComponent = null);
  }
};
u(Q5, "TokenHUDA5e");
let Yg = Q5;
function aG() {
  game.canvas.hud.token = new Yg();
}
u(aG, "canvasInit");
function se() {
}
u(se, "noop");
const Ec = /* @__PURE__ */ u((i) => i, "identity");
function Dt(i, e) {
  for (const t in e) i[t] = e[t];
  return (
    /** @type {T & S} */
    i
  );
}
u(Dt, "assign");
function X7(i) {
  return i();
}
u(X7, "run");
function W3() {
  return /* @__PURE__ */ Object.create(null);
}
u(W3, "blank_object");
function Me(i) {
  i.forEach(X7);
}
u(Me, "run_all");
function $t(i) {
  return typeof i == "function";
}
u($t, "is_function");
function le(i, e) {
  return i != i ? e == e : i !== e || i && typeof i == "object" || typeof i == "function";
}
u(le, "safe_not_equal");
let cd;
function ze(i, e) {
  return i === e ? !0 : (cd || (cd = document.createElement("a")), cd.href = e, i === cd.href);
}
u(ze, "src_url_equal");
function cG(i) {
  return Object.keys(i).length === 0;
}
u(cG, "is_empty");
function Xt(i, ...e) {
  if (i == null) {
    for (const s of e)
      s(void 0);
    return se;
  }
  const t = i.subscribe(...e);
  return t.unsubscribe ? () => t.unsubscribe() : t;
}
u(Xt, "subscribe");
function Bn(i) {
  let e;
  return Xt(i, (t) => e = t)(), e;
}
u(Bn, "get_store_value");
function pe(i, e, t) {
  i.$$.on_destroy.push(Xt(e, t));
}
u(pe, "component_subscribe");
function Gt(i, e, t, s) {
  if (i) {
    const n = J7(i, e, t, s);
    return i[0](n);
  }
}
u(Gt, "create_slot");
function J7(i, e, t, s) {
  return i[1] && s ? Dt(t.ctx.slice(), i[1](s(e))) : t.ctx;
}
u(J7, "get_slot_context");
function zt(i, e, t, s) {
  if (i[2] && s) {
    const n = i[2](s(t));
    if (e.dirty === void 0)
      return n;
    if (typeof n == "object") {
      const l = [], r = Math.max(e.dirty.length, n.length);
      for (let o = 0; o < r; o += 1)
        l[o] = e.dirty[o] | n[o];
      return l;
    }
    return e.dirty | n;
  }
  return e.dirty;
}
u(zt, "get_slot_changes");
function Ht(i, e, t, s, n, l) {
  if (n) {
    const r = J7(e, t, s, l);
    i.p(r, n);
  }
}
u(Ht, "update_slot_base");
function Ut(i) {
  if (i.ctx.length > 32) {
    const e = [], t = i.ctx.length / 32;
    for (let s = 0; s < t; s++)
      e[s] = -1;
    return e;
  }
  return -1;
}
u(Ut, "get_all_dirty_from_scope");
function K3(i) {
  const e = {};
  for (const t in i) t[0] !== "$" && (e[t] = i[t]);
  return e;
}
u(K3, "exclude_internal_props");
function O5(i) {
  const e = {};
  for (const t in i)
    e[t] = !0;
  return e;
}
u(O5, "compute_slots");
function di(i) {
  return i ?? "";
}
u(di, "null_to_empty");
function wo(i, e, t) {
  return i.set(t), e;
}
u(wo, "set_store_value");
function Et(i) {
  return i && $t(i.destroy) ? i.destroy : se;
}
u(Et, "action_destroyer");
const Z7 = typeof window < "u";
let uu = Z7 ? () => window.performance.now() : () => Date.now(), D5 = Z7 ? (i) => requestAnimationFrame(i) : se;
const Ho = /* @__PURE__ */ new Set();
function Q7(i) {
  Ho.forEach((e) => {
    e.c(i) || (Ho.delete(e), e.f());
  }), Ho.size !== 0 && D5(Q7);
}
u(Q7, "run_tasks");
function rg(i) {
  let e;
  return Ho.size === 0 && D5(Q7), {
    promise: new Promise((t) => {
      Ho.add(e = { c: i, f: t });
    }),
    abort() {
      Ho.delete(e);
    }
  };
}
u(rg, "loop");
const x7 = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);
function A(i, e) {
  i.appendChild(e);
}
u(A, "append");
function eL(i) {
  if (!i) return document;
  const e = i.getRootNode ? i.getRootNode() : i.ownerDocument;
  return e && /** @type {ShadowRoot} */
  e.host ? (
    /** @type {ShadowRoot} */
    e
  ) : i.ownerDocument;
}
u(eL, "get_root_for_style");
function uG(i) {
  const e = E("style");
  return e.textContent = "/* empty */", fG(eL(i), e), e.sheet;
}
u(uG, "append_empty_stylesheet");
function fG(i, e) {
  return A(
    /** @type {Document} */
    i.head || i,
    e
  ), e.sheet;
}
u(fG, "append_stylesheet");
function T(i, e, t) {
  i.insertBefore(e, t || null);
}
u(T, "insert");
function C(i) {
  i.parentNode && i.parentNode.removeChild(i);
}
u(C, "detach");
function Le(i, e) {
  for (let t = 0; t < i.length; t += 1)
    i[t] && i[t].d(e);
}
u(Le, "destroy_each");
function E(i) {
  return document.createElement(i);
}
u(E, "element");
function fi(i) {
  return document.createElementNS("http://www.w3.org/2000/svg", i);
}
u(fi, "svg_element");
function Q(i) {
  return document.createTextNode(i);
}
u(Q, "text");
function F() {
  return Q(" ");
}
u(F, "space");
function $e() {
  return Q("");
}
u($e, "empty");
function W(i, e, t, s) {
  return i.addEventListener(e, t, s), () => i.removeEventListener(e, t, s);
}
u(W, "listen");
function st(i) {
  return function(e) {
    return e.preventDefault(), i.call(this, e);
  };
}
u(st, "prevent_default");
function Ve(i) {
  return function(e) {
    return e.stopPropagation(), i.call(this, e);
  };
}
u(Ve, "stop_propagation");
function b(i, e, t) {
  t == null ? i.removeAttribute(e) : i.getAttribute(e) !== t && i.setAttribute(e, t);
}
u(b, "attr");
const dG = ["width", "height"];
function Bd(i, e) {
  const t = Object.getOwnPropertyDescriptors(i.__proto__);
  for (const s in e)
    e[s] == null ? i.removeAttribute(s) : s === "style" ? i.style.cssText = e[s] : s === "__value" ? i.value = i[s] = e[s] : t[s] && t[s].set && dG.indexOf(s) === -1 ? i[s] = e[s] : b(i, s, e[s]);
}
u(Bd, "set_attributes");
function Hn(i) {
  return i === "" ? null : +i;
}
u(Hn, "to_number");
function pG(i) {
  return Array.from(i.childNodes);
}
u(pG, "children");
function be(i, e) {
  e = "" + e, i.data !== e && (i.data = /** @type {string} */
  e);
}
u(be, "set_data");
function He(i, e) {
  i.value = e ?? "";
}
u(He, "set_input_value");
function G(i, e, t, s) {
  t == null ? i.style.removeProperty(e) : i.style.setProperty(e, t, "");
}
u(G, "set_style");
function Ys(i, e, t) {
  for (let s = 0; s < i.options.length; s += 1) {
    const n = i.options[s];
    if (n.__value === e) {
      n.selected = !0;
      return;
    }
  }
  (!t || e !== void 0) && (i.selectedIndex = -1);
}
u(Ys, "select_option");
function fo(i) {
  const e = i.querySelector(":checked");
  return e && e.__value;
}
u(fo, "select_value");
let ud;
function mG() {
  if (ud === void 0) {
    ud = !1;
    try {
      typeof window < "u" && window.parent && window.parent.document;
    } catch {
      ud = !0;
    }
  }
  return ud;
}
u(mG, "is_crossorigin");
function hG(i, e) {
  getComputedStyle(i).position === "static" && (i.style.position = "relative");
  const s = E("iframe");
  s.setAttribute(
    "style",
    "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;"
  ), s.setAttribute("aria-hidden", "true"), s.tabIndex = -1;
  const n = mG();
  let l;
  return n ? (s.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>", l = W(
    window,
    "message",
    /** @param {MessageEvent} event */
    (r) => {
      r.source === s.contentWindow && e();
    }
  )) : (s.src = "about:blank", s.onload = () => {
    l = W(s.contentWindow, "resize", e), e();
  }), A(i, s), () => {
    (n || l && s.contentWindow) && l(), C(s);
  };
}
u(hG, "add_iframe_resize_listener");
function Z(i, e, t) {
  i.classList.toggle(e, !!t);
}
u(Z, "toggle_class");
function tL(i, e, { bubbles: t = !1, cancelable: s = !1 } = {}) {
  return new CustomEvent(i, { detail: e, bubbles: t, cancelable: s });
}
u(tL, "custom_event");
const x5 = class x5 {
  constructor(e = !1) {
    /**
     * @private
     * @default false
     */
    qe(this, "is_svg", !1);
    /** parent for creating node */
    qe(this, "e");
    /** html tag nodes */
    qe(this, "n");
    /** target */
    qe(this, "t");
    /** anchor */
    qe(this, "a");
    this.is_svg = e, this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(e) {
    this.h(e);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(e, t, s = null) {
    this.e || (this.is_svg ? this.e = fi(
      /** @type {keyof SVGElementTagNameMap} */
      t.nodeName
    ) : this.e = E(
      /** @type {keyof HTMLElementTagNameMap} */
      t.nodeType === 11 ? "TEMPLATE" : t.nodeName
    ), this.t = t.tagName !== "TEMPLATE" ? t : (
      /** @type {HTMLTemplateElement} */
      t.content
    ), this.c(e)), this.i(s);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(e) {
    this.e.innerHTML = e, this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(e) {
    for (let t = 0; t < this.n.length; t += 1)
      T(this.t, this.n[t], e);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(e) {
    this.d(), this.h(e), this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(C);
  }
};
u(x5, "HtmlTag");
let bn = x5;
function et(i, e) {
  return new i(e);
}
u(et, "construct_svelte_component");
const qd = /* @__PURE__ */ new Map();
let Gd = 0;
function gG(i) {
  let e = 5381, t = i.length;
  for (; t--; ) e = (e << 5) - e ^ i.charCodeAt(t);
  return e >>> 0;
}
u(gG, "hash");
function bG(i, e) {
  const t = { stylesheet: uG(e), rules: {} };
  return qd.set(i, t), t;
}
u(bG, "create_style_information");
function zd(i, e, t, s, n, l, r, o = 0) {
  const a = 16.666 / s;
  let c = `{
`;
  for (let _ = 0; _ <= 1; _ += a) {
    const y = e + (t - e) * l(_);
    c += _ * 100 + `%{${r(y, 1 - y)}}
`;
  }
  const f = c + `100% {${r(t, 1 - t)}}
}`, d = `__svelte_${gG(f)}_${o}`, p = eL(i), { stylesheet: m, rules: g } = qd.get(p) || bG(p, i);
  g[d] || (g[d] = !0, m.insertRule(`@keyframes ${d} ${f}`, m.cssRules.length));
  const h = i.style.animation || "";
  return i.style.animation = `${h ? `${h}, ` : ""}${d} ${s}ms linear ${n}ms 1 both`, Gd += 1, d;
}
u(zd, "create_rule");
function Hd(i, e) {
  const t = (i.style.animation || "").split(", "), s = t.filter(
    e ? (l) => l.indexOf(e) < 0 : (l) => l.indexOf("__svelte") === -1
    // remove all Svelte animations
  ), n = t.length - s.length;
  n && (i.style.animation = s.join(", "), Gd -= n, Gd || _G());
}
u(Hd, "delete_rule");
function _G() {
  D5(() => {
    Gd || (qd.forEach((i) => {
      const { ownerNode: e } = i.stylesheet;
      e && C(e);
    }), qd.clear());
  });
}
u(_G, "clear_rules");
let fu;
function Kc(i) {
  fu = i;
}
u(Kc, "set_current_component");
function Sc() {
  if (!fu) throw new Error("Function called outside component initialization");
  return fu;
}
u(Sc, "get_current_component");
function yG(i) {
  Sc().$$.before_update.push(i);
}
u(yG, "beforeUpdate");
function $o(i) {
  Sc().$$.on_mount.push(i);
}
u($o, "onMount");
function Qt(i) {
  Sc().$$.on_destroy.push(i);
}
u(Qt, "onDestroy");
function ft() {
  const i = Sc();
  return (e, t, { cancelable: s = !1 } = {}) => {
    const n = i.$$.callbacks[e];
    if (n) {
      const l = tL(
        /** @type {string} */
        e,
        t,
        { cancelable: s }
      );
      return n.slice().forEach((r) => {
        r.call(i, l);
      }), !l.defaultPrevented;
    }
    return !0;
  };
}
u(ft, "createEventDispatcher");
function lt(i, e) {
  return Sc().$$.context.set(i, e), e;
}
u(lt, "setContext");
function de(i) {
  return Sc().$$.context.get(i);
}
u(de, "getContext");
function bt(i, e) {
  const t = i.$$.callbacks[e.type];
  t && t.slice().forEach((s) => s.call(this, e));
}
u(bt, "bubble");
const Do = [], rt = [];
let Uo = [];
const Xg = [], sL = /* @__PURE__ */ Promise.resolve();
let Jg = !1;
function nL() {
  Jg || (Jg = !0, sL.then(Xe));
}
u(nL, "schedule_update");
function I5() {
  return nL(), sL;
}
u(I5, "tick");
function ks(i) {
  Uo.push(i);
}
u(ks, "add_render_callback");
function It(i) {
  Xg.push(i);
}
u(It, "add_flush_callback");
const Fg = /* @__PURE__ */ new Set();
let Co = 0;
function Xe() {
  if (Co !== 0)
    return;
  const i = fu;
  do {
    try {
      for (; Co < Do.length; ) {
        const e = Do[Co];
        Co++, Kc(e), vG(e.$$);
      }
    } catch (e) {
      throw Do.length = 0, Co = 0, e;
    }
    for (Kc(null), Do.length = 0, Co = 0; rt.length; ) rt.pop()();
    for (let e = 0; e < Uo.length; e += 1) {
      const t = Uo[e];
      Fg.has(t) || (Fg.add(t), t());
    }
    Uo.length = 0;
  } while (Do.length);
  for (; Xg.length; )
    Xg.pop()();
  Jg = !1, Fg.clear(), Kc(i);
}
u(Xe, "flush");
function vG(i) {
  if (i.fragment !== null) {
    i.update(), Me(i.before_update);
    const e = i.dirty;
    i.dirty = [-1], i.fragment && i.fragment.p(i.ctx, e), i.after_update.forEach(ks);
  }
}
u(vG, "update");
function kG(i) {
  const e = [], t = [];
  Uo.forEach((s) => i.indexOf(s) === -1 ? e.push(s) : t.push(s)), t.forEach((s) => s()), Uo = e;
}
u(kG, "flush_render_callbacks");
let Dc;
function P5() {
  return Dc || (Dc = Promise.resolve(), Dc.then(() => {
    Dc = null;
  })), Dc;
}
u(P5, "wait");
function oo(i, e, t) {
  i.dispatchEvent(tL(`${e ? "intro" : "outro"}${t}`));
}
u(oo, "dispatch");
const yd = /* @__PURE__ */ new Set();
let sl;
function ae() {
  sl = {
    r: 0,
    c: [],
    p: sl
    // parent group
  };
}
u(ae, "group_outros");
function ce() {
  sl.r || Me(sl.c), sl = sl.p;
}
u(ce, "check_outros");
function w(i, e) {
  i && i.i && (yd.delete(i), i.i(e));
}
u(w, "transition_in");
function O(i, e, t, s) {
  if (i && i.o) {
    if (yd.has(i)) return;
    yd.add(i), sl.c.push(() => {
      yd.delete(i), s && (t && i.d(1), s());
    }), i.o(e);
  } else s && s();
}
u(O, "transition_out");
const M5 = { duration: 0 };
function og(i, e, t) {
  const s = { direction: "in" };
  let n = e(i, t, s), l = !1, r, o, a = 0;
  function c() {
    r && Hd(i, r);
  }
  u(c, "cleanup");
  function f() {
    const {
      delay: p = 0,
      duration: m = 300,
      easing: g = Ec,
      tick: h = se,
      css: _
    } = n || M5;
    _ && (r = zd(i, 0, 1, m, p, g, _, a++)), h(0, 1);
    const y = uu() + p, v = y + m;
    o && o.abort(), l = !0, ks(() => oo(i, !0, "start")), o = rg((k) => {
      if (l) {
        if (k >= v)
          return h(1, 0), oo(i, !0, "end"), c(), l = !1;
        if (k >= y) {
          const S = g((k - y) / m);
          h(S, 1 - S);
        }
      }
      return l;
    });
  }
  u(f, "go");
  let d = !1;
  return {
    start() {
      d || (d = !0, Hd(i), $t(n) ? (n = n(s), P5().then(f)) : f());
    },
    invalidate() {
      d = !1;
    },
    end() {
      l && (c(), l = !1);
    }
  };
}
u(og, "create_in_transition");
function ag(i, e, t) {
  const s = { direction: "out" };
  let n = e(i, t, s), l = !0, r;
  const o = sl;
  o.r += 1;
  let a;
  function c() {
    const {
      delay: f = 0,
      duration: d = 300,
      easing: p = Ec,
      tick: m = se,
      css: g
    } = n || M5;
    g && (r = zd(i, 1, 0, d, f, p, g));
    const h = uu() + f, _ = h + d;
    ks(() => oo(i, !1, "start")), "inert" in i && (a = /** @type {HTMLElement} */
    i.inert, i.inert = !0), rg((y) => {
      if (l) {
        if (y >= _)
          return m(0, 1), oo(i, !1, "end"), --o.r || Me(o.c), !1;
        if (y >= h) {
          const v = p((y - h) / d);
          m(1 - v, v);
        }
      }
      return l;
    });
  }
  return u(c, "go"), $t(n) ? P5().then(() => {
    n = n(s), c();
  }) : c(), {
    end(f) {
      f && "inert" in i && (i.inert = a), f && n.tick && n.tick(1, 0), l && (r && Hd(i, r), l = !1);
    }
  };
}
u(ag, "create_out_transition");
function yr(i, e, t, s) {
  let l = e(i, t, { direction: "both" }), r = s ? 0 : 1, o = null, a = null, c = null, f;
  function d() {
    c && Hd(i, c);
  }
  u(d, "clear_animation");
  function p(g, h) {
    const _ = (
      /** @type {Program['d']} */
      g.b - r
    );
    return h *= Math.abs(_), {
      a: r,
      b: g.b,
      d: _,
      duration: h,
      start: g.start,
      end: g.start + h,
      group: g.group
    };
  }
  u(p, "init");
  function m(g) {
    const {
      delay: h = 0,
      duration: _ = 300,
      easing: y = Ec,
      tick: v = se,
      css: k
    } = l || M5, S = {
      start: uu() + h,
      b: g
    };
    g || (S.group = sl, sl.r += 1), "inert" in i && (g ? f !== void 0 && (i.inert = f) : (f = /** @type {HTMLElement} */
    i.inert, i.inert = !0)), o || a ? a = S : (k && (d(), c = zd(i, r, g, _, h, y, k)), g && v(0, 1), o = p(S, _), ks(() => oo(i, g, "start")), rg((D) => {
      if (a && D > a.start && (o = p(a, _), a = null, oo(i, o.b, "start"), k && (d(), c = zd(
        i,
        r,
        o.b,
        o.duration,
        0,
        y,
        l.css
      ))), o) {
        if (D >= o.end)
          v(r = o.b, 1 - r), oo(i, o.b, "end"), a || (o.b ? d() : --o.group.r || Me(o.group.c)), o = null;
        else if (D >= o.start) {
          const I = D - o.start;
          r = o.a + o.d * y(I / o.duration), v(r, 1 - r);
        }
      }
      return !!(o || a);
    }));
  }
  return u(m, "go"), {
    run(g) {
      $t(l) ? P5().then(() => {
        l = l({ direction: g ? "in" : "out" }), m(g);
      }) : m(g);
    },
    end() {
      d(), o = a = null;
    }
  };
}
u(yr, "create_bidirectional_transition");
function ue(i) {
  return (i == null ? void 0 : i.length) !== void 0 ? i : Array.from(i);
}
u(ue, "ensure_array_like");
function an(i, e) {
  i.d(1), e.delete(i.key);
}
u(an, "destroy_block");
function cn(i, e) {
  O(i, 1, 1, () => {
    e.delete(i.key);
  });
}
u(cn, "outro_and_destroy_block");
function Lt(i, e, t, s, n, l, r, o, a, c, f, d) {
  let p = i.length, m = l.length, g = p;
  const h = {};
  for (; g--; ) h[i[g].key] = g;
  const _ = [], y = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map(), k = [];
  for (g = m; g--; ) {
    const M = d(n, l, g), L = t(M);
    let B = r.get(L);
    B ? k.push(() => B.p(M, e)) : (B = c(L, M), B.c()), y.set(L, _[g] = B), L in h && v.set(L, Math.abs(g - h[L]));
  }
  const S = /* @__PURE__ */ new Set(), D = /* @__PURE__ */ new Set();
  function I(M) {
    w(M, 1), M.m(o, f), r.set(M.key, M), f = M.first, m--;
  }
  for (u(I, "insert"); p && m; ) {
    const M = _[m - 1], L = i[p - 1], B = M.key, z = L.key;
    M === L ? (f = M.first, p--, m--) : y.has(z) ? !r.has(B) || S.has(B) ? I(M) : D.has(z) ? p-- : v.get(B) > v.get(z) ? (D.add(B), I(M)) : (S.add(z), p--) : (a(L, r), p--);
  }
  for (; p--; ) {
    const M = i[p];
    y.has(M.key) || a(M, r);
  }
  for (; m; ) I(_[m - 1]);
  return Me(k), _;
}
u(Lt, "update_keyed_each");
function Vt(i, e) {
  const t = {}, s = {}, n = { $$scope: 1 };
  let l = i.length;
  for (; l--; ) {
    const r = i[l], o = e[l];
    if (o) {
      for (const a in r)
        a in o || (s[a] = 1);
      for (const a in o)
        n[a] || (t[a] = o[a], n[a] = 1);
      i[l] = o;
    } else
      for (const a in r)
        n[a] = 1;
  }
  for (const r in s)
    r in t || (t[r] = void 0);
  return t;
}
u(Vt, "get_spread_update");
function Jt(i) {
  return typeof i == "object" && i !== null ? i : {};
}
u(Jt, "get_spread_object");
function Ot(i, e, t) {
  const s = i.$$.props[e];
  s !== void 0 && (i.$$.bound[s] = t, t(i.$$.ctx[s]));
}
u(Ot, "bind");
function j(i) {
  i && i.c();
}
u(j, "create_component");
function R(i, e, t) {
  const { fragment: s, after_update: n } = i.$$;
  s && s.m(e, t), ks(() => {
    const l = i.$$.on_mount.map(X7).filter($t);
    i.$$.on_destroy ? i.$$.on_destroy.push(...l) : Me(l), i.$$.on_mount = [];
  }), n.forEach(ks);
}
u(R, "mount_component");
function N(i, e) {
  const t = i.$$;
  t.fragment !== null && (kG(t.after_update), Me(t.on_destroy), t.fragment && t.fragment.d(e), t.on_destroy = t.fragment = null, t.ctx = []);
}
u(N, "destroy_component");
function wG(i, e) {
  i.$$.dirty[0] === -1 && (Do.push(i), nL(), i.$$.dirty.fill(0)), i.$$.dirty[e / 31 | 0] |= 1 << e % 31;
}
u(wG, "make_dirty");
function oe(i, e, t, s, n, l, r = null, o = [-1]) {
  const a = fu;
  Kc(i);
  const c = i.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: l,
    update: se,
    not_equal: n,
    bound: W3(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (a ? a.$$.context : [])),
    // everything else
    callbacks: W3(),
    dirty: o,
    skip_bound: !1,
    root: e.target || a.$$.root
  };
  r && r(c.root);
  let f = !1;
  if (c.ctx = t ? t(i, e.props || {}, (d, p, ...m) => {
    const g = m.length ? m[0] : p;
    return c.ctx && n(c.ctx[d], c.ctx[d] = g) && (!c.skip_bound && c.bound[d] && c.bound[d](g), f && wG(i, d)), p;
  }) : [], c.update(), f = !0, Me(c.before_update), c.fragment = s ? s(c.ctx) : !1, e.target) {
    if (e.hydrate) {
      const d = pG(e.target);
      c.fragment && c.fragment.l(d), d.forEach(C);
    } else
      c.fragment && c.fragment.c();
    e.intro && w(i.$$.fragment), R(i, e.target, e.anchor), Xe();
  }
  Kc(a);
}
u(oe, "init$1");
const ew = class ew {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    qe(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    qe(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    N(this, 1), this.$destroy = se;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(e, t) {
    if (!$t(t))
      return se;
    const s = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return s.push(t), () => {
      const n = s.indexOf(t);
      n !== -1 && s.splice(n, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(e) {
    this.$$set && !cG(e) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);
  }
};
u(ew, "SvelteComponent");
let re = ew;
const $G = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add($G);
var rm;
const om = class om {
  /**
   * @hideconstructor
   */
  constructor() {
    throw new Error("Hashing constructor: This is a static class and should not be constructed.");
  }
  /**
   * Provides a solid string hashing algorithm.
   *
   * Sourced from: https://stackoverflow.com/a/52171480
   *
   * @param {string}   str - String to hash.
   *
   * @param {number}   [seed=0] - A seed value altering the hash.
   *
   * @returns {number} Hash code.
   */
  static hashCode(e, t = 0) {
    if (typeof e != "string")
      return 0;
    let s = 3735928559 ^ t, n = 1103547991 ^ t;
    for (let l, r = 0; r < e.length; r++)
      l = e.charCodeAt(r), s = Math.imul(s ^ l, 2654435761), n = Math.imul(n ^ l, 1597334677);
    return s = Math.imul(s ^ s >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(s ^ s >>> 13, 3266489909), 4294967296 * (2097151 & n) + (s >>> 0);
  }
  /**
   * Validates that the given string is formatted as a UUIDv4 string.
   *
   * @param {string}   uuid - UUID string to test.
   *
   * @returns {boolean} Is UUIDv4 string.
   */
  static isUuidv4(e) {
    return P(this, rm).test(e);
  }
  /**
   * Generates a UUID v4 compliant ID. Please use a complete UUID generation package for guaranteed compliance.
   *
   * This code is an evolution of the following Gist.
   * https://gist.github.com/jed/982883
   *
   * There is a public domain / free copy license attached to it that is not a standard OSS license...
   * https://gist.github.com/jed/982883#file-license-txt
   *
   * @returns {string} UUIDv4
   */
  static uuidv4() {
    return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (e) => (e ^ (globalThis.crypto ?? globalThis.msCrypto).getRandomValues(
      new Uint8Array(1)
    )[0] & 15 >> e / 4).toString(16));
  }
};
rm = new WeakMap(), u(om, "Hashing"), x(om, rm, /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i);
let Zg = om;
const tw = class tw {
  /**
   * @hideconstructor
   */
  constructor() {
    throw new Error("Strings constructor: This is a static class and should not be constructed.");
  }
  /**
   * Escape a given input string prefacing special characters with backslashes for use in a regular expression.
   *
   * @param {string}   string - An un-escaped input string.
   *
   * @returns {string} The escaped string suitable for use in a regular expression.
   */
  static escape(e) {
    return e.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  /**
   * Normalizes a string.
   *
   * @param {string}   string - A string to normalize for comparisons.
   *
   * @returns {string} Cleaned string.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
   */
  static normalize(e) {
    return e.trim().normalize("NFD").replace(/[\x00-\x1F]/gm, "");
  }
};
u(tw, "Strings");
let Jl = tw;
const To = [];
function AG(i, e) {
  return {
    subscribe: Mt(i, e).subscribe
  };
}
u(AG, "readable");
function Mt(i, e = se) {
  let t;
  const s = /* @__PURE__ */ new Set();
  function n(o) {
    if (le(i, o) && (i = o, t)) {
      const a = !To.length;
      for (const c of s)
        c[1](), To.push(c, i);
      if (a) {
        for (let c = 0; c < To.length; c += 2)
          To[c][0](To[c + 1]);
        To.length = 0;
      }
    }
  }
  u(n, "set");
  function l(o) {
    n(o(i));
  }
  u(l, "update");
  function r(o, a = se) {
    const c = [o, a];
    return s.add(c), s.size === 1 && (t = e(n, l) || se), o(i), () => {
      s.delete(c), s.size === 0 && t && (t(), t = null);
    };
  }
  return u(r, "subscribe"), { set: n, update: l, subscribe: r };
}
u(Mt, "writable");
function Vo(i, e, t) {
  const s = !Array.isArray(i), n = s ? [i] : i;
  if (!n.every(Boolean))
    throw new Error("derived() expects stores as input, got a falsy value");
  const l = e.length < 2;
  return AG(t, (r, o) => {
    let a = !1;
    const c = [];
    let f = 0, d = se;
    const p = /* @__PURE__ */ u(() => {
      if (f)
        return;
      d();
      const g = e(s ? c[0] : c, r, o);
      l ? r(g) : d = $t(g) ? g : se;
    }, "sync"), m = n.map(
      (g, h) => Xt(
        g,
        (_) => {
          c[h] = _, f &= ~(1 << h), a && p();
        },
        () => {
          f |= 1 << h;
        }
      )
    );
    return a = !0, p(), /* @__PURE__ */ u(function() {
      Me(m), d(), a = !1;
    }, "stop");
  });
}
u(Vo, "derived");
function Ud(i) {
  if (i == null)
    return !1;
  switch (typeof i) {
    case "function":
    case "object":
      return typeof i.subscribe == "function";
  }
  return !1;
}
u(Ud, "isReadableStore");
function Cn(i) {
  if (i == null)
    return !1;
  switch (typeof i) {
    case "function":
    case "object":
      return typeof i.subscribe == "function" && typeof i.set == "function";
  }
  return !1;
}
u(Cn, "isMinimalWritableStore");
function Y3(i) {
  if (i == null)
    return !1;
  switch (typeof i) {
    case "function":
    case "object":
      return typeof i.subscribe == "function" && typeof i.set == "function" && typeof i.update == "function";
  }
  return !1;
}
u(Y3, "isWritableStore");
function Yc(i, e) {
  let t = !1;
  return i.subscribe((s) => {
    t ? e(s) : t = !0;
  });
}
u(Yc, "subscribeIgnoreFirst");
const sw = class sw {
  /**
   * Checks for array equality between two arrays of numbers.
   *
   * @param a - Array A
   *
   * @param b - Array B
   *
   * @returns Arrays are equal.
   */
  static arrayEquals(e, t) {
    if (e === t)
      return !0;
    if (e === null || t === null || e.length !== t.length)
      return !1;
    for (let s = e.length; --s >= 0; )
      if (e[s] !== t[s])
        return !1;
    return !0;
  }
  /**
   * Provides a solid string hashing algorithm.
   *
   * Sourced from: https://stackoverflow.com/a/52171480
   *
   * @param str - String to hash.
   *
   * @param seed - A seed value altering the hash.
   *
   * @returns Hash code.
   */
  static hashString(e, t = 0) {
    let s = 3735928559 ^ t, n = 1103547991 ^ t;
    for (let l, r = 0; r < e.length; r++)
      l = e.charCodeAt(r), s = Math.imul(s ^ l, 2654435761), n = Math.imul(n ^ l, 1597334677);
    return s = Math.imul(s ^ s >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(s ^ s >>> 13, 3266489909), 4294967296 * (2097151 & n) + (s >>> 0);
  }
  /**
   * Converts an unknown value for hashing purposes in {@link AdapterIndexer.calcHashUpdate}.
   *
   * Currently objects / Map w/ object keys is not supported. Potentially can include `object-hash` to handle this
   * case, but it is not common to use objects as keys in Maps.
   *
   * @param value - An unknown value to convert to a number.
   */
  static hashUnknown(e) {
    if (e == null)
      return 0;
    let t = 0;
    switch (typeof e) {
      case "boolean":
        t = e ? 1 : 0;
        break;
      case "bigint":
        t = Number(BigInt.asIntN(64, e));
        break;
      case "function":
        t = this.hashString(e.name);
        break;
      case "number":
        t = Number.isFinite(e) ? e : 0;
        break;
      case "object":
        break;
      case "string":
        t = this.hashString(e);
        break;
      case "symbol":
        t = this.hashString(Symbol.keyFor(e));
        break;
    }
    return t;
  }
  /**
   * @param target -
   *
   * @param Prototype -
   *
   * @returns target constructor function has Prototype.
   */
  static hasPrototype(e, t) {
    if (typeof e != "function")
      return !1;
    if (e === t)
      return !0;
    for (let s = Object.getPrototypeOf(e); s; s = Object.getPrototypeOf(s))
      if (s === t)
        return !0;
    return !1;
  }
  /**
   * Provides a utility method to determine if the given data is iterable / implements iterator protocol.
   *
   * @param data - Data to verify as iterable.
   *
   * @returns Is data iterable.
   */
  static isIterable(e) {
    return e != null && typeof e == "object" && typeof e[Symbol.iterator] == "function";
  }
};
u(sw, "DynReducerUtils");
let Fl = sw;
var Qo, Mu, xo, Gi, zi;
const nw = class nw {
  /**
   * @param {DynDataHost<D>} hostData - Hosted data structure.
   *
   * @param {IndexerAPI<K, T>}  parentIndex - Any associated parent index API.
   *
   * @param {DynDerivedReducerCtor<T>} DerivedReducerCtor - The default derived reducer constructor function.
   */
  constructor(e, t, s) {
    x(this, Qo);
    x(this, Mu);
    x(this, xo);
    x(this, Gi, /* @__PURE__ */ new Map());
    x(this, zi, !1);
    Ae(this, Qo, e), Ae(this, xo, t), Ae(this, Mu, s), Object.freeze(this);
  }
  /**
   * Creates a new derived reducer.
   *
   * @param {DynOptionsDerivedCreate<T>} options - Options defining the new derived reducer.
   *
   * @returns {DynDerivedReducer<D, K, T>} Newly created derived reducer.
   */
  create(e) {
    if (P(this, zi))
      throw Error("AdapterDerived.create error: this instance has been destroyed.");
    let t, s = {}, n;
    const l = P(this, Mu);
    if (typeof e == "string")
      t = e, n = l;
    else if (typeof e == "function" && Fl.hasPrototype(e, l))
      n = e;
    else if (typeof e == "object" && e !== null)
      ({ name: t, ctor: n = l, ...s } = e);
    else
      throw new TypeError("AdapterDerived.create error: 'options' does not conform to allowed parameters.");
    if (!Fl.hasPrototype(n, l))
      throw new TypeError(`AdapterDerived.create error: 'ctor' is not a '${l == null ? void 0 : l.name}'.`);
    if (t = t ?? (n == null ? void 0 : n.name), typeof t != "string")
      throw new TypeError("AdapterDerived.create error: 'name' is not a string.");
    const r = new n(P(this, Qo), P(this, xo), s);
    return P(this, Gi).set(t, r), r;
  }
  /**
   * Removes all derived reducers and associated subscriptions.
   */
  clear() {
    if (!P(this, zi)) {
      for (const e of P(this, Gi).values())
        e.destroy();
      P(this, Gi).clear();
    }
  }
  /**
   * Deletes and destroys a derived reducer by name.
   *
   * @param {string}   name - Name of the derived reducer.
   *
   * @returns {boolean} true if an element in the Map existed and has been removed, or false if the element does not
   *          exist.
   */
  delete(e) {
    if (P(this, zi))
      throw Error("AdapterDerived.delete error: this instance has been destroyed.");
    const t = P(this, Gi).get(e);
    return t && t.destroy(), P(this, Gi).delete(e);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    P(this, zi) || (this.clear(), Ae(this, Qo, [null]), Ae(this, xo, null), Ae(this, zi, !0));
  }
  /**
   * Returns an existing derived reducer.
   *
   * @param {string}   name - Name of derived reducer.
   *
   * @returns {DynDerivedReducer<D, K, T>} Any associated derived reducer.
   */
  get(e) {
    if (P(this, zi))
      throw Error("AdapterDerived.get error: this instance has been destroyed.");
    return P(this, Gi).get(e);
  }
  /**
   * Updates all managed derived reducer indexes.
   *
   * @param {boolean}  [force=false] - Force an update to subscribers.
   */
  update(e = !1) {
    if (!P(this, zi))
      for (const t of P(this, Gi).values())
        t.index.update(e);
  }
};
Qo = new WeakMap(), Mu = new WeakMap(), xo = new WeakMap(), Gi = new WeakMap(), zi = new WeakMap(), u(nw, "AdapterDerived");
let Vd = nw;
var us, Hi, Pn;
const iw = class iw {
  constructor(e, t) {
    x(this, us);
    x(this, Hi);
    x(this, Pn, /* @__PURE__ */ new Map());
    Ae(this, Hi, e), Ae(this, us, t), Object.freeze(this);
  }
  get length() {
    return P(this, us).filters.length;
  }
  *[Symbol.iterator]() {
    if (P(this, us).filters.length !== 0)
      for (const e of P(this, us).filters)
        yield { ...e };
  }
  add(...e) {
    let t = 0;
    for (const s of e) {
      const n = typeof s;
      if (n !== "function" && (n !== "object" || s === null))
        throw new TypeError("AdapterFilters error: 'filter' is not a function or object.");
      let l, r;
      if (n === "function")
        l = {
          id: void 0,
          filter: s,
          weight: 1
        }, r = s.subscribe;
      else if (n === "object")
        if ("filter" in s) {
          if (typeof s.filter != "function")
            throw new TypeError("AdapterFilters error: 'filter' attribute is not a function.");
          if (s.weight !== void 0 && typeof s.weight != "number" || s.weight < 0 || s.weight > 1)
            throw new TypeError("AdapterFilters error: 'weight' attribute is not a number between '0 - 1' inclusive.");
          l = {
            id: s.id !== void 0 ? s.id : void 0,
            filter: s.filter,
            weight: s.weight || 1
          }, r = s.filter.subscribe ?? s.subscribe;
        } else
          throw new TypeError("AdapterFilters error: 'filter' attribute is not a function.");
      const o = P(this, us).filters.findIndex((a) => l.weight < a.weight);
      if (o >= 0 ? P(this, us).filters.splice(o, 0, l) : P(this, us).filters.push(l), typeof r == "function") {
        const a = r(P(this, Hi));
        if (typeof a != "function")
          throw new TypeError("AdapterFilters error: Filter has subscribe function, but no unsubscribe function is returned.");
        if (P(this, Pn).has(l.filter))
          throw new Error("AdapterFilters error: Filter added already has an unsubscribe function registered.");
        P(this, Pn).set(l.filter, a), t++;
      }
    }
    t < e.length && P(this, Hi).call(this, !0);
  }
  clear() {
    P(this, us).filters.length = 0;
    for (const e of P(this, Pn).values())
      e();
    P(this, Pn).clear(), P(this, Hi).call(this);
  }
  remove(...e) {
    const t = P(this, us).filters.length;
    if (t !== 0) {
      for (const s of e) {
        const n = typeof s == "function" ? s : s !== null && typeof s == "object" ? s.filter : void 0;
        if (n) {
          for (let l = P(this, us).filters.length; --l >= 0; )
            if (P(this, us).filters[l].filter === n) {
              P(this, us).filters.splice(l, 1);
              let r;
              typeof (r = P(this, Pn).get(n)) == "function" && (r(), P(this, Pn).delete(n));
            }
        }
      }
      t !== P(this, us).filters.length && P(this, Hi).call(this, !0);
    }
  }
  removeBy(e) {
    const t = P(this, us).filters.length;
    if (t !== 0) {
      if (typeof e != "function")
        throw new TypeError("AdapterFilters error: 'callback' is not a function.");
      P(this, us).filters = P(this, us).filters.filter((s) => {
        const n = e.call(e, { ...s });
        if (n) {
          let l;
          typeof (l = P(this, Pn).get(s.filter)) == "function" && (l(), P(this, Pn).delete(s.filter));
        }
        return !n;
      }), t !== P(this, us).filters.length && P(this, Hi).call(this, !0);
    }
  }
  removeById(...e) {
    const t = P(this, us).filters.length;
    t !== 0 && (P(this, us).filters = P(this, us).filters.filter((s) => {
      let n = 0;
      for (const l of e)
        n |= s.id === l ? 1 : 0;
      if (n) {
        let l;
        typeof (l = P(this, Pn).get(s.filter)) == "function" && (l(), P(this, Pn).delete(s.filter));
      }
      return !n;
    }), t !== P(this, us).filters.length && P(this, Hi).call(this, !0));
  }
};
us = new WeakMap(), Hi = new WeakMap(), Pn = new WeakMap(), u(iw, "AdapterFilters");
let Wd = iw;
const lw = class lw {
  /**
   * @param {DynDataHost<D>}       hostData - Hosted data structure.
   *
   * @param {Function}             hostUpdate - Host update function invoked on index updates.
   *
   * @param {DynIndexerAPI<K, T>} [parentIndexer] - Any associated parent index API.
   *
   * @returns Indexer adapter instance.
   */
  constructor(e, t, s) {
    qe(this, "derivedAdapter");
    qe(this, "filtersData");
    qe(this, "hostData");
    qe(this, "hostUpdate");
    qe(this, "indexData");
    qe(this, "sortData");
    qe(this, "sortFn");
    qe(this, "destroyed", !1);
    this.hostData = e, this.hostUpdate = t, this.indexData = { index: null, hash: null, reversed: !1, parent: s };
  }
  /**
   * @returns Returns whether the index is active.
   */
  get active() {
    var e;
    return this.filtersData.filters.length > 0 || this.sortData.compareFn !== null || ((e = this.indexData.parent) == null ? void 0 : e.active) === !0;
  }
  /**
   * @returns Returns length of reduced index.
   */
  get length() {
    return this.indexData.index ? this.indexData.index.length : 0;
  }
  /* c8 ignore start */
  /**
   * @returns Returns reversed state.
   */
  get reversed() {
    return this.indexData.reversed;
  }
  /* c8 ignore end */
  /**
   * @param reversed - New reversed state.
   */
  set reversed(e) {
    this.indexData.reversed = e;
  }
  // -------------------------------------------------------------------------------------------------------------------
  /**
   * Calculates a new hash value for the new index array if any. If the new index array is null then the hash value
   * is set to null. Set calculated new hash value to the index adapter hash value.
   *
   * After hash generation compare old and new hash values and perform an update if they are different. If they are
   * equal check for array equality between the old and new index array and perform an update if they are not equal.
   *
   * @param oldIndex - Old index array.
   *
   * @param oldHash - Old index hash value.
   *
   * @param [force=false] - When true forces an update to subscribers.
   */
  calcHashUpdate(e, t, s = !1) {
    const n = typeof s == "boolean" ? s : (
      /* c8 ignore next */
      !1
    );
    let l = null;
    const r = this.indexData.index;
    if (r)
      for (let o = r.length; --o >= 0; )
        l ^= Fl.hashUnknown(r[o]) + 2654435769 + (l << 6) + (l >> 2);
    this.indexData.hash = l, (n || (t !== l || !Fl.arrayEquals(e, r))) && this.hostUpdate();
  }
  /**
   * Destroys all resources.
   */
  destroy() {
    this.destroyed || (this.indexData.index = null, this.indexData.hash = null, this.indexData.reversed = null, this.indexData.parent = null, this.destroyed = !0);
  }
  /**
   * Store associated filter and sort data that are constructed after the indexer.
   *
   * @param filtersData - Associated AdapterFilters instance.
   *
   * @param sortData - Associated AdapterSort instance.
   *
   * @param derivedAdapter - Associated AdapterDerived instance.
   */
  initAdapters(e, t, s) {
    this.filtersData = e, this.sortData = t, this.derivedAdapter = s, this.sortFn = this.createSortFn();
  }
};
u(lw, "AdapterIndexer");
let Qg = lw;
var _l, er, $i;
const rw = class rw {
  constructor(e, t) {
    x(this, _l);
    x(this, er);
    x(this, $i);
    Ae(this, er, e), Ae(this, _l, t), Object.freeze(this);
  }
  clear() {
    const e = P(this, _l).compareFn;
    P(this, _l).compareFn = null, typeof P(this, $i) == "function" && (P(this, $i).call(this), Ae(this, $i, void 0)), typeof e == "function" && P(this, er).call(this, !0);
  }
  set(e) {
    typeof P(this, $i) == "function" && (P(this, $i).call(this), Ae(this, $i, void 0));
    let t, s;
    switch (typeof e) {
      case "function":
        t = e, s = e.subscribe;
        break;
      case "object":
        if (e === null)
          break;
        if (typeof e.compare != "function")
          throw new TypeError("AdapterSort error: 'compare' attribute is not a function.");
        t = e.compare, s = e.compare.subscribe ?? e.subscribe;
        break;
    }
    if (typeof t == "function")
      P(this, _l).compareFn = t;
    else {
      const n = P(this, _l).compareFn;
      P(this, _l).compareFn = null, typeof n == "function" && P(this, er).call(this);
      return;
    }
    if (typeof s == "function") {
      if (Ae(this, $i, s(P(this, er))), typeof P(this, $i) != "function")
        throw new Error("AdapterSort error: sort has 'subscribe' function, but no 'unsubscribe' function is returned.");
    } else
      P(this, er).call(this, !0);
  }
};
_l = new WeakMap(), er = new WeakMap(), $i = new WeakMap(), u(rw, "AdapterSort");
let Kd = rw;
var ea;
const ow = class ow {
  constructor(e) {
    x(this, ea);
    /**
     * Provides a getter to determine if the index is active.
     */
    qe(this, "active");
    /**
     * Provides length of reduced / indexed elements.
     */
    qe(this, "length");
    /**
     * Manually invoke an update of the index.
     *
     * @param force - Force update to any subscribers.
     */
    qe(this, "update");
    Ae(this, ea, e.indexData), this.update = e.update.bind(e), Object.defineProperties(this, {
      active: { get: /* @__PURE__ */ u(() => e.active, "get") },
      length: { get: /* @__PURE__ */ u(() => e.length, "get") }
    }), Object.freeze(this);
  }
  get hash() {
    return P(this, ea).hash;
  }
  *[Symbol.iterator]() {
    const e = P(this, ea);
    if (!e.index)
      return;
    const t = e.reversed, s = e.index.length;
    if (t)
      for (let n = s; --n >= 0; )
        yield e.index[n];
    else
      for (let n = 0; n < s; n++)
        yield e.index[n];
  }
};
ea = new WeakMap(), u(ow, "IndexerAPI");
let Yd = ow;
const aw = class aw {
  constructor(e) {
    qe(this, "clear");
    qe(this, "create");
    qe(this, "delete");
    qe(this, "destroy");
    qe(this, "get");
    this.clear = e.clear.bind(e), this.create = e.create.bind(e), this.delete = e.delete.bind(e), this.destroy = e.destroy.bind(e), this.get = e.get.bind(e), Object.freeze(this);
  }
};
u(aw, "DerivedAPI");
let Xd = aw;
const cw = class cw extends Qg {
  /**
   * @inheritDoc
   */
  createSortFn() {
    return (e, t) => this.sortData.compareFn(this.hostData[0].get(e), this.hostData[0].get(t));
  }
  /**
   * Provides the custom filter / reduce step that is ~25-40% faster than implementing with `Array.reduce`.
   *
   * Note: Other loop unrolling techniques like Duff's Device gave a slight faster lower bound on large data sets,
   * but the maintenance factor is not worth the extra complication.
   *
   * @returns {K[]} New filtered index array.
   */
  reduceImpl() {
    const e = [], t = this.hostData[0];
    if (!t)
      return e;
    const s = this.filtersData.filters;
    let n = !0;
    const l = this.indexData.parent;
    if (Fl.isIterable(l) && l.active)
      for (const r of l) {
        const o = t.get(r);
        n = !0;
        for (let a = 0, c = s.length; a < c; a++)
          if (!s[a].filter(o)) {
            n = !1;
            break;
          }
        n && e.push(r);
      }
    else
      for (const r of t.keys()) {
        n = !0;
        const o = t.get(r);
        for (let a = 0, c = s.length; a < c; a++)
          if (!s[a].filter(o)) {
            n = !1;
            break;
          }
        n && e.push(r);
      }
    return e;
  }
  /**
   * Update the reducer indexes. If there are changes subscribers are notified. If data order is changed externally
   * pass in true to force an update to subscribers.
   *
   * @param {boolean}  [force=false] - When true forces an update to subscribers.
   */
  update(e = !1) {
    var r;
    if (this.destroyed)
      return;
    const t = this.indexData.index, s = this.indexData.hash, n = this.hostData[0], l = this.indexData.parent;
    (this.filtersData.filters.length === 0 && !this.sortData.compareFn || this.indexData.index && (n == null ? void 0 : n.size) !== this.indexData.index.length) && (this.indexData.index = null), this.filtersData.filters.length > 0 && (this.indexData.index = this.reduceImpl()), !this.indexData.index && (l != null && l.active) && (this.indexData.index = [...l]), this.sortData.compareFn && n instanceof Map && (this.indexData.index || (this.indexData.index = this.indexData.index = [...n.keys()]), this.indexData.index.sort(this.sortFn)), this.calcHashUpdate(t, s, e), (r = this.derivedAdapter) == null || r.update(e);
  }
};
u(cw, "MapIndexer");
let Jd = cw;
var Ui, Gr, Fu, ta, Ru, Ai, tr, Nu, sa, ju, yl, na, am, iL;
const cm = class cm {
  /**
   * @param {DynDataHost<Map<K, T>>}  map - Data host Map.
   *
   * @param {DynIndexerAPI<K, T>}    parentIndex - Parent indexer.
   *
   * @param {DynDataOptions<T>}       options - Any filters and sort functions to apply.
   */
  constructor(e, t, s) {
    x(this, am);
    x(this, Ui);
    x(this, Gr);
    x(this, Fu);
    x(this, ta);
    x(this, Ru, { filters: [] });
    x(this, Ai);
    x(this, tr);
    x(this, Nu, !1);
    x(this, sa);
    x(this, ju, { compareFn: null });
    x(this, yl, []);
    x(this, na, !1);
    Ae(this, Ui, e), Ae(this, Ai, new Jd(P(this, Ui), X(this, am, iL).bind(this), t)), Ae(this, tr, new Yd(P(this, Ai))), Ae(this, ta, new Wd(P(this, tr).update, P(this, Ru))), Ae(this, sa, new Kd(P(this, tr).update, P(this, ju))), Ae(this, Gr, new Vd(P(this, Ui), P(this, tr), cm)), Ae(this, Fu, new Xd(P(this, Gr))), P(this, Ai).initAdapters(P(this, Ru), P(this, ju), P(this, Gr));
    const { filters: n, sort: l, ...r } = s;
    if (n !== void 0) {
      if (!Fl.isIterable(n))
        throw new TypeError("DerivedMapReducer error (DataDerivedOptions): 'filters' attribute is not iterable.");
      this.filters.add(...n);
    }
    if (l !== void 0) {
      if (typeof l != "function" && (typeof l != "object" || l === null))
        throw new TypeError("DerivedMapReducer error (DataDerivedOptions): 'sort' attribute is not a function or object.");
      this.sort.set(l);
    }
    this.initialize(r);
  }
  /**
   * Returns the internal data of this instance. Be careful!
   *
   * Note: The returned map is the same map set by the main reducer. If any changes are performed to the data
   * externally do invoke {@link DynIndexerAPI.update} with `true` to recalculate the index and notify all
   * subscribers.
   *
   * @returns The internal data.
   */
  get data() {
    return P(this, Ui)[0];
  }
  /**
   * @returns Derived public API.
   */
  get derived() {
    return P(this, Fu);
  }
  /**
   * @returns The filters adapter.
   */
  get filters() {
    return P(this, ta);
  }
  /**
   * Returns the Indexer public API.
   *
   * @returns Indexer API - is also iterable.
   */
  get index() {
    return P(this, tr);
  }
  /**
   * Returns whether this derived reducer is destroyed.
   */
  get destroyed() {
    return P(this, na);
  }
  /**
   * @returns Main data / items length or indexed length.
   */
  get length() {
    const e = P(this, Ui)[0];
    return P(this, Ai).active ? this.index.length : e ? e.size : 0;
  }
  /**
   * @returns Gets current reversed state.
   */
  get reversed() {
    return P(this, Nu);
  }
  /**
   * @returns The sort adapter.
   */
  get sort() {
    return P(this, sa);
  }
  /**
   * Sets reversed state and notifies subscribers.
   *
   * @param reversed - New reversed state.
   */
  set reversed(e) {
    if (typeof e != "boolean")
      throw new TypeError("DerivedMapReducer.reversed error: 'reversed' is not a boolean.");
    Ae(this, Nu, e), P(this, Ai).reversed = e, this.index.update(!0);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    Ae(this, na, !0), Ae(this, Ui, [null]), P(this, Ai).update(!0), P(this, yl).length = 0, P(this, Gr).destroy(), P(this, Ai).destroy(), P(this, ta).clear(), P(this, sa).clear();
  }
  /**
   * Provides a callback for custom derived reducers to initialize any data / custom configuration. This allows
   * child classes to avoid implementing the constructor.
   *
   * @param [optionsRest] - Any additional custom options passed beyond {@link DynDataOptions}.
   *
   * @protected
   */
  initialize(e) {
  }
  /**
   * Provides an iterator for data stored in DerivedMapReducer.
   *
   * @returns {IterableIterator<T>}
   * @yields {T}
   */
  *[Symbol.iterator]() {
    const e = P(this, Ui)[0];
    if (!(P(this, na) || e === null || (e == null ? void 0 : e.size) === 0))
      if (P(this, Ai).active)
        for (const t of this.index)
          yield e.get(t);
      else if (this.reversed) {
        const t = [...e.values()];
        for (let s = t.length; --s >= 0; )
          yield t[s];
      } else
        for (const t of e.values())
          yield t;
  }
  // -------------------------------------------------------------------------------------------------------------------
  /**
   * Subscribe to this DerivedMapReducer.
   *
   * @param handler - Callback function that is invoked on update / changes. Receives `this` reference.
   *
   * @returns Unsubscribe function.
   */
  subscribe(e) {
    return P(this, yl).push(e), e(this), () => {
      const t = P(this, yl).findIndex((s) => s === e);
      t >= 0 && P(this, yl).splice(t, 1);
    };
  }
};
Ui = new WeakMap(), Gr = new WeakMap(), Fu = new WeakMap(), ta = new WeakMap(), Ru = new WeakMap(), Ai = new WeakMap(), tr = new WeakMap(), Nu = new WeakMap(), sa = new WeakMap(), ju = new WeakMap(), yl = new WeakMap(), na = new WeakMap(), am = new WeakSet(), /**
 * Updates subscribers on changes.
 */
iL = /* @__PURE__ */ u(function() {
  for (let e = 0; e < P(this, yl).length; e++)
    P(this, yl)[e](this);
}, "#updateSubscribers"), u(cm, "DynMapReducerDerived");
let xg = cm;
var Mn, zr, Lu, ia, Bu, Vi, vl, qu, la, Gu, kl, Hr, um, lL;
const uw = class uw {
  /**
   * Initializes DynMapReducer. Any iterable is supported for initial data. Take note that if `data` is an array it
   * will be used as the host array and not copied. All non-array iterables otherwise create a new array / copy.
   *
   * @param {Map<K, T> | DynMapData<K, T>} [data] - Data iterable to store if array or copy otherwise.
   */
  constructor(e) {
    x(this, um);
    x(this, Mn, [null]);
    x(this, zr);
    x(this, Lu);
    x(this, ia);
    x(this, Bu, { filters: [] });
    x(this, Vi);
    x(this, vl);
    x(this, qu, !1);
    x(this, la);
    x(this, Gu, { compareFn: null });
    x(this, kl, []);
    x(this, Hr, !1);
    let t, s, n;
    if (e === null)
      throw new TypeError("DynMapReducer error: 'data' is not an object or Map.");
    if (e !== void 0 && typeof e != "object" && !(e instanceof Map))
      throw new TypeError("DynMapReducer error: 'data' is not an object or Map.");
    if (e !== void 0 && e instanceof Map)
      t = e;
    else if (e !== void 0 && ("data" in e || "filters" in e || "sort" in e)) {
      if (e.data !== void 0 && !(e.data instanceof Map))
        throw new TypeError("DynMapReducer error (DataDynMap): 'data' attribute is not a Map.");
      if (t = e.data, e.filters !== void 0)
        if (Fl.isIterable(e.filters))
          s = e.filters;
        else
          throw new TypeError("DynMapReducer error (DataDynMap): 'filters' attribute is not iterable.");
      if (e.sort !== void 0)
        if (typeof e.sort == "function")
          n = e.sort;
        else if (typeof e.sort == "object" && e.sort !== null)
          n = e.sort;
        else
          throw new TypeError("DynMapReducer error (DataDynMap): 'sort' attribute is not a function or object.");
    }
    t && (P(this, Mn)[0] = t), Ae(this, Vi, new Jd(P(this, Mn), X(this, um, lL).bind(this))), Ae(this, vl, new Yd(P(this, Vi))), Ae(this, ia, new Wd(P(this, vl).update, P(this, Bu))), Ae(this, la, new Kd(P(this, vl).update, P(this, Gu))), Ae(this, zr, new Vd(P(this, Mn), P(this, vl), xg)), Ae(this, Lu, new Xd(P(this, zr))), P(this, Vi).initAdapters(P(this, Bu), P(this, Gu), P(this, zr)), s && this.filters.add(...s), n && this.sort.set(n), this.initialize();
  }
  /**
   * Returns the internal data of this instance. Be careful!
   *
   * Note: When a map is set as data then that map is used as the internal data. If any changes are performed to the
   * data externally do invoke `update` via {@link DynMapReducer.index} with `true` to recalculate the  index and
   * notify all subscribers.
   *
   * @returns {Map<K, T> | null} The internal data.
   */
  get data() {
    return P(this, Mn)[0];
  }
  /**
   * @returns {DynDerivedAPI<Map<K, T>, K, T>} Derived public API.
   */
  get derived() {
    return P(this, Lu);
  }
  /**
   * @returns {DynAdapterFilters<T>} The filters adapter.
   */
  get filters() {
    return P(this, ia);
  }
  /**
   * @returns {DynIndexerAPI<K, T>} Returns the Indexer public API.
   */
  get index() {
    return P(this, vl);
  }
  /**
   * @returns {boolean} Returns whether this instance is destroyed.
   */
  get destroyed() {
    return P(this, Hr);
  }
  /**
   * Gets the main data / items length.
   *
   * @returns {number} Main data / items length.
   */
  get length() {
    const e = P(this, Mn)[0];
    return P(this, Vi).active ? P(this, vl).length : e ? e.size : 0;
  }
  /**
   * Gets current reversed state.
   *
   * @returns {boolean} Reversed state.
   */
  get reversed() {
    return P(this, qu);
  }
  /**
   * @returns {DynAdapterSort<T>} The sort adapter.
   */
  get sort() {
    return P(this, la);
  }
  /**
   * Sets reversed state and notifies subscribers.
   *
   * @param {boolean} reversed - New reversed state.
   */
  set reversed(e) {
    if (typeof e != "boolean")
      throw new TypeError("DynMapReducer.reversed error: 'reversed' is not a boolean.");
    Ae(this, qu, e), P(this, Vi).reversed = e, this.index.update(!0);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    P(this, Hr) || (Ae(this, Hr, !0), P(this, zr).destroy(), Ae(this, Mn, [null]), this.index.update(!0), P(this, kl).length = 0, P(this, Vi).destroy(), P(this, ia).clear(), P(this, la).clear());
  }
  /**
   * Provides a callback for custom reducers to initialize any data / custom configuration. This allows
   * child classes to avoid implementing the constructor.
   *
   * @protected
   */
  initialize() {
  }
  /**
   * Removes internal data and pushes new data. This does not destroy any initial array set to internal data unless
   * `replace` is set to true.
   *
   * @param {Map<K, T> | null}  data - New data to set to internal data.
   *
   * @param {boolean} [replace=false] - New data to set to internal data.
   */
  setData(e, t = !1) {
    if (e !== null && !(e instanceof Map))
      throw new TypeError("DynMapReducer.setData error: 'data' is not iterable.");
    if (typeof t != "boolean")
      throw new TypeError("DynMapReducer.setData error: 'replace' is not a boolean.");
    const s = P(this, Mn)[0];
    if (!(s instanceof Map) || t)
      P(this, Mn)[0] = e instanceof Map ? e : null;
    else if (e instanceof Map && s instanceof Map) {
      const n = new Set(s.keys());
      for (const l of e.keys())
        s.set(l, e.get(l)), n.has(l) && n.delete(l);
      for (const l of n)
        s.delete(l);
    } else e === null && (P(this, Mn)[0] = null);
    this.index.update(!0);
  }
  /**
   * Add a subscriber to this DynMapReducer instance.
   *
   * @param {(value: DynMapReducer<K, T>) => void} handler - Callback function that is invoked on update / changes.
   *        Receives `this` reference.
   *
   * @returns {() => void} Unsubscribe function.
   */
  subscribe(e) {
    return P(this, kl).push(e), e(this), () => {
      const t = P(this, kl).findIndex((s) => s === e);
      t >= 0 && P(this, kl).splice(t, 1);
    };
  }
  /**
   * Provides an iterator for data stored in DynMapReducer.
   *
   * @returns {IterableIterator<T>}
   * @yields {T}
   */
  *[Symbol.iterator]() {
    const e = P(this, Mn)[0];
    if (!(P(this, Hr) || e === null || (e == null ? void 0 : e.size) === 0))
      if (P(this, Vi).active)
        for (const t of this.index)
          yield e.get(t);
      else if (this.reversed) {
        const t = [...e.values()];
        for (let s = t.length; --s >= 0; )
          yield t[s];
      } else
        for (const t of e.values())
          yield t;
  }
};
Mn = new WeakMap(), zr = new WeakMap(), Lu = new WeakMap(), ia = new WeakMap(), Bu = new WeakMap(), Vi = new WeakMap(), vl = new WeakMap(), qu = new WeakMap(), la = new WeakMap(), Gu = new WeakMap(), kl = new WeakMap(), Hr = new WeakMap(), um = new WeakSet(), /**
 * Updates subscribers on changes.
 */
lL = /* @__PURE__ */ u(function() {
  for (let e = 0; e < P(this, kl).length; e++)
    P(this, kl)[e](this);
}, "#updateSubscribers"), u(uw, "DynMapReducer");
let Sn = uw;
function EG(i, { accessWarn: e = !1, caseSensitive: t = !1, store: s } = {}) {
  let n = "", l;
  if (s !== void 0 && !Cn(s))
    throw new TypeError("regexObjectQuery error: 'store' is not a minimal writable store.");
  const r = s || Mt(n);
  if (s) {
    const a = Bn(s);
    typeof a == "string" ? (n = Jl.normalize(a), l = new RegExp(Jl.escape(n), t ? "" : "i")) : s.set(n);
  }
  function o(a) {
    if (n === "" || !l)
      return !0;
    if (Nt(i)) {
      for (const c of i) {
        const f = cu(a, c);
        if (typeof f != "string") {
          e && console.warn(`regexObjectQuery warning: could not access string data from '${c}'.`);
          continue;
        }
        if (l.test(Jl.normalize(f)))
          return !0;
      }
      return !1;
    } else {
      const c = cu(a, i);
      return typeof c != "string" ? (e && console.warn(`regexObjectQuery warning: could not access string data from '${i}'.`), !1) : l.test(Jl.normalize(c));
    }
  }
  return u(o, "filterQuery"), o.subscribe = (a) => r.subscribe(a), o.set = (a) => {
    typeof a == "string" && (n = Jl.normalize(a), l = new RegExp(Jl.escape(n), t ? "" : "i"), r.set(n));
  }, o;
}
u(EG, "regexObjectQuery");
const SG = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  regexObjectQuery: EG
}), fw = class fw {
  /**
   * Returns the following filter functions:
   * - regexObjectQuery(accessors, options); suitable for object reducers matching one or more property keys /
   *   accessors against the store value as a regex. To access deeper entries into the object format the accessor
   *   string with `.` between entries to walk. Optional parameters include logging access warnings, case sensitivity,
   *   and passing in an existing store.
   *
   * @returns {{
   *    regexObjectQuery: (accessors: string|Iterable<string>, options?: {accessWarn?: boolean,
   *     caseSensitive?: boolean, store?: import('svelte/store').Writable<string>}) =>
   *      (((data: {}) => boolean) & import('#runtime/svelte/store/util').MinimalWritable<string>)
   * }} All available filters.
   */
  static get filters() {
    return SG;
  }
};
u(fw, "DynReducerHelper");
let e1 = fw;
var fm, Fs, ra, sr, dn;
const xc = class xc {
  /**
   * @param {foundry.abstract.Document[]} document - The associated document holder.
   */
  constructor(e) {
    /**
     * @type {Map<string, EmbeddedCollectionData<any>>}
     */
    x(this, Fs, /* @__PURE__ */ new Map());
    /**
     * @type {foundry.abstract.Document[]}
     */
    x(this, ra);
    /**
     * @type {Map<string, string>}
     */
    x(this, sr, /* @__PURE__ */ new Map());
    /**
     * @type {Set<string>}
     */
    x(this, dn, /* @__PURE__ */ new Set());
    Ae(this, ra, e), this.handleDocChange(), Object.seal(this);
  }
  /**
   * @template [T=import('./types').NamedDocumentConstructor]
   *
   * @param {T} FoundryDoc - A Foundry document class / constructor.
   *
   * @param {import('#runtime/svelte/store/reducer').DynOptionsMapCreate<string, T>} options - DynMapReducer
   *        creation options.
   *
   * @returns {import('#runtime/svelte/store/reducer').DynMapReducer<string, T>} DynMapReducer instance.
   */
  create(e, t) {
    const s = e == null ? void 0 : e.documentName;
    if (typeof s != "string")
      throw new TypeError(
        "EmbeddedStoreManager.create error: 'FoundryDoc' does not have a valid 'documentName' property."
      );
    const n = P(this, ra)[0];
    let l = null;
    if (n)
      try {
        l = n.getEmbeddedCollection(s);
      } catch {
        console.warn(`EmbeddedStoreManager.create error: No valid embedded collection for: ${s}`);
      }
    let r;
    P(this, Fs).has(s) ? r = P(this, Fs).get(s) : (r = {
      collection: l,
      stores: /* @__PURE__ */ new Map()
    }, P(this, Fs).set(s, r));
    let o, a = {}, c;
    if (typeof t == "string")
      o = t, c = Sn;
    else if (typeof t == "function" && V3(t, Sn))
      c = t;
    else if (he(t))
      ({ name: o, ctor: c = Sn, ...a } = t);
    else
      throw new TypeError("EmbeddedStoreManager.create error: 'options' does not conform to allowed parameters.");
    if (!V3(c, Sn))
      throw new TypeError("EmbeddedStoreManager.create error: 'ctor' is not a 'DynMapReducer'.");
    if (o = o ?? (c == null ? void 0 : c.name), typeof o != "string")
      throw new TypeError("EmbeddedStoreManager.create error: 'name' is not a string.");
    if (r.stores.has(o))
      return r.stores.get(o);
    {
      const f = l ? { data: l, ...a } : { ...a }, d = new c(f);
      return r.stores.set(o, d), d;
    }
  }
  /**
   * @template [T=import('./types').NamedDocumentConstructor]
   *
   * Destroys and removes embedded collection stores. Invoking this method with no parameters destroys all stores.
   * Invoking with an embedded name destroys all stores for that particular collection. If you provide an embedded and
   * store name just that particular store is destroyed and removed.
   *
   * @param {T}   [FoundryDoc] - A Foundry document class / constructor.
   *
   * @param {string}   [storeName] - Specific store name.
   *
   * @returns {boolean} One or more stores destroyed?
   */
  destroy(e, t) {
    let s = 0;
    if (e === void 0) {
      for (const n of P(this, Fs).values()) {
        n.collection = null;
        for (const l of n.stores.values())
          l.destroy(), s++;
      }
      P(this, Fs).clear();
    } else {
      const n = e == null ? void 0 : e.documentName;
      if (typeof n != "string")
        throw new TypeError(
          "EmbeddedStoreManager.delete error: 'FoundryDoc' does not have a valid 'documentName' property."
        );
      if (t === void 0) {
        const l = P(this, Fs).get(n);
        if (l) {
          l.collection = null;
          for (const r of l.stores.values())
            r.destroy(), s++;
        }
        P(this, Fs).delete(n);
      } else if (t === "string") {
        const l = P(this, Fs).get(n);
        if (l) {
          const r = l.stores.get(t);
          r && (r.destroy(), s++);
        }
      }
    }
    return s > 0;
  }
  /**
   * @template [T=import('./types').NamedDocumentConstructor]
   *
   * @param {T} FoundryDoc - A Foundry document class / constructor.
   *
   * @param {string} storeName - Name of the embedded collection to retrieve.
   *
   * @returns {import('#runtime/svelte/store/reducer').DynMapReducer<string, InstanceType<T>>} DynMapReducer
   *          instance.
   */
  get(e, t) {
    const s = e == null ? void 0 : e.documentName;
    if (typeof s != "string")
      throw new TypeError(
        "EmbeddedStoreManager.get error: 'FoundryDoc' does not have a valid 'documentName' property."
      );
    if (P(this, Fs).has(s))
      return P(this, Fs).get(s).stores.get(t);
  }
  /**
   * Updates all existing embedded collection stores with the associated embedded collection
   */
  handleDocChange() {
    var t, s;
    const e = P(this, ra)[0];
    if (e instanceof globalThis.foundry.abstract.Document) {
      const n = new Set(P(this, Fs).keys()), l = Object.entries(((s = (t = e.constructor) == null ? void 0 : t.metadata) == null ? void 0 : s.embedded) ?? []);
      P(this, sr).clear(), P(this, dn).clear();
      for (const [r, o] of l) {
        n.delete(r), P(this, dn).add(`create${r}`), P(this, dn).add(`delete${r}`), P(this, dn).add(`update${r}`), P(this, dn).add(`create.${o}`), P(this, dn).add(`delete.${o}`), P(this, dn).add(`update.${o}`), P(this, dn).add(`create${o}`), P(this, dn).add(`delete${o}`), P(this, dn).add(`update${o}`), P(this, sr).set(r, r), P(this, sr).set(o, r);
        let a = null;
        try {
          a = e.getEmbeddedCollection(r);
        } catch {
          console.warn(`EmbeddedStoreManager.handleDocUpdate error: No valid embedded collection for: ${r}`);
        }
        const c = P(this, Fs).get(r);
        if (c) {
          c.collection = a;
          for (const f of c.stores.values())
            f.setData(a, !0);
        }
      }
      for (const r of n) {
        const o = P(this, Fs).get(r);
        if (o) {
          o.collection = null;
          for (const a of o.stores.values())
            a.setData(null, !0);
        }
      }
    } else {
      P(this, sr).clear(), P(this, dn).clear();
      for (const n of P(this, Fs).values()) {
        n.collection = null;
        for (const l of n.stores.values())
          l.setData(null, !0);
      }
    }
  }
  /**
   * Handles updates to embedded stores parsing the render context for valid embedded store types.
   *
   * On create, delete, update parse the type being modified then force index updates for the embedded type.
   *
   * @param {string}   renderContext - render context update from document.
   */
  handleUpdate(e) {
    if (!P(this, dn).has(e))
      return;
    const t = P(xc, fm).exec(e);
    if (t) {
      const s = t.groups.name, n = P(this, sr).get(s);
      if (!P(this, Fs).has(n))
        return;
      for (const l of P(this, Fs).get(n).stores.values())
        l.index.update(!0);
    }
  }
};
fm = new WeakMap(), Fs = new WeakMap(), ra = new WeakMap(), sr = new WeakMap(), dn = new WeakMap(), u(xc, "EmbeddedStoreManager"), /**
 * RegExp for detecting CRUD updates for renderContext.
 *
 * @type {RegExp}
 */
x(xc, fm, /(?<action>create|delete|update)(?<sep>\.?)(?<name>\w+)/);
let t1 = xc;
var zu, Zn, wn, Ur, nr, Ei, Qn, oa, Ks, s1, n1, rL, vd, kd;
const dm = class dm {
  /**
   * @param {T | TJSDocumentOptions}  [document] - Document to wrap or TJSDocumentOptions.
   *
   * @param {TJSDocumentOptions}      [options] - TJSDocument options.
   */
  constructor(e, t = {}) {
    x(this, Ks);
    /**
     * Fake Application API that ClientDocumentMixin uses for document model callbacks.
     *
     * @type {{ close: Function, render: Function }}
     */
    x(this, zu);
    /**
     * @type {T[]}
     */
    x(this, Zn, [void 0]);
    /**
     * @type {EmbeddedStoreManager}
     */
    x(this, wn);
    /**
     * @type {import('./types').EmbeddedAPI}
     */
    x(this, Ur);
    /**
     * @type {string}
     */
    x(this, nr);
    /**
     * @type {{ delete?: Function, preDelete?: Function }}
     */
    x(this, Ei, { delete: void 0, preDelete: void 0 });
    /**
     * @type {((value: T, updateOptions?: TJSDocumentUpdateOptions) => void)[]}
     */
    x(this, Qn, []);
    /**
     * @type {TJSDocumentUpdateOptions}
     */
    x(this, oa);
    Ae(this, nr, `tjs-document-${Zg.uuidv4()}`), Ae(this, zu, {
      close: X(this, Ks, rL).bind(this),
      render: X(this, Ks, kd).bind(this)
    }), W7(e) ? this.setOptions(e) : (this.setOptions(t), this.set(e));
  }
  /**
   * @returns {import('./types').EmbeddedAPI} Embedded store manager.
   */
  get embedded() {
    return P(this, Ur) || (Ae(this, wn, new t1(P(this, Zn))), Ae(this, Ur, {
      create: /* @__PURE__ */ u((e, t) => P(this, wn).create(e, t), "create"),
      destroy: /* @__PURE__ */ u((e, t) => P(this, wn).destroy(e, t), "destroy"),
      get: /* @__PURE__ */ u((e, t) => P(this, wn).get(e, t), "get")
    })), P(this, Ur);
  }
  /**
   * Returns the options passed on last update.
   *
   * @returns {TJSDocumentUpdateOptions} Last update options.
   */
  get updateOptions() {
    return P(this, oa) ?? {};
  }
  /**
   * Returns the UUID assigned to this store.
   *
   * @returns {string} UUID
   */
  get uuidv4() {
    return P(this, nr);
  }
  /**
   * Completely removes all internal subscribers, any optional delete callback, and unregisters from the
   * ClientDocumentMixin `apps` tracking object.
   */
  destroy() {
    P(this, wn) && (P(this, wn).destroy(), Ae(this, wn, void 0), Ae(this, Ur, void 0)), X(this, Ks, vd).call(this, void 0), P(this, Ei).delete = void 0, P(this, Ei).preDelete = void 0, P(this, Qn).length = 0;
  }
  /**
   * @returns {T} Current document
   */
  get() {
    return P(this, Zn)[0];
  }
  /**
   * Attempts to create a Foundry UUID from standard drop data. This may not work for all systems.
   *
   * @param {object}   data - Drop transfer data.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.compendium=true] - Accept compendium documents.
   *
   * @param {boolean}  [opts.world=true] - Accept world documents.
   *
   * @param {string[]} [opts.types] - Require the `data.type` to match entry in `types`.
   *
   * @returns {string|undefined} Foundry UUID for drop data.
   */
  static getUUIDFromDataTransfer(e, { compendium: t = !0, world: s = !0, types: n = void 0 } = {}) {
    if (!he(e) || Array.isArray(n) && !n.includes(e.type))
      return;
    let l;
    return typeof e.uuid == "string" && (e.uuid.startsWith("Compendium") && t || s) && (l = e.uuid), l;
  }
  /**
   * @param {T | undefined}  document - New document to set.
   *
   * @param {TJSDocumentUpdateOptions}   [options] - New document update options to set.
   */
  set(e, t = {}) {
    if (e !== void 0 && !(e instanceof globalThis.foundry.abstract.Document))
      throw new TypeError("TJSDocument set error: 'document' is not a valid Document or undefined.");
    if (!he(t))
      throw new TypeError("TJSDocument set error: 'options' is not an object.");
    X(this, Ks, vd).call(this, e) && (e instanceof globalThis.foundry.abstract.Document && P(this, Qn).length && X(this, Ks, s1).call(this), X(this, Ks, kd).call(this, !1, { action: `tjs-set-${e === void 0 ? "undefined" : "new"}`, ...t }));
  }
  /**
   * Potentially sets new document from data transfer object.
   *
   * @param {object}   data - Document transfer data.
   *
   * @param {{ compendium?: boolean, world?: boolean, types?: string[] }}   [options] - Optional parameters for
   *        {@link TJSDocument.getUUIDFromDataTransfer}.
   *
   * @returns {Promise<boolean>} Returns true if new document set from data transfer blob.
   */
  async setFromDataTransfer(e, t) {
    return this.setFromUUID(dm.getUUIDFromDataTransfer(e, t));
  }
  /**
   * Sets the document by Foundry UUID performing a lookup and setting the document if found.
   *
   * @param {string}   uuid - A Foundry UUID to lookup.
   *
   * @param {TJSDocumentUpdateOptions}   [options] - New document update options to set.
   *
   * @returns {Promise<boolean>} True if successfully set document from UUID.
   */
  async setFromUUID(e, t = {}) {
    if (typeof e != "string" || e.length === 0)
      return !1;
    try {
      const s = await globalThis.fromUuid(e);
      if (s)
        return this.set(s, t), !0;
    } catch {
    }
    return !1;
  }
  /**
   * Sets options for this document wrapper / store.
   *
   * @param {TJSDocumentOptions}   options - Options for TJSDocument.
   */
  setOptions(e) {
    if (!he(e))
      throw new TypeError("TJSDocument error: 'options' is not a plain object.");
    if (e.delete !== void 0 && e.delete !== null && typeof e.delete != "function")
      throw new TypeError("TJSDocument error: 'delete' attribute in options is not a function or null.");
    if (e.preDelete !== void 0 && e.preDelete !== null && typeof e.preDelete != "function")
      throw new TypeError("TJSDocument error: 'preDelete' attribute in options is not a function or null.");
    e.delete !== void 0 && (P(this, Ei).delete = typeof e.delete == "function" ? e.delete : void 0), e.preDelete !== void 0 && (P(this, Ei).preDelete = typeof e.preDelete == "function" ? e.preDelete : void 0);
  }
  /**
   * @param {(value: T, updateOptions?: TJSDocumentUpdateOptions) => void} handler - Callback function that is
   * invoked on update / changes.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(e) {
    P(this, Qn).push(e), P(this, Qn).length === 1 && X(this, Ks, s1).call(this);
    const t = { action: "subscribe", data: void 0 };
    return e(P(this, Zn)[0], t), () => {
      const s = P(this, Qn).findIndex((n) => n === e);
      s >= 0 && P(this, Qn).splice(s, 1), P(this, Qn).length === 0 && X(this, Ks, n1).call(this);
    };
  }
};
zu = new WeakMap(), Zn = new WeakMap(), wn = new WeakMap(), Ur = new WeakMap(), nr = new WeakMap(), Ei = new WeakMap(), Qn = new WeakMap(), oa = new WeakMap(), Ks = new WeakSet(), /**
 * Register the callback API with the underlying Foundry document.
 */
s1 = /* @__PURE__ */ u(function() {
  const e = P(this, Zn)[0];
  e instanceof globalThis.foundry.abstract.Document && he(e == null ? void 0 : e.apps) && !e.apps[P(this, nr)] && (e.apps[P(this, nr)] = P(this, zu));
}, "#callbackRegister"), /**
 * Unregister the callback API with the underlying Foundry document.
 */
n1 = /* @__PURE__ */ u(function() {
  var t;
  const e = P(this, Zn)[0];
  e instanceof globalThis.foundry.abstract.Document && ((t = e == null ? void 0 : e.apps) == null || delete t[P(this, nr)]);
}, "#callbackUnregister"), rL = /* @__PURE__ */ u(async function() {
  var t;
  const e = P(this, Zn)[0];
  e instanceof globalThis.foundry.abstract.Document && !((t = e == null ? void 0 : e.collection) != null && t.has(e.id)) && (X(this, Ks, vd).call(this, void 0), typeof P(this, Ei).preDelete == "function" && await P(this, Ei).preDelete(e), X(this, Ks, kd).call(this, !1, { action: "delete", data: void 0 }), typeof P(this, Ei).delete == "function" && await P(this, Ei).delete(e), await I5(), Ae(this, oa, void 0));
}, "#deleted"), /**
 * Internally sets the new document being tracked.
 *
 * @param {T | undefined} doc -
 *
 * @returns {boolean} Whether the document changed.
 */
vd = /* @__PURE__ */ u(function(e) {
  const t = e !== P(this, Zn)[0];
  return t && X(this, Ks, n1).call(this), P(this, Zn)[0] = e, t && P(this, wn) && P(this, wn).handleDocChange(), t;
}, "#setDocument"), /**
 * @param {boolean}  [force] - unused - signature from Foundry render function.
 *
 * @param {TJSDocumentUpdateOptions}   [options] - Options from render call; will have document update context.
 */
kd = /* @__PURE__ */ u(function(e = !1, t = {}) {
  Ae(this, oa, t);
  const s = P(this, Zn)[0];
  for (let n = 0; n < P(this, Qn).length; n++)
    P(this, Qn)[n](s, t);
  P(this, wn) && P(this, wn).handleUpdate(t.renderContext);
}, "#updateSubscribers"), u(dm, "TJSDocument");
let Zt = dm;
var Hu, Vr, Qs, pm, oL, Wr, Mc;
const eu = class eu {
  /**
   * Creates the TJSGameSettings instance.
   *
   * @param {string}   namespace - The namespace for all settings.
   */
  constructor(e) {
    x(this, Wr);
    /** @type {string} */
    x(this, Hu);
    /** @type {GameSettingData[]} */
    x(this, Vr, []);
    /**
     * @type {Map<string, import('svelte/store').Writable>}
     */
    x(this, Qs, /* @__PURE__ */ new Map());
    if (typeof e != "string")
      throw new TypeError("'namespace' is not a string.");
    Ae(this, Hu, e);
  }
  /**
   * @returns {string} Returns namespace set in constructor.
   */
  get namespace() {
    return P(this, Hu);
  }
  /**
   * Returns a readable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Readable | undefined} The associated store for the given game setting key.
   */
  getReadableStore(e) {
    if (!P(this, Qs).has(e)) {
      console.warn(`TJSGameSettings - getReadableStore: '${e}' is not a registered setting.`);
      return;
    }
    return { subscribe: X(this, Wr, Mc).call(this, e).subscribe };
  }
  /**
   * Returns a writable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Writable | undefined} The associated store for the given game setting key.
   */
  getStore(e) {
    return this.getWritableStore(e);
  }
  /**
   * Returns a writable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Writable | undefined} The associated store for the given game setting key.
   */
  getWritableStore(e) {
    if (!P(this, Qs).has(e)) {
      console.warn(`TJSGameSettings - getWritableStore: '${e}' is not a registered setting.`);
      return;
    }
    return X(this, Wr, Mc).call(this, e);
  }
  /**
   * Registers a setting with TJSGameSettings and Foundry core.
   *
   * Note: The specific store subscription handler assigned to the passed in store or store created for the setting
   * internally is returned from this function. In some cases when setting up custom stores particularly of object
   * types with several child property stores (`propertyStore`) it is necessary to only update the setting store and
   * not all subscribers to the custom store as the `propertyStore` instances are also subscribers to the custom store.
   *
   * This allows the custom store in the `set` implementation to mainly only trigger the TJSGameSettings subscriber
   * handler on updates and not all the connected `propertyStore` instances.
   *
   * @param {GameSetting} setting - A GameSetting instance to set to Foundry game settings.
   *
   * @param {boolean}     coreConfig - When false this overrides the `setting.options.config` parameter when
   *                                   registering the setting with Foundry. This allows the settings to be displayed
   *                                   in the app itself, but removed from the standard Foundry configuration location.
   *
   * @returns {Function} The specific store subscription handler assigned to the passed in store.
   */
  register(e, t = !0) {
    if (!he(e))
      throw new TypeError("TJSGameSettings - register: setting is not an object.");
    if (!he(e.options))
      throw new TypeError("TJSGameSettings - register: 'setting.options' attribute is not an object.");
    if (typeof t != "boolean")
      throw new TypeError("TJSGameSettings - register: 'coreConfig' is not an boolean.");
    if (e.store !== void 0 && !Cn(e.store))
      throw new TypeError(
        "TJSGameSettings - register: 'setting.store' attribute is not a minimal writable store."
      );
    const s = e.namespace, n = e.key, l = e.folder, r = t ? e.options.config : !1;
    if (typeof s != "string")
      throw new TypeError("TJSGameSettings - register: 'namespace' attribute is not a string.");
    if (typeof n != "string")
      throw new TypeError("TJSGameSettings - register: 'key' attribute is not a string.");
    if (l !== void 0 && typeof l != "string")
      throw new TypeError("TJSGameSettings - register: 'folder' attribute is not a string.");
    const o = e.store, a = e.options, c = [];
    let f = !1;
    if (c.push((h) => {
      const _ = X(this, Wr, Mc).call(this, n);
      _ && !f && (f = !0, _.set(h), f = !1);
    }), Nt(a == null ? void 0 : a.onChange))
      for (const h of a.onChange)
        typeof h == "function" && c.push(h);
    else typeof a.onChange == "function" && c.push(a.onChange);
    const d = /* @__PURE__ */ u((h) => {
      for (const _ of c)
        _(h);
    }, "onChange");
    globalThis.game.settings.register(s, n, { ...a, config: r, onChange: d });
    const p = o || X(this, Wr, Mc).call(this, n, globalThis.game.settings.get(s, n));
    o && (P(this, Qs).set(n, p), o.set(globalThis.game.settings.get(s, n)));
    const m = /* @__PURE__ */ u(async (h) => {
      f || (f = !0, await globalThis.game.settings.set(s, n, h)), f = !1;
    }, "storeHandler");
    Yc(p, m);
    const g = {
      namespace: s,
      key: n,
      folder: l,
      ...a
    };
    return Object.freeze(g), P(this, Vr).push(g), m;
  }
  /**
   * Registers multiple settings.
   *
   * Please refer to the note in {@link TJSGameSettings.register} about the returned object of store subscriber handler
   * functions.
   *
   * @param {Iterable<GameSetting>} settings - An iterable list of game setting configurations to register.
   *
   * @param {boolean}     coreConfig - When false this overrides the `setting.options.config` parameter when
   *                                   registering the setting with Foundry. This allows the settings to be displayed
   *                                   in the app itself, but removed from the standard Foundry configuration location.
   *
   * @returns { {[key: string]: Function} } An object containing all TJSGameSetting store subscriber handlers for each
   *          setting `key` added.
   */
  registerAll(e, t) {
    const s = {};
    if (!Nt(e))
      throw new TypeError("TJSGameSettings - registerAll: settings is not iterable.");
    for (const n of e) {
      if (!he(n))
        throw new TypeError("TJSGameSettings - registerAll: entry in settings is not an object.");
      if (typeof n.namespace != "string")
        throw new TypeError("TJSGameSettings - registerAll: entry in settings missing 'namespace' attribute.");
      if (typeof n.key != "string")
        throw new TypeError("TJSGameSettings - registerAll: entry in settings missing 'key' attribute.");
      if (!he(n.options))
        throw new TypeError("TJSGameSettings - registerAll: entry in settings missing 'options' attribute.");
      s[n.key] = this.register(n, t);
    }
    return s;
  }
  // Iterators ------------------------------------------------------------------------------------------------------
  /**
   * Returns an iterable for the game setting data; {@link GameSettingData}.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by game setting keys.
   *
   * @returns {IterableIterator<GameSettingData>} Iterable iterator of GameSettingData.
   * @yields {GameSettingData}
   */
  *data(e = void 0) {
    if (e !== void 0 && !(e instanceof RegExp))
      throw new TypeError("'regex' is not a RegExp");
    if (P(this, Vr).length)
      if (e)
        for (const t of P(this, Vr))
          e.test(t.key) && (yield t);
      else
        for (const t of P(this, Vr))
          yield t;
  }
  /**
   * @template T
   *
   * Returns an iterable for the game setting keys and stores.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by game setting keys.
   *
   * @returns {IterableIterator<[string, import('svelte/store').Writable<T>]>} Iterable iterator of keys and stores.
   * @yields {import('svelte/store').Writable<T>}
   */
  *entries(e = void 0) {
    if (e !== void 0 && !(e instanceof RegExp))
      throw new TypeError("'regex' is not a RegExp");
    if (P(this, Qs).size)
      if (e)
        for (const t of P(this, Qs).keys())
          e.test(t) && (yield [t, this.getStore(t)]);
      else
        for (const t of P(this, Qs).keys())
          yield [t, this.getStore(t)];
  }
  /**
   * Returns an iterable for the game setting keys from existing stores.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by game setting keys.
   *
   * @returns {IterableIterator<string>} Iterable iterator of game setting keys.
   * @yields {string}
   */
  *keys(e = void 0) {
    if (e !== void 0 && !(e instanceof RegExp))
      throw new TypeError("'regex' is not a RegExp");
    if (P(this, Qs).size)
      if (e)
        for (const t of P(this, Qs).keys())
          e.test(t) && (yield t);
      else
        for (const t of P(this, Qs).keys())
          yield t;
  }
  /**
   * @template T
   *
   * Returns an iterable for the game setting stores.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by game setting keys.
   *
   * @returns {IterableIterator<import('svelte/store').Writable<T>>} Iterable iterator of stores.
   * @yields {import('svelte/store').Writable<T>}
   */
  *stores(e = void 0) {
    if (e !== void 0 && !(e instanceof RegExp))
      throw new TypeError("'regex' is not a RegExp");
    if (P(this, Qs).size)
      if (e)
        for (const t of P(this, Qs).keys())
          e.test(t) && (yield this.getStore(t));
      else
        for (const t of P(this, Qs).keys())
          yield this.getStore(t);
  }
};
Hu = new WeakMap(), Vr = new WeakMap(), Qs = new WeakMap(), pm = new WeakSet(), oL = /* @__PURE__ */ u(function(e) {
  return Mt(e);
}, "#createStore"), Wr = new WeakSet(), /**
 * Gets a store from the `stores` Map or creates a new store for the key.
 *
 * @param {string}   key - Key to lookup in stores map.
 *
 * @param {string}   [initialValue] - An initial value to set to new stores.
 *
 * @returns {import('svelte/store').Writable} The store for the given key.
 */
Mc = /* @__PURE__ */ u(function(e, t) {
  var n;
  let s = P(this, Qs).get(e);
  return s === void 0 && (s = X(n = eu, pm, oL).call(n, t), P(this, Qs).set(e, s)), s;
}, "#getStore"), x(eu, pm), u(eu, "TJSGameSettings");
let i1 = eu;
var ir, Io;
const jr = class jr {
  constructor(e) {
    x(this, ir);
    qe(this, "migrations");
    e || (e = []), this.migrations = e.sort((t, s) => t.version - s.version);
  }
  needsMigration(e) {
    return e < jr.LATEST_MIGRATION_VERSION;
  }
  diffCollection(e, t) {
    const s = {
      inserted: [],
      deleted: [],
      updated: []
    }, n = /* @__PURE__ */ new Map();
    return e.forEach((l) => n.set(l._id, l)), t.forEach((l) => {
      const r = n.get(l._id);
      r ? (JSON.stringify(r) !== JSON.stringify(l) && s.updated.push(l), n.delete(l._id)) : s.inserted.push(l);
    }), n.forEach((l) => s.deleted.push(l._id)), s;
  }
  async getUpdatedActor(e, t) {
    var n, l, r, o, a, c;
    const s = foundry.utils.deepClone(e);
    for (const f of t)
      try {
        await ((n = f == null ? void 0 : f.updateActor) == null ? void 0 : n.call(f, s));
        for (const d of s.items)
          try {
            await ((l = f == null ? void 0 : f.updateItem) == null ? void 0 : l.call(f, d, s));
          } catch (p) {
            console.info(`Actor ${s.name} failed items update.`), console.error(p);
          }
        for (const d of s.effects)
          try {
            await ((r = f.updateEffect) == null ? void 0 : r.call(f, d, s));
          } catch (p) {
            console.info(`Actor ${s.name} failed effects update.`), console.error(p);
          }
      } catch (d) {
        console.info(`Actor ${s.name} failed actor update.`), console.error(d);
      }
    if ("game" in globalThis) {
      const f = t.at(-1);
      (o = s.system).migrationData ?? (o.migrationData = { version: null, lastMigration: null }), X(this, ir, Io).call(this, s.system.migration, f);
      for (const d of s.items)
        (a = d.system)._migration ?? (a._migration = { version: null, previous: null }), X(this, ir, Io).call(this, d.system._migration, f);
      for (const d of s.effects)
        (c = d.system)._migration ?? (c._migration = { version: null, previous: null }), X(this, ir, Io).call(this, d.system._migration, f);
    }
    return s;
  }
  async getUpdatedItem(e, t) {
    var n, l, r, o;
    const s = foundry.utils.deepClone(e);
    try {
      for (const a of t) {
        await ((n = a == null ? void 0 : a.updateItem) == null ? void 0 : n.call(a, s));
        for (const c of s.effects)
          try {
            await ((l = a == null ? void 0 : a.updateEffect) == null ? void 0 : l.call(a, c, s));
          } catch (f) {
            console.info(`Item ${s.name} failed effects update.`), console.error(f);
          }
      }
    } catch (a) {
      console.info(`Item ${s.name} failed item update.`), console.error(a);
    }
    if ("game" in globalThis) {
      const a = t.at(-1);
      (r = s.system).migrationData ?? (r.migrationData = { version: null, lastMigration: null }), X(this, ir, Io).call(this, s.system.migration, a);
      for (const c of s.effects)
        (o = c.system)._migration ?? (o._migration = { version: null, previous: null }), X(this, ir, Io).call(this, c.system._migration, a);
    }
    return s;
  }
  async getUpdatedJournalEntry(e, t) {
    var n;
    const s = foundry.utils.deepClone(e);
    for (const l of t)
      try {
        await ((n = l.updateJournalEntry) == null ? void 0 : n.call(l, s));
      } catch (r) {
        console.error(r);
      }
    return s;
  }
  async getUpdatedTable(e, t) {
    var n;
    const s = foundry.utils.deepClone(e);
    for (const l of t)
      try {
        await ((n = l.updateTable) == null ? void 0 : n.call(l, s));
      } catch (r) {
        console.error(r);
      }
    return s;
  }
  async getUpdatedMacro(e, t) {
    var n;
    const s = foundry.utils.deepClone(e);
    for (const l of t)
      try {
        await ((n = l.updateMacro) == null ? void 0 : n.call(l, s));
      } catch (r) {
        console.error(r);
      }
    return s;
  }
  async getUpdatedToken(e, t) {
    var n;
    const s = e.toObject();
    for (const l of t)
      try {
        await ((n = l.updateToken) == null ? void 0 : n.call(l, s, e.actor, e.scene));
      } catch (r) {
        console.info(`Token ${s.name} failed token update on scene ${e.scene.id}.`), console.error(r);
      }
    return s;
  }
  async getUpdatedUser(e, t) {
    var n;
    const s = foundry.utils.deepClone(e);
    for (const l of t)
      try {
        await ((n = l == null ? void 0 : l.updateUser) == null ? void 0 : n.call(l, s));
      } catch (r) {
        console.info(`User ${s.name} failed user update.`), console.error(r);
      }
    return s;
  }
};
ir = new WeakSet(), Io = /* @__PURE__ */ u(function(e, t = {}, s = null) {
  if (!("game" in globalThis && s)) return;
  const n = typeof (t == null ? void 0 : t.version) == "number" ? t.version : null;
  t.version = s == null ? void 0 : s.version, t.lastMigration = {
    version: n,
    // @ts-expect-error
    foundry: game.version,
    system: game.system.version
  };
}, "#updateMigrationRecord"), u(jr, "MigrationRunnerBase"), qe(jr, "LATEST_MIGRATION_VERSION", 0.02), qe(jr, "RECOMMENDED_SAFE_VERSION", 0.019), qe(jr, "MINIMUM_SAFE_VERSION", 0.014);
let du = jr;
var aa, jt, wd, aL, Fc, $d, cL, uL, fL, dL, pL, mL, l1;
const Zl = class Zl extends du {
  constructor() {
    super(...arguments);
    x(this, jt);
    x(this, aa);
  }
  needsMigration() {
    return super.needsMigration(game.settings.get("a5e", "worldSchemaVersion"));
  }
  static async ensureSchemaVersion(t, s) {
    if (s.length === 0) return;
    const n = Zl.LATEST_MIGRATION_VERSION;
    if ((Number(t.migrationVersion) || 0) < n) {
      const l = new Zl(s), r = t._source, o = await (async () => {
        try {
          return "items" in r ? await l.getUpdatedActor(r, l.migrations) : await l.getUpdatedItem(r, l.migrations);
        } catch {
          return null;
        }
      })();
      if (o) {
        if ("items" in o && "items" in t._source) {
          for (const c of o.items)
            c._id ?? (c._id = foundry.utils.randomID());
          const a = t._source.items;
          for (const c of [...a])
            o.items.some((f) => f._id === c._id) || a.splice(a.indexOf(c), 1);
        }
        t.updateSource(o);
      }
    }
    if (t.updateSource({ "system.migrationData.version": n }), "items" in t && "prototypeToken" in t)
      for (const l of t.items)
        l.migrationVersion || l.updateSource({ "system.migrationData.version": n });
  }
  async runCompendiumMigration(t, s, n) {
    if (!["Adventure", "Actor", "Item"].includes(s.documentName)) return;
    await s.getDocuments();
    const l = await X(this, jt, mL).call(this, s);
    if (!l) return;
    const r = s.locked;
    r && await s.configure({ locked: !1 }), s.documentName === "Adventure" ? await X(this, jt, aL).call(this, s, t) : await X(this, jt, wd).call(this, s, t, { ...n, packData: l }), r && await s.configure({ locked: !0 });
  }
  async runMigrations(t, s = {}) {
    var l, r;
    if (t.length === 0) return;
    s.fromSourceData ?? (s.fromSourceData = !0), s.inPreCreate ?? (s.inPreCreate = !1), await X(this, jt, wd).call(this, game.actors, t, s), await X(this, jt, wd).call(this, game.items, t, s);
    const n = [];
    game.journal.forEach((o) => n.push(X(this, jt, cL).call(this, o, t))), game.macros.forEach((o) => n.push(X(this, jt, uL).call(this, o, t))), game.tables.forEach((o) => n.push(X(this, jt, fL).call(this, o, t))), game.users.forEach((o) => n.push(X(this, jt, pL).call(this, o, t))), t.forEach((o) => {
      o.migrate && n.push(o.migrate());
    }), await Promise.allSettled(n);
    for (const o of game.scenes)
      for (const a of o.tokens) {
        const { actor: c } = a;
        if (!c || !!!await X(this, jt, dL).call(this, a, t)) continue;
        const d = (l = a.delta) == null ? void 0 : l._source, p = !!d && !!((r = d.flags) != null && r.a5e) || ((d == null ? void 0 : d.items) ?? []).length > 0 || Object.keys((d == null ? void 0 : d.system) ?? {}).length > 0;
        if (c.isToken && p) {
          const m = await X(this, jt, Fc).call(this, t, c);
          if (m)
            try {
              await c.update(m, { noHook: !0 });
            } catch (g) {
              console.warn(g);
            }
        }
      }
    for (const o of game.packs)
      o.metadata.packageType === "world" && ["Actor", "Item"].includes(o.documentName) && (ui.notifications.info(
        K("A5E.migration.compendium.starting", { packName: o.metadata.label })
      ), console.info(`A5E | Migrating ${o.index.size} documents in ${o.metadata.id}.`), await this.runCompendiumMigration(t, o, s), ui.notifications.info(
        K("A5E.migration.compendium.finished", { packName: o.metadata.label })
      ));
  }
  async runDocumentMigration(t) {
    var r;
    if ((((r = t.system.migrationData) == null ? void 0 : r.version) ?? Zl.RECOMMENDED_SAFE_VERSION) >= Zl.LATEST_MIGRATION_VERSION || !["Actor", "Item"].includes(t.documentName)) return !1;
    const n = {
      fromSourceData: !0,
      // Marked as true for world data
      inPreCreate: !1
    };
    await X(this, jt, l1).call(this);
    const l = "items" in t ? await X(this, jt, Fc).call(this, this.migrations, t, n) : await X(this, jt, $d).call(this, this.migrations, t, n);
    return await t.update(l), !0;
  }
  async runMigration(t = !1) {
    const s = {
      latest: Zl.LATEST_MIGRATION_VERSION,
      current: game.settings.get("a5e", "worldSchemaVersion")
    }, n = game.system.version;
    ui.notifications.info(K("A5E.migration.world.starting", { version: n }));
    const l = t ? this.migrations : this.migrations.filter((o) => s.current < o.version), r = [[]];
    for (const o of l)
      r[r.length - 1].push(o), o.requiresFlush && r.push([]);
    await X(this, jt, l1).call(this);
    for (const o of r)
      o.length > 0 && await this.runMigrations(o);
    await game.settings.set("a5e", "worldSchemaVersion", s.latest), ui.notifications.info(K("A5E.migration.world.finished", { version: n }));
  }
};
aa = new WeakMap(), jt = new WeakSet(), wd = /* @__PURE__ */ u(async function(t, s, n) {
  const { documentClass: l } = t, r = "metadata" in t ? t.metadata.id : null, o = [], { fromSourceData: a, packData: c } = n ?? {};
  for (const f of t.contents) {
    if (o.length === 50)
      try {
        await l.updateDocuments(o, { noHook: !0, pack: r });
      } catch (p) {
        console.error(p);
      } finally {
        o.length = 0;
      }
    const d = "prototypeToken" in f ? await X(this, jt, Fc).call(this, s, f, { pack: r, fromSourceData: a, packData: c }) : await X(this, jt, $d).call(this, s, f, { pack: r, fromSourceData: a, packData: c });
    d && o.push(d);
  }
  if (o.length > 0)
    try {
      await l.updateDocuments(o, { noHook: !0, pack: r });
    } catch (f) {
      console.warn(f);
    }
}, "#migrateDocuments"), aL = /* @__PURE__ */ u(async function(t, s) {
  const n = "metadata" in t ? t.metadata.id : null, l = !0;
  for (const r of t.contents) {
    const o = [], a = [...r.actors], c = [...r.items];
    for (const f of a) {
      const d = await X(this, jt, Fc).call(this, s, f, { pack: n, isAdventure: l });
      d && o.push(d);
    }
    try {
      await r.update({ actors: o }, { noHook: !0, pack: n });
    } catch (f) {
      console.warn(f);
    }
    o.length = 0;
    for (const f of c) {
      const d = await X(this, jt, $d).call(this, s, f, { pack: n, isAdventure: l });
      d && o.push(d);
    }
    try {
      await r.update({ items: o }, { noHook: !0, pack: n });
    } catch (f) {
      console.warn(f);
    }
  }
}, "#migrateAdventureDocuments"), Fc = /* @__PURE__ */ u(async function(t, s, n) {
  var D;
  const { pack: l, packData: r, isAdventure: o = !1, fromSourceData: a = !1 } = n ?? {};
  let c;
  l && r ? c = r.find((I) => s._id === I._id) ?? foundry.utils.deepClone(s._source) : a ? c = ((D = P(this, aa).actors) == null ? void 0 : D.find((I) => s._id === I._id)) ?? s.toObject() : c = foundry.utils.deepClone(s._source);
  const f = await (async () => {
    try {
      return await this.getUpdatedActor(c, t);
    } catch (I) {
      return I instanceof Error && console.error(`Error thrown while migrating ${s.uuid}: ${I.message}`), null;
    }
  })();
  if (!f) return null;
  const d = [...c.items], p = [...f.items], m = this.diffCollection(d, p), g = m.deleted.filter((I) => s.items.has(I));
  if (g.length > 0 && !o)
    try {
      await s.deleteEmbeddedDocuments("Item", g, { noHook: !0, pack: l });
    } catch (I) {
      console.warn(I);
    }
  const h = m.updated.filter((I) => s.items.has(I._id));
  f.items = [...m.inserted, ...h];
  const _ = [...c.effects], y = [...f.effects], v = this.diffCollection(_, y), k = v.deleted.filter((I) => s.effects.has(I));
  if (k.length > 0 && !o)
    try {
      await s.deleteEmbeddedDocuments("ActiveEffect", k, { noHook: !0, pack: l });
    } catch (I) {
      console.warn(I);
    }
  const S = v.updated.filter((I) => s.effects.has(I._id));
  return f.effects = [...v.inserted, ...S], f;
}, "#migrateActor"), $d = /* @__PURE__ */ u(async function(t, s, n) {
  var _;
  const { pack: l, packData: r, isAdventure: o = !1, fromSourceData: a = !1 } = n ?? {};
  let c;
  l && r ? c = r.find((y) => s._id === y._id) ?? s._source.toObject() : a ? c = ((_ = P(this, aa).items) == null ? void 0 : _.find((y) => s._id === y._id)) ?? s.toObject() : c = s._source.toObject();
  const f = await (() => {
    try {
      return this.getUpdatedItem(c, t);
    } catch (y) {
      return y instanceof Error && console.error(`Error thrown while migrating ${s.uuid}: ${y.message}`), null;
    }
  })();
  if (!f) return null;
  const d = [...c.effects], p = [...f.effects], m = this.diffCollection(d, p), g = m.deleted.filter((y) => s.effects.has(y));
  if (g.length > 0 && !o)
    try {
      await s.deleteEmbeddedDocuments("ActiveEffect", g, { noHook: !0, pack: l });
    } catch (y) {
      console.warn(y);
    }
  const h = m.updated.filter((y) => s.effects.has(y._id));
  return f.effects = [...m.inserted, ...h], f;
}, "#migrateItem"), cL = /* @__PURE__ */ u(async function(t, s) {
  if (s.some((n) => !!n.updateJournalEntry))
    try {
      const n = await this.getUpdatedJournalEntry(t.toObject(), s), l = foundry.utils.diffObject(t.toObject(), n);
      Object.keys(l).length > 0 && await t.update(l, { noHook: !0 });
    } catch (n) {
      console.warn(n);
    }
}, "#migrateJournalEntry"), uL = /* @__PURE__ */ u(async function(t, s) {
  if (s.some((n) => !!n.updateMacro))
    try {
      const n = await this.getUpdatedMacro(t.toObject(), s), l = foundry.utils.diffObject(t.toObject(), n);
      Object.keys(l).length > 0 && await t.update(l, { noHook: !0 });
    } catch (n) {
      console.warn(n);
    }
}, "#migrateMacro"), fL = /* @__PURE__ */ u(async function(t, s) {
  if (s.some((n) => !!n.updateTable))
    try {
      const n = await this.getUpdatedTable(t.toObject(), s), l = foundry.utils.diffObject(t.toObject(), n);
      Object.keys(l).length > 0 && t.update(l, { noHook: !0 });
    } catch (n) {
      console.warn(n);
    }
}, "#migrateTable"), dL = /* @__PURE__ */ u(async function(t, s) {
  if (!s.some((n) => !!n.updateToken)) return t.toObject();
  try {
    const n = await this.getUpdatedToken(t, s), l = foundry.utils.diffObject(t.toObject(), n);
    if (Object.keys(l).length > 0)
      try {
        await t.update(l, { noHook: !0 });
      } catch (r) {
        console.warn(r);
      }
    return n;
  } catch (n) {
    return console.error(n), null;
  }
}, "#migrateSceneToken"), pL = /* @__PURE__ */ u(async function(t, s) {
  if (s.some((n) => !!n.updateUser))
    try {
      const n = t.toObject(), l = await this.getUpdatedUser(n, s), r = foundry.utils.diffObject(t.toObject(), l);
      Object.keys(r).length > 0 && await t.update(r, { noHook: !0 });
    } catch (n) {
      console.error(n);
    }
}, "#migrateUser"), mL = /* @__PURE__ */ u(async function(t) {
  const s = t.documentClass, n = {
    broadcast: !1,
    modifiedTime: Date.now(),
    parent: null,
    query: {},
    pack: t.collection
  }, l = { type: s.documentName, action: "get", operation: n }, r = await SocketInterface.dispatch("modifyDocument", l);
  return new foundry.abstract.DocumentSocketResponse(r).result;
}, "#getTruePackSource"), l1 = /* @__PURE__ */ u(async function() {
  const t = game.socket;
  Ae(this, aa, await Game.getData(t, "game"));
}, "#setupSourceData"), u(Zl, "MigrationRunnerFoundry");
let tn = Zl;
function CG() {
  return {
    // Constants
    ACTION_CONSUMER_TYPES: [
      "actionUses",
      "ammunition",
      "hitDice",
      "itemUses",
      "quantity",
      "resource",
      "spell"
    ],
    SPELL_CONSUMER_MODES: [
      "variable",
      "chargesOnly",
      "inventionsOnly",
      "slotsOnly",
      "pointsOnly"
    ],
    // Config
    configurableConsumers: /* @__PURE__ */ new Set(["actionUses", "itemUses", "hitDice", "spell"]),
    resourceConsumerConfig: {
      classResource: { path: "resources.classResources", label: "Class Resource", type: "value" },
      exertion: { path: "attributes.exertion.current", label: "A5E.Exertion", type: "value" },
      favorPoints: {
        path: "attributes.favorPoints.current",
        label: "A5E.FavorPoints",
        type: "value"
      },
      hp: { path: "attributes.hp.value", label: "A5E.HitPoints", type: "value" },
      inspiration: { path: "attributes.inspiration", label: "A5E.Inspiration", type: "boolean" },
      primaryResource: {
        path: "resources.primary.value",
        label: "A5E.ResourcesPrimary",
        type: "value"
      },
      secondaryResource: {
        path: "resources.secondary.value",
        label: "A5E.ResourcesSecondary",
        type: "value"
      },
      tertiaryResource: {
        path: "resources.tertiary.value",
        label: "A5E.ResourcesTertiary",
        type: "value"
      },
      quaternaryResource: {
        path: "resources.quaternary.value",
        label: "A5E.ResourcesQuaternary",
        type: "value"
      }
    },
    spellConsumerModes: {
      variable: "A5E.ConsumerSpellModeVariable",
      chargesOnly: "A5E.ConsumerSpellModeChargesOnly",
      inventionsOnly: "A5E.ConsumerSpellModeInventionsOnly",
      pointsOnly: "A5E.ConsumerSpellModePointsOnly",
      slotsOnly: "A5E.ConsumerSpellModeSlotsOnly"
    }
  };
}
u(CG, "registerActionsConfig");
function TG() {
  const i = {
    CUSTOM: 0,
    MULTIPLY: 1,
    ADD: 2,
    SUBTRACT: 3,
    DOWNGRADE: 4,
    UPGRADE: 5,
    OVERRIDE: 6,
    CONDITIONAL: 7
  }, e = {
    onUse: "A5E.effects.types.plural.onUse",
    ongoing: "A5E.effects.types.plural.ongoing",
    inactive: "A5E.effects.types.plural.inactive",
    passive: "A5E.effects.types.plural.passive",
    temporary: "A5E.effects.types.plural.temporary"
  }, t = {
    blinded: "icons/svg/blind.svg",
    bloodied: "icons/svg/blood.svg",
    charmed: "systems/a5e/assets/icons/charmed.svg",
    concentration: "systems/a5e/assets/icons/concentration.svg",
    confused: "systems/a5e/assets/icons/confused.svg",
    corruption: "systems/a5e/assets/icons/corruption.svg",
    dazzled: "systems/a5e/assets/icons/dazzled.svg",
    deafened: "icons/svg/deaf.svg",
    dead: "icons/svg/skull.svg",
    doomed: "systems/a5e/assets/icons/doomed.svg",
    encumbered: "systems/a5e/assets/icons/encumbered.svg",
    enervated: "systems/a5e/assets/icons/enervated.svg",
    fatigue: "systems/a5e/assets/icons/fatigue.svg",
    fixated: "systems/a5e/assets/icons/fixated.svg",
    frightened: "icons/svg/terror.svg",
    grappled: "systems/a5e/assets/icons/grappled.svg",
    hungover: "systems/a5e/assets/icons/hungover.svg",
    incapacitated: "systems/a5e/assets/icons/incapacitated.svg",
    inebriated: "systems/a5e/assets/icons/inebriated.svg",
    invisible: "icons/svg/invisible.svg",
    paralyzed: "icons/svg/paralysis.svg",
    petrified: "systems/a5e/assets/icons/petrified.svg",
    poisoned: "icons/svg/poison.svg",
    prone: "icons/svg/falling.svg",
    rattled: "systems/a5e/assets/icons/rattled.svg",
    restrained: "icons/svg/net.svg",
    slowed: "systems/a5e/assets/icons/slowed.svg",
    strife: "systems/a5e/assets/icons/strife.svg",
    stunned: "icons/svg/daze.svg",
    unconscious: "icons/svg/unconscious.svg"
  };
  return Array.from(
    { length: 10 },
    (f, d) => t[`generic${d + 1}`] = `systems/a5e/assets/icons/circle${d + 1}.svg`
  ), {
    ACTIVE_EFFECT_MODES: i,
    activeEffectTypes: e,
    conditionIconsDefault: t,
    actionActiveEffectTypes: {
      onUse: "A5E.effects.types.singular.onUse"
    },
    actionActiveEffectTypesPlural: {
      onUse: "A5E.effects.types.plural.onUse"
    },
    itemActiveEffectTypes: {
      passive: "A5E.effects.types.singular.passive"
    },
    itemActiveEffectTypesPlural: {
      passive: "A5E.effects.types.plural.passive"
    },
    effectDurationTypes: {
      seconds: "A5E.effects.durationTypes.plural.seconds",
      rounds: "A5E.effects.durationTypes.plural.roundsAndTurns"
    },
    effectDurationUnits: {
      seconds: "A5E.effects.durationUnits.plural.seconds",
      minutes: "A5E.effects.durationUnits.plural.minutes",
      hours: "A5E.effects.durationUnits.plural.hours"
    },
    EXPANDED_EFFECTS: /* @__PURE__ */ new Set([
      "system.attributes.spellDC",
      "flags.a5e.effects.movement.allDistances",
      "flags.a5e.effects.movement.allUnits",
      "flags.a5e.effects.senses.allSenses",
      "flags.a5e.effects.senses.allUnits"
    ])
  };
}
u(TG, "registerActiveEffectConfig");
function OG() {
  return { bonusTypes: {
    abilities: "A5E.Ability",
    attacks: "A5E.Attack",
    damage: "A5E.Damage",
    exertion: "A5E.Exertion",
    healing: "A5E.Healing",
    hitPoint: "A5E.HitPoints",
    initiative: "A5E.Initiative",
    movement: "A5E.Movement",
    senses: "A5E.Senses",
    skills: "A5E.Skill"
  }, bonusLabels: {
    abilities: {
      addButton: "A5E.bonuses.labels.abilities.addButton",
      sectionHeader: "A5E.bonuses.labels.abilities.sectionHeader",
      defaultName: "A5E.bonuses.labels.abilities.defaultName",
      dialogName: "A5E.bonuses.labels.abilities.dialogName"
    },
    attacks: {
      addButton: "A5E.bonuses.labels.attack.addButton",
      sectionHeader: "A5E.bonuses.labels.attack.sectionHeader",
      defaultName: "A5E.bonuses.labels.attack.defaultName",
      dialogName: "A5E.bonuses.labels.attacks.dialogName"
    },
    damage: {
      addButton: "A5E.bonuses.labels.damage.addButton",
      sectionHeader: "A5E.bonuses.labels.damage.sectionHeader",
      defaultName: "A5E.bonuses.labels.damage.defaultName",
      dialogName: "A5E.bonuses.labels.damage.dialogName"
    },
    exertion: {
      addButton: "A5E.bonuses.labels.exertion.addButton",
      sectionHeader: "A5E.bonuses.labels.exertion.sectionHeader",
      defaultName: "A5E.bonuses.labels.exertion.defaultName",
      dialogName: "A5E.bonuses.labels.exertion.dialogName"
    },
    healing: {
      addButton: "A5E.bonuses.labels.healing.addButton",
      sectionHeader: "A5E.bonuses.labels.healing.sectionHeader",
      defaultName: "A5E.bonuses.labels.healing.defaultName",
      dialogName: "A5E.bonuses.labels.healing.dialogName"
    },
    hitPoint: {
      addButton: "A5E.bonuses.labels.hitPoint.addButton",
      sectionHeader: "A5E.bonuses.labels.hitPoint.sectionHeader",
      defaultName: "A5E.bonuses.labels.hitPoint.defaultName",
      dialogName: "A5E.bonuses.labels.hitPoint.dialogName"
    },
    initiative: {
      addButton: "A5E.bonuses.labels.initiative.addButton",
      sectionHeader: "A5E.bonuses.labels.initiative.sectionHeader",
      defaultName: "A5E.bonuses.labels.initiative.defaultName",
      dialogName: "A5E.bonuses.labels.initiative.dialogName"
    },
    movement: {
      addButton: "A5E.bonuses.labels.movement.addButton",
      sectionHeader: "A5E.bonuses.labels.movement.sectionHeader",
      defaultName: "A5E.bonuses.labels.movement.defaultName",
      dialogName: "A5E.bonuses.labels.movement.dialogName"
    },
    senses: {
      addButton: "A5E.bonuses.labels.senses.addButton",
      sectionHeader: "A5E.bonuses.labels.senses.sectionHeader",
      defaultName: "A5E.bonuses.labels.senses.defaultName",
      dialogName: "A5E.bonuses.labels.senses.dialogName"
    },
    skills: {
      addButton: "A5E.bonuses.labels.skills.addButton",
      sectionHeader: "A5E.bonuses.labels.skills.sectionHeader",
      defaultName: "A5E.bonuses.labels.skills.defaultName",
      dialogName: "A5E.bonuses.labels.skills.dialogName"
    }
  }, bonusDialogKeys: {
    abilities: "abilityBonus",
    attacks: "attackBonus",
    damage: "damageBonus",
    exertion: "exertionBonus",
    healing: "healingBonus",
    hitPoint: "hitPointsBonus",
    initiative: "initiativeBonus",
    movement: "movementBonus",
    senses: "sensesBonus",
    skills: "skillBonus"
  } };
}
u(OG, "registerBonusesConfig");
function DG() {
  return { classSpellLists: {
    artificer: "A5E.characterClasses.artificer",
    bard: "A5E.characterClasses.bard",
    cleric: "A5E.characterClasses.cleric",
    druid: "A5E.characterClasses.druid",
    elementalistAir: "A5E.characterClasses.elementalistAir",
    elementalistEarth: "A5E.characterClasses.elementalistEarth",
    elementalistFire: "A5E.characterClasses.elementalistFire",
    elementalistWater: "A5E.characterClasses.elementalistWater",
    herald: "A5E.characterClasses.herald",
    sorcerer: "A5E.characterClasses.sorcerer",
    warlock: "A5E.characterClasses.warlock",
    wielder: "A5E.characterClasses.wielder",
    witch: "A5E.characterClasses.witch",
    wizard: "A5E.characterClasses.wizard"
  }, characterClasses: {
    adept: "A5E.characterClasses.adept",
    artificer: "A5E.characterClasses.artificer",
    bard: "A5E.characterClasses.bard",
    berserker: "A5E.characterClasses.berserker",
    bloodblade: "A5E.characterClasses.bloodblade",
    cleric: "A5E.characterClasses.cleric",
    dirgesinger: "A5E.characterClasses.dirgesinger",
    druid: "A5E.characterClasses.druid",
    elementalist: "A5E.characterClasses.elementalist",
    esper: "A5E.characterClasses.esper",
    fighter: "A5E.characterClasses.fighter",
    gambler: "A5E.characterClasses.gambler",
    herald: "A5E.characterClasses.herald",
    marshal: "A5E.characterClasses.marshal",
    psion: "A5E.characterClasses.psion",
    psyknight: "A5E.characterClasses.psyknight",
    ranger: "A5E.characterClasses.ranger",
    rogue: "A5E.characterClasses.rogue",
    savant: "A5E.characterClasses.savant",
    scholar: "A5E.characterClasses.scholar",
    scientist: "A5E.characterClasses.scientist",
    scout: "A5E.characterClasses.scout",
    sorcerer: "A5E.characterClasses.sorcerer",
    trooper: "A5E.characterClasses.trooper",
    warlock: "A5E.characterClasses.warlock",
    wielder: "A5E.characterClasses.wielder",
    witch: "A5E.characterClasses.witch",
    wizard: "A5E.characterClasses.wizard"
  } };
}
u(DG, "registerCharacterClassesConfig");
function IG() {
  const i = {
    adept: "A5E.characterClasses.adept",
    artificer: "A5E.characterClasses.artificer",
    artificerrevised: "A5E.characterClasses.artificerRevised",
    bard: "A5E.characterClasses.bard",
    berserker: "A5E.characterClasses.berserker",
    bloodblade: "A5E.characterClasses.bloodblade",
    cleric: "A5E.characterClasses.cleric",
    dirgesinger: "A5E.characterClasses.dirgesinger",
    druid: "A5E.characterClasses.druid",
    elementalist: "A5E.characterClasses.elementalist",
    fighter: "A5E.characterClasses.fighter",
    gambler: "A5E.characterClasses.gambler",
    herald: "A5E.characterClasses.herald",
    marshal: "A5E.characterClasses.marshal",
    psion: "A5E.characterClasses.psion",
    psyknight: "A5E.characterClasses.psyknight",
    ranger: "A5E.characterClasses.ranger",
    rogue: "A5E.characterClasses.rogue",
    savant: "A5E.characterClasses.savant",
    scholar: "A5E.characterClasses.scholar",
    scientist: "A5E.characterClasses.scientist",
    scout: "A5E.characterClasses.scout",
    sorcerer: "A5E.characterClasses.sorcerer",
    trooper: "A5E.characterClasses.trooper",
    warlock: "A5E.characterClasses.warlock",
    wielder: "A5E.characterClasses.wielder",
    witch: "A5E.characterClasses.witch",
    wizard: "A5E.characterClasses.wizard"
  }, e = {
    dnd5eArtificer: "A5E.characterClasses.artificer",
    dnd5eBarbarian: "A5E.characterClasses.barbarian",
    dnd5eBard: "A5E.characterClasses.bard",
    dnd5eCleric: "A5E.characterClasses.cleric",
    dnd5eDruid: "A5E.characterClasses.druid",
    dnd5eFighter: "A5E.characterClasses.fighter",
    dnd5eMonk: "A5E.characterClasses.monk",
    dnd5ePaladin: "A5E.characterClasses.paladin",
    dnd5eRanger: "A5E.characterClasses.ranger",
    dnd5eRogue: "A5E.characterClasses.rogue",
    dnd5eSorcerer: "A5E.characterClasses.sorcerer",
    dnd5eWarlock: "A5E.characterClasses.warlock",
    dnd5eWizard: "A5E.characterClasses.wizard"
  }, t = {
    character: "A5E.classes.levelTypes.character",
    class: "A5E.classes.levelTypes.class"
  }, s = {
    average: "A5E.classes.hpTypes.average",
    roll: "A5E.classes.hpTypes.roll",
    custom: "A5E.classes.hpTypes.custom"
  }, n = {
    none: "A5E.None",
    fullCaster: "A5E.classes.casterTypes.fullCaster",
    halfCaster: "A5E.classes.casterTypes.halfCaster",
    halfCasterWithFirstLevel: "A5E.classes.casterTypes.halfCasterWithFirstLevel",
    tertiaryCaster: "A5E.classes.casterTypes.tertiaryCaster",
    quaternaryCaster: "A5E.classes.casterTypes.quaternaryCaster",
    artificerA5e: "A5E.classes.casterTypes.artificerA5e",
    elementalist: "A5E.classes.casterTypes.elementalist",
    herald: "A5E.classes.casterTypes.herald",
    psion: "A5E.classes.casterTypes.psion",
    warlockA5e: "A5E.classes.casterTypes.warlockA5e",
    warlock5e: "A5E.classes.casterTypes.warlock5e",
    wielder: "A5E.classes.casterTypes.wielder"
  }, l = {
    none: "A5E.classes.exertionPoolTypes.none",
    prof: "A5E.classes.exertionPoolTypes.prof",
    doubleProf: "A5E.classes.exertionPoolTypes.double"
  }, r = {
    1: [2],
    2: [3],
    3: [4, 2],
    4: [4, 3],
    5: [4, 3, 2],
    6: [4, 3, 3],
    7: [4, 3, 3, 1],
    8: [4, 3, 3, 2],
    9: [4, 3, 3, 3, 1],
    10: [4, 3, 3, 3, 2],
    11: [4, 3, 3, 3, 2, 1],
    12: [4, 3, 3, 3, 2, 1],
    13: [4, 3, 3, 3, 2, 1, 1],
    14: [4, 3, 3, 3, 2, 1, 1],
    15: [4, 3, 3, 3, 2, 1, 1, 1],
    16: [4, 3, 3, 3, 2, 1, 1, 1],
    17: [4, 3, 3, 3, 2, 1, 1, 1, 1],
    18: [4, 3, 3, 3, 3, 1, 1, 1, 1],
    19: [4, 3, 3, 3, 3, 2, 1, 1, 1],
    20: [4, 3, 3, 3, 3, 2, 2, 1, 1]
  }, o = {
    1: { points: 2, level: 1 },
    2: { points: 4, level: 1 },
    3: { points: 5, level: 1 },
    4: { points: 6, level: 1 },
    5: { points: 7, level: 2 },
    6: { points: 8, level: 2 },
    7: { points: 9, level: 2 },
    8: { points: 10, level: 2 },
    9: { points: 11, level: 3 },
    10: { points: 12, level: 3 },
    11: { points: 13, level: 3 },
    12: { points: 14, level: 3 },
    13: { points: 15, level: 4 },
    14: { points: 16, level: 4 },
    15: { points: 17, level: 4 },
    16: { points: 18, level: 4 },
    17: { points: 19, level: 5 },
    18: { points: 20, level: 5 },
    19: { points: 21, level: 5 },
    20: { points: 22, level: 5 }
  }, a = {
    1: { points: 4, level: 1 },
    2: { points: 5, level: 1 },
    3: { points: 6, level: 1 },
    4: { points: 6, level: 2 },
    5: { points: 7, level: 2 },
    6: { points: 7, level: 2 },
    7: { points: 9, level: 3 },
    8: { points: 9, level: 3 },
    9: { points: 10, level: 3 },
    10: { points: 10, level: 4 },
    11: { points: 11, level: 4 },
    12: { points: 11, level: 4 },
    13: { points: 13, level: 5 },
    14: { points: 13, level: 5 },
    15: { points: 14, level: 5 },
    16: { points: 14, level: 6 },
    17: { points: 15, level: 6 },
    18: { points: 15, level: 6 },
    19: { points: 17, level: 7 },
    20: { points: 17, level: 7 }
  }, c = {
    1: { points: 2, level: 1 },
    2: { points: 4, level: 1 },
    3: { points: 6, level: 2 },
    4: { points: 8, level: 2 },
    5: { points: 10, level: 3 },
    6: { points: 11, level: 3 },
    7: { points: 12, level: 4 },
    8: { points: 13, level: 4 },
    9: { points: 14, level: 5 },
    10: { points: 17, level: 5 },
    11: { points: 21, level: 5 },
    12: { points: 22, level: 5 },
    13: { points: 24, level: 5 },
    14: { points: 25, level: 5 },
    15: { points: 26, level: 5 },
    16: { points: 27, level: 5 },
    17: { points: 28, level: 5 },
    18: { points: 29, level: 5 },
    19: { points: 30, level: 5 },
    20: { points: 31, level: 5 }
  }, f = {
    1: { slots: 1, level: 1 },
    2: { slots: 2, level: 1 },
    3: { slots: 2, level: 2 },
    4: { slots: 2, level: 2 },
    5: { slots: 2, level: 3 },
    6: { slots: 2, level: 3 },
    7: { slots: 2, level: 4 },
    8: { slots: 2, level: 4 },
    9: { slots: 2, level: 5 },
    10: { slots: 2, level: 5 },
    11: { slots: 3, level: 5 },
    12: { slots: 3, level: 5 },
    13: { slots: 3, level: 5 },
    14: { slots: 3, level: 5 },
    15: { slots: 3, level: 5 },
    16: { slots: 3, level: 5 },
    17: { slots: 4, level: 5 },
    18: { slots: 4, level: 5 },
    19: { slots: 4, level: 5 },
    20: { slots: 4, level: 5 }
  }, d = {
    1: { count: 2, level: 1 },
    2: { count: 2, level: 1 },
    3: { count: 2, level: 1 },
    4: { count: 2, level: 1 },
    5: { count: 2, level: 2 },
    6: { count: 3, level: 2 },
    7: { count: 3, level: 2 },
    8: { count: 3, level: 2 },
    9: { count: 3, level: 3 },
    10: { count: 4, level: 3 },
    11: { count: 4, level: 3 },
    12: { count: 4, level: 3 },
    13: { count: 4, level: 4 },
    14: { count: 5, level: 4 },
    15: { count: 5, level: 4 },
    16: { count: 5, level: 4 },
    17: { count: 5, level: 5 },
    18: { count: 6, level: 5 },
    19: { count: 6, level: 5 },
    20: { count: 6, level: 5 }
  }, p = {
    1: { charges: 2, level: 1 },
    2: { charges: 4, level: 1 },
    3: { charges: 5, level: 1 },
    4: { charges: 6, level: 1 },
    5: { charges: 7, level: 2 },
    6: { charges: 8, level: 2 },
    7: { charges: 9, level: 2 },
    8: { charges: 10, level: 2 },
    9: { charges: 11, level: 3 },
    10: { charges: 12, level: 3 },
    11: { charges: 13, level: 3 },
    12: { charges: 14, level: 3 },
    13: { charges: 15, level: 4 },
    14: { charges: 16, level: 4 },
    15: { charges: 17, level: 4 },
    16: { charges: 18, level: 4 },
    17: { charges: 19, level: 5 },
    18: { charges: 20, level: 5 },
    19: { charges: 21, level: 5 },
    20: { charges: 22, level: 5 }
  };
  return {
    classes: i,
    classes5e: e,
    classLevelTypes: t,
    classHPTypes: s,
    casterTypes: n,
    exertionPoolTypes: l,
    SPELL_SLOT_TABLE: r,
    SPELL_POINTS_TABLE_ELEMENTALIST: o,
    SPELL_POINTS_TABLE_PSION: a,
    SPELL_POINTS_TABLE_WARLOCK: c,
    PACT_SLOT_TABLE: f,
    ARTIFICER_SPELL_INVENTIONS: d,
    WIELDER_ARTIFACT_CHARGES: p,
    casterProgression: {
      none: { type: null, config: null, reference: null },
      fullCaster: {
        type: "multiplier",
        config: r,
        resource: "slots",
        multiplier: 1
      },
      halfCaster: {
        type: "multiplier",
        config: r,
        resource: "slots",
        multiplier: 0.5
      },
      tertiaryCaster: {
        type: "multiplier",
        config: r,
        resource: "slots",
        multiplier: 0.33
      },
      quaternaryCaster: {
        type: "multiplier",
        config: r,
        resource: "slots",
        multiplier: 0.25
      },
      halfCasterWithFirstLevel: {
        type: "multiplier",
        config: r,
        resource: "slots",
        multiplier: 0.5,
        roundUp: !0,
        roundUpMulti: !0
      },
      artificerA5e: {
        type: "reference",
        config: d,
        resource: "inventions"
      },
      elementalist: {
        type: "reference",
        config: o,
        resource: "points",
        multiclassMode: "ADD"
      },
      herald: {
        type: "multiplier",
        config: r,
        resource: "slots",
        multiplier: 0.5,
        roundUp: !0,
        roundUpMulti: !1
      },
      psion: {
        type: "reference",
        config: a,
        resource: "points",
        multiclassMode: "ADD"
      },
      warlockA5e: {
        type: "reference",
        config: c,
        resource: "points",
        multiclassMode: "ADD"
      },
      warlock5e: {
        type: "reference",
        config: f,
        resource: "slots"
      },
      wielder: {
        type: "reference",
        config: p,
        resource: "artifactCharges"
      }
    }
  };
}
u(IG, "registerClassesConfig");
function PG() {
  return {
    abilityBonusContexts: {
      base: "A5E.contexts.base",
      check: "A5E.contexts.check",
      save: "A5E.contexts.save"
    },
    damageBonusContexts: {
      meleeWeaponAttack: "A5E.damageBonuses.contexts.meleeWeaponAttacks",
      meleeSpellAttack: "A5E.damageBonuses.contexts.meleeSpellAttacks",
      rangedWeaponAttack: "A5E.damageBonuses.contexts.rangedWeaponAttacks",
      rangedSpellAttack: "A5E.damageBonuses.contexts.rangedSpellAttacks"
    },
    damageBonusSummariesByContext: {
      all: "A5E.damageBonuses.summaries.contexts.all",
      meleeWeaponAttack: "A5E.damageBonuses.summaries.contexts.meleeWeaponAttacks",
      meleeSpellAttack: "A5E.damageBonuses.summaries.contexts.meleeSpellAttacks",
      rangedWeaponAttack: "A5E.damageBonuses.summaries.contexts.rangedWeaponAttacks",
      rangedSpellAttack: "A5E.damageBonuses.summaries.contexts.rangedSpellAttacks",
      spellAttacks: "A5E.damageBonuses.summaries.contexts.spellAttacks",
      weaponAttacks: "A5E.damageBonuses.summaries.contexts.weaponAttacks"
    },
    healingBonusContexts: {
      healing: "A5E.healingBonuses.contexts.healing",
      temporaryHealing: "A5E.healingBonuses.contexts.temporaryHealing"
    },
    healingBonusSummariesByContext: {
      healing: "A5E.healingBonuses.summaries.contexts.healing",
      temporaryHealing: "A5E.healingBonuses.summaries.contexts.temporaryHealing"
    },
    skillBonusContexts: {
      check: "A5E.contexts.check",
      passive: "A5E.contexts.passive"
    }
  };
}
u(PG, "registerContextsConfig");
function r1(i) {
  try {
    return JSON.parse(i);
  } catch {
    return i;
  }
}
u(r1, "parseOrString");
function MG(i) {
  let e;
  try {
    e = JSON.parse(i), e = e instanceof Array ? e : [e];
  } catch {
    e = [i];
  }
  return e;
}
u(MG, "castArray");
function FG(i) {
  let e;
  try {
    e = JSON.parse(i), e = e instanceof Object ? e : {};
  } catch {
    e = {};
  }
  return e;
}
u(FG, "castObject");
function RG(i) {
  let e;
  try {
    e = r1(i), e = e instanceof Set ? e : new Set(e);
  } catch {
    e = /* @__PURE__ */ new Set([i]);
  }
  return e;
}
u(RG, "castSet");
function hL(i, e) {
  if (e === "Array") return MG(i);
  if (e === "Object") return FG(i);
  if (e === "Set") return RG(i);
  if (e === "boolean") return !!r1(i);
  if (e === "number") {
    const t = Number.fromString(i);
    return Number.isNaN(t) ? 0 : t;
  }
  return e === "string" ? String(i) : r1(i);
}
u(hL, "castType");
const NG = {
  "==": /* @__PURE__ */ u((i, e) => i === e, "=="),
  "!=": /* @__PURE__ */ u((i, e) => i !== e, "!="),
  ">=": /* @__PURE__ */ u((i, e) => i >= e, ">="),
  "<=": /* @__PURE__ */ u((i, e) => i <= e, "<="),
  ">": /* @__PURE__ */ u((i, e) => i > e, ">"),
  "<": /* @__PURE__ */ u((i, e) => i < e, "<")
};
function jG(i, e, t, s, n) {
  if (!i && i !== 0) return i;
  const l = NG[e];
  return l(i, t) ? s : n;
}
u(jG, "evaluateConditional");
function LG(i, e) {
  var o, a, c;
  const t = game.model.Actor[i.type] ?? {}, s = foundry.utils.getProperty(i, e) ?? null, n = ((c = (a = (o = game.a5e.activeEffects.options[i.type]) == null ? void 0 : o.allOptions) == null ? void 0 : a[e]) == null ? void 0 : c.sampleValue) ?? foundry.utils.getProperty(t, e) ?? null;
  if (s == null) return n;
  if (!n && n !== 0) return s;
  const l = foundry.utils.getType(s), r = foundry.utils.getType(n);
  if (l === r) return s;
  try {
    return hL(s, r);
  } catch {
    return console.error(
      `Actor [${i.id}] | Unable to parse active effect change for ${e}: "${s}"`
    ), null;
  }
}
u(LG, "getCorrectedTypeValueFromKey");
function mt(i, e = {}, t = {}) {
  var l;
  if (i == null) return null;
  if (typeof i == "string" && i.trim() === "" || typeof i == "number" && i === 0) return 0;
  typeof i == "number" && (i = i.toString()), t.strict ?? (t.strict = !1);
  let s;
  try {
    if (s = new Roll(i, e), !Roll.validate(s.formula)) throw Error("Invalid roll formula");
  } catch {
    return (l = ui.notifications) == null || l.error(`Invalid roll formula: ${i}`), null;
  }
  return s.evaluateSync({ strict: t.strict }).total ?? 0;
}
u(mt, "getDeterministicBonus");
var Os, gL, o1, bL, _L, yL, Ad, a1;
const No = class No extends ActiveEffect {
  constructor() {
    super(...arguments);
    x(this, Os);
  }
  // -------------------------------------------------------
  //  Getters
  // -------------------------------------------------------
  /**
   * @returns {Boolean}
   */
  get isSuppressed() {
    var s;
    if (this.disabled || !["Actor", "ActorDelta", "Token"].includes(this.parent.documentName))
      return !0;
    if (this.system.effectType === "onUse") return !1;
    const { parentItem: t } = this;
    return !t || (t == null ? void 0 : t.type) !== "object" ? !1 : ((s = t == null ? void 0 : t.system) == null ? void 0 : s.equippedState) !== CONFIG.A5E.EQUIPPED_STATES.EQUIPPED;
  }
  get parentItem() {
    var n, l;
    if (!(this.parent instanceof Actor)) return null;
    const t = /Item\.([a-zA-Z0-9]+)/, s = (l = (n = this.origin) == null ? void 0 : n.match(t)) == null ? void 0 : l[1];
    return s ? this.parent.items.get(s) : null;
  }
  get isLocked() {
    var s;
    if (!["Actor", "ActorDelta", "Token"].includes(this.parent.documentName)) return !0;
    if (this.system.effectType === "onUse") return !1;
    const { parentItem: t } = this;
    return !t || (t == null ? void 0 : t.type) !== "object" ? !1 : ((s = t == null ? void 0 : t.system) == null ? void 0 : s.equippedState) !== CONFIG.A5E.EQUIPPED_STATES.EQUIPPED;
  }
  // -------------------------------------------------------
  //  Class Methods
  // -------------------------------------------------------
  /**
   * @inheritdoc
   */
  apply(t, s, n = "applyAEs") {
    if (this.isSuppressed) return null;
    const l = foundry.utils.deepClone(s);
    if (l.key = l.key.replace("@token.", ""), n === "applyAEs") {
      const d = foundry.utils.deepClone(l.value).replace("@original", "");
      if (Roll.replaceFormulaData(d, t.getRollData(), { missing: null }).includes("null")) return null;
    }
    const r = LG(t, l.key) ?? null;
    l.mode !== CONFIG.A5E.ACTIVE_EFFECT_MODES.CUSTOM && (l.value = l.value.replace("@original", r));
    const o = foundry.utils.getType(r), a = hL(X(this, Os, yL).call(this, t, l), o), c = X(this, Os, gL).call(this, t, r, l, a), f = { [l.key]: c };
    return foundry.utils.mergeObject(t, f), f;
  }
  // -------------------------------------------------------
  //  CRUD Methods
  // -------------------------------------------------------
  _onCreate(t, s, n) {
    var l;
    super._onCreate(t, s, n), X(this, Os, Ad).call(this), ((l = this.parent) == null ? void 0 : l.documentName) !== "Item" && X(this, Os, a1).call(this, t, n, !0);
  }
  _preUpdate(t, s, n) {
    this._preUpdateParentEffect(t, s, n), this._preUpdateStatusEffects(t, s, n);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _preUpdateParentEffect(t, s, n) {
    var a;
    if (!(((a = this.parent) == null ? void 0 : a.parent) instanceof Actor)) return;
    const l = this.parent.parent;
    if (this.system.effectType !== "passive") return;
    const r = l.effects.contents.find((c) => this.equals(c));
    if (!r) return;
    const o = foundry.utils.deepClone(t);
    delete o._id, r.update(o);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _preUpdateStatusEffects(t, s, n) {
    const l = t.changes ?? [], r = /* @__PURE__ */ new Set();
    l.forEach((o) => {
      if (o.key !== "flags.a5e.effects.statusConditions") return;
      let a;
      try {
        if (a = JSON.parse(o.value), !Array.isArray(a)) return;
      } catch {
        return;
      }
      a.forEach((c) => {
        const f = CONFIG.statusEffects.find((d) => d.id === c);
        f && r.add(f.id);
      });
    }), r.size && (t.statuses = Array.from(r));
  }
  _onUpdate(t, s, n) {
    var r;
    if (super._onUpdate(t, s, n), X(this, Os, Ad).call(this), !(((r = this.parent) == null ? void 0 : r.parent) instanceof Actor)) return;
    const l = this.parent.parent;
    l.effectPhases = null, l.reset();
  }
  _onDelete(t, s) {
    var n;
    super._onDelete(t, s), X(this, Os, Ad).call(this), ((n = this.parent) == null ? void 0 : n.documentName) === "Actor" && (this.parent.effectPhases = null, this.parent.reset(), X(this, Os, a1).call(this, {}, s, !1));
  }
  async duplicateEffect(t = null) {
    const s = this.parent, n = foundry.utils.duplicate(this);
    if (n.name = `${K(n.name)} (Copy)`, !s) return;
    const l = await s.createEmbeddedDocuments("ActiveEffect", [n]);
    if ((s == null ? void 0 : s.documentName) === "Item" && t) {
      const r = s.actions.get(t);
      s.update({
        [`system.actions.${t}.effects`]: [[...r.effects], ...l.map((o) => o.id)]
      });
    }
  }
  // -------------------------------------------------------
  //  Custom API
  // -------------------------------------------------------
  async toggleActiveState() {
    await this.update({ disabled: !this.disabled });
  }
  /**
   * Transfer effect to another document
   */
  transferEffect(t) {
    ["Actor", "ActorDelta", "Token"].includes(t.documentName) || ui.notifications.error(
      `Document of type ${t.documentName} is not supported by this operation.`
    );
    const s = foundry.utils.deepClone(this);
    s.origin = this.parent.uuid;
    const n = t.documentName === "Token" ? t.actor.effects.contents : t.effects.contents;
    for (const l of n)
      if (this.equals(l)) {
        l.update({ disabled: !1 });
        return;
      }
    t.createEmbeddedDocuments("ActiveEffect", [s]);
  }
  equals(t) {
    var l, r, o, a, c, f, d, p;
    const s = foundry.utils.deepClone(this.toObject()), n = foundry.utils.deepClone(t.toObject());
    return delete s._id, delete n._id, delete s.disabled, delete n.disabled, delete s.duration, delete n.duration, (r = (l = s.flags) == null ? void 0 : l.a5e) == null || delete r.sort, (a = (o = n.flags) == null ? void 0 : o.a5e) == null || delete a.sort, (f = (c = s.flags) == null ? void 0 : c.a5e) == null || delete f.actionId, (p = (d = n.flags) == null ? void 0 : d.a5e) == null || delete p.actionId, s.changes.forEach((m) => delete m.priority), n.changes.forEach((m) => delete m.priority), foundry.utils.objectsEqual(s, n);
  }
  // -------------------------------------------------------
  //  Static Methods
  // -------------------------------------------------------
  static generateExpandedEffects(t) {
    const s = [], n = [];
    t.forEach(({ change: l, effect: r }) => {
      var o, a;
      CONFIG.A5E.EXPANDED_EFFECTS.has(l.key) && (l.key === "flags.a5e.effects.movement.allDistances" && Object.keys(CONFIG.A5E.movement).forEach((f) => {
        const d = foundry.utils.deepClone(l);
        d.key = `system.attributes.movement.${f}.distance`, s.push({ effect: r, change: d }), n.push(l.key);
      }), l.key === "flags.a5e.effects.movements.allUnits" && Object.keys(CONFIG.A5E.movement).forEach((f) => {
        const d = foundry.utils.deepClone(l);
        d.key = `system.attributes.movement.${f}.unit`, s.push({ effect: r, change: d }), n.push(l.key);
      }), l.key === "flags.a5e.effects.senses.allSenses" && Object.keys(CONFIG.A5E.senses).forEach((f) => {
        const d = foundry.utils.deepClone(l);
        d.key = `system.attributes.senses.${f}.value`, s.push({ effect: r, change: d }), n.push(l.key);
      }), l.key === "flags.a5e.effects.senses.allUnits" && Object.keys(CONFIG.A5E.senses).forEach((f) => {
        const d = foundry.utils.deepClone(l);
        d.key = `system.attributes.senses.${f}.unit`, s.push({ effect: r, change: d }), n.push(l.key);
      }), l.key === "system.attributes.spellDC" && Object.keys(((a = (o = r.parent) == null ? void 0 : o.system) == null ? void 0 : a.spellBooks) ?? {}).forEach((f) => {
        const d = foundry.utils.deepClone(l);
        d.key = `system.spellBooks.${f}.stats.dc`, s.push({ effect: r, change: d });
      }));
    }), n.forEach((l) => {
      const r = t.findIndex((o) => o.change.key === l);
      r !== -1 && t.splice(r, 1);
    }), t.push(...s);
  }
  /**
   *
   * @param {} document
   * @param {Array<ActiveEffectA5e>} effects
   * @param {() => boolean} predicate
   */
  static applyEffects(t, s, n, l, r = () => !0) {
    var c;
    const o = {}, a = s.flatMap((f) => f.disabled || f.isSuppressed ? [] : (t.documentName !== "Token" && f.statuses.forEach((d) => t.statuses.add(d)), f._source.changes.filter(r).map((d) => {
      const p = d.priority ?? 0;
      return d.priority = p ?? d.mode * 10, { effect: f, change: d };
    })));
    this.generateExpandedEffects(a), n === "afterDerived" && a.push(...((c = t.effectPhases) == null ? void 0 : c[n]) ?? []), a.sort((f, d) => (f.change.priority ?? 0) - (d.change.priority ?? 0)), a.forEach((f) => {
      var p, m, g;
      if (!((p = f.change) != null && p.key)) return;
      let d;
      if (t.documentName === "Token" && n === "afterDerived")
        d = f.effect.apply(t, f.change, n), Object.assign(o, d);
      else {
        if (d = f.effect.apply(t, f.change, n), d === null && !f.effect.isSuppressed) {
          if (!l) {
            ui.notifications.error(K("A5E.notifications.effects.invalidChange"));
            return;
          }
          let h = ((m = t.effectPhases[l]) == null ? void 0 : m.findIndex(
            (_) => _.effect._id === f.effect._id && _.change.key === f.change.key
          )) ?? -1;
          if (h === -1 && t.effectPhases[l].push(f), n === "afterDerived") return;
          h = ((g = t.effectPhases[n]) == null ? void 0 : g.findIndex(
            (_) => _.effect._id === f.effect._id && _.change.key === f.change.key
          )) ?? -1, h !== -1 && t.effectPhases[n].splice(h, 1);
        }
        Object.assign(o, d);
      }
    }), t.overrides = foundry.utils.expandObject({
      ...foundry.utils.flattenObject(t.overrides),
      ...o
    });
  }
  /**
   * Creates a new default active effect on an actor or an item
   * @param {import("../actor/actor").default| import("../item").default} parentDocument
   * @returns
   */
  static createDefaultEffect(t) {
    const s = {
      name: K("A5E.effects.new"),
      icon: this.FALLBACK_IMG,
      flags: { a5e: { sort: 0 } }
    };
    return super.create(s, { parent: t });
  }
};
Os = new WeakSet(), /**
 * Returns the new value that should be applied to the actor.
 * @param {*} current
 * @param {*} change
 */
gL = /* @__PURE__ */ u(function(t, s, n, l) {
  const r = CONFIG.A5E.ACTIVE_EFFECT_MODES, { mode: o } = n;
  if (o === r.ADD) return X(this, Os, o1).call(this, s, l);
  if (o === r.MULTIPLY)
    return typeof l == "number" && (typeof s == "number" || s === void 0) ? Math.trunc((s ?? 0) * l) : s;
  if ([r.SUBTRACT, r.REMOVE].includes(o)) {
    const a = (typeof s == "number" || s === void 0) && typeof l == "number" ? -1 * l : l;
    return X(this, Os, o1).call(this, s, a, !0);
  }
  return o === r.DOWNGRADE ? typeof l == "number" && (typeof s == "number" || s === void 0) ? Math.min(s ?? 0, l) : s : o === r.UPGRADE ? typeof l == "number" && (typeof s == "number" || s === void 0) ? Math.max(s ?? 0, l) : s : o === r.OVERRIDE ? l : o === r.CUSTOM ? X(this, Os, bL).call(this, s, l, n) : o === r.CONDITIONAL ? X(this, Os, _L).call(this, t, s, n) : s;
}, "#getNewValue"), o1 = /* @__PURE__ */ u(function(t, s, n = !1) {
  const l = typeof s == "number" && (typeof t == "number" || [void 0, null].includes(t)), r = Array.isArray(t) && s instanceof Array, o = t instanceof Set && s instanceof Set;
  return l ? (t ?? 0) + s : r ? n ? t.filter((a) => !s.includes(a)) : [.../* @__PURE__ */ new Set([...t, ...s])] : o ? n ? t.difference(s) : t.union(s) : t.length ? n ? `${t} - ${s}` : `${t} + ${s}` : s;
}, "#addOrSubtractValues"), bL = /* @__PURE__ */ u(function(t, s, n) {
  if (!n.key.startsWith("flags.a5e.effects")) return null;
  let l = "";
  switch (s = s || "", n.key) {
    case "flags.a5e.effects.damageResistances.all":
    case "flags.a5e.effects.damageVulnerabilities.all":
    case "flags.a5e.effects.damageImmunities.all":
      l = `system.traits.${n.key.split(".").at(-2)}`, s = Object.keys(CONFIG.A5E.damageTypes);
      break;
    case "flags.a5e.effects.conditionImmunities.all":
      l = `system.traits.${n.key.split(".").at(-2)}`, s = Object.keys(CONFIG.A5E.conditions);
      break;
    default:
      if (n.key.startsWith("flags.a5e.effects.bonuses")) {
        l = `system.bonuses.${n.key.split(".").at(-1)}.${foundry.utils.randomID()}`;
        break;
      }
      break;
  }
  return n.key = l, s;
}, "#applyCustom"), _L = /* @__PURE__ */ u(function(t, s, n) {
  let l;
  try {
    if (l = JSON.parse(n.value), typeof l != "object") return s;
  } catch {
    return s;
  }
  let r = `${l.positiveValue}`, o = `${l.negativeValue}`;
  const a = mt(l.comparisonValue ?? "0", t.getRollData()), c = l.comparisonOperator ?? "==";
  return r = mt(r ?? "0", t.getRollData()), o = mt(o ?? "0", t.getRollData()), jG(s, c, a, r, o);
}, "#applyConditional"), /**
 *
 * @param {import("../actor/actor").default| import("../item").default} document
 * @param {*} change
 * @param {*} delta
 */
yL = /* @__PURE__ */ u(function(t, s) {
  var r, o;
  const n = t.documentName === "Actor", l = t.documentName === "Item";
  if (s.mode === CONFIG.A5E.ACTIVE_EFFECT_MODES.CONDITIONAL) return 0;
  try {
    if (n)
      return typeof game.a5e.activeEffects.options[t.type].allOptions[s.key].sampleValue != "number" ? s.value : mt(s.value ?? 0, t.getRollData()) ?? s.value;
    if (l && ((r = t.parent) == null ? void 0 : r.documentName) === "Actor")
      return mt(s.value ?? 0, (o = t.parent) == null ? void 0 : o.getRollData()) ?? s.value;
  } catch {
    return s.value;
  }
  return s.value;
}, "#convertToDeterministicBonus"), /**
 * Updates the canvas perception and lights if token effect has changed.
 * @param {Object} data
 */
Ad = /* @__PURE__ */ u(function() {
  var n, l;
  if (((n = this.parent) == null ? void 0 : n.documentName) !== "Actor") return;
  const t = ((l = this.changes) == null ? void 0 : l.map((r) => r.key)) ?? [];
  if (!t.some((r) => r.startsWith("@token"))) return;
  if (foundry.utils.getProperty(this.parent, "prototypeToken.actorLink") ?? !0) {
    const r = this.parent.getActiveTokens().map((o) => o.document);
    if (!r.length) return;
    r.forEach((o) => {
      var a;
      o == null || o.reset(), (a = o == null ? void 0 : o.object) == null || a.draw();
    });
  } else {
    if (!this.parent.token) return;
    this.parent.token.reset(), this.parent.token.object.draw();
  }
  const s = t.some((r) => r.startsWith("@token.light"));
  s && canvas.perception.update({ initializeLighting: s }, !0);
}, "#updateCanvas"), a1 = /* @__PURE__ */ u(async function(t, s, n) {
  if (game.user.id !== s) return;
  const l = t.statuses ?? [...(this == null ? void 0 : this.statuses) ?? []], r = /* @__PURE__ */ new Set();
  if (l.forEach((a) => {
    const c = CONFIG.statusEffects.find((f) => f.id === a);
    c && r.add(...(c == null ? void 0 : c.statuses) ?? []);
  }), !r.size) return;
  const o = this.parent;
  o && r.forEach(async (a) => {
    const c = CONFIG.statusEffects.find((d) => d.id === a);
    if (!c) return;
    const f = await o.toggleStatusEffect(c.id, { active: n });
    f && f.update({ "flags.a5e.source": l[0] });
  });
}, "#handleSubConditions"), u(No, "ActiveEffectA5e"), // -------------------------------------------------------
//  Static Properties
// -------------------------------------------------------
qe(No, "FALLBACK_IMG", "icons/svg/hazard.svg"), qe(No, "PHASES", ["applyAEs", "afterDerived"]), qe(No, "ITEM_TYPES", ["passive", "onUse"]);
let lc = No;
const ki = class ki extends foundry.abstract.TypeDataModel {
  get metadata() {
    return ki.metadata;
  }
  static get fullType() {
    return this.metadata.type ? `${this.metadata.module}.${this.metadata.type}` : this.metadata.module;
  }
  static defineSchema() {
    var t;
    const e = {};
    for (const s of this._schemaTemplates) {
      if (!s.defineSchema)
        throw new Error(
          `Invalid a5e template mixin ${s} defined on class ${this.constructor}`
        );
      this.mergeSchema(e, ((t = s.defineSchema) == null ? void 0 : t.call(s)) ?? {});
    }
    return e;
  }
  /**
   * The field names of the base templates used for construction.
   * @type {Set<string>}
   * @private
   */
  static get _schemaTemplateFields() {
    const e = Object.freeze(
      new Set(this._schemaTemplates.map((t) => t.schema.keys()).flat())
    );
    return Object.defineProperty(this, "_schemaTemplateFields", {
      value: e,
      writable: !1,
      configurable: !1
    }), e;
  }
  static mergeSchema(e, t) {
    const { fields: s } = foundry.data;
    for (const n of Object.keys(t)) {
      if (!(n in e) || e[n].constructor !== t[n].constructor) {
        t[n] === !1 ? delete e[n] : e[n] = t[n];
        continue;
      }
      const l = foundry.utils.mergeObject(e[n].options, t[n].options), r = t[n].constructor;
      if (r === s.SchemaField) {
        const o = this.mergeSchema(e[n].fields, t[n].fields);
        Object.values(o).forEach((a) => {
          a.parent = void 0;
        }), e[n] = new s.SchemaField(o, l);
      } else if (r === s.ArrayField || r === s.SetField) {
        const o = foundry.utils.mergeObject(
          e[n].element.options,
          t[n].element.options
        ), a = (t[n].element || e[n].element).constructor;
        e[n] = new t[n].constructor(new a(o), l);
      } else
        e[n] = new t[n].constructor(l);
    }
    return e;
  }
  // eslint-disable-next-line generator-star-spacing
  static *_initializationOrder() {
    super._initializationOrder();
    for (const e of this._schemaTemplates)
      for (const t of e._initializationOrder())
        t[1] = this.schema.get(t[0]), yield t;
    for (const e of this.schema.entries())
      this._schemaTemplateFields.has(e[0]) || (yield e);
  }
  /**
   * Mix multiple templates with the base type.
   */
  static mixin(...e) {
    var s;
    const t = (s = class extends ki {
    }, u(s, "Base"), s);
    Object.defineProperty(t, "_schemaTemplates", {
      value: Object.seal([...this._schemaTemplates, ...e]),
      writable: !1,
      configurable: !1
    });
    for (const n of e) {
      let l;
      for (const [r, o] of Object.entries(Object.getOwnPropertyDescriptors(n)))
        r === "defineSchema" && (l = o), !this._immiscible.has(r) && Object.defineProperty(t.prototype, r, { ...o, enumerable: !0 });
      for (const [r, o] of Object.entries(
        Object.getOwnPropertyDescriptors(n.prototype)
      ))
        ["constructor"].includes(r) || Object.defineProperty(t.prototype, r, { ...o, enumerable: !0 });
      l && Object.defineProperty(t, `${n.name}_defineSchema`, l);
    }
    return t;
  }
  /**
   * Determine whether this class mixes in a specific template.
   */
  static mixes(e) {
    return foundry.utils.getType(e) === "string" ? this._schemaTemplates.find((t) => t.name === e) !== void 0 : this._schemaTemplates.includes(e);
  }
  /**
   * Helper method to get all enumerable methods, inherited or own, for this class.
   * @param {object} options
   * @param {string} [options.startingWith] - Optional filtering string.
   * @param {string} [options.notEndingWith] - Exclude any method that ends with this suffix.
   * @param {boolean} [options.prototype=true] - Whether the prototype should be checked or the class.
   * @returns {string[]} - Array of method keys.
   */
  static _getMethods({
    startingWith: e,
    notEndingWith: t,
    prototype: s = !0
  }) {
    let n = [];
    for (const l in s ? this.prototype : this)
      n.push(l);
    for (let l of [this, ...foundry.utils.getParentClasses(this)].reverse())
      ["Base", "BaseDataModel", "DataModel"].includes(l.name) || (s && (l = l.prototype), n.push(...Object.getOwnPropertyNames(l)));
    return e && (n = n.filter((l) => l.startsWith(e) && l !== e)), t && (n = n.filter((l) => !l.endsWith(t))), n;
  }
  static migrateData(e) {
    return this._getMethods({ startingWith: "migrate", notEndingWith: "Data", prototype: !1 }).forEach(
      (t) => this[t](e)
    ), super.migrateData(e);
  }
  prepareBaseData() {
    ki._getMethods({ startingWith: "prepareBase", notEndingWith: "Data" }).forEach(
      (e) => this[e]()
    );
  }
  prepareEmbeddedData() {
    ki._getMethods({ startingWith: "prepareEmbedded", notEndingWith: "Data" }).forEach(
      (e) => this[e]()
    );
  }
  prepareDerivedData() {
    ki._getMethods({ startingWith: "prepareDerived", notEndingWith: "Data" }).forEach(
      (e) => this[e]()
    );
  }
};
u(ki, "A5EDataModel"), qe(ki, "metadata", {}), qe(ki, "_schemaTemplates", []), qe(ki, "_immiscible", /* @__PURE__ */ new Set([
  "length",
  "mixed",
  "name",
  "prototype",
  "migrateData",
  "defineSchema"
]));
let Zd = ki;
const dw = class dw extends Zd {
  constructor(e, t = {}) {
    super(e, t);
  }
  static defineSchema() {
    const { fields: e } = foundry.data;
    return {
      // TODO: v12 - Update to UUIDField in v12
      itemUuid: new e.StringField({ required: !0, initial: "" }),
      // itemUuid: new fields.DocumentUUIDField({ required: true, initial: '' }),
      grantId: new e.DocumentIdField({ required: !0, initial: "" }),
      grantType: new e.StringField({ required: !0, initial: "" }),
      level: new e.NumberField({
        nullable: !1,
        initial: 1,
        integer: !0,
        min: 1
      })
    };
  }
};
u(dw, "ActorBaseGrant");
let pi = dw;
const pw = class pw extends pi {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "bonus" }),
      bonusId: new e.StringField({ required: !0, initial: "" }),
      type: new e.StringField({ required: !0, initial: "" })
    });
  }
};
u(pw, "ActorBonusGrant");
let c1 = pw;
const mw = class mw extends pi {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "feature" }),
      documentIds: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
        required: !0,
        initial: []
      })
    });
  }
};
u(mw, "ActorFeatureGrant");
let u1 = mw;
const hw = class hw extends pi {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "item" }),
      documentIds: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
        required: !0,
        initial: []
      })
    });
  }
};
u(hw, "ActorItemGrant");
let f1 = hw;
const gw = class gw extends pi {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "exertion" }),
      exertionData: new e.SchemaField({
        exertionType: new e.StringField({ required: !0, initial: "" }),
        bonusId: new e.StringField({ required: !1, initial: "" }),
        poolType: new e.StringField({ required: !0, initial: "" })
      }),
      type: new e.StringField({ required: !0, initial: "" })
    });
  }
};
u(gw, "ActorExertionGrant");
let d1 = gw;
const bw = class bw extends pi {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "expertiseDice" }),
      expertiseDiceData: new e.SchemaField({
        keys: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
        expertiseCount: new e.NumberField({ nullable: !1, initial: 1, integer: !0 }),
        expertiseType: new e.StringField({ required: !0, initial: "" })
      })
    });
  }
};
u(bw, "ActorExpertiseDiceGrant");
let p1 = bw;
const _w = class _w extends pi {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "proficiency" }),
      proficiencyData: new e.SchemaField({
        keys: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
        proficiencyType: new e.StringField({ required: !0, initial: "" })
      })
    });
  }
};
u(_w, "ActorProficiencyGrant");
let m1 = _w;
const yw = class yw extends pi {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "rollOverride" }),
      rollOverrideData: new e.SchemaField({
        keys: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
        rollOverrideType: new e.StringField({ required: !1, initial: "abilityCheck" }),
        rollMode: new e.NumberField({ nullable: !1, initial: 0 })
      })
    });
  }
};
u(yw, "ActorRollOverrideGrant");
let h1 = yw;
const vw = class vw extends pi {
  defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "skillSpecialty" }),
      specialtyData: new e.SchemaField({
        specialties: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
        skill: new e.StringField({ required: !0, initial: "" })
      })
    });
  }
};
u(vw, "ActorSkillSpecialtyGrant");
let g1 = vw;
const kw = class kw extends pi {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "trait" }),
      traitData: new e.SchemaField({
        traits: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
        traitType: new e.StringField({ required: !0, initial: "" })
      })
    });
  }
};
u(kw, "ActorTraitGrant");
let b1 = kw;
const vi = {
  base: pi,
  bonus: c1,
  feature: u1,
  item: f1,
  exertion: d1,
  expertiseDice: p1,
  proficiency: m1,
  rollOverride: h1,
  skillSpecialty: g1,
  trait: b1
};
var wl, Kr, Si, Uu, y1;
const ww = class ww {
  /**
   * @param {object}   application - The application.
   */
  constructor(e) {
    x(this, Uu);
    /** @type {object} */
    x(this, wl);
    /**
     * Stores the current save state key being restored by animating. When a restore is already being animated with the
     * same name the subsequent restore animation is ignored.
     *
     * @type {string | undefined}
     */
    x(this, Kr);
    /** @type {Map<string, import('./types').ApplicationStateData>} */
    x(this, Si, /* @__PURE__ */ new Map());
    Ae(this, wl, e), Object.seal(this);
  }
  /**
   * Clears all saved application state.
   */
  clear() {
    P(this, Si).clear();
  }
  /**
   * Returns current application state along with any extra data passed into method.
   *
   * @param {object} [extra] - Extra data to add to application state.
   *
   * @returns {import('./types').ApplicationStateData} Passed in object with current application state.
   */
  current(e = {}) {
    var t, s, n, l, r, o, a, c;
    return Object.assign(e, {
      position: (s = (t = P(this, wl)) == null ? void 0 : t.position) == null ? void 0 : s.get(),
      beforeMinimized: (l = (n = P(this, wl)) == null ? void 0 : n.position) == null ? void 0 : l.state.get({ name: "#beforeMinimized" }),
      options: (o = (r = P(this, wl)) == null ? void 0 : r.reactive) == null ? void 0 : o.toJSON(),
      ui: { minimized: (c = (a = P(this, wl)) == null ? void 0 : a.reactive) == null ? void 0 : c.minimized }
    });
  }
  /**
   * Gets any saved application state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Saved data set name.
   *
   * @returns {import('./types').ApplicationStateData | undefined} Any saved application state.
   */
  get({ name: e }) {
    if (typeof e != "string")
      throw new TypeError("ApplicationState - get error: 'name' is not a string.");
    return P(this, Si).get(e);
  }
  /**
   * @returns {IterableIterator<string>} The saved application state names / keys.
   */
  keys() {
    return P(this, Si).keys();
  }
  /**
   * Removes and returns any saved application state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Name to remove and retrieve.
   *
   * @returns {import('./types').ApplicationStateData | undefined} Any saved application state.
   */
  remove({ name: e }) {
    if (typeof e != "string")
      throw new TypeError("ApplicationState - remove: 'name' is not a string.");
    const t = P(this, Si).get(e);
    return P(this, Si).delete(e), t;
  }
  /**
   * Restores a previously saved application state by `name` returning the data. Several optional parameters are
   * available to animate / tween to the new state. When `animateTo` is true an animation is scheduled via
   * {@link AnimationAPI.to} and the duration and easing name or function may be specified.
   *
   * @param {object}            options - Options.
   *
   * @param {string}            options.name - Saved data set name.
   *
   * @param {boolean}           [options.remove=false] - Remove data set.
   *
   * @param {boolean}           [options.animateTo=false] - Animate to restore data.
   *
   * @param {number}            [options.duration=0.1] - Duration in seconds.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/easing').EasingReference} [options.ease='linear'] - Easing function or easing
   *        function name.
   *
   * @returns {import('./types').ApplicationStateData | undefined} Any saved application state.
   */
  restore({ name: e, remove: t = !1, animateTo: s = !1, duration: n = 0.1, ease: l = "linear" }) {
    if (typeof e != "string")
      throw new TypeError("ApplicationState - restore error: 'name' is not a string.");
    const r = P(this, Si).get(e);
    return r && (t && P(this, Si).delete(e), s && e !== P(this, Kr) && (Ae(this, Kr, e), X(this, Uu, y1).call(this, r, {
      animateTo: s,
      async: !0,
      duration: n,
      ease: l
    }).then(() => {
      e === P(this, Kr) && Ae(this, Kr, void 0);
    }))), r;
  }
  /**
   * Saves current application state with the opportunity to add extra data to the saved state.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Name to index this saved state.
   *
   * @returns {import('./types').ApplicationStateData} Current saved application state.
   */
  save({ name: e, ...t }) {
    if (typeof e != "string")
      throw new TypeError("ApplicationState - save error: 'name' is not a string.");
    const s = this.current(t);
    return P(this, Si).set(e, s), s;
  }
  /**
   * Sets application state from the given {@link ApplicationStateData} instance. Several optional parameters are
   * available to animate / tween to the new state. When `animateTo` is true an animation is scheduled via
   * {@link AnimationAPI.to} and the duration and easing name or function may be specified.
   *
   * Note: If serializing application state any minimized apps will use the before minimized state on initial render
   * of the app as it is currently not possible to render apps with Foundry VTT core API in the minimized state.
   *
   * @param {import('./types').ApplicationStateData}   data - Saved data set name.
   *
   * @param {object}         [options] - Optional parameters
   *
   * @param {boolean}        [options.animateTo=false] - Animate to restore data.
   *
   * @param {number}         [options.duration=0.1] - Duration in seconds.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/easing').EasingReference} [options.ease='linear'] - Easing function or easing
   *        function name.
   */
  set(e, t = {}) {
    X(this, Uu, y1).call(this, e, { ...t, async: !1 });
  }
};
wl = new WeakMap(), Kr = new WeakMap(), Si = new WeakMap(), Uu = new WeakSet(), // Internal implementation ----------------------------------------------------------------------------------------
/**
 * Sets application state from the given {@link ApplicationStateData} instance. Several optional parameters are
 * available to animate / tween to the new state. When `animateTo` is true an animation is scheduled via
 * {@link AnimationAPI.to} and the duration and easing name or function may be specified.
 *
 * Note: If serializing application state any minimized apps will use the before minimized state on initial render
 * of the app as it is currently not possible to render apps with Foundry VTT core API in the minimized state.
 *
 * TODO: THIS METHOD NEEDS TO BE REFACTORED WHEN TRL IS MADE INTO A STANDALONE FRAMEWORK.
 *
 * @param {import('./types').ApplicationStateData}   data - Saved data set name.
 *
 * @param {object}            [opts] - Optional parameters
 *
 * @param {boolean}           [opts.async=false] - If animating return a Promise that resolves with any saved data.
 *
 * @param {boolean}           [opts.animateTo=false] - Animate to restore data.
 *
 * @param {number}            [opts.duration=0.1] - Duration in seconds.
 *
 * @param {import('@typhonjs-fvtt/runtime/svelte/easing').EasingReference} [opts.ease='linear'] - Easing function or easing
 *        function name.
 *
 * @returns {undefined | Promise<void>} When asynchronous the animation Promise.
 */
y1 = /* @__PURE__ */ u(function(e, { async: t = !1, animateTo: s = !1, duration: n = 0.1, ease: l = "linear" } = {}) {
  var a, c, f, d, p;
  if (!he(e))
    throw new TypeError("ApplicationState - restore error: 'data' is not an object.");
  const r = P(this, wl);
  if (!he(e == null ? void 0 : e.position)) {
    console.warn("ApplicationState.set warning: 'data.position' is not an object.");
    return;
  }
  const o = r.rendered;
  if (s) {
    if (!o) {
      console.warn("ApplicationState.set warning: Application is not rendered and 'animateTo' is true.");
      return;
    }
    if (e.position.transformOrigin !== r.position.transformOrigin && (r.position.transformOrigin = e.position.transformOrigin), he(e == null ? void 0 : e.ui)) {
      const g = typeof ((a = e.ui) == null ? void 0 : a.minimized) == "boolean" ? e.ui.minimized : !1;
      (c = r == null ? void 0 : r.reactive) != null && c.minimized && !g && r.maximize({ animate: !1, duration: 0 });
    }
    const m = r.position.animate.to(e.position, {
      duration: n,
      ease: l,
      strategy: "cancelAll"
    }).finished.then(({ cancelled: g }) => {
      var h, _;
      if (!g) {
        if (he(e == null ? void 0 : e.options) && (r == null || r.reactive.mergeOptions(e.options)), he(e == null ? void 0 : e.ui)) {
          const y = typeof ((h = e.ui) == null ? void 0 : h.minimized) == "boolean" ? e.ui.minimized : !1;
          !((_ = r == null ? void 0 : r.reactive) != null && _.minimized) && y && r.minimize({ animate: !1, duration: 0 });
        }
        he(e == null ? void 0 : e.beforeMinimized) && r.position.state.set({ name: "#beforeMinimized", ...e.beforeMinimized });
      }
    });
    if (t)
      return m;
  } else if (o) {
    if (he(e == null ? void 0 : e.options) && (r == null || r.reactive.mergeOptions(e.options)), he(e == null ? void 0 : e.ui)) {
      const m = typeof ((f = e.ui) == null ? void 0 : f.minimized) == "boolean" ? e.ui.minimized : !1;
      (d = r == null ? void 0 : r.reactive) != null && d.minimized && !m ? r.maximize({ animate: !1, duration: 0 }) : !((p = r == null ? void 0 : r.reactive) != null && p.minimized) && m && r.minimize({ animate: !1, duration: n });
    }
    he(e == null ? void 0 : e.beforeMinimized) && r.position.state.set({ name: "#beforeMinimized", ...e.beforeMinimized }), r.position.set(e.position);
  } else {
    let m = e.position;
    he(e.beforeMinimized) && (m = e.beforeMinimized, m.left = e.position.left, m.top = e.position.top), r.position.set(m);
  }
}, "#setImpl"), u(ww, "ApplicationState");
let _1 = ww;
var Vu, $n;
const $w = class $w {
  /**
   * Keep a direct reference to the SvelteData array in an associated {@link SvelteApplication}.
   *
   * @param {import('./types').MountedAppShell[] | null[]}  applicationShellHolder - A reference to the
   *        MountedAppShell array.
   *
   * @param {import('./types').SvelteData[]}  svelteData - A reference to the SvelteData array of mounted components.
   */
  constructor(e, t) {
    /** @type {import('./types').MountedAppShell[] | null[]} */
    x(this, Vu);
    /** @type {import('./types').SvelteData[]} */
    x(this, $n);
    Ae(this, Vu, e), Ae(this, $n, t);
  }
  /**
   * Returns any mounted {@link MountedAppShell}.
   *
   * @returns {import('./types').MountedAppShell | null} Any mounted application shell.
   */
  get applicationShell() {
    return P(this, Vu)[0];
  }
  /**
   * Returns the indexed Svelte component.
   *
   * @param {number}   index -
   *
   * @returns {object} The loaded Svelte component.
   */
  component(e) {
    const t = P(this, $n)[e];
    return (t == null ? void 0 : t.component) ?? void 0;
  }
  /**
   * Returns the Svelte component entries iterator.
   *
   * @returns {IterableIterator<[number, import('svelte').SvelteComponent]>} Svelte component entries iterator.
   * @yields
   */
  *componentEntries() {
    for (let e = 0; e < P(this, $n).length; e++)
      yield [e, P(this, $n)[e].component];
  }
  /**
   * Returns the Svelte component values iterator.
   *
   * @returns {IterableIterator<import('svelte').SvelteComponent>} Svelte component values iterator.
   * @yields
   */
  *componentValues() {
    for (let e = 0; e < P(this, $n).length; e++)
      yield P(this, $n)[e].component;
  }
  /**
   * Returns the indexed SvelteData entry.
   *
   * @param {number}   index - The index of SvelteData instance to retrieve.
   *
   * @returns {import('./types').SvelteData} The loaded Svelte config + component.
   */
  data(e) {
    return P(this, $n)[e];
  }
  /**
   * Returns the {@link SvelteData} instance for a given component.
   *
   * @param {import('svelte').SvelteComponent} component - Svelte component.
   *
   * @returns {import('./types').SvelteData} -  The loaded Svelte config + component.
   */
  dataByComponent(e) {
    for (const t of P(this, $n))
      if (t.component === e)
        return t;
  }
  /**
   * Returns the SvelteData entries iterator.
   *
   * @returns {IterableIterator<[number, import('./types').SvelteData]>} SvelteData entries iterator.
   */
  dataEntries() {
    return P(this, $n).entries();
  }
  /**
   * Returns the SvelteData values iterator.
   *
   * @returns {IterableIterator<import('./types').SvelteData>} SvelteData values iterator.
   */
  dataValues() {
    return P(this, $n).values();
  }
  /**
   * Returns the length of the mounted Svelte component list.
   *
   * @returns {number} Length of mounted Svelte component list.
   */
  get length() {
    return P(this, $n).length;
  }
};
Vu = new WeakMap(), $n = new WeakMap(), u($w, "GetSvelteData");
let v1 = $w;
function BG({ storage: i, serialize: e = JSON.stringify, deserialize: t = JSON.parse }) {
  function s(o) {
    return o.length < 2;
  }
  u(s, "isSimpleDeriver");
  function n(o, a, c) {
    return {
      subscribe: l(o, a, c).subscribe
    };
  }
  u(n, "storageReadable");
  function l(o, a, c) {
    function f(h) {
      return c(/* @__PURE__ */ u(function(y) {
        return i && i.setItem(o, e(y)), h(y);
      }, "wrap_set"), /* @__PURE__ */ u(function(y) {
        p(y(Bn(d)));
      }, "wrap_update"));
    }
    if (u(f, "wrap_start"), i) {
      const h = i.getItem(o);
      try {
        h && (a = t(h));
      } catch {
      }
      i.setItem(o, e(a));
    }
    const d = Mt(a, c ? f : void 0);
    function p(h) {
      i && i.setItem(o, e(h)), d.set(h);
    }
    u(p, "set");
    function m(h) {
      p(h(Bn(d)));
    }
    u(m, "update");
    function g(h, _) {
      return d.subscribe(h, _);
    }
    return u(g, "subscribe"), { set: p, update: m, subscribe: g };
  }
  u(l, "storageWritable");
  function r(o, a, c, f) {
    const d = !Array.isArray(a), p = d ? [a] : a;
    if (i && i.getItem(o))
      try {
        f = t(i.getItem(o));
      } catch {
      }
    return n(o, f, (m, g) => {
      let h = !1;
      const _ = [];
      let y = 0, v;
      const k = /* @__PURE__ */ u(() => {
        if (y)
          return;
        v == null || v();
        const D = d ? _[0] : _;
        if (s(c))
          m(c(D));
        else {
          const I = c(D, m, g);
          typeof I == "function" && (v = I);
        }
      }, "sync"), S = p.map((D, I) => D.subscribe((M) => {
        _[I] = M, y &= ~(1 << I), h && k();
      }, () => {
        y |= 1 << I;
      }));
      return h = !0, k(), /* @__PURE__ */ u(function() {
        S.forEach((I) => I()), v == null || v();
      }, "stop");
    });
  }
  return u(r, "storageDerived"), {
    readable: n,
    writable: l,
    derived: r,
    storage: i,
    serialize: e,
    deserialize: t
  };
}
u(BG, "storeGenerator");
const qG = BG({ storage: globalThis == null ? void 0 : globalThis.sessionStorage });
var xn, xs, zn, vL, k1, kL, Ed;
const Aw = class Aw {
  /**
   * @param {import('./').StorageStores} storageStores - Provides a complete set of
   *        storage API store helper functions and the associated storage API instance and serializations strategy.
   */
  constructor(e) {
    x(this, zn);
    /** @type {import('./').StorageStores} */
    x(this, xn);
    /**
     * @type {(Map<string, {
     *    store: import('svelte/store').Writable,
     *    deserialize?: (value: string, ...rest: any[]) => any,
     *    serialize?: (value: any, ...rest: any[]) => string
     * }>)}
     */
    x(this, xs, /* @__PURE__ */ new Map());
    Ae(this, xn, e);
  }
  /**
   * Get value from the storage API.
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {*}        [defaultValue] - A default value to return if key not present in session storage.
   *
   * @returns {*} Value from session storage or if not defined any default value provided.
   */
  getItem(e, t) {
    let s = t;
    const n = P(this, xn).storage.getItem(e);
    if (n !== null)
      try {
        s = X(this, zn, k1).call(this, e)(n);
      } catch {
        s = t;
      }
    else if (t !== void 0)
      try {
        const l = X(this, zn, kL).call(this, e)(t);
        P(this, xn).storage.setItem(e, l);
      } catch {
      }
    return s;
  }
  /**
   * Returns the backing Svelte store for the given key; potentially sets a default value if the key
   * is not already set.
   *
   * @template T
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {T}        [defaultValue] - A default value to return if key not present in session storage.
   *
   * @param {import('./').StorageStores} [storageStores] - Additional store creation options.
   *
   * @returns {import('svelte/store').Writable<T>} The Svelte store for this key.
   */
  getStore(e, t, s) {
    return X(this, zn, Ed).call(this, e, t, s);
  }
  /**
   * Returns whether a store has already been created for the given key.
   *
   * @param {string}   key - Key to lookup in storage API.
   */
  hasStore(e) {
    return P(this, xs).has(e);
  }
  /**
   * Sets the value for the given key in storage API.
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {*}        value - A value to set for this key.
   */
  setItem(e, t) {
    X(this, zn, Ed).call(this, e).set(t);
  }
  /**
   * Convenience method to swap a boolean value stored in storage API updating the associated store value.
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {boolean}  [defaultValue] - A default value to return if key not present in session storage.
   *
   * @returns {boolean} The boolean swap for the given key.
   */
  swapItemBoolean(e, t) {
    const s = X(this, zn, Ed).call(this, e, t);
    let n = !1;
    try {
      n = !!X(this, zn, k1).call(this, e)(P(this, xn).storage.getItem(e));
    } catch {
    }
    const l = typeof n == "boolean" ? !n : !1;
    return s.set(l), l;
  }
  // Iterators ------------------------------------------------------------------------------------------------------
  /**
   * @template T
   *
   * Returns an iterable for the session storage keys and stores.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by storage keys.
   *
   * @returns {IterableIterator<[string, import('svelte/store').Writable<T>]>} Iterable iterator of keys and stores.
   * @yields {import('svelte/store').Writable<[string, Writable<T>]>}
   */
  *entries(e = void 0) {
    if (e !== void 0 && !(e instanceof RegExp))
      throw new TypeError("'regex' is not a RegExp");
    if (P(this, xs).size)
      if (e)
        for (const t of P(this, xs).keys())
          e.test(t) && (yield [t, this.getStore(t)]);
      else
        for (const t of P(this, xs).keys())
          yield [t, this.getStore(t)];
  }
  /**
   * Returns an iterable for the session storage keys from existing stores.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by storage keys.
   *
   * @returns {IterableIterator<string>} Iterable iterator of session storage keys.
   * @yields {string}
   */
  *keys(e = void 0) {
    if (e !== void 0 && !(e instanceof RegExp))
      throw new TypeError("'regex' is not a RegExp");
    if (P(this, xs).size)
      if (e)
        for (const t of P(this, xs).keys())
          e.test(t) && (yield t);
      else
        for (const t of P(this, xs).keys())
          yield t;
  }
  /**
   * @template T
   *
   * Returns an iterable for the session storage stores.
   *
   * @param {RegExp} [regex] - Optional regular expression to filter by storage keys.
   *
   * @returns {IterableIterator<import('svelte/store').Writable<T>>} Iterable iterator of stores.
   * @yields {import('svelte/store').Writable<T>}
   */
  *stores(e = void 0) {
    if (e !== void 0 && !(e instanceof RegExp))
      throw new TypeError("'regex' is not a RegExp");
    if (P(this, xs).size)
      if (e)
        for (const t of P(this, xs).keys())
          e.test(t) && (yield this.getStore(t));
      else
        for (const t of P(this, xs).keys())
          yield this.getStore(t);
  }
};
xn = new WeakMap(), xs = new WeakMap(), zn = new WeakSet(), /**
 * Creates a new store for the given key.
 *
 * @template T
 *
 * @param {string}   key - Key to lookup in stores map.
 *
 * @param {T}        [defaultValue] - A default value to set for the store.
 *
 * @param {import('./').StorageStores} [storageStores] - Additional store creation options.
 *
 * @returns {import('svelte/store').Writable<T>} The new store.
 */
vL = /* @__PURE__ */ u(function(e, t = void 0, s) {
  try {
    const l = P(this, xn).storage.getItem(e);
    l !== null && (t = ((s == null ? void 0 : s.deserialize) ?? P(this, xn).deserialize)(l));
  } catch {
  }
  return ((s == null ? void 0 : s.writable) ?? P(this, xn).writable)(e, t);
}, "#createStore"), /**
 * @param {string}   key - Storage key.
 *
 * @returns {(value: string, ...rest: any[]) => any} Deserialize function.
 */
k1 = /* @__PURE__ */ u(function(e) {
  var t;
  return ((t = P(this, xs).get(e)) == null ? void 0 : t.deserialize) ?? P(this, xn).deserialize;
}, "#getDeserialize"), /**
 * @param {string}   key - Storage key.
 *
 * @returns {(value: any, ...rest: any[]) => string} Serialize function.
 */
kL = /* @__PURE__ */ u(function(e) {
  var t;
  return ((t = P(this, xs).get(e)) == null ? void 0 : t.serialize) ?? P(this, xn).serialize;
}, "#getSerialize"), /**
 * Gets a store from the `stores` Map or creates a new store for the key and a given default value.
 *
 * @template T
 *
 * @param {string}   key - Key to lookup in stores map.
 *
 * @param {T}        [defaultValue] - A default value to set for the store.
 *
 * @param {import('./').StorageStores} [storageStores] - Additional store creation options.
 *
 * @returns {import('svelte/store').Writable<T>} The store for the given key.
 */
Ed = /* @__PURE__ */ u(function(e, t = void 0, s) {
  const n = P(this, xs).get(e);
  if (n)
    return n.store;
  const l = X(this, zn, vL).call(this, e, t, s);
  return P(this, xs).set(e, {
    store: l,
    deserialize: s == null ? void 0 : s.deserialize,
    serialize: s == null ? void 0 : s.serialize
  }), l;
}, "#getStore"), u(Aw, "TJSWebStorage");
let Qd = Aw;
const Ew = class Ew extends Qd {
  constructor() {
    super(qG);
  }
};
u(Ew, "TJSSessionStorage");
let w1 = Ew;
function X3(i, e, t, s) {
  var n, l, r = !1, o = t.length >= 2, a = /* @__PURE__ */ u((g, h, _) => {
    if (n = h, o && (l = g), !r) {
      let y = e(g, h, _);
      if (e.length < 2)
        h(y);
      else
        return y;
    }
    r = !1;
  }, "wrappedDerive"), c = Vo(i, a, s), f = !Array.isArray(i);
  function d(g) {
    var h = t(g, l);
    f ? (r = !0, i.set(h)) : h.forEach((_, y) => {
      r = !0, i[y].set(_);
    }), r = !1;
  }
  u(d, "doReflect");
  var p = !1;
  function m(g) {
    var h, _, y, v;
    if (p) {
      v = g(Bn(c)), n(v);
      return;
    }
    var k = c.subscribe((S) => {
      p ? h ? _ = !0 : h = !0 : y = S;
    });
    v = g(y), p = !0, n(v), k(), p = !1, _ && (v = Bn(c)), h && d(v);
  }
  return u(m, "update"), {
    subscribe: c.subscribe,
    set(g) {
      m(() => g);
    },
    update: m
  };
}
u(X3, "writableDerived");
function Tt(i, e) {
  if (Array.isArray(e)) {
    let t = e.concat();
    return X3(
      i,
      (s) => {
        for (let n = 0; n < t.length; ++n)
          s = s[t[n]];
        return s;
      },
      (s, n) => {
        let l = n;
        for (let r = 0; r < t.length - 1; ++r)
          l = l[t[r]];
        return l[t[t.length - 1]] = s, n;
      }
    );
  } else
    return X3(
      i,
      (t) => t[e],
      (t, s) => (s[e] = t, s)
    );
}
u(Tt, "propertyStore");
var At, Wu, Ku, lr, Yr, $l, Yu, Xr, rr, Or, wL, $L, AL;
const Sw = class Sw {
  /**
   * @param {import('../SvelteApplication').SvelteApplication} application - The host Foundry application.
   */
  constructor(e) {
    x(this, Or);
    /**
     * @type {import('../SvelteApplication').SvelteApplication}
     */
    x(this, At);
    /**
     * @type {boolean}
     */
    x(this, Wu, !1);
    /** @type {import('@typhonjs-fvtt/runtime/svelte/store/web-storage').WebStorage} */
    x(this, Ku);
    /**
     * The Application option store which is injected into mounted Svelte component context under the `external` key.
     *
     * @type {import('./types').StoreAppOptions}
     */
    x(this, lr);
    /**
     * Stores the update function for `#storeAppOptions`.
     *
     * @type {(this: void, updater: import('svelte/store').Updater<object>) => void}
     */
    x(this, Yr);
    /**
     * Stores the UI state data to make it accessible via getters.
     *
     * @type {object}
     */
    x(this, $l);
    /**
     * The UI option store which is injected into mounted Svelte component context under the `external` key.
     *
     * @type {import('./types').StoreUIOptions}
     */
    x(this, Yu);
    /**
     * Stores the update function for `#storeUIState`.
     *
     * @type {(this: void, updater: import('svelte/store').Updater<object>) => void}
     */
    x(this, Xr);
    /**
     * Stores the unsubscribe functions from local store subscriptions.
     *
     * @type {import('svelte/store').Unsubscriber[]}
     */
    x(this, rr, []);
    var s;
    Ae(this, At, e);
    const t = (s = e == null ? void 0 : e.options) == null ? void 0 : s.sessionStorage;
    if (t !== void 0 && !(t instanceof Qd))
      throw new TypeError("'options.sessionStorage' is not an instance of TJSWebStorage.");
    Ae(this, Ku, t !== void 0 ? t : new w1());
  }
  /**
   * Initializes reactive support. Package private for internal use.
   *
   * @returns {SvelteReactiveStores | undefined} Internal methods to interact with Svelte stores.
   * @package
   * @internal
   */
  initialize() {
    if (!P(this, Wu))
      return Ae(this, Wu, !0), X(this, Or, wL).call(this), {
        appOptionsUpdate: P(this, Yr),
        uiStateUpdate: P(this, Xr),
        subscribe: X(this, Or, $L).bind(this),
        unsubscribe: X(this, Or, AL).bind(this)
      };
  }
  // Store getters -----------------------------------------------------------------------------------------------------
  /**
   * @returns {import('@typhonjs-fvtt/runtime/svelte/store/web-storage').WebStorage} Returns WebStorage (session) instance.
   */
  get sessionStorage() {
    return P(this, Ku);
  }
  /**
   * Returns the store for app options.
   *
   * @returns {import('./types').StoreAppOptions} App options store.
   */
  get storeAppOptions() {
    return P(this, lr);
  }
  /**
   * Returns the store for UI options.
   *
   * @returns {import('./types').StoreUIOptions} UI options store.
   */
  get storeUIState() {
    return P(this, Yu);
  }
  // Only reactive getters ---------------------------------------------------------------------------------------------
  /**
   * Returns the current active Window / WindowProxy UI state.
   *
   * @returns {Window} Active window UI state.
   */
  get activeWindow() {
    return P(this, $l).activeWindow ?? globalThis;
  }
  /**
   * Returns the current dragging UI state.
   *
   * @returns {boolean} Dragging UI state.
   */
  get dragging() {
    return P(this, $l).dragging;
  }
  /**
   * Returns the current minimized UI state.
   *
   * @returns {boolean} Minimized UI state.
   */
  get minimized() {
    return P(this, $l).minimized;
  }
  /**
   * Returns the current resizing UI state.
   *
   * @returns {boolean} Resizing UI state.
   */
  get resizing() {
    return P(this, $l).resizing;
  }
  /**
   * Sets the current active Window / WindowProxy UI state.
   *
   * Note: This is protected usage and used internally.
   *
   * @param {Window} activeWindow - Active Window / WindowProxy UI state.
   */
  set activeWindow(e) {
    (e == null || Object.prototype.toString.call(e) === "[object Window]") && P(this, Xr).call(this, (t) => tl(t, { activeWindow: e ?? globalThis }));
  }
  // Reactive getter / setters -----------------------------------------------------------------------------------------
  /**
   * Returns the draggable app option.
   *
   * @returns {boolean} Draggable app option.
   */
  get draggable() {
    var e, t;
    return (t = (e = P(this, At)) == null ? void 0 : e.options) == null ? void 0 : t.draggable;
  }
  /**
   * Returns the focusAuto app option.
   *
   * @returns {boolean} When true auto-management of app focus is enabled.
   */
  get focusAuto() {
    var e, t;
    return (t = (e = P(this, At)) == null ? void 0 : e.options) == null ? void 0 : t.focusAuto;
  }
  /**
   * Returns the focusKeep app option.
   *
   * @returns {boolean} When `focusAuto` and `focusKeep` is true; keeps internal focus.
   */
  get focusKeep() {
    var e, t;
    return (t = (e = P(this, At)) == null ? void 0 : e.options) == null ? void 0 : t.focusKeep;
  }
  /**
   * Returns the focusTrap app option.
   *
   * @returns {boolean} When true focus trapping / wrapping is enabled keeping focus inside app.
   */
  get focusTrap() {
    var e, t;
    return (t = (e = P(this, At)) == null ? void 0 : e.options) == null ? void 0 : t.focusTrap;
  }
  /**
   * Returns the headerButtonNoClose app option.
   *
   * @returns {boolean} Remove the close the button in header app option.
   */
  get headerButtonNoClose() {
    var e, t;
    return (t = (e = P(this, At)) == null ? void 0 : e.options) == null ? void 0 : t.headerButtonNoClose;
  }
  /**
   * Returns the headerButtonNoLabel app option.
   *
   * @returns {boolean} Remove the labels from buttons in header app option.
   */
  get headerButtonNoLabel() {
    var e, t;
    return (t = (e = P(this, At)) == null ? void 0 : e.options) == null ? void 0 : t.headerButtonNoLabel;
  }
  /**
   * Returns the headerIcon app option.
   *
   * @returns {string|void} URL for header app icon.
   */
  get headerIcon() {
    var e, t;
    return (t = (e = P(this, At)) == null ? void 0 : e.options) == null ? void 0 : t.headerIcon;
  }
  /**
   * Returns the headerNoTitleMinimized app option.
   *
   * @returns {boolean} When true removes the header title when minimized.
   */
  get headerNoTitleMinimized() {
    var e, t;
    return (t = (e = P(this, At)) == null ? void 0 : e.options) == null ? void 0 : t.headerNoTitleMinimized;
  }
  /**
   * Returns the minimizable app option.
   *
   * @returns {boolean} Minimizable app option.
   */
  get minimizable() {
    var e, t;
    return (t = (e = P(this, At)) == null ? void 0 : e.options) == null ? void 0 : t.minimizable;
  }
  /**
   * Returns the Foundry popOut state; {@link Application.popOut}
   *
   * @returns {boolean} Positionable app option.
   */
  get popOut() {
    return P(this, At).popOut;
  }
  /**
   * Returns the positionable app option; {@link SvelteApplicationOptions.positionable}
   *
   * @returns {boolean} Positionable app option.
   */
  get positionable() {
    var e, t;
    return (t = (e = P(this, At)) == null ? void 0 : e.options) == null ? void 0 : t.positionable;
  }
  /**
   * Returns the resizable option.
   *
   * @returns {boolean} Resizable app option.
   */
  get resizable() {
    var e, t;
    return (t = (e = P(this, At)) == null ? void 0 : e.options) == null ? void 0 : t.resizable;
  }
  /**
   * Returns the title accessor from the parent Application class; {@link Application.title}
   * TODO: Application v2; note that super.title localizes `this.options.title`; IMHO it shouldn't.
   *
   * @returns {string} Title.
   */
  get title() {
    return P(this, At).title;
  }
  /**
   * Sets `this.options.draggable` which is reactive for application shells.
   *
   * @param {boolean}  draggable - Sets the draggable option.
   */
  set draggable(e) {
    typeof e == "boolean" && this.setOptions("draggable", e);
  }
  /**
   * Sets `this.options.focusAuto` which is reactive for application shells.
   *
   * @param {boolean}  focusAuto - Sets the focusAuto option.
   */
  set focusAuto(e) {
    typeof e == "boolean" && this.setOptions("focusAuto", e);
  }
  /**
   * Sets `this.options.focusKeep` which is reactive for application shells.
   *
   * @param {boolean}  focusKeep - Sets the focusKeep option.
   */
  set focusKeep(e) {
    typeof e == "boolean" && this.setOptions("focusKeep", e);
  }
  /**
   * Sets `this.options.focusTrap` which is reactive for application shells.
   *
   * @param {boolean}  focusTrap - Sets the focusTrap option.
   */
  set focusTrap(e) {
    typeof e == "boolean" && this.setOptions("focusTrap", e);
  }
  /**
   * Sets `this.options.headerButtonNoClose` which is reactive for application shells.
   *
   * @param {boolean}  headerButtonNoClose - Sets the headerButtonNoClose option.
   */
  set headerButtonNoClose(e) {
    typeof e == "boolean" && this.setOptions("headerButtonNoClose", e);
  }
  /**
   * Sets `this.options.headerButtonNoLabel` which is reactive for application shells.
   *
   * @param {boolean}  headerButtonNoLabel - Sets the headerButtonNoLabel option.
   */
  set headerButtonNoLabel(e) {
    typeof e == "boolean" && this.setOptions("headerButtonNoLabel", e);
  }
  /**
   * Sets `this.options.headerIcon` which is reactive for application shells.
   *
   * @param {string | undefined}  headerIcon - Sets the headerButtonNoLabel option.
   */
  set headerIcon(e) {
    (e === void 0 || typeof e == "string") && this.setOptions("headerIcon", e);
  }
  /**
   * Sets `this.options.headerNoTitleMinimized` which is reactive for application shells.
   *
   * @param {boolean}  headerNoTitleMinimized - Sets the headerNoTitleMinimized option.
   */
  set headerNoTitleMinimized(e) {
    typeof e == "boolean" && this.setOptions("headerNoTitleMinimized", e);
  }
  /**
   * Sets `this.options.minimizable` which is reactive for application shells that are also pop out.
   *
   * @param {boolean}  minimizable - Sets the minimizable option.
   */
  set minimizable(e) {
    typeof e == "boolean" && this.setOptions("minimizable", e);
  }
  /**
   * Sets `this.options.popOut` which is reactive for application shells. This will add / remove this application
   * from `ui.windows`.
   *
   * @param {boolean}  popOut - Sets the popOut option.
   */
  set popOut(e) {
    typeof e == "boolean" && this.setOptions("popOut", e);
  }
  /**
   * Sets `this.options.positionable` enabling / disabling {@link SvelteApplication.position}.
   *
   * @param {boolean}  positionable - Sets the positionable option.
   */
  set positionable(e) {
    typeof e == "boolean" && this.setOptions("positionable", e);
  }
  /**
   * Sets `this.options.resizable` which is reactive for application shells.
   *
   * @param {boolean}  resizable - Sets the resizable option.
   */
  set resizable(e) {
    typeof e == "boolean" && this.setOptions("resizable", e);
  }
  /**
   * Sets `this.options.title` which is reactive for application shells.
   *
   * Note: Will set empty string if title is undefined or null.
   *
   * @param {string | undefined | null}   title - Application title; will be localized, so a translation key is fine.
   */
  set title(e) {
    typeof e == "string" ? this.setOptions("title", e) : e == null && this.setOptions("title", "");
  }
  // Reactive Options API -------------------------------------------------------------------------------------------
  /**
   * Provides a way to safely get this applications options given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * // TODO DOCUMENT the accessor in more detail.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {*}        [defaultValue] - A default value returned if the accessor is not found.
   *
   * @returns {*} Value at the accessor.
   */
  getOptions(e, t) {
    return cu(P(this, At).options, e, t);
  }
  /**
   * Provides a way to merge `options` into this applications options and update the appOptions store.
   *
   * @param {object}   options - The options object to merge with `this.options`.
   */
  mergeOptions(e) {
    P(this, Yr).call(this, (t) => tl(t, e));
  }
  /**
   * Provides a way to safely set this applications options given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * Additionally if an application shell Svelte component is mounted and exports the `appOptions` property then
   * the application options is set to `appOptions` potentially updating the application shell / Svelte component.
   *
   * // TODO DOCUMENT the accessor in more detail.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {any}      value - Value to set.
   */
  setOptions(e, t) {
    K7(P(this, At).options, e, t) && P(this, Yr).call(this, () => P(this, At).options);
  }
  /**
   * Serializes the main {@link SvelteApplicationOptions} for common application state.
   *
   * @returns {import('./types').SvelteReactiveData} Common application state.
   */
  toJSON() {
    var e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S;
    return {
      draggable: ((t = (e = P(this, At)) == null ? void 0 : e.options) == null ? void 0 : t.draggable) ?? !0,
      focusAuto: ((n = (s = P(this, At)) == null ? void 0 : s.options) == null ? void 0 : n.focusAuto) ?? !0,
      focusKeep: ((r = (l = P(this, At)) == null ? void 0 : l.options) == null ? void 0 : r.focusKeep) ?? !1,
      focusTrap: ((a = (o = P(this, At)) == null ? void 0 : o.options) == null ? void 0 : a.focusTrap) ?? !0,
      headerButtonNoClose: ((f = (c = P(this, At)) == null ? void 0 : c.options) == null ? void 0 : f.headerButtonNoClose) ?? !1,
      headerButtonNoLabel: ((p = (d = P(this, At)) == null ? void 0 : d.options) == null ? void 0 : p.headerButtonNoLabel) ?? !1,
      headerNoTitleMinimized: ((g = (m = P(this, At)) == null ? void 0 : m.options) == null ? void 0 : g.headerNoTitleMinimized) ?? !1,
      minimizable: ((_ = (h = P(this, At)) == null ? void 0 : h.options) == null ? void 0 : _.minimizable) ?? !0,
      positionable: ((v = (y = P(this, At)) == null ? void 0 : y.options) == null ? void 0 : v.positionable) ?? !0,
      resizable: ((S = (k = P(this, At)) == null ? void 0 : k.options) == null ? void 0 : S.resizable) ?? !0
    };
  }
  /**
   * Updates the UI Options store with the current header buttons. You may dynamically add / remove header buttons
   * if using an application shell Svelte component. In either overriding `_getHeaderButtons` or responding to the
   * Hooks fired return a new button array and the uiOptions store is updated and the application shell will render
   * the new buttons.
   *
   * Optionally you can set in the SvelteApplication app options {@link SvelteApplicationOptions.headerButtonNoClose}
   * to remove the close button and {@link SvelteApplicationOptions.headerButtonNoLabel} to true and labels will be
   * removed from the header buttons.
   *
   * @param {object} [opts] - Optional parameters (for internal use)
   *
   * @param {boolean} [opts.headerButtonNoClose] - The value for `headerButtonNoClose`.
   *
   * @param {boolean} [opts.headerButtonNoLabel] - The value for `headerButtonNoLabel`.
   */
  updateHeaderButtons({
    headerButtonNoClose: e = P(this, At).options.headerButtonNoClose,
    headerButtonNoLabel: t = P(this, At).options.headerButtonNoLabel
  } = {}) {
    let s = P(this, At)._getHeaderButtons();
    if (typeof e == "boolean" && e && (s = s.filter((n) => n.class !== "close")), typeof t == "boolean" && t)
      for (const n of s)
        n.label = void 0;
    P(this, Xr).call(this, (n) => (n.headerButtons = s, n));
  }
};
At = new WeakMap(), Wu = new WeakMap(), Ku = new WeakMap(), lr = new WeakMap(), Yr = new WeakMap(), $l = new WeakMap(), Yu = new WeakMap(), Xr = new WeakMap(), rr = new WeakMap(), Or = new WeakSet(), // Internal implementation ----------------------------------------------------------------------------------------
/**
 * Initializes the Svelte stores and derived stores for the application options and UI state.
 *
 * While writable stores are created the update method is stored in private variables locally and derived Readable
 * stores are provided for essential options which are commonly used.
 *
 * These stores are injected into all Svelte components mounted under the `external` context: `storeAppOptions` and
 * `storeUIState`.
 */
wL = /* @__PURE__ */ u(function() {
  const e = Mt(P(this, At).options);
  Ae(this, Yr, e.update);
  const t = {
    subscribe: e.subscribe,
    draggable: Tt(e, "draggable"),
    focusAuto: Tt(e, "focusAuto"),
    focusKeep: Tt(e, "focusKeep"),
    focusTrap: Tt(e, "focusTrap"),
    headerButtonNoClose: Tt(e, "headerButtonNoClose"),
    headerButtonNoLabel: Tt(e, "headerButtonNoLabel"),
    headerIcon: Tt(e, "headerIcon"),
    headerNoTitleMinimized: Tt(e, "headerNoTitleMinimized"),
    minimizable: Tt(e, "minimizable"),
    popOut: Tt(e, "popOut"),
    positionable: Tt(e, "positionable"),
    resizable: Tt(e, "resizable"),
    title: Tt(e, "title")
  };
  Object.freeze(t), Ae(this, lr, t), Ae(this, $l, {
    activeWindow: globalThis,
    dragging: !1,
    headerButtons: [],
    minimized: P(this, At)._minimized,
    resizing: !1
  });
  const s = Mt(P(this, $l));
  Ae(this, Xr, s.update);
  const n = {
    subscribe: s.subscribe,
    // activeWindow: propertyStore(writableUIOptions, 'activeWindow'),
    activeWindow: Vo(s, (l, r) => r(l.activeWindow)),
    dragging: Tt(s, "dragging"),
    headerButtons: Vo(s, (l, r) => r(l.headerButtons)),
    minimized: Vo(s, (l, r) => r(l.minimized)),
    resizing: Tt(s, "resizing")
  };
  Object.freeze(n), Ae(this, Yu, n);
}, "#storesInitialize"), /**
 * Registers local store subscriptions for app options. `popOut` controls registering this app with `ui.windows`.
 *
 * @see SvelteApplication._injectHTML
 */
$L = /* @__PURE__ */ u(function() {
  P(this, rr).push(Yc(P(this, lr).headerButtonNoClose, (e) => {
    this.updateHeaderButtons({ headerButtonNoClose: e });
  })), P(this, rr).push(Yc(P(this, lr).headerButtonNoLabel, (e) => {
    this.updateHeaderButtons({ headerButtonNoLabel: e });
  })), P(this, rr).push(Yc(P(this, lr).popOut, (e) => {
    e && P(this, At).rendered ? globalThis.ui.windows[P(this, At).appId] = P(this, At) : delete globalThis.ui.windows[P(this, At).appId];
  }));
}, "#storesSubscribe"), /**
 * Unsubscribes from any locally monitored stores.
 *
 * @see SvelteApplication.close
 */
AL = /* @__PURE__ */ u(function() {
  P(this, rr).forEach((e) => e()), Ae(this, rr, []);
}, "#storesUnsubscribe"), u(Sw, "SvelteReactive");
let $1 = Sw;
const A1 = ["elementRoot"];
Object.freeze(A1);
function E1(i) {
  if (i == null)
    return !1;
  let e = !0, t = !0;
  for (const n of A1) {
    const l = Object.getOwnPropertyDescriptor(i, n);
    (l === void 0 || l.get === void 0 || l.set === void 0) && (e = !1);
  }
  const s = Object.getPrototypeOf(i);
  for (const n of A1) {
    const l = Object.getOwnPropertyDescriptor(s, n);
    (l === void 0 || l.get === void 0 || l.set === void 0) && (t = !1);
  }
  return e || t;
}
u(E1, "isApplicationShell");
const Cw = class Cw {
  /**
   * Provides basic duck typing to determine if the provided function is a constructor function for a Svelte component.
   *
   * @param {unknown}  comp - Data to check as a Svelte component.
   *
   * @returns {boolean} Whether basic duck typing succeeds.
   */
  static isComponent(e) {
    var s, n;
    if (e == null || typeof e != "function")
      return !1;
    const t = (n = (s = e == null ? void 0 : e.prototype) == null ? void 0 : s.constructor) == null ? void 0 : n.name;
    return typeof t == "string" && (t.startsWith("Proxy<") || t === "ProxyComponent") ? !0 : typeof window < "u" ? typeof e.prototype.$destroy == "function" && typeof e.prototype.$on == "function" : (
      // client-side
      typeof e.render == "function"
    );
  }
  /**
   * Provides basic duck typing to determine if the provided object is a HMR ProxyComponent instance or class.
   *
   * @param {unknown}  comp - Data to check as a HMR proxy component.
   *
   * @returns {boolean} Whether basic duck typing succeeds.
   */
  static isHMRProxy(e) {
    var n, l, r;
    const t = (n = e == null ? void 0 : e.constructor) == null ? void 0 : n.name;
    if (typeof t == "string" && (t.startsWith("Proxy<") || t === "ProxyComponent"))
      return !0;
    const s = (r = (l = e == null ? void 0 : e.prototype) == null ? void 0 : l.constructor) == null ? void 0 : r.name;
    return typeof s == "string" && (s.startsWith("Proxy<") || s === "ProxyComponent");
  }
  /**
   * Runs outro transition then destroys Svelte component.
   *
   * Workaround for https://github.com/sveltejs/svelte/issues/4056
   *
   * @param {*}  instance - A Svelte component.
   *
   * @returns {Promise} Promise returned after outro transition completed and component destroyed.
   */
  static async outroAndDestroy(e) {
    return e == null ? Promise.resolve() : new Promise((t) => {
      var s, n, l, r;
      (s = e == null ? void 0 : e.$$) != null && s.fragment && ((l = (n = e == null ? void 0 : e.$$) == null ? void 0 : n.fragment) != null && l.o) ? (ae(), O(e.$$.fragment, 0, 0, () => {
        var o;
        (o = e == null ? void 0 : e.$destroy) == null || o.call(e), t();
      }), ce()) : ((r = e == null ? void 0 : e.$destroy) == null || r.call(e), t());
    });
  }
};
u(Cw, "TJSSvelteUtil");
let Ws = Cw;
Object.seal(Ws);
var ca, Sd;
const mm = class mm {
  /**
   * Validates `config` argument whether it is a valid {@link TJSSvelteConfig}.
   *
   * @param {unknown}  config - The potential config object to validate.
   *
   * @param {object}   [options] - Options.
   *
   * @param {boolean}  [options.raiseException=false] - If validation fails raise an exception.
   *
   * @returns {config is import('./types').TJSSvelteConfig} Is the config a valid TJSSvelteConfig.
   *
   * @throws {TypeError}  Any validation error when `raiseException` is enabled.
   */
  static isConfig(e, { raiseException: t = !1 } = {}) {
    if (!he(e)) {
      if (t)
        throw new TypeError("TJSSvelteConfigUtil.isConfig error: 'config' is not an object.");
      return !1;
    }
    if (!Ws.isComponent(e.class)) {
      if (t)
        throw new TypeError(
          "TJSSvelteConfigUtil.isConfig error: 'config.class' is not a Svelte component constructor."
        );
      return !1;
    }
    return !0;
  }
  /**
   * Parses a TyphonJS Svelte config object ensuring that classes specified are Svelte components and props are set
   * correctly.
   *
   * @param {import('./types').TJSSvelteConfig}   config - Svelte config object.
   *
   * @param {any}       [thisArg] - `This` reference to set for invoking any props function.
   *
   * @returns {import('./types').TJSSvelteConfig} The processed Svelte config object.
   */
  static parseConfig(e, t = void 0) {
    if (!he(e))
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'config' is not an object:
${JSON.stringify(e)}.`
      );
    if (!Ws.isComponent(e.class))
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'class' is not a Svelte component constructor for config:
${JSON.stringify(e)}.`
      );
    if (e.hydrate !== void 0 && typeof e.hydrate != "boolean")
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'hydrate' is not a boolean for config:
${JSON.stringify(e)}.`
      );
    if (e.intro !== void 0 && typeof e.intro != "boolean")
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'intro' is not a boolean for config:
${JSON.stringify(e)}.`
      );
    if (e.target !== void 0 && typeof e.target != "string" && !(e.target instanceof Element) && !(e.target instanceof ShadowRoot) && !(e.target instanceof DocumentFragment))
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'target' is not a Element, ShadowRoot, or DocumentFragment for config:
${JSON.stringify(e)}.`
      );
    if (e.anchor !== void 0 && typeof e.anchor != "string" && !(e.anchor instanceof Element) && !(e.anchor instanceof ShadowRoot) && !(e.anchor instanceof DocumentFragment))
      throw new TypeError(`TJSSvelteConfigUtil.parseConfig - 'anchor' is not a string, Element for config:
${JSON.stringify(e)}.`);
    if (e.context !== void 0 && typeof e.context != "function" && !(e.context instanceof Map) && !he(e.context))
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'context' is not a Map, function or object for config:
${JSON.stringify(e)}.`
      );
    if (e.selectorTarget !== void 0 && typeof e.selectorTarget != "string")
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'selectorTarget' is not a string for config:
${JSON.stringify(e)}.`
      );
    if (e.options !== void 0 && !he(e.options))
      throw new TypeError(
        `TJSSvelteConfigUtil.parseConfig - 'options' is not an object for config:
${JSON.stringify(e)}.`
      );
    if (he(e.options)) {
      if (e.options.injectApp !== void 0 && typeof e.options.injectApp != "boolean")
        throw new TypeError(`TJSSvelteConfigUtil.parseConfig - 'options.injectApp' is not a boolean for config:
${JSON.stringify(e)}.`);
      if (e.options.injectEventbus !== void 0 && typeof e.options.injectEventbus != "boolean")
        throw new TypeError(
          `TJSSvelteConfigUtil.parseConfig - 'options.injectEventbus' is not a boolean for config:
${JSON.stringify(e)}.`
        );
      if (e.options.selectorElement !== void 0 && typeof e.options.selectorElement != "string")
        throw new TypeError(`TJSSvelteConfigUtil.parseConfig - 'selectorElement' is not a string for config:
${JSON.stringify(e)}.`);
    }
    const s = { ...e };
    delete s.options;
    let n = {};
    if (typeof s.context == "function") {
      const l = s.context;
      delete s.context;
      const r = l.call(t);
      if (he(r))
        n = { ...r };
      else
        throw new Error(
          `TJSSvelteConfigUtil.parseConfig - 'context' is a function that did not return an object for config:
${JSON.stringify(e)}`
        );
    } else s.context instanceof Map ? (n = Object.fromEntries(s.context), delete s.context) : he(s.context) && (n = s.context, delete s.context);
    if (s.props = X(this, ca, Sd).call(this, s.props, t, e), Array.isArray(s.children)) {
      const l = [];
      for (let r = 0; r < s.children.length; r++) {
        const o = s.children[r];
        if (!Ws.isComponent(o.class))
          throw new Error(`TJSSvelteConfigUtil.parseConfig - 'class' is not a Svelte component for child[${r}] for config:
${JSON.stringify(e)}`);
        o.props = X(this, ca, Sd).call(this, o.props, t, e), l.push(o);
      }
      l.length > 0 && (n.children = l), delete s.children;
    } else if (he(s.children)) {
      if (!Ws.isComponent(s.children.class))
        throw new Error(
          `TJSSvelteConfigUtil.parseConfig - 'class' is not a Svelte component for children object for config:
${JSON.stringify(e)}`
        );
      s.children.props = X(this, ca, Sd).call(this, s.children.props, t, e), n.children = [s.children], delete s.children;
    }
    return s.context instanceof Map || (s.context = /* @__PURE__ */ new Map()), s.context.set("#external", n), s;
  }
};
ca = new WeakSet(), Sd = /* @__PURE__ */ u(function(e, t, s) {
  if (typeof e == "function") {
    const n = e.call(t);
    if (he(n))
      return n;
    throw new Error(
      `TJSSvelteConfigUtil.parseConfig - 'props' is a function that did not return an object for config:
${JSON.stringify(s)}`
    );
  } else {
    if (he(e))
      return e;
    if (e !== void 0)
      throw new Error(`TJSSvelteConfigUtil.parseConfig - 'props' is not a function or an object for config:
${JSON.stringify(s)}`);
  }
  return {};
}, "#processProps"), x(mm, ca), u(mm, "TJSSvelteConfigUtil");
let mi = mm;
Object.seal(mi);
function J3({ app: i, template: e, config: t, elementRootUpdate: s } = {}) {
  var m;
  const n = he(t.options) ? t.options : {};
  let l;
  if (t.target instanceof HTMLElement ? l = t.target : e instanceof HTMLElement && typeof t.target == "string" ? l = e.querySelector(t.target) : l = (((m = i == null ? void 0 : i.reactive) == null ? void 0 : m.activeWindow) ?? globalThis).document.createDocumentFragment(), l === void 0)
    throw console.log(
      `%c[TRL] loadSvelteConfig error - could not find target selector, '${t.target}', for config:
`,
      "background: rgb(57,34,34)",
      t
    ), new Error();
  const r = t.class, o = mi.parseConfig({ ...t, target: l }, i), a = o.context.get("#external");
  a.application = i, a.elementRootUpdate = s, a.sessionStorage = i.reactive.sessionStorage;
  let c;
  he(i._eventbus) && typeof i._eventbus.createProxy == "function" && (c = i._eventbus.createProxy(), a.eventbus = c), Object.seal(a), o.context.set("external", new Proxy({}, {
    get(g, h) {
      return console.warn("[TRL] Deprecation warning: Please change getContext('external') to getContext('#external')."), a[h];
    }
  }));
  const f = new r(o);
  o.eventbus = c;
  let d;
  if (E1(f) && (d = f.elementRoot), l instanceof DocumentFragment && l.firstElementChild)
    d === void 0 && (d = l.firstElementChild), e.append(l);
  else if (t.target instanceof HTMLElement && d === void 0) {
    if (t.target instanceof HTMLElement && typeof n.selectorElement != "string")
      throw console.log(
        `%c[TRL] loadSvelteConfig error - HTMLElement target with no 'selectorElement' defined.

Note: If configuring an application shell and directly targeting a HTMLElement did you bind an'elementRoot' and include '<svelte:options accessors={true}/>'?

Offending config:
`,
        "background: rgb(57,34,34)",
        t
      ), new Error();
    if (d = l.querySelector(n.selectorElement), d == null)
      throw console.log(
        `%c[TRL] loadSvelteConfig error - HTMLElement target with 'selectorElement', '${n.selectorElement}', not found for config:
`,
        "background: rgb(57,34,34)",
        t
      ), new Error();
  }
  const p = !(t.target instanceof HTMLElement);
  return { config: o, component: f, element: d, injectHTML: p };
}
u(J3, "loadSvelteConfig");
var Al;
const hm = class hm {
  /**
   * Adds a SvelteApplication to all visible apps tracked.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication} app - A SvelteApplication
   *
   * @package
   */
  static add(e) {
    P(this, Al).set(e.id, e);
  }
  /**
   * Removes a SvelteApplication from all visible apps tracked.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication} app - A SvelteApplication
   *
   * @package
   */
  static delete(e) {
    P(this, Al).delete(e.id);
  }
  /**
   * Gets a particular app by ID.
   *
   * @param {string}   key - App ID.
   *
   * @returns {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication} Associated app.
   */
  static get(e) {
    return P(this, Al).get(e);
  }
  /**
   * Returns whether an associated app by ID is being tracked.
   *
   * @param {string}   key - App ID.
   *
   * @returns {boolean} The given App ID is visible.
   */
  static has(e) {
    return P(this, Al).has(e);
  }
  /**
   * @returns {IterableIterator<string>} All visible app IDs.
   */
  static keys() {
    return P(this, Al).keys();
  }
  /**
   * @returns {IterableIterator<import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication>} All visible apps.
   */
  static values() {
    return P(this, Al).values();
  }
};
Al = new WeakMap(), u(hm, "TJSAppIndex"), /**
 * Stores all visible / rendered apps.
 *
 * @type {Map<string, import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication>}
 */
x(hm, Al, /* @__PURE__ */ new Map());
let xd = hm;
function ep(i = 0, e = 0, t = 0) {
  return Math.min(Math.max(i, e), t);
}
u(ep, "clamp$1");
function Yn(i) {
  return i * (Math.PI / 180);
}
u(Yn, "degToRad");
function GG(i) {
  return i * (180 / Math.PI);
}
u(GG, "radToDeg");
var gm, bm, Xu, _m, EL;
const wi = class wi {
  /**
   * @returns {boolean} Global debugging enabled.
   */
  static get debug() {
    return P(this, Xu);
  }
  /**
   * @param {boolean}  debug - Global debug enabled
   */
  static set debug(e) {
    if (typeof e != "boolean")
      throw new TypeError("'debug' is not a boolean.");
    Ae(this, Xu, e);
  }
  /**
   * Runs a media query to determine if the user / OS configuration is set up for reduced motion / animation.
   *
   * @returns {boolean} User prefers reduced motion.
   */
  static get prefersReducedMotion() {
    var e;
    return ((e = globalThis == null ? void 0 : globalThis.matchMedia("(prefers-reduced-motion: reduce)")) == null ? void 0 : e.matches) ?? !1;
  }
  /**
   * Apply focus to the HTMLElement / SVGElement targets in a given A11yFocusSource data object. An iterable list
   * `options.focusEl` can contain HTMLElement / SVGElements or selector strings. If multiple focus targets are
   * provided in a list then the first valid target found will be focused. If focus target is a string then a lookup
   * via `document.querySelector` is performed. In this case you should provide a unique selector for the desired
   * focus target.
   *
   * Note: The body of this method is postponed to the next clock tick to allow any changes in the DOM to occur that
   * might alter focus targets before applying.
   *
   * @param {A11yFocusSource | { focusSource: A11yFocusSource }}   options - The focus options instance to apply.
   */
  static applyFocusSource(e) {
    if (!he(e))
      return;
    const t = he(e == null ? void 0 : e.focusSource) ? e.focusSource : e;
    setTimeout(() => {
      const s = typeof t.debug == "boolean" ? this.debug || t.debug : this.debug;
      if (Nt(t.focusEl)) {
        s && console.debug(
          "A11yHelper.applyFocusSource debug - Attempting to apply focus target: ",
          t.focusEl
        );
        for (const n of t.focusEl)
          if ((n == null ? void 0 : n.nodeType) === Node.ELEMENT_NODE && (n != null && n.isConnected)) {
            n == null || n.focus(), s && console.debug("A11yHelper.applyFocusSource debug - Applied focus to target: ", n);
            break;
          } else if (typeof n == "string") {
            const l = document.querySelector(n);
            if ((l == null ? void 0 : l.nodeType) === Node.ELEMENT_NODE && (l != null && l.isConnected)) {
              l == null || l.focus(), s && console.debug("A11yHelper.applyFocusSource debug - Applied focus to target: ", l);
              break;
            } else s && console.debug("A11yHelper.applyFocusSource debug - Could not query selector: ", n);
          }
      } else s && console.debug("A11yHelper.applyFocusSource debug - No focus targets defined.");
    }, 0);
  }
  /**
   * Returns first focusable element within a specified element.
   *
   * @param {Element | Document} [element=document] - Optional element to start query.
   *
   * @param {object}            [options] - Optional parameters.
   *
   * @param {Iterable<string>}  [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @param {Set<Element>}      [options.ignoreElements] - Set of elements to ignore.
   *
   * @returns {FocusableElement} First focusable child element.
   */
  static getFirstFocusableElement(e = document, t) {
    const s = this.getFocusableElements(e, t);
    return s.length > 0 ? s[0] : void 0;
  }
  /**
   * Returns all focusable elements within a specified element.
   *
   * @param {Element | Document} [element=document] Optional element to start query.
   *
   * @param {object}            [options] - Optional parameters.
   *
   * @param {boolean}           [options.anchorHref=true] - When true anchors must have an HREF.
   *
   * @param {Iterable<string>}  [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @param {Set<Element>}      [options.ignoreElements] - Set of elements to ignore.
   *
   * @param {string}            [options.selectors] - Custom list of focusable selectors for `querySelectorAll`.
   *
   * @returns {Array<FocusableElement>} Child keyboard focusable elements.
   */
  static getFocusableElements(e = document, { anchorHref: t = !0, ignoreClasses: s, ignoreElements: n, selectors: l } = {}) {
    if ((e == null ? void 0 : e.nodeType) !== Node.ELEMENT_NODE && (e == null ? void 0 : e.nodeType) !== Node.DOCUMENT_NODE)
      throw new TypeError("'element' is not a HTMLElement, SVGElement, or Document instance.");
    if (typeof t != "boolean")
      throw new TypeError("'anchorHref' is not a boolean.");
    if (s !== void 0 && !Nt(s))
      throw new TypeError("'ignoreClasses' is not an iterable list.");
    if (n !== void 0 && !(n instanceof Set))
      throw new TypeError("'ignoreElements' is not a Set.");
    if (l !== void 0 && typeof l != "string")
      throw new TypeError("'selectors' is not a string.");
    const r = l ?? X(this, _m, EL).call(this, t), o = [...e.querySelectorAll(r)];
    return n && s ? o.filter((a) => {
      let c = !1;
      for (const f of s)
        if (a.classList.contains(f)) {
          c = !0;
          break;
        }
      return !c && !n.has(a) && a.style.display !== "none" && a.style.visibility !== "hidden" && !a.hasAttribute("disabled") && !a.hasAttribute("inert") && a.getAttribute("aria-hidden") !== "true";
    }) : s ? o.filter((a) => {
      let c = !1;
      for (const f of s)
        if (a.classList.contains(f)) {
          c = !0;
          break;
        }
      return !c && a.style.display !== "none" && a.style.visibility !== "hidden" && !a.hasAttribute("disabled") && !a.hasAttribute("inert") && a.getAttribute("aria-hidden") !== "true";
    }) : n ? o.filter((a) => !n.has(a) && a.style.display !== "none" && a.style.visibility !== "hidden" && !a.hasAttribute("disabled") && !a.hasAttribute("inert") && a.getAttribute("aria-hidden") !== "true") : o.filter((a) => a.style.display !== "none" && a.style.visibility !== "hidden" && !a.hasAttribute("disabled") && !a.hasAttribute("inert") && a.getAttribute("aria-hidden") !== "true");
  }
  /**
   * Gets a A11yFocusSource object from the given DOM event allowing for optional X / Y screen space overrides.
   * Browsers (Firefox / Chrome) forwards a mouse event for the context menu keyboard button. Provides detection of
   * when the context menu event is from the keyboard. Firefox as of (1/23) does not provide the correct screen space
   * coordinates, so for keyboard context menu presses coordinates are generated from the centroid point of the
   * element.
   *
   * A default fallback element or selector string may be provided to provide the focus target. If the event comes from
   * the keyboard however the source focused element is inserted as the target with the fallback value appended to the
   * list of focus targets. When A11yFocusSource is applied by {@link A11yHelper.applyFocusSource} the target focus
   * list is iterated through until a connected target is found and focus applied.
   *
   * @param {object} options - Options
   *
   * @param {KeyboardEvent | MouseEvent}   [options.event] - The source DOM event.
   *
   * @param {boolean} [options.debug] - When true {@link A11yHelper.applyFocusSource} logs focus target data.
   *
   * @param {FocusableElement | string} [options.focusEl] - A specific HTMLElement / SVGElement or selector
   *        string as the focus target.
   *
   * @param {number}   [options.x] - Used when an event isn't provided; integer of event source in screen space.
   *
   * @param {number}   [options.y] - Used when an event isn't provided; integer of event source in screen space.
   *
   * @returns {A11yFocusSource} A A11yFocusSource object.
   *
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1426671
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=314314
   *
   * TODO: Evaluate / test against touch input devices.
   */
  static getFocusSource({ event: e, x: t, y: s, focusEl: n, debug: l = !1 }) {
    var c, f;
    if (n !== void 0 && !this.isFocusSource(n))
      throw new TypeError(
        "A11yHelper.getFocusSource error: 'focusEl' is not a HTMLElement, SVGElement, or string."
      );
    if (l !== void 0 && typeof l != "boolean")
      throw new TypeError("A11yHelper.getFocusSource error: 'debug' is not a boolean.");
    const r = typeof l == "boolean" ? this.debug || l : this.debug;
    if (e === void 0) {
      if (typeof t != "number")
        throw new TypeError("A11yHelper.getFocusSource error: 'event' not defined and 'x' is not a number.");
      if (typeof s != "number")
        throw new TypeError("A11yHelper.getFocusSource error: 'event' not defined and 'y' is not a number.");
      const d = {
        debug: l,
        focusEl: n !== void 0 ? [n] : void 0,
        x: t,
        y: s
      };
      return r && console.debug("A11yHelper.getFocusSource debug: generated 'focusSource' without event: ", d), d;
    }
    if (!P(wi, gm).has((c = e == null ? void 0 : e.constructor) == null ? void 0 : c.name))
      throw new TypeError(
        "A11yHelper.getFocusSource error: 'event' is not a KeyboardEvent, MouseEvent, or PointerEvent."
      );
    if (t !== void 0 && !Number.isInteger(t))
      throw new TypeError("A11yHelper.getFocusSource error: 'x' is not a number.");
    if (s !== void 0 && !Number.isInteger(s))
      throw new TypeError("A11yHelper.getFocusSource error: 'y' is not a number.");
    let o;
    if (e && (wi.isFocusable(e.target) ? (o = e.target, r && console.debug("A11yHelper.getFocusSource debug: 'targetEl' set to event.target: ", o)) : wi.isFocusable(e.currentTarget) ? (o = e.currentTarget, r && console.debug("A11yHelper.getFocusSource debug: 'targetEl' set to event.currentTarget: ", o)) : r && (console.debug(
      "A11yHelper.getFocusSource debug: 'event.target' / 'event.currentTarget' are not focusable."
    ), console.debug("A11yHelper.getFocusSource debug: 'event.target': ", e.target), console.debug("A11yHelper.getFocusSource debug: 'event.currentTarget': ", e.currentTarget)), o && (o == null ? void 0 : o.nodeType) !== Node.ELEMENT_NODE && typeof (o == null ? void 0 : o.focus) != "function"))
      throw new TypeError("A11yHelper.getFocusSource error: 'targetEl' is not an HTMLElement or SVGElement.");
    const a = { debug: l };
    if (P(wi, bm).has((f = e == null ? void 0 : e.constructor) == null ? void 0 : f.name))
      if ((e == null ? void 0 : e.button) !== 2 && e.type === "contextmenu") {
        const p = (o ?? e.target).getBoundingClientRect();
        a.source = "keyboard", a.x = t ?? p.left + p.width / 2, a.y = s ?? p.top + p.height / 2, a.focusEl = o ? [o] : [], n && a.focusEl.push(n);
      } else
        a.source = "pointer", a.x = t ?? e.pageX, a.y = s ?? e.pageY, a.focusEl = o ? [o] : [], n && a.focusEl.push(n);
    else {
      const p = (o ?? e.target).getBoundingClientRect();
      a.source = "keyboard", a.x = t ?? p.left + p.width / 2, a.y = s ?? p.top + p.height / 2, a.focusEl = o ? [o] : [], n && a.focusEl.push(n);
    }
    return r && console.debug("A11yHelper.getFocusSource debug: generated 'focusSource' with event: ", a), a;
  }
  /**
   * Returns first focusable element within a specified element.
   *
   * @param {Element | Document} [element=document] - Optional element to start query.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @param {Set<Element>} [options.ignoreElements] - Set of elements to ignore.
   *
   * @returns {FocusableElement} Last focusable child element.
   */
  static getLastFocusableElement(e = document, t) {
    const s = this.getFocusableElements(e, t);
    return s.length > 0 ? s[s.length - 1] : void 0;
  }
  /**
   * Tests if the given element is focusable.
   *
   * @param {Element} el - Element to test.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {boolean} [options.anchorHref=true] - When true anchors must have an HREF.
   *
   * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @returns {boolean} Element is focusable.
   */
  static isFocusable(e, { anchorHref: t = !0, ignoreClasses: s } = {}) {
    if (e == null || e != null && e.hidden || !(e != null && e.isConnected) || (e == null ? void 0 : e.nodeType) !== Node.ELEMENT_NODE || typeof (e == null ? void 0 : e.focus) != "function")
      return !1;
    if (typeof t != "boolean")
      throw new TypeError("'anchorHref' is not a boolean.");
    if (s !== void 0 && !Nt(s))
      throw new TypeError("'ignoreClasses' is not an iterable list.");
    const n = e.getAttribute("contenteditable"), l = typeof n == "string" && (n === "" || n === "true"), r = globalThis.parseInt(e.getAttribute("tabindex")), o = Number.isInteger(r) && r >= 0, a = e instanceof HTMLAnchorElement;
    return l || o || a || e instanceof HTMLButtonElement || e instanceof HTMLDetailsElement || e instanceof HTMLEmbedElement || e instanceof HTMLIFrameElement || e instanceof HTMLInputElement || e instanceof HTMLObjectElement || e instanceof HTMLSelectElement || e instanceof HTMLTextAreaElement ? a && !o && t && typeof e.getAttribute("href") != "string" ? !1 : e.style.display !== "none" && e.style.visibility !== "hidden" && !e.hasAttribute("disabled") && !e.hasAttribute("inert") && e.getAttribute("aria-hidden") !== "true" : !1;
  }
  /**
   * Convenience method to check if the given data is a valid focus source.
   *
   * @param {Element | string}   data - Either an HTMLElement, SVGElement, or selector string.
   *
   * @returns {boolean} Is valid focus source.
   */
  static isFocusSource(e) {
    return typeof e == "string" || (e == null ? void 0 : e.nodeType) === Node.ELEMENT_NODE && typeof (e == null ? void 0 : e.focus) == "function";
  }
  /**
   * Tests if the given `element` is a Element node and has a `focus` method.
   *
   * @param {Element}  element - Element to test for focus method.
   *
   * @returns {boolean} Whether the element has a focus method.
   */
  static isFocusTarget(e) {
    return e != null && (e == null ? void 0 : e.nodeType) === Node.ELEMENT_NODE && typeof (e == null ? void 0 : e.focus) == "function";
  }
  /**
   * Perform a parent traversal from the current active element attempting to match the given element to test whether
   * current active element is within that element.
   *
   * @param {Element}  element - An element to match in parent traversal from the active element.
   *
   * @param {Window}   [activeWindow=globalThis] The active window to use for the current active element.
   *
   * @returns {boolean} Whether there is focus within the given element.
   */
  static isFocusWithin(e, t = globalThis) {
    if (e == null || e != null && e.hidden || !(e != null && e.isConnected) || Object.prototype.toString.call(t) !== "[object Window]")
      return !1;
    let s = t.document.activeElement;
    for (; s; ) {
      if (s === e)
        return !0;
      s = s.parentElement;
    }
    return !1;
  }
};
gm = new WeakMap(), bm = new WeakMap(), Xu = new WeakMap(), _m = new WeakSet(), EL = /* @__PURE__ */ u(function(e = !0) {
  return `button, [contenteditable=""], [contenteditable="true"], details summary:not([tabindex="-1"]), embed, a${e ? "[href]" : ""}, iframe, object, input:not([type=hidden]), select, textarea, [tabindex]:not([tabindex="-1"])`;
}, "#getFocusableSelectors"), x(wi, _m), u(wi, "A11yHelper"), /**
 * Provides the event constructor names to duck type against. This is necessary for when HTML nodes / elements are
 * moved to another browser window as `instanceof` checks will fail.
 *
 * @type {Set<string>}
 */
x(wi, gm, /* @__PURE__ */ new Set(["KeyboardEvent", "MouseEvent", "PointerEvent"])), x(wi, bm, /* @__PURE__ */ new Set(["MouseEvent", "PointerEvent"])), /**
 * You can set global focus debugging enabled by setting `A11yHelper.debug = true`.
 *
 * @type {boolean}
 */
x(wi, Xu, !1);
let ot = wi;
// @license MIT (https://github.com/toji/gl-matrix/blob/master/LICENSE.md)
var cs = 1e-6, wt, Ju, An, Ye = (wt = class extends Float32Array {
  /**
   * Create a {@link Mat4}.
   *
   * @category Constructor
   */
  constructor(...e) {
    switch (e.length) {
      case 16:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 16);
        break;
      case 1:
        const t = e[0];
        typeof t == "number" ? super([
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t
        ]) : super(t, 0, 16);
        break;
      default:
        super(P(wt, Ju));
        break;
    }
  }
  // ============
  // Accessors
  // ============
  /**
   * A string representation of `this`
   * Equivalent to `Mat4.str(this);`
   *
   * @category Accessors
   */
  get str() {
    return wt.str(this);
  }
  // ===================
  // Instance methods
  // ===================
  /**
   * Copy the values from another {@link Mat4} into `this`.
   * @category Methods
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Set `this` to the identity matrix
   * Equivalent to Mat4.identity(this)
   * @category Methods
   *
   * @returns `this`
   */
  identity() {
    return this.set(P(wt, Ju)), this;
  }
  /**
   * Multiplies this {@link Mat4} against another one
   * Equivalent to `Mat4.multiply(this, this, b);`
   * @category Methods
   *
   * @param b - The second operand
   * @returns `this`
   */
  multiply(e) {
    return wt.multiply(this, this, e);
  }
  /**
   * Alias for {@link Mat4.multiply}
   * @category Methods
   */
  mul(e) {
    return this;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Transpose this {@link Mat4}
   * Equivalent to `Mat4.transpose(this, this);`
   * @category Methods
   *
   * @returns `this`
   */
  transpose() {
    return wt.transpose(this, this);
  }
  /**
   * Inverts this {@link Mat4}
   * Equivalent to `Mat4.invert(this, this);`
   * @category Methods
   *
   * @returns `this`
   */
  invert() {
    return wt.invert(this, this);
  }
  /**
   * Translate this {@link Mat4} by the given vector
   * Equivalent to `Mat4.translate(this, this, v);`
   * @category Methods
   *
   * @param v - The {@link Vec3} to translate by
   * @returns `this`
   */
  translate(e) {
    return wt.translate(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the given axis
   * Equivalent to `Mat4.rotate(this, this, rad, axis);`
   * @category Methods
   *
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `this`
   */
  rotate(e, t) {
    return wt.rotate(this, this, e, t);
  }
  /**
   * Scales this {@link Mat4} by the dimensions in the given vec3 not using vectorization
   * Equivalent to `Mat4.scale(this, this, v);`
   * @category Methods
   *
   * @param v - The {@link Vec3} to scale the matrix by
   * @returns `this`
   */
  scale(e) {
    return wt.scale(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the X axis
   * Equivalent to `Mat4.rotateX(this, this, rad);`
   * @category Methods
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateX(e) {
    return wt.rotateX(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the Y axis
   * Equivalent to `Mat4.rotateY(this, this, rad);`
   * @category Methods
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateY(e) {
    return wt.rotateY(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the Z axis
   * Equivalent to `Mat4.rotateZ(this, this, rad);`
   * @category Methods
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateZ(e) {
    return wt.rotateZ(this, this, e);
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * Equivalent to `Mat4.perspectiveNO(this, fovy, aspect, near, far);`
   * @category Methods
   *
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `this`
   */
  perspectiveNO(e, t, s, n) {
    return wt.perspectiveNO(this, e, t, s, n);
  }
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * Equivalent to `Mat4.perspectiveZO(this, fovy, aspect, near, far);`
   * @category Methods
   *
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `this`
   */
  perspectiveZO(e, t, s, n) {
    return wt.perspectiveZO(this, e, t, s, n);
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Equivalent to `Mat4.orthoNO(this, left, right, bottom, top, near, far);`
   * @category Methods
   *
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `this`
   */
  orthoNO(e, t, s, n, l, r) {
    return wt.orthoNO(this, e, t, s, n, l, r);
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Equivalent to `Mat4.orthoZO(this, left, right, bottom, top, near, far);`
   * @category Methods
   *
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `this`
   */
  orthoZO(e, t, s, n, l, r) {
    return wt.orthoZO(this, e, t, s, n, l, r);
  }
  // ===================
  // Static accessors
  // ===================
  /**
   * @category Static
   *
   * @returns The number of bytes in a {@link Mat4}.
   */
  static get BYTE_LENGTH() {
    return 16 * Float32Array.BYTES_PER_ELEMENT;
  }
  // ===================
  // Static methods
  // ===================
  /**
   * Creates a new, identity {@link Mat4}
   * @category Static
   *
   * @returns A new {@link Mat4}
   */
  static create() {
    return new wt();
  }
  /**
   * Creates a new {@link Mat4} initialized with values from an existing matrix
   * @category Static
   *
   * @param a - Matrix to clone
   * @returns A new {@link Mat4}
   */
  static clone(e) {
    return new wt(e);
  }
  /**
   * Copy the values from one {@link Mat4} to another
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - Matrix to copy
   * @returns `out`
   */
  static copy(e, t) {
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
  }
  /**
   * Create a new mat4 with the given values
   * @category Static
   *
   * @param values - Matrix components
   * @returns A new {@link Mat4}
   */
  static fromValues(...e) {
    return new wt(...e);
  }
  /**
   * Set the components of a mat4 to the given values
   * @category Static
   *
   * @param out - The receiving matrix
   * @param values - Matrix components
   * @returns `out`
   */
  static set(e, ...t) {
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
  }
  /**
   * Set a {@link Mat4} to the identity matrix
   * @category Static
   *
   * @param out - The receiving Matrix
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Transpose the values of a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static transpose(e, t) {
    if (e === t) {
      const s = t[1], n = t[2], l = t[3], r = t[6], o = t[7], a = t[11];
      e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = s, e[6] = t[9], e[7] = t[13], e[8] = n, e[9] = r, e[11] = t[14], e[12] = l, e[13] = o, e[14] = a;
    } else
      e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];
    return e;
  }
  /**
   * Inverts a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out` or `null` if the matrix is not invertible
   */
  static invert(e, t) {
    const s = t[0], n = t[1], l = t[2], r = t[3], o = t[4], a = t[5], c = t[6], f = t[7], d = t[8], p = t[9], m = t[10], g = t[11], h = t[12], _ = t[13], y = t[14], v = t[15], k = s * a - n * o, S = s * c - l * o, D = s * f - r * o, I = n * c - l * a, M = n * f - r * a, L = l * f - r * c, B = d * _ - p * h, z = d * y - m * h, q = d * v - g * h, U = p * y - m * _, H = p * v - g * _, V = m * v - g * y;
    let Y = k * V - S * H + D * U + I * q - M * z + L * B;
    return Y ? (Y = 1 / Y, e[0] = (a * V - c * H + f * U) * Y, e[1] = (l * H - n * V - r * U) * Y, e[2] = (_ * L - y * M + v * I) * Y, e[3] = (m * M - p * L - g * I) * Y, e[4] = (c * q - o * V - f * z) * Y, e[5] = (s * V - l * q + r * z) * Y, e[6] = (y * D - h * L - v * S) * Y, e[7] = (d * L - m * D + g * S) * Y, e[8] = (o * H - a * q + f * B) * Y, e[9] = (n * q - s * H - r * B) * Y, e[10] = (h * M - _ * D + v * k) * Y, e[11] = (p * D - d * M - g * k) * Y, e[12] = (a * z - o * U - c * B) * Y, e[13] = (s * U - n * z + l * B) * Y, e[14] = (_ * S - h * I - y * k) * Y, e[15] = (d * I - p * S + m * k) * Y, e) : null;
  }
  /**
   * Calculates the adjugate of a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static adjoint(e, t) {
    const s = t[0], n = t[1], l = t[2], r = t[3], o = t[4], a = t[5], c = t[6], f = t[7], d = t[8], p = t[9], m = t[10], g = t[11], h = t[12], _ = t[13], y = t[14], v = t[15], k = s * a - n * o, S = s * c - l * o, D = s * f - r * o, I = n * c - l * a, M = n * f - r * a, L = l * f - r * c, B = d * _ - p * h, z = d * y - m * h, q = d * v - g * h, U = p * y - m * _, H = p * v - g * _, V = m * v - g * y;
    return e[0] = a * V - c * H + f * U, e[1] = l * H - n * V - r * U, e[2] = _ * L - y * M + v * I, e[3] = m * M - p * L - g * I, e[4] = c * q - o * V - f * z, e[5] = s * V - l * q + r * z, e[6] = y * D - h * L - v * S, e[7] = d * L - m * D + g * S, e[8] = o * H - a * q + f * B, e[9] = n * q - s * H - r * B, e[10] = h * M - _ * D + v * k, e[11] = p * D - d * M - g * k, e[12] = a * z - o * U - c * B, e[13] = s * U - n * z + l * B, e[14] = _ * S - h * I - y * k, e[15] = d * I - p * S + m * k, e;
  }
  /**
   * Calculates the determinant of a {@link Mat4}
   * @category Static
   *
   * @param a - the source matrix
   * @returns determinant of a
   */
  static determinant(e) {
    const t = e[0], s = e[1], n = e[2], l = e[3], r = e[4], o = e[5], a = e[6], c = e[7], f = e[8], d = e[9], p = e[10], m = e[11], g = e[12], h = e[13], _ = e[14], y = e[15], v = t * o - s * r, k = t * a - n * r, S = s * a - n * o, D = f * h - d * g, I = f * _ - p * g, M = d * _ - p * h, L = t * M - s * I + n * D, B = r * M - o * I + a * D, z = f * S - d * k + p * v, q = g * S - h * k + _ * v;
    return c * L - l * B + y * z - m * q;
  }
  /**
   * Multiplies two {@link Mat4}s
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(e, t, s) {
    const n = t[0], l = t[1], r = t[2], o = t[3], a = t[4], c = t[5], f = t[6], d = t[7], p = t[8], m = t[9], g = t[10], h = t[11], _ = t[12], y = t[13], v = t[14], k = t[15];
    let S = s[0], D = s[1], I = s[2], M = s[3];
    return e[0] = S * n + D * a + I * p + M * _, e[1] = S * l + D * c + I * m + M * y, e[2] = S * r + D * f + I * g + M * v, e[3] = S * o + D * d + I * h + M * k, S = s[4], D = s[5], I = s[6], M = s[7], e[4] = S * n + D * a + I * p + M * _, e[5] = S * l + D * c + I * m + M * y, e[6] = S * r + D * f + I * g + M * v, e[7] = S * o + D * d + I * h + M * k, S = s[8], D = s[9], I = s[10], M = s[11], e[8] = S * n + D * a + I * p + M * _, e[9] = S * l + D * c + I * m + M * y, e[10] = S * r + D * f + I * g + M * v, e[11] = S * o + D * d + I * h + M * k, S = s[12], D = s[13], I = s[14], M = s[15], e[12] = S * n + D * a + I * p + M * _, e[13] = S * l + D * c + I * m + M * y, e[14] = S * r + D * f + I * g + M * v, e[15] = S * o + D * d + I * h + M * k, e;
  }
  /**
   * Alias for {@link Mat4.multiply}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static mul(e, t, s) {
    return e;
  }
  /**
   * Translate a {@link Mat4} by the given vector
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to translate
   * @param v - vector to translate by
   * @returns `out`
   */
  static translate(e, t, s) {
    const n = s[0], l = s[1], r = s[2];
    if (t === e)
      e[12] = t[0] * n + t[4] * l + t[8] * r + t[12], e[13] = t[1] * n + t[5] * l + t[9] * r + t[13], e[14] = t[2] * n + t[6] * l + t[10] * r + t[14], e[15] = t[3] * n + t[7] * l + t[11] * r + t[15];
    else {
      const o = t[0], a = t[1], c = t[2], f = t[3], d = t[4], p = t[5], m = t[6], g = t[7], h = t[8], _ = t[9], y = t[10], v = t[11];
      e[0] = o, e[1] = a, e[2] = c, e[3] = f, e[4] = d, e[5] = p, e[6] = m, e[7] = g, e[8] = h, e[9] = _, e[10] = y, e[11] = v, e[12] = o * n + d * l + h * r + t[12], e[13] = a * n + p * l + _ * r + t[13], e[14] = c * n + m * l + y * r + t[14], e[15] = f * n + g * l + v * r + t[15];
    }
    return e;
  }
  /**
   * Scales the {@link Mat4} by the dimensions in the given {@link Vec3} not using vectorization
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param v - the {@link Vec3} to scale the matrix by
   * @returns `out`
   **/
  static scale(e, t, s) {
    const n = s[0], l = s[1], r = s[2];
    return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * l, e[5] = t[5] * l, e[6] = t[6] * l, e[7] = t[7] * l, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = t[11] * r, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
  }
  /**
   * Rotates a {@link Mat4} by the given angle around the given axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out` or `null` if axis has a length of 0
   */
  static rotate(e, t, s, n) {
    let l = n[0], r = n[1], o = n[2], a = Math.sqrt(l * l + r * r + o * o);
    if (a < cs)
      return null;
    a = 1 / a, l *= a, r *= a, o *= a;
    const c = Math.sin(s), f = Math.cos(s), d = 1 - f, p = t[0], m = t[1], g = t[2], h = t[3], _ = t[4], y = t[5], v = t[6], k = t[7], S = t[8], D = t[9], I = t[10], M = t[11], L = l * l * d + f, B = r * l * d + o * c, z = o * l * d - r * c, q = l * r * d - o * c, U = r * r * d + f, H = o * r * d + l * c, V = l * o * d + r * c, Y = r * o * d - l * c, J = o * o * d + f;
    return e[0] = p * L + _ * B + S * z, e[1] = m * L + y * B + D * z, e[2] = g * L + v * B + I * z, e[3] = h * L + k * B + M * z, e[4] = p * q + _ * U + S * H, e[5] = m * q + y * U + D * H, e[6] = g * q + v * U + I * H, e[7] = h * q + k * U + M * H, e[8] = p * V + _ * Y + S * J, e[9] = m * V + y * Y + D * J, e[10] = g * V + v * Y + I * J, e[11] = h * V + k * Y + M * J, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateX(e, t, s) {
    const n = Math.sin(s), l = Math.cos(s), r = t[4], o = t[5], a = t[6], c = t[7], f = t[8], d = t[9], p = t[10], m = t[11];
    return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = r * l + f * n, e[5] = o * l + d * n, e[6] = a * l + p * n, e[7] = c * l + m * n, e[8] = f * l - r * n, e[9] = d * l - o * n, e[10] = p * l - a * n, e[11] = m * l - c * n, e;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateY(e, t, s) {
    const n = Math.sin(s), l = Math.cos(s), r = t[0], o = t[1], a = t[2], c = t[3], f = t[8], d = t[9], p = t[10], m = t[11];
    return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = r * l - f * n, e[1] = o * l - d * n, e[2] = a * l - p * n, e[3] = c * l - m * n, e[8] = r * n + f * l, e[9] = o * n + d * l, e[10] = a * n + p * l, e[11] = c * n + m * l, e;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateZ(e, t, s) {
    const n = Math.sin(s), l = Math.cos(s), r = t[0], o = t[1], a = t[2], c = t[3], f = t[4], d = t[5], p = t[6], m = t[7];
    return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = r * l + f * n, e[1] = o * l + d * n, e[2] = a * l + p * n, e[3] = c * l + m * n, e[4] = f * l - r * n, e[5] = d * l - o * n, e[6] = p * l - a * n, e[7] = m * l - c * n, e;
  }
  /**
   * Creates a {@link Mat4} from a vector translation
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.translate(dest, dest, vec);
   * ```
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param v - Translation vector
   * @returns `out`
   */
  static fromTranslation(e, t) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e;
  }
  /**
   * Creates a {@link Mat4} from a vector scaling
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.scale(dest, dest, vec);
   * ```
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param v - Scaling vector
   * @returns `out`
   */
  static fromScaling(e, t) {
    return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a {@link Mat4} from a given angle around a given axis
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.rotate(dest, dest, rad, axis);
   * ```
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out` or `null` if `axis` has a length of 0
   */
  static fromRotation(e, t, s) {
    let n = s[0], l = s[1], r = s[2], o = Math.sqrt(n * n + l * l + r * r);
    if (o < cs)
      return null;
    o = 1 / o, n *= o, l *= o, r *= o;
    const a = Math.sin(t), c = Math.cos(t), f = 1 - c;
    return e[0] = n * n * f + c, e[1] = l * n * f + r * a, e[2] = r * n * f - l * a, e[3] = 0, e[4] = n * l * f - r * a, e[5] = l * l * f + c, e[6] = r * l * f + n * a, e[7] = 0, e[8] = n * r * f + l * a, e[9] = l * r * f - n * a, e[10] = r * r * f + c, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.rotateX(dest, dest, rad);
   * ```
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromXRotation(e, t) {
    const s = Math.sin(t), n = Math.cos(t);
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = s, e[7] = 0, e[8] = 0, e[9] = -s, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.rotateY(dest, dest, rad);
   * ```
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromYRotation(e, t) {
    const s = Math.sin(t), n = Math.cos(t);
    return e[0] = n, e[1] = 0, e[2] = -s, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = s, e[9] = 0, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.rotateZ(dest, dest, rad);
   * ```
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromZRotation(e, t) {
    const s = Math.sin(t), n = Math.cos(t);
    return e[0] = n, e[1] = s, e[2] = 0, e[3] = 0, e[4] = -s, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.translate(dest, vec);
   *   let quatMat = mat4.create();
   *   quat4.toMat4(quat, quatMat);
   *   mat4.multiply(dest, quatMat);
   * ```
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @returns `out`
   */
  static fromRotationTranslation(e, t, s) {
    const n = t[0], l = t[1], r = t[2], o = t[3], a = n + n, c = l + l, f = r + r, d = n * a, p = n * c, m = n * f, g = l * c, h = l * f, _ = r * f, y = o * a, v = o * c, k = o * f;
    return e[0] = 1 - (g + _), e[1] = p + k, e[2] = m - v, e[3] = 0, e[4] = p - k, e[5] = 1 - (d + _), e[6] = h + y, e[7] = 0, e[8] = m + v, e[9] = h - y, e[10] = 1 - (d + g), e[11] = 0, e[12] = s[0], e[13] = s[1], e[14] = s[2], e[15] = 1, e;
  }
  /**
   * Sets a {@link Mat4} from a {@link Quat2}.
   * @category Static
   *
   * @param out - Matrix
   * @param a - Dual Quaternion
   * @returns `out`
   */
  static fromQuat2(e, t) {
    const s = -t[0], n = -t[1], l = -t[2], r = t[3], o = t[4], a = t[5], c = t[6], f = t[7], d = s * s + n * n + l * l + r * r;
    return d > 0 ? (P(wt, An)[0] = (o * r + f * s + a * l - c * n) * 2 / d, P(wt, An)[1] = (a * r + f * n + c * s - o * l) * 2 / d, P(wt, An)[2] = (c * r + f * l + o * n - a * s) * 2 / d) : (P(wt, An)[0] = (o * r + f * s + a * l - c * n) * 2, P(wt, An)[1] = (a * r + f * n + c * s - o * l) * 2, P(wt, An)[2] = (c * r + f * l + o * n - a * s) * 2), wt.fromRotationTranslation(e, t, P(wt, An)), e;
  }
  /**
   * Calculates a {@link Mat4} normal matrix (transpose inverse) from a {@link Mat4}
   * @category Static
   *
   * @param out - Matrix receiving operation result
   * @param a - Mat4 to derive the normal matrix from
   * @returns `out` or `null` if the matrix is not invertible
   */
  static normalFromMat4(e, t) {
    const s = t[0], n = t[1], l = t[2], r = t[3], o = t[4], a = t[5], c = t[6], f = t[7], d = t[8], p = t[9], m = t[10], g = t[11], h = t[12], _ = t[13], y = t[14], v = t[15], k = s * a - n * o, S = s * c - l * o, D = s * f - r * o, I = n * c - l * a, M = n * f - r * a, L = l * f - r * c, B = d * _ - p * h, z = d * y - m * h, q = d * v - g * h, U = p * y - m * _, H = p * v - g * _, V = m * v - g * y;
    let Y = k * V - S * H + D * U + I * q - M * z + L * B;
    return Y ? (Y = 1 / Y, e[0] = (a * V - c * H + f * U) * Y, e[1] = (c * q - o * V - f * z) * Y, e[2] = (o * H - a * q + f * B) * Y, e[3] = 0, e[4] = (l * H - n * V - r * U) * Y, e[5] = (s * V - l * q + r * z) * Y, e[6] = (n * q - s * H - r * B) * Y, e[7] = 0, e[8] = (_ * L - y * M + v * I) * Y, e[9] = (y * D - h * L - v * S) * Y, e[10] = (h * M - _ * D + v * k) * Y, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e) : null;
  }
  /**
   * Calculates a {@link Mat4} normal matrix (transpose inverse) from a {@link Mat4}
   * This version omits the calculation of the constant factor (1/determinant), so
   * any normals transformed with it will need to be renormalized.
   * From https://stackoverflow.com/a/27616419/25968
   * @category Static
   *
   * @param out - Matrix receiving operation result
   * @param a - Mat4 to derive the normal matrix from
   * @returns `out`
   */
  static normalFromMat4Fast(e, t) {
    const s = t[0], n = t[1], l = t[2], r = t[4], o = t[5], a = t[6], c = t[8], f = t[9], d = t[10];
    return e[0] = o * d - d * f, e[1] = a * c - c * d, e[2] = r * f - f * c, e[3] = 0, e[4] = f * l - d * n, e[5] = d * s - c * l, e[6] = c * n - f * s, e[7] = 0, e[8] = n * a - l * o, e[9] = l * r - s * a, e[10] = s * o - n * r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Returns the translation vector component of a transformation
   * matrix. If a matrix is built with fromRotationTranslation,
   * the returned vector will be the same as the translation vector
   * originally supplied.
   * @category Static
   *
   * @param  {vec3} out Vector to receive translation component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */
  static getTranslation(e, t) {
    return e[0] = t[12], e[1] = t[13], e[2] = t[14], e;
  }
  /**
   * Returns the scaling factor component of a transformation
   * matrix. If a matrix is built with fromRotationTranslationScale
   * with a normalized Quaternion parameter, the returned vector will be
   * the same as the scaling vector
   * originally supplied.
   * @category Static
   *
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */
  static getScaling(e, t) {
    const s = t[0], n = t[1], l = t[2], r = t[4], o = t[5], a = t[6], c = t[8], f = t[9], d = t[10];
    return e[0] = Math.sqrt(s * s + n * n + l * l), e[1] = Math.sqrt(r * r + o * o + a * a), e[2] = Math.sqrt(c * c + f * f + d * d), e;
  }
  /**
   * Returns a quaternion representing the rotational component
   * of a transformation matrix. If a matrix is built with
   * fromRotationTranslation, the returned quaternion will be the
   * same as the quaternion originally supplied.
   * @category Static
   *
   * @param out - Quaternion to receive the rotation component
   * @param mat - Matrix to be decomposed (input)
   * @return `out`
   */
  static getRotation(e, t) {
    wt.getScaling(P(wt, An), t);
    const s = 1 / P(wt, An)[0], n = 1 / P(wt, An)[1], l = 1 / P(wt, An)[2], r = t[0] * s, o = t[1] * n, a = t[2] * l, c = t[4] * s, f = t[5] * n, d = t[6] * l, p = t[8] * s, m = t[9] * n, g = t[10] * l, h = r + f + g;
    let _ = 0;
    return h > 0 ? (_ = Math.sqrt(h + 1) * 2, e[3] = 0.25 * _, e[0] = (d - m) / _, e[1] = (p - a) / _, e[2] = (o - c) / _) : r > f && r > g ? (_ = Math.sqrt(1 + r - f - g) * 2, e[3] = (d - m) / _, e[0] = 0.25 * _, e[1] = (o + c) / _, e[2] = (p + a) / _) : f > g ? (_ = Math.sqrt(1 + f - r - g) * 2, e[3] = (p - a) / _, e[0] = (o + c) / _, e[1] = 0.25 * _, e[2] = (d + m) / _) : (_ = Math.sqrt(1 + g - r - f) * 2, e[3] = (o - c) / _, e[0] = (p + a) / _, e[1] = (d + m) / _, e[2] = 0.25 * _), e;
  }
  /**
   * Decomposes a transformation matrix into its rotation, translation
   * and scale components. Returns only the rotation component
   * @category Static
   *
   * @param out_r - Quaternion to receive the rotation component
   * @param out_t - Vector to receive the translation vector
   * @param out_s - Vector to receive the scaling factor
   * @param mat - Matrix to be decomposed (input)
   * @returns `out_r`
   */
  static decompose(e, t, s, n) {
    t[0] = n[12], t[1] = n[13], t[2] = n[14];
    const l = n[0], r = n[1], o = n[2], a = n[4], c = n[5], f = n[6], d = n[8], p = n[9], m = n[10];
    s[0] = Math.sqrt(l * l + r * r + o * o), s[1] = Math.sqrt(a * a + c * c + f * f), s[2] = Math.sqrt(d * d + p * p + m * m);
    const g = 1 / s[0], h = 1 / s[1], _ = 1 / s[2], y = l * g, v = r * h, k = o * _, S = a * g, D = c * h, I = f * _, M = d * g, L = p * h, B = m * _, z = y + D + B;
    let q = 0;
    return z > 0 ? (q = Math.sqrt(z + 1) * 2, e[3] = 0.25 * q, e[0] = (I - L) / q, e[1] = (M - k) / q, e[2] = (v - S) / q) : y > D && y > B ? (q = Math.sqrt(1 + y - D - B) * 2, e[3] = (I - L) / q, e[0] = 0.25 * q, e[1] = (v + S) / q, e[2] = (M + k) / q) : D > B ? (q = Math.sqrt(1 + D - y - B) * 2, e[3] = (M - k) / q, e[0] = (v + S) / q, e[1] = 0.25 * q, e[2] = (I + L) / q) : (q = Math.sqrt(1 + B - y - D) * 2, e[3] = (v - S) / q, e[0] = (M + k) / q, e[1] = (I + L) / q, e[2] = 0.25 * q), e;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.translate(dest, vec);
   *   let quatMat = mat4.create();
   *   quat4.toMat4(quat, quatMat);
   *   mat4.multiply(dest, quatMat);
   *   mat4.scale(dest, scale);
   * ```
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @param s - Scaling vector
   * @returns `out`
   */
  static fromRotationTranslationScale(e, t, s, n) {
    const l = t[0], r = t[1], o = t[2], a = t[3], c = l + l, f = r + r, d = o + o, p = l * c, m = l * f, g = l * d, h = r * f, _ = r * d, y = o * d, v = a * c, k = a * f, S = a * d, D = n[0], I = n[1], M = n[2];
    return e[0] = (1 - (h + y)) * D, e[1] = (m + S) * D, e[2] = (g - k) * D, e[3] = 0, e[4] = (m - S) * I, e[5] = (1 - (p + y)) * I, e[6] = (_ + v) * I, e[7] = 0, e[8] = (g + k) * M, e[9] = (_ - v) * M, e[10] = (1 - (p + h)) * M, e[11] = 0, e[12] = s[0], e[13] = s[1], e[14] = s[2], e[15] = 1, e;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the
   * given origin. This is equivalent to (but much faster than):
   * ```js
   *   mat4.identity(dest);
   *   mat4.translate(dest, vec);
   *   mat4.translate(dest, origin);
   *   let quatMat = mat4.create();
   *   quat4.toMat4(quat, quatMat);
   *   mat4.multiply(dest, quatMat);
   *   mat4.scale(dest, scale)
   *   mat4.translate(dest, negativeOrigin);
   * ```
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @param s - Scaling vector
   * @param o - The origin vector around which to scale and rotate
   * @returns `out`
   */
  static fromRotationTranslationScaleOrigin(e, t, s, n, l) {
    const r = t[0], o = t[1], a = t[2], c = t[3], f = r + r, d = o + o, p = a + a, m = r * f, g = r * d, h = r * p, _ = o * d, y = o * p, v = a * p, k = c * f, S = c * d, D = c * p, I = n[0], M = n[1], L = n[2], B = l[0], z = l[1], q = l[2], U = (1 - (_ + v)) * I, H = (g + D) * I, V = (h - S) * I, Y = (g - D) * M, J = (1 - (m + v)) * M, fe = (y + k) * M, ke = (h + S) * L, ee = (y - k) * L, ne = (1 - (m + _)) * L;
    return e[0] = U, e[1] = H, e[2] = V, e[3] = 0, e[4] = Y, e[5] = J, e[6] = fe, e[7] = 0, e[8] = ke, e[9] = ee, e[10] = ne, e[11] = 0, e[12] = s[0] + B - (U * B + Y * z + ke * q), e[13] = s[1] + z - (H * B + J * z + ee * q), e[14] = s[2] + q - (V * B + fe * z + ne * q), e[15] = 1, e;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Quaternion to create matrix from
   * @returns `out`
   */
  static fromQuat(e, t) {
    const s = t[0], n = t[1], l = t[2], r = t[3], o = s + s, a = n + n, c = l + l, f = s * o, d = n * o, p = n * a, m = l * o, g = l * a, h = l * c, _ = r * o, y = r * a, v = r * c;
    return e[0] = 1 - p - h, e[1] = d + v, e[2] = m - y, e[3] = 0, e[4] = d - v, e[5] = 1 - f - h, e[6] = g + _, e[7] = 0, e[8] = m + y, e[9] = g - _, e[10] = 1 - f - p, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Generates a frustum matrix with the given bounds
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far -  Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static frustumNO(e, t, s, n, l, r, o = 1 / 0) {
    const a = 1 / (s - t), c = 1 / (l - n);
    if (e[0] = r * 2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = r * 2 * c, e[6] = 0, e[7] = 0, e[8] = (s + t) * a, e[9] = (l + n) * c, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, o != null && o !== 1 / 0) {
      const f = 1 / (r - o);
      e[10] = (o + r) * f, e[14] = 2 * o * r * f;
    } else
      e[10] = -1, e[14] = -2 * r;
    return e;
  }
  /**
   * Alias for {@link Mat4.frustumNO}
   * @category Static
   * @deprecated Use {@link Mat4.frustumNO} or {@link Mat4.frustumZO} explicitly
   */
  static frustum(e, t, s, n, l, r, o = 1 / 0) {
    return e;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Generates a frustum matrix with the given bounds
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static frustumZO(e, t, s, n, l, r, o = 1 / 0) {
    const a = 1 / (s - t), c = 1 / (l - n);
    if (e[0] = r * 2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = r * 2 * c, e[6] = 0, e[7] = 0, e[8] = (s + t) * a, e[9] = (l + n) * c, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, o != null && o !== 1 / 0) {
      const f = 1 / (r - o);
      e[10] = o * f, e[14] = o * r * f;
    } else
      e[10] = -1, e[14] = -r;
    return e;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static perspectiveNO(e, t, s, n, l = 1 / 0) {
    const r = 1 / Math.tan(t / 2);
    if (e[0] = r / s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = r, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, l != null && l !== 1 / 0) {
      const o = 1 / (n - l);
      e[10] = (l + n) * o, e[14] = 2 * l * n * o;
    } else
      e[10] = -1, e[14] = -2 * n;
    return e;
  }
  /**
   * Alias for {@link Mat4.perspectiveNO}
   * @category Static
   * @deprecated Use {@link Mat4.perspectiveNO} or {@link Mat4.perspectiveZO} explicitly
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static perspective(e, t, s, n, l = 1 / 0) {
    return e;
  }
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static perspectiveZO(e, t, s, n, l = 1 / 0) {
    const r = 1 / Math.tan(t / 2);
    if (e[0] = r / s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = r, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, l != null && l !== 1 / 0) {
      const o = 1 / (n - l);
      e[10] = l * o, e[14] = l * n * o;
    } else
      e[10] = -1, e[14] = -n;
    return e;
  }
  /**
   * Generates a perspective projection matrix with the given field of view. This is primarily useful for generating
   * projection matrices to be used with the still experimental WebVR API.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fov - Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   * @deprecated
   */
  static perspectiveFromFieldOfView(e, t, s, n) {
    const l = Math.tan(t.upDegrees * Math.PI / 180), r = Math.tan(t.downDegrees * Math.PI / 180), o = Math.tan(t.leftDegrees * Math.PI / 180), a = Math.tan(t.rightDegrees * Math.PI / 180), c = 2 / (o + a), f = 2 / (l + r);
    return e[0] = c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = f, e[6] = 0, e[7] = 0, e[8] = -((o - a) * c * 0.5), e[9] = (l - r) * f * 0.5, e[10] = n / (s - n), e[11] = -1, e[12] = 0, e[13] = 0, e[14] = n * s / (s - n), e[15] = 0, e;
  }
  /**
   * Generates an orthogonal projection matrix with the given bounds. The near / far clip planes correspond to a
   * normalized device coordinate Z range of [-1, 1], which matches WebGL / OpenGLs clip volume.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static orthoNO(e, t, s, n, l, r, o) {
    const a = 1 / (t - s), c = 1 / (n - l), f = 1 / (r - o);
    return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * f, e[11] = 0, e[12] = (t + s) * a, e[13] = (l + n) * c, e[14] = (o + r) * f, e[15] = 1, e;
  }
  /**
   * Alias for {@link Mat4.orthoNO}
   * @category Static
   * @deprecated Use {@link Mat4.orthoNO} or {@link Mat4.orthoZO} explicitly
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static ortho(e, t, s, n, l, r, o) {
    return e;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds. The near / far clip planes correspond to a
   * normalized device coordinate Z range of [0, 1], which matches WebGPU / Vulkan / DirectX / Metal's clip volume.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static orthoZO(e, t, s, n, l, r, o) {
    const a = 1 / (t - s), c = 1 / (n - l), f = 1 / (r - o);
    return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = f, e[11] = 0, e[12] = (t + s) * a, e[13] = (l + n) * c, e[14] = r * f, e[15] = 1, e;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis. If you want a matrix that
   * actually makes an object look at another object, you should use targetTo instead.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param eye - Position of the viewer
   * @param center - Point the viewer is looking at
   * @param up - vec3 pointing up
   * @returns `out`
   */
  static lookAt(e, t, s, n) {
    const l = t[0], r = t[1], o = t[2], a = n[0], c = n[1], f = n[2], d = s[0], p = s[1], m = s[2];
    if (Math.abs(l - d) < cs && Math.abs(r - p) < cs && Math.abs(o - m) < cs)
      return wt.identity(e);
    let g = l - d, h = r - p, _ = o - m, y = 1 / Math.sqrt(g * g + h * h + _ * _);
    g *= y, h *= y, _ *= y;
    let v = c * _ - f * h, k = f * g - a * _, S = a * h - c * g;
    y = Math.sqrt(v * v + k * k + S * S), y ? (y = 1 / y, v *= y, k *= y, S *= y) : (v = 0, k = 0, S = 0);
    let D = h * S - _ * k, I = _ * v - g * S, M = g * k - h * v;
    return y = Math.sqrt(D * D + I * I + M * M), y ? (y = 1 / y, D *= y, I *= y, M *= y) : (D = 0, I = 0, M = 0), e[0] = v, e[1] = D, e[2] = g, e[3] = 0, e[4] = k, e[5] = I, e[6] = h, e[7] = 0, e[8] = S, e[9] = M, e[10] = _, e[11] = 0, e[12] = -(v * l + k * r + S * o), e[13] = -(D * l + I * r + M * o), e[14] = -(g * l + h * r + _ * o), e[15] = 1, e;
  }
  /**
   * Generates a matrix that makes something look at something else.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param eye - Position of the viewer
   * @param target - Point the viewer is looking at
   * @param up - vec3 pointing up
   * @returns `out`
   */
  static targetTo(e, t, s, n) {
    const l = t[0], r = t[1], o = t[2], a = n[0], c = n[1], f = n[2];
    let d = l - s[0], p = r - s[1], m = o - s[2], g = d * d + p * p + m * m;
    g > 0 && (g = 1 / Math.sqrt(g), d *= g, p *= g, m *= g);
    let h = c * m - f * p, _ = f * d - a * m, y = a * p - c * d;
    return g = h * h + _ * _ + y * y, g > 0 && (g = 1 / Math.sqrt(g), h *= g, _ *= g, y *= g), e[0] = h, e[1] = _, e[2] = y, e[3] = 0, e[4] = p * y - m * _, e[5] = m * h - d * y, e[6] = d * _ - p * h, e[7] = 0, e[8] = d, e[9] = p, e[10] = m, e[11] = 0, e[12] = l, e[13] = r, e[14] = o, e[15] = 1, e;
  }
  /**
   * Returns Frobenius norm of a {@link Mat4}
   * @category Static
   *
   * @param a - the matrix to calculate Frobenius norm of
   * @returns Frobenius norm
   */
  static frob(e) {
    return Math.sqrt(
      e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3] + e[4] * e[4] + e[5] * e[5] + e[6] * e[6] + e[7] * e[7] + e[8] * e[8] + e[9] * e[9] + e[10] * e[10] + e[11] * e[11] + e[12] * e[12] + e[13] * e[13] + e[14] * e[14] + e[15] * e[15]
    );
  }
  /**
   * Adds two {@link Mat4}'s
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, t, s) {
    return e[0] = t[0] + s[0], e[1] = t[1] + s[1], e[2] = t[2] + s[2], e[3] = t[3] + s[3], e[4] = t[4] + s[4], e[5] = t[5] + s[5], e[6] = t[6] + s[6], e[7] = t[7] + s[7], e[8] = t[8] + s[8], e[9] = t[9] + s[9], e[10] = t[10] + s[10], e[11] = t[11] + s[11], e[12] = t[12] + s[12], e[13] = t[13] + s[13], e[14] = t[14] + s[14], e[15] = t[15] + s[15], e;
  }
  /**
   * Subtracts matrix b from matrix a
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, t, s) {
    return e[0] = t[0] - s[0], e[1] = t[1] - s[1], e[2] = t[2] - s[2], e[3] = t[3] - s[3], e[4] = t[4] - s[4], e[5] = t[5] - s[5], e[6] = t[6] - s[6], e[7] = t[7] - s[7], e[8] = t[8] - s[8], e[9] = t[9] - s[9], e[10] = t[10] - s[10], e[11] = t[11] - s[11], e[12] = t[12] - s[12], e[13] = t[13] - s[13], e[14] = t[14] - s[14], e[15] = t[15] - s[15], e;
  }
  /**
   * Alias for {@link Mat4.subtract}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static sub(e, t, s) {
    return e;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param b - amount to scale the matrix's elements by
   * @returns `out`
   */
  static multiplyScalar(e, t, s) {
    return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s, e[4] = t[4] * s, e[5] = t[5] * s, e[6] = t[6] * s, e[7] = t[7] * s, e[8] = t[8] * s, e[9] = t[9] * s, e[10] = t[10] * s, e[11] = t[11] * s, e[12] = t[12] * s, e[13] = t[13] * s, e[14] = t[14] * s, e[15] = t[15] * s, e;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b's elements by before adding
   * @returns `out`
   */
  static multiplyScalarAndAdd(e, t, s, n) {
    return e[0] = t[0] + s[0] * n, e[1] = t[1] + s[1] * n, e[2] = t[2] + s[2] * n, e[3] = t[3] + s[3] * n, e[4] = t[4] + s[4] * n, e[5] = t[5] + s[5] * n, e[6] = t[6] + s[6] * n, e[7] = t[7] + s[7] * n, e[8] = t[8] + s[8] * n, e[9] = t[9] + s[9] * n, e[10] = t[10] + s[10] * n, e[11] = t[11] + s[11] * n, e[12] = t[12] + s[12] * n, e[13] = t[13] + s[13] * n, e[14] = t[14] + s[14] * n, e[15] = t[15] + s[15] * n, e;
  }
  /**
   * Returns whether two {@link Mat4}s have exactly the same elements in the same position (when compared with ===).
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static exactEquals(e, t) {
    return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15];
  }
  /**
   * Returns whether two {@link Mat4}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static equals(e, t) {
    const s = e[0], n = e[1], l = e[2], r = e[3], o = e[4], a = e[5], c = e[6], f = e[7], d = e[8], p = e[9], m = e[10], g = e[11], h = e[12], _ = e[13], y = e[14], v = e[15], k = t[0], S = t[1], D = t[2], I = t[3], M = t[4], L = t[5], B = t[6], z = t[7], q = t[8], U = t[9], H = t[10], V = t[11], Y = t[12], J = t[13], fe = t[14], ke = t[15];
    return Math.abs(s - k) <= cs * Math.max(1, Math.abs(s), Math.abs(k)) && Math.abs(n - S) <= cs * Math.max(1, Math.abs(n), Math.abs(S)) && Math.abs(l - D) <= cs * Math.max(1, Math.abs(l), Math.abs(D)) && Math.abs(r - I) <= cs * Math.max(1, Math.abs(r), Math.abs(I)) && Math.abs(o - M) <= cs * Math.max(1, Math.abs(o), Math.abs(M)) && Math.abs(a - L) <= cs * Math.max(1, Math.abs(a), Math.abs(L)) && Math.abs(c - B) <= cs * Math.max(1, Math.abs(c), Math.abs(B)) && Math.abs(f - z) <= cs * Math.max(1, Math.abs(f), Math.abs(z)) && Math.abs(d - q) <= cs * Math.max(1, Math.abs(d), Math.abs(q)) && Math.abs(p - U) <= cs * Math.max(1, Math.abs(p), Math.abs(U)) && Math.abs(m - H) <= cs * Math.max(1, Math.abs(m), Math.abs(H)) && Math.abs(g - V) <= cs * Math.max(1, Math.abs(g), Math.abs(V)) && Math.abs(h - Y) <= cs * Math.max(1, Math.abs(h), Math.abs(Y)) && Math.abs(_ - J) <= cs * Math.max(1, Math.abs(_), Math.abs(J)) && Math.abs(y - fe) <= cs * Math.max(1, Math.abs(y), Math.abs(fe)) && Math.abs(v - ke) <= cs * Math.max(1, Math.abs(v), Math.abs(ke));
  }
  /**
   * Returns a string representation of a {@link Mat4}
   * @category Static
   *
   * @param a - matrix to represent as a string
   * @returns string representation of the matrix
   */
  static str(e) {
    return `Mat4(${e.join(", ")})`;
  }
}, Ju = new WeakMap(), An = new WeakMap(), u(wt, "_Mat4"), x(wt, Ju, new Float32Array([
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1
])), /**
 * Temporary variable to prevent repeated allocations in the algorithms within Mat4.
 * These are declared as TypedArrays to aid in tree-shaking.
 */
x(wt, An, new Float32Array(3)), wt);
Ye.prototype.mul = Ye.prototype.multiply;
Ye.sub = Ye.subtract;
Ye.mul = Ye.multiply;
Ye.frustum = Ye.frustumNO;
Ye.perspective = Ye.perspectiveNO;
Ye.ortho = Ye.orthoNO;
var gn, gt = (gn = class extends Float32Array {
  /**
   * Create a {@link Vec3}.
   *
   * @category Constructor
   */
  constructor(...e) {
    switch (e.length) {
      case 3:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 3);
        break;
      case 1: {
        const t = e[0];
        typeof t == "number" ? super([t, t, t]) : super(t, 0, 3);
        break;
      }
      default:
        super(3);
        break;
    }
  }
  // ============
  // Accessors
  // ============
  // Getters and setters to make component access read better.
  // These are likely to be a little bit slower than direct array access.
  /**
   * The x component of the vector. Equivalent to `this[0];`
   * @category Vector Components
   */
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = e;
  }
  /**
   * The y component of the vector. Equivalent to `this[1];`
   * @category Vector Components
   */
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = e;
  }
  /**
   * The z component of the vector. Equivalent to `this[2];`
   * @category Vector Components
   */
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = e;
  }
  // Alternate set of getters and setters in case this is being used to define
  // a color.
  /**
   * The r component of the vector. Equivalent to `this[0];`
   * @category Color Components
   */
  get r() {
    return this[0];
  }
  set r(e) {
    this[0] = e;
  }
  /**
   * The g component of the vector. Equivalent to `this[1];`
   * @category Color Components
   */
  get g() {
    return this[1];
  }
  set g(e) {
    this[1] = e;
  }
  /**
   * The b component of the vector. Equivalent to `this[2];`
   * @category Color Components
   */
  get b() {
    return this[2];
  }
  set b(e) {
    this[2] = e;
  }
  /**
   * The magnitude (length) of this.
   * Equivalent to `Vec3.magnitude(this);`
   *
   * Magnitude is used because the `length` attribute is already defined by
   * TypedArrays to mean the number of elements in the array.
   *
   * @category Accessors
   */
  get magnitude() {
    const e = this[0], t = this[1], s = this[2];
    return Math.sqrt(e * e + t * t + s * s);
  }
  /**
   * Alias for {@link Vec3.magnitude}
   *
   * @category Accessors
   */
  get mag() {
    return this.magnitude;
  }
  /**
   * The squared magnitude (length) of `this`.
   * Equivalent to `Vec3.squaredMagnitude(this);`
   *
   * @category Accessors
   */
  get squaredMagnitude() {
    const e = this[0], t = this[1], s = this[2];
    return e * e + t * t + s * s;
  }
  /**
   * Alias for {@link Vec3.squaredMagnitude}
   *
   * @category Accessors
   */
  get sqrMag() {
    return this.squaredMagnitude;
  }
  /**
   * A string representation of `this`
   * Equivalent to `Vec3.str(this);`
   *
   * @category Accessors
   */
  get str() {
    return gn.str(this);
  }
  // ===================
  // Instances methods
  // ===================
  /**
   * Copy the values from another {@link Vec3} into `this`.
   * @category Methods
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Adds a {@link Vec3} to `this`.
   * Equivalent to `Vec3.add(this, this, b);`
   * @category Methods
   *
   * @param b - The vector to add to `this`
   * @returns `this`
   */
  add(e) {
    return this[0] += e[0], this[1] += e[1], this[2] += e[2], this;
  }
  /**
   * Subtracts a {@link Vec3} from `this`.
   * Equivalent to `Vec3.subtract(this, this, b);`
   * @category Methods
   *
   * @param b - The vector to subtract from `this`
   * @returns `this`
   */
  subtract(e) {
    return this[0] -= e[0], this[1] -= e[1], this[2] -= e[2], this;
  }
  /**
   * Alias for {@link Vec3.subtract}
   * @category Methods
   */
  sub(e) {
    return this;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Multiplies `this` by a {@link Vec3}.
   * Equivalent to `Vec3.multiply(this, this, b);`
   * @category Methods
   *
   * @param b - The vector to multiply `this` by
   * @returns `this`
   */
  multiply(e) {
    return this[0] *= e[0], this[1] *= e[1], this[2] *= e[2], this;
  }
  /**
   * Alias for {@link Vec3.multiply}
   * @category Methods
   */
  mul(e) {
    return this;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Divides `this` by a {@link Vec3}.
   * Equivalent to `Vec3.divide(this, this, b);`
   * @category Methods
   *
   * @param b - The vector to divide `this` by
   * @returns `this`
   */
  divide(e) {
    return this[0] /= e[0], this[1] /= e[1], this[2] /= e[2], this;
  }
  /**
   * Alias for {@link Vec3.divide}
   * @category Methods
   */
  div(e) {
    return this;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Scales `this` by a scalar number.
   * Equivalent to `Vec3.scale(this, this, b);`
   * @category Methods
   *
   * @param b - Amount to scale `this` by
   * @returns `this`
   */
  scale(e) {
    return this[0] *= e, this[1] *= e, this[2] *= e, this;
  }
  /**
   * Calculates `this` scaled by a scalar value then adds the result to `this`.
   * Equivalent to `Vec3.scaleAndAdd(this, this, b, scale);`
   * @category Methods
   *
   * @param b - The vector to add to `this`
   * @param scale - The amount to scale `b` by before adding
   * @returns `this`
   */
  scaleAndAdd(e, t) {
    return this[0] += e[0] * t, this[1] += e[1] * t, this[2] += e[2] * t, this;
  }
  /**
   * Calculates the Euclidean distance between another {@link Vec3} and `this`.
   * Equivalent to `Vec3.distance(this, b);`
   * @category Methods
   *
   * @param b - The vector to calculate the distance to
   * @returns Distance between `this` and `b`
   */
  distance(e) {
    return gn.distance(this, e);
  }
  /**
   * Alias for {@link Vec3.distance}
   * @category Methods
   */
  dist(e) {
    return 0;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Calculates the squared Euclidean distance between another {@link Vec3} and `this`.
   * Equivalent to `Vec3.squaredDistance(this, b);`
   * @category Methods
   *
   * @param b The vector to calculate the squared distance to
   * @returns Squared distance between `this` and `b`
   */
  squaredDistance(e) {
    return gn.squaredDistance(this, e);
  }
  /**
   * Alias for {@link Vec3.squaredDistance}
   * @category Methods
   */
  sqrDist(e) {
    return 0;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Negates the components of `this`.
   * Equivalent to `Vec3.negate(this, this);`
   * @category Methods
   *
   * @returns `this`
   */
  negate() {
    return this[0] *= -1, this[1] *= -1, this[2] *= -1, this;
  }
  /**
   * Inverts the components of `this`.
   * Equivalent to `Vec3.inverse(this, this);`
   * @category Methods
   *
   * @returns `this`
   */
  invert() {
    return this[0] = 1 / this[0], this[1] = 1 / this[1], this[2] = 1 / this[2], this;
  }
  /**
   * Sets each component of `this` to its absolute value.
   * Equivalent to `Vec3.abs(this, this);`
   * @category Methods
   *
   * @returns `this`
   */
  abs() {
    return this[0] = Math.abs(this[0]), this[1] = Math.abs(this[1]), this[2] = Math.abs(this[2]), this;
  }
  /**
   * Calculates the dot product of this and another {@link Vec3}.
   * Equivalent to `Vec3.dot(this, b);`
   * @category Methods
   *
   * @param b - The second operand
   * @returns Dot product of `this` and `b`
   */
  dot(e) {
    return this[0] * e[0] + this[1] * e[1] + this[2] * e[2];
  }
  /**
   * Normalize `this`.
   * Equivalent to `Vec3.normalize(this, this);`
   * @category Methods
   *
   * @returns `this`
   */
  normalize() {
    return gn.normalize(this, this);
  }
  // ===================
  // Static accessors
  // ===================
  /**
   * @category Static
   *
   * @returns The number of bytes in a {@link Vec3}.
   */
  static get BYTE_LENGTH() {
    return 3 * Float32Array.BYTES_PER_ELEMENT;
  }
  // ===================
  // Static methods
  // ===================
  /**
   * Creates a new, empty vec3
   * @category Static
   *
   * @returns a new 3D vector
   */
  static create() {
    return new gn();
  }
  /**
   * Creates a new vec3 initialized with values from an existing vector
   * @category Static
   *
   * @param a - vector to clone
   * @returns a new 3D vector
   */
  static clone(e) {
    return new gn(e);
  }
  /**
   * Calculates the magnitude (length) of a {@link Vec3}
   * @category Static
   *
   * @param a - Vector to calculate magnitude of
   * @returns Magnitude of a
   */
  static magnitude(e) {
    const t = e[0], s = e[1], n = e[2];
    return Math.sqrt(t * t + s * s + n * n);
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   */
  static mag(e) {
    return 0;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   * @deprecated Use {@link Vec3.magnitude} to avoid conflicts with builtin `length` methods/attribs
   *
   * @param a - vector to calculate length of
   * @returns length of a
   */
  // Length conflicts with Function.length
  static length(e) {
    return 0;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   * @deprecated Use {@link Vec3.mag}
   */
  static len(e) {
    return 0;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Creates a new vec3 initialized with the given values
   * @category Static
   *
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @returns a new 3D vector
   */
  static fromValues(e, t, s) {
    return new gn(e, t, s);
  }
  /**
   * Copy the values from one vec3 to another
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the source vector
   * @returns `out`
   */
  static copy(e, t) {
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
  }
  /**
   * Set the components of a vec3 to the given values
   * @category Static
   *
   * @param out - the receiving vector
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @returns `out`
   */
  static set(e, t, s, n) {
    return e[0] = t, e[1] = s, e[2] = n, e;
  }
  /**
   * Adds two {@link Vec3}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static add(e, t, s) {
    return e[0] = t[0] + s[0], e[1] = t[1] + s[1], e[2] = t[2] + s[2], e;
  }
  /**
   * Subtracts vector b from vector a
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, t, s) {
    return e[0] = t[0] - s[0], e[1] = t[1] - s[1], e[2] = t[2] - s[2], e;
  }
  /**
   * Alias for {@link Vec3.subtract}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static sub(e, t, s) {
    return [0, 0, 0];
  }
  /**
   * Multiplies two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static multiply(e, t, s) {
    return e[0] = t[0] * s[0], e[1] = t[1] * s[1], e[2] = t[2] * s[2], e;
  }
  /**
   * Alias for {@link Vec3.multiply}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static mul(e, t, s) {
    return [0, 0, 0];
  }
  /**
   * Divides two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static divide(e, t, s) {
    return e[0] = t[0] / s[0], e[1] = t[1] / s[1], e[2] = t[2] / s[2], e;
  }
  /**
   * Alias for {@link Vec3.divide}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static div(e, t, s) {
    return [0, 0, 0];
  }
  /**
   * Math.ceil the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to ceil
   * @returns `out`
   */
  static ceil(e, t) {
    return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e;
  }
  /**
   * Math.floor the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to floor
   * @returns `out`
   */
  static floor(e, t) {
    return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e;
  }
  /**
   * Returns the minimum of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static min(e, t, s) {
    return e[0] = Math.min(t[0], s[0]), e[1] = Math.min(t[1], s[1]), e[2] = Math.min(t[2], s[2]), e;
  }
  /**
   * Returns the maximum of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static max(e, t, s) {
    return e[0] = Math.max(t[0], s[0]), e[1] = Math.max(t[1], s[1]), e[2] = Math.max(t[2], s[2]), e;
  }
  /**
   * symmetric round the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to round
   * @returns `out`
   */
  /*
    static round(out: Vec3Like, a: Readonly<Vec3Like>): Vec3Like {
    out[0] = glMatrix.round(a[0]);
    out[1] = glMatrix.round(a[1]);
    out[2] = glMatrix.round(a[2]);
    return out;
  }*/
  /**
   * Scales a vec3 by a scalar number
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to scale
   * @param scale - amount to scale the vector by
   * @returns `out`
   */
  static scale(e, t, s) {
    return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b by before adding
   * @returns `out`
   */
  static scaleAndAdd(e, t, s, n) {
    return e[0] = t[0] + s[0] * n, e[1] = t[1] + s[1] * n, e[2] = t[2] + s[2] * n, e;
  }
  /**
   * Calculates the Euclidean distance between two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns distance between a and b
   */
  static distance(e, t) {
    const s = t[0] - e[0], n = t[1] - e[1], l = t[2] - e[2];
    return Math.sqrt(s * s + n * n + l * l);
  }
  /**
   * Alias for {@link Vec3.distance}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static dist(e, t) {
    return 0;
  }
  /**
   * Calculates the squared Euclidean distance between two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns squared distance between a and b
   */
  static squaredDistance(e, t) {
    const s = t[0] - e[0], n = t[1] - e[1], l = t[2] - e[2];
    return s * s + n * n + l * l;
  }
  /**
   * Alias for {@link Vec3.squaredDistance}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static sqrDist(e, t) {
    return 0;
  }
  /**
   * Calculates the squared length of a vec3
   * @category Static
   *
   * @param a - vector to calculate squared length of
   * @returns squared length of a
   */
  static squaredLength(e) {
    const t = e[0], s = e[1], n = e[2];
    return t * t + s * s + n * n;
  }
  /**
   * Alias for {@link Vec3.squaredLength}
   * @category Static
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static sqrLen(e, t) {
    return 0;
  }
  /**
   * Negates the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to negate
   * @returns `out`
   */
  static negate(e, t) {
    return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e;
  }
  /**
   * Returns the inverse of the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to invert
   * @returns `out`
   */
  static inverse(e, t) {
    return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e;
  }
  /**
   * Returns the absolute value of the components of a {@link Vec3}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to compute the absolute values of
   * @returns `out`
   */
  static abs(e, t) {
    return e[0] = Math.abs(t[0]), e[1] = Math.abs(t[1]), e[2] = Math.abs(t[2]), e;
  }
  /**
   * Normalize a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to normalize
   * @returns `out`
   */
  static normalize(e, t) {
    const s = t[0], n = t[1], l = t[2];
    let r = s * s + n * n + l * l;
    return r > 0 && (r = 1 / Math.sqrt(r)), e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e;
  }
  /**
   * Calculates the dot product of two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns dot product of a and b
   */
  static dot(e, t) {
    return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
  }
  /**
   * Computes the cross product of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static cross(e, t, s) {
    const n = t[0], l = t[1], r = t[2], o = s[0], a = s[1], c = s[2];
    return e[0] = l * c - r * a, e[1] = r * o - n * c, e[2] = n * a - l * o, e;
  }
  /**
   * Performs a linear interpolation between two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(e, t, s, n) {
    const l = t[0], r = t[1], o = t[2];
    return e[0] = l + n * (s[0] - l), e[1] = r + n * (s[1] - r), e[2] = o + n * (s[2] - o), e;
  }
  /**
   * Performs a spherical linear interpolation between two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static slerp(e, t, s, n) {
    const l = Math.acos(Math.min(Math.max(gn.dot(t, s), -1), 1)), r = Math.sin(l), o = Math.sin((1 - n) * l) / r, a = Math.sin(n * l) / r;
    return e[0] = o * t[0] + a * s[0], e[1] = o * t[1] + a * s[1], e[2] = o * t[2] + a * s[2], e;
  }
  /**
   * Performs a hermite interpolation with two control points
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static hermite(e, t, s, n, l, r) {
    const o = r * r, a = o * (2 * r - 3) + 1, c = o * (r - 2) + r, f = o * (r - 1), d = o * (3 - 2 * r);
    return e[0] = t[0] * a + s[0] * c + n[0] * f + l[0] * d, e[1] = t[1] * a + s[1] * c + n[1] * f + l[1] * d, e[2] = t[2] * a + s[2] * c + n[2] * f + l[2] * d, e;
  }
  /**
   * Performs a bezier interpolation with two control points
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static bezier(e, t, s, n, l, r) {
    const o = 1 - r, a = o * o, c = r * r, f = a * o, d = 3 * r * a, p = 3 * c * o, m = c * r;
    return e[0] = t[0] * f + s[0] * d + n[0] * p + l[0] * m, e[1] = t[1] * f + s[1] * d + n[1] * p + l[1] * m, e[2] = t[2] * f + s[2] * d + n[2] * p + l[2] * m, e;
  }
  /**
   * Generates a random vector with the given scale
   * @category Static
   *
   * @param out - the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
   * @returns `out`
   */
  /*
      static random(out: Vec3Like, scale) {
      scale = scale === undefined ? 1.0 : scale;
  
      let r = glMatrix.RANDOM() * 2.0 * Math.PI;
      let z = glMatrix.RANDOM() * 2.0 - 1.0;
      let zScale = Math.sqrt(1.0 - z * z) * scale;
  
      out[0] = Math.cos(r) * zScale;
      out[1] = Math.sin(r) * zScale;
      out[2] = z * scale;
      return out;
    }*/
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - matrix to transform with
   * @returns `out`
   */
  static transformMat4(e, t, s) {
    const n = t[0], l = t[1], r = t[2], o = s[3] * n + s[7] * l + s[11] * r + s[15] || 1;
    return e[0] = (s[0] * n + s[4] * l + s[8] * r + s[12]) / o, e[1] = (s[1] * n + s[5] * l + s[9] * r + s[13]) / o, e[2] = (s[2] * n + s[6] * l + s[10] * r + s[14]) / o, e;
  }
  /**
   * Transforms the vec3 with a mat3.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - the 3x3 matrix to transform with
   * @returns `out`
   */
  static transformMat3(e, t, s) {
    const n = t[0], l = t[1], r = t[2];
    return e[0] = n * s[0] + l * s[3] + r * s[6], e[1] = n * s[1] + l * s[4] + r * s[7], e[2] = n * s[2] + l * s[5] + r * s[8], e;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param q - quaternion to transform with
   * @returns `out`
   */
  static transformQuat(e, t, s) {
    const n = s[0], l = s[1], r = s[2], o = s[3] * 2, a = t[0], c = t[1], f = t[2], d = l * f - r * c, p = r * a - n * f, m = n * c - l * a, g = (l * m - r * p) * 2, h = (r * d - n * m) * 2, _ = (n * p - l * d) * 2;
    return e[0] = a + d * o + g, e[1] = c + p * o + h, e[2] = f + m * o + _, e;
  }
  /**
   * Rotate a 3D vector around the x-axis
   * @category Static
   *
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateX(e, t, s, n) {
    const l = s[1], r = s[2], o = t[1] - l, a = t[2] - r;
    return e[0] = t[0], e[1] = o * Math.cos(n) - a * Math.sin(n) + l, e[2] = o * Math.sin(n) + a * Math.cos(n) + r, e;
  }
  /**
   * Rotate a 3D vector around the y-axis
   * @category Static
   *
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateY(e, t, s, n) {
    const l = s[0], r = s[2], o = t[0] - l, a = t[2] - r;
    return e[0] = a * Math.sin(n) + o * Math.cos(n) + l, e[1] = t[1], e[2] = a * Math.cos(n) - o * Math.sin(n) + r, e;
  }
  /**
   * Rotate a 3D vector around the z-axis
   * @category Static
   *
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateZ(e, t, s, n) {
    const l = s[0], r = s[1], o = t[0] - l, a = t[1] - r;
    return e[0] = o * Math.cos(n) - a * Math.sin(n) + l, e[1] = o * Math.sin(n) + a * Math.cos(n) + r, e[2] = s[2], e;
  }
  /**
   * Get the angle between two 3D vectors
   * @category Static
   *
   * @param a - The first operand
   * @param b - The second operand
   * @returns The angle in radians
   */
  static angle(e, t) {
    const s = e[0], n = e[1], l = e[2], r = t[0], o = t[1], a = t[2], c = Math.sqrt((s * s + n * n + l * l) * (r * r + o * o + a * a)), f = c && gn.dot(e, t) / c;
    return Math.acos(Math.min(Math.max(f, -1), 1));
  }
  /**
   * Set the components of a vec3 to zero
   * @category Static
   *
   * @param out - the receiving vector
   * @returns `out`
   */
  static zero(e) {
    return e[0] = 0, e[1] = 0, e[2] = 0, e;
  }
  /**
   * Returns a string representation of a vector
   * @category Static
   *
   * @param a - vector to represent as a string
   * @returns string representation of the vector
   */
  static str(e) {
    return `Vec3(${e.join(", ")})`;
  }
  /**
   * Returns whether the vectors have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static exactEquals(e, t) {
    return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];
  }
  /**
   * Returns whether the vectors have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static equals(e, t) {
    const s = e[0], n = e[1], l = e[2], r = t[0], o = t[1], a = t[2];
    return Math.abs(s - r) <= cs * Math.max(1, Math.abs(s), Math.abs(r)) && Math.abs(n - o) <= cs * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(l - a) <= cs * Math.max(1, Math.abs(l), Math.abs(a));
  }
}, u(gn, "_Vec3"), gn);
gt.prototype.sub = gt.prototype.subtract;
gt.prototype.mul = gt.prototype.multiply;
gt.prototype.div = gt.prototype.divide;
gt.prototype.dist = gt.prototype.distance;
gt.prototype.sqrDist = gt.prototype.squaredDistance;
gt.sub = gt.subtract;
gt.mul = gt.multiply;
gt.div = gt.divide;
gt.dist = gt.distance;
gt.sqrDist = gt.squaredDistance;
gt.sqrLen = gt.squaredLength;
gt.mag = gt.magnitude;
gt.length = gt.magnitude;
gt.len = gt.magnitude;
function Rc(i, e, t) {
  return (1 - t) * i + t * e;
}
u(Rc, "lerp");
function zG(i) {
  const e = 2.5949095;
  return (i *= 2) < 1 ? 0.5 * (i * i * ((e + 1) * i - e)) : 0.5 * ((i -= 2) * i * ((e + 1) * i + e) + 2);
}
u(zG, "backInOut");
function HG(i) {
  return i * i * ((1.70158 + 1) * i - 1.70158);
}
u(HG, "backIn");
function UG(i) {
  return --i * i * ((1.70158 + 1) * i + 1.70158) + 1;
}
u(UG, "backOut");
function tp(i) {
  const e = 0.36363636363636365, t = 8 / 11, s = 9 / 10, n = 4356 / 361, l = 35442 / 1805, r = 16061 / 1805, o = i * i;
  return i < e ? 7.5625 * o : i < t ? 9.075 * o - 9.9 * i + 3.4 : i < s ? n * o - l * i + r : 10.8 * i * i - 20.52 * i + 10.72;
}
u(tp, "bounceOut");
function VG(i) {
  return i < 0.5 ? 0.5 * (1 - tp(1 - i * 2)) : 0.5 * tp(i * 2 - 1) + 0.5;
}
u(VG, "bounceInOut");
function WG(i) {
  return 1 - tp(1 - i);
}
u(WG, "bounceIn");
function KG(i) {
  return (i *= 2) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1);
}
u(KG, "circInOut");
function YG(i) {
  return 1 - Math.sqrt(1 - i * i);
}
u(YG, "circIn");
function XG(i) {
  return Math.sqrt(1 - --i * i);
}
u(XG, "circOut");
function JG(i) {
  return i < 0.5 ? 4 * i * i * i : 0.5 * Math.pow(2 * i - 2, 3) + 1;
}
u(JG, "cubicInOut");
function ZG(i) {
  return i * i * i;
}
u(ZG, "cubicIn");
function SL(i) {
  const e = i - 1;
  return e * e * e + 1;
}
u(SL, "cubicOut");
function QG(i) {
  return i < 0.5 ? 0.5 * Math.sin(13 * Math.PI / 2 * 2 * i) * Math.pow(2, 10 * (2 * i - 1)) : 0.5 * Math.sin(-13 * Math.PI / 2 * (2 * i - 1 + 1)) * Math.pow(2, -10 * (2 * i - 1)) + 1;
}
u(QG, "elasticInOut");
function xG(i) {
  return Math.sin(13 * i * Math.PI / 2) * Math.pow(2, 10 * (i - 1));
}
u(xG, "elasticIn");
function ez(i) {
  return Math.sin(-13 * (i + 1) * Math.PI / 2) * Math.pow(2, -10 * i) + 1;
}
u(ez, "elasticOut");
function tz(i) {
  return i === 0 || i === 1 ? i : i < 0.5 ? 0.5 * Math.pow(2, 20 * i - 10) : -0.5 * Math.pow(2, 10 - i * 20) + 1;
}
u(tz, "expoInOut");
function sz(i) {
  return i === 0 ? i : Math.pow(2, 10 * (i - 1));
}
u(sz, "expoIn");
function nz(i) {
  return i === 1 ? i : 1 - Math.pow(2, -10 * i);
}
u(nz, "expoOut");
function iz(i) {
  return i /= 0.5, i < 1 ? 0.5 * i * i : (i--, -0.5 * (i * (i - 2) - 1));
}
u(iz, "quadInOut");
function lz(i) {
  return i * i;
}
u(lz, "quadIn");
function rz(i) {
  return -i * (i - 2);
}
u(rz, "quadOut");
function oz(i) {
  return i < 0.5 ? 8 * Math.pow(i, 4) : -8 * Math.pow(i - 1, 4) + 1;
}
u(oz, "quartInOut");
function az(i) {
  return Math.pow(i, 4);
}
u(az, "quartIn");
function cz(i) {
  return Math.pow(i - 1, 3) * (1 - i) + 1;
}
u(cz, "quartOut");
function uz(i) {
  return (i *= 2) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2);
}
u(uz, "quintInOut");
function fz(i) {
  return i * i * i * i * i;
}
u(fz, "quintIn");
function dz(i) {
  return --i * i * i * i * i + 1;
}
u(dz, "quintOut");
function pz(i) {
  return -0.5 * (Math.cos(Math.PI * i) - 1);
}
u(pz, "sineInOut");
function mz(i) {
  const e = Math.cos(i * Math.PI * 0.5);
  return Math.abs(e) < 1e-14 ? 1 : 1 - e;
}
u(mz, "sineIn");
function hz(i) {
  return Math.sin(i * Math.PI / 2);
}
u(hz, "sineOut");
const gz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backIn: HG,
  backInOut: zG,
  backOut: UG,
  bounceIn: WG,
  bounceInOut: VG,
  bounceOut: tp,
  circIn: YG,
  circInOut: KG,
  circOut: XG,
  cubicIn: ZG,
  cubicInOut: JG,
  cubicOut: SL,
  elasticIn: xG,
  elasticInOut: QG,
  elasticOut: ez,
  expoIn: sz,
  expoInOut: tz,
  expoOut: nz,
  linear: Ec,
  quadIn: lz,
  quadInOut: iz,
  quadOut: rz,
  quartIn: az,
  quartInOut: oz,
  quartOut: cz,
  quintIn: fz,
  quintInOut: uz,
  quintOut: dz,
  sineIn: mz,
  sineInOut: pz,
  sineOut: hz
}, Symbol.toStringTag, { value: "Module" })), Z3 = gz;
function Pl(i, e) {
  if (typeof i == "function")
    return i;
  const t = Z3[i];
  return t || Z3[(e == null ? void 0 : e.default) ?? "linear"];
}
u(Pl, "getEasingFunc");
var ym;
const vm = class vm {
  /**
   * Parses a pixel string / computed styles. Ex. `100px` returns `100`.
   *
   * @param {string}   value - Value to parse.
   *
   * @returns {number|undefined} The integer component of a pixel string.
   */
  static pixels(e) {
    if (typeof e != "string")
      return;
    const t = P(this, ym).test(e), s = parseInt(e);
    return t && Number.isFinite(s) ? s : void 0;
  }
  /**
   * Returns the pixel value for `1rem` based on the root document element. You may apply an optional multiplier.
   *
   * @param {number} [multiplier=1] - Optional multiplier to apply to `rem` pixel value; default: 1.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {Document} [options.targetDocument=document] The target DOM {@link Document} if different from the main
   *        browser global `document`.
   *
   * @returns {number} The pixel value for `1rem` with or without a multiplier based on the root document element.
   */
  static remPixels(e = 1, { targetDocument: t = document } = {}) {
    return t != null && t.documentElement ? e * parseFloat(globalThis.getComputedStyle(t.documentElement).fontSize) : void 0;
  }
};
ym = new WeakMap(), u(vm, "StyleParse"), x(vm, ym, /(\d+)\s*px/);
let yt = vm;
var Rs, ua, Zu, ei, fa;
const km = class km {
  /**
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.docKey - Required key providing a link to a specific style sheet element.
   *
   * @param {string}   [opts.selector=:root] - Selector element.
   *
   * @param {Document} [opts.document] - Target document to load styles into.
   *
   * @param {number}   [opts.version] - An integer representing the version / level of styles being managed.
   */
  constructor({ docKey: e, selector: t = ":root", document: s = globalThis.document, version: n } = {}) {
    /** @type {CSSStyleRule} */
    x(this, Rs);
    /** @type {string} */
    x(this, ua);
    /** @type {string} */
    x(this, Zu);
    /** @type {HTMLStyleElement} */
    x(this, ei);
    /** @type {number} */
    x(this, fa);
    if (typeof e != "string")
      throw new TypeError("StyleManager error: 'docKey' is not a string.");
    if (Object.prototype.toString.call(s) !== "[object HTMLDocument]")
      throw new TypeError("TJSStyleManager error: 'document' is not an instance of HTMLDocument.");
    if (typeof t != "string")
      throw new TypeError("StyleManager error: 'selector' is not a string.");
    if (n !== void 0 && !Number.isSafeInteger(n) && n < 1)
      throw new TypeError("StyleManager error: 'version' is defined and is not a positive integer >= 1.");
    if (Ae(this, Zu, t), Ae(this, ua, e), Ae(this, fa, n), s[P(this, ua)] === void 0)
      Ae(this, ei, s.createElement("style")), s.head.append(P(this, ei)), P(this, ei)._STYLE_MANAGER_VERSION = n, P(this, ei).sheet.insertRule(`${t} {}`, 0), Ae(this, Rs, P(this, ei).sheet.cssRules[0]), s[e] = P(this, ei);
    else if (Ae(this, ei, s[e]), Ae(this, Rs, P(this, ei).sheet.cssRules[0]), n) {
      const l = P(this, ei)._STYLE_MANAGER_VERSION ?? 0;
      n > l && (P(this, Rs).style.cssText = "");
    }
  }
  /**
   * @returns {string} Provides an accessor to get the `cssText` for the style sheet.
   */
  get cssText() {
    return P(this, Rs).style.cssText;
  }
  /**
   * @returns {number} Returns the version of this instance.
   */
  get version() {
    return P(this, fa);
  }
  /**
   * Provides a copy constructor to duplicate an existing TJSStyleManager instance into a new document.
   *
   * Note: This is used to support the `PopOut` module.
   *
   * @param {Document} [document] Target browser document to clone into.
   *
   * @returns {TJSStyleManager} New style manager instance.
   */
  clone(e = globalThis.document) {
    const t = new km({
      selector: P(this, Zu),
      docKey: P(this, ua),
      document: e,
      version: P(this, fa)
    });
    return P(t, Rs).style.cssText = P(this, Rs).style.cssText, t;
  }
  get() {
    const e = P(this, Rs).style.cssText, t = {};
    if (e !== "") {
      for (const s of e.split(";"))
        if (s !== "") {
          const n = s.split(":");
          t[n[0].trim()] = n[1];
        }
    }
    return t;
  }
  /**
   * Gets a particular CSS variable.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @returns {string} Returns CSS variable value.
   */
  getProperty(e) {
    if (typeof e != "string")
      throw new TypeError("StyleManager error: 'key' is not a string.");
    return P(this, Rs).style.getPropertyValue(e);
  }
  /**
   * Set rules by property / value; useful for CSS variables.
   *
   * @param {{ [key: string]: string }}  rules - An object with property / value string pairs to load.
   *
   * @param {boolean}                 [overwrite=true] - When true overwrites any existing values.
   */
  setProperties(e, t = !0) {
    if (!he(e))
      throw new TypeError("StyleManager error: 'rules' is not an object.");
    if (typeof t != "boolean")
      throw new TypeError("StyleManager error: 'overwrite' is not a boolean.");
    if (t)
      for (const [s, n] of Object.entries(e))
        P(this, Rs).style.setProperty(s, n);
    else
      for (const [s, n] of Object.entries(e))
        P(this, Rs).style.getPropertyValue(s) === "" && P(this, Rs).style.setProperty(s, n);
  }
  /**
   * Sets a particular property.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @param {string}   value - CSS variable value.
   *
   * @param {boolean}  [overwrite=true] - Overwrite any existing value.
   */
  setProperty(e, t, s = !0) {
    if (typeof e != "string")
      throw new TypeError("StyleManager error: 'key' is not a string.");
    if (typeof t != "string")
      throw new TypeError("StyleManager error: 'value' is not a string.");
    if (typeof s != "boolean")
      throw new TypeError("StyleManager error: 'overwrite' is not a boolean.");
    s ? P(this, Rs).style.setProperty(e, t) : P(this, Rs).style.getPropertyValue(e) === "" && P(this, Rs).style.setProperty(e, t);
  }
  /**
   * Removes the property keys specified. If `keys` is an iterable list then all property keys in the list are removed.
   *
   * @param {Iterable<string>} keys - The property keys to remove.
   */
  removeProperties(e) {
    if (!Nt(e))
      throw new TypeError("StyleManager error: 'keys' is not an iterable list.");
    for (const t of e)
      typeof t == "string" && P(this, Rs).style.removeProperty(t);
  }
  /**
   * Removes a particular CSS variable.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @returns {string} CSS variable value when removed.
   */
  removeProperty(e) {
    if (typeof e != "string")
      throw new TypeError("StyleManager error: 'key' is not a string.");
    return P(this, Rs).style.removeProperty(e);
  }
};
Rs = new WeakMap(), ua = new WeakMap(), Zu = new WeakMap(), ei = new WeakMap(), fa = new WeakMap(), u(km, "TJSStyleManager");
let sp = km;
async function CL(i = 1) {
  if (!Number.isInteger(i) || i < 1)
    throw new TypeError("nextAnimationFrame error: 'cntr' must be a positive integer greater than 0.");
  let e;
  for (; --i >= 0; )
    e = await new Promise((t) => requestAnimationFrame(t));
  return e;
}
u(CL, "nextAnimationFrame");
function TL(i, {
  position: e,
  enabled: t = !0,
  button: s = 0,
  storeDragging: n = void 0,
  tween: l = !1,
  tweenOptions: r = { duration: 1, ease: "cubicOut" },
  hasTargetClassList: o,
  ignoreTargetClassList: a
}) {
  if (o !== void 0 && !Nt(o))
    throw new TypeError("'hasTargetClassList' is not iterable.");
  if (a !== void 0 && !Nt(a))
    throw new TypeError("'ignoreTargetClassList' is not iterable.");
  const c = { left: 0, top: 0 };
  let f = (e == null ? void 0 : e.position) ?? e, d = null, p = {}, m = !1, g = f.animate.quickTo(["top", "left"], r);
  const h = {
    dragDown: [
      "pointerdown",
      /** @type {EventListener} */
      v,
      !1
    ],
    dragMove: [
      "pointermove",
      /** @type {EventListener} */
      k,
      !1
    ],
    dragUp: [
      "pointerup",
      /** @type {EventListener} */
      S,
      !1
    ]
  };
  function _() {
    i.addEventListener(...h.dragDown), i.classList.add("draggable");
  }
  u(_, "activateListeners");
  function y() {
    typeof (n == null ? void 0 : n.set) == "function" && n.set(!1), i.removeEventListener(...h.dragDown), i.removeEventListener(...h.dragMove), i.removeEventListener(...h.dragUp), i.classList.remove("draggable");
  }
  u(y, "removeListeners"), t && _();
  function v(D) {
    if (!(D.button !== s || !D.isPrimary) && f.enabled) {
      if (a !== void 0 && ot.isFocusTarget(D.target)) {
        for (const I of a)
          if (D.target.classList.contains(I))
            return;
      }
      if (o !== void 0 && ot.isFocusTarget(D.target)) {
        let I = !1;
        for (const M of o)
          if (D.target.classList.contains(M)) {
            I = !0;
            break;
          }
        if (!I)
          return;
      }
      D.preventDefault(), m = !1, d = f.get(), p = { x: D.clientX, y: D.clientY }, i.addEventListener(...h.dragMove), i.addEventListener(...h.dragUp), i.setPointerCapture(D.pointerId);
    }
  }
  u(v, "onDragPointerDown");
  function k(D) {
    if (!(D.buttons & 1)) {
      S(D);
      return;
    }
    if (D.button !== -1 || !D.isPrimary)
      return;
    D.preventDefault(), !m && typeof (n == null ? void 0 : n.set) == "function" && (m = !0, n.set(!0));
    const I = d.left + (D.clientX - p.x), M = d.top + (D.clientY - p.y);
    l ? g(M, I) : (c.left = I, c.top = M, f.set(c));
  }
  u(k, "onDragPointerChange");
  function S(D) {
    D.preventDefault(), m = !1, typeof (n == null ? void 0 : n.set) == "function" && n.set(!1), i.removeEventListener(...h.dragMove), i.removeEventListener(...h.dragUp);
  }
  return u(S, "onDragPointerUp"), {
    // The default of enabled being true won't automatically add listeners twice.
    update: /* @__PURE__ */ u((D) => {
      var I;
      if (D.position !== void 0) {
        const M = ((I = D.position) == null ? void 0 : I.position) ?? D.position;
        M !== f && (f = M, g = f.animate.quickTo(["top", "left"], r));
      }
      if (typeof D.enabled == "boolean" && (t = D.enabled, t ? _() : y()), typeof D.button == "number" && (s = D.button), typeof D.tween == "boolean" && (l = D.tween), he(D.tweenOptions) && (r = D.tweenOptions, g.options(r)), D.hasTargetClassList !== void 0)
        if (Nt(D.hasTargetClassList))
          o = D.hasTargetClassList;
        else
          throw new TypeError("'hasTargetClassList' is not iterable.");
      if (D.ignoreTargetClassList !== void 0)
        if (Nt(D.ignoreTargetClassList))
          a = D.ignoreTargetClassList;
        else
          throw new TypeError("'ignoreTargetClassList' is not iterable.");
    }, "update"),
    destroy: /* @__PURE__ */ u(() => y(), "destroy")
  };
}
u(TL, "draggable");
var da, pa, or, En, Jr, Wi, Yl;
const Tw = class Tw {
  /**
   * @param {object} [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.tween = false] - Tween enabled.
   *
   * @param {import('../animation/types').AnimationAPI.QuickTweenOptions}   [opts.tweenOptions] - Quick tween options.
   */
  constructor({ tween: e = !1, tweenOptions: t } = {}) {
    x(this, Wi);
    /** @type {boolean} */
    x(this, da);
    /**
     * @type {import('../animation/types').AnimationAPI.QuickTweenOptions}
     */
    x(this, pa);
    /** @type {boolean} */
    x(this, or);
    /**
     * @type {import('../animation/types').AnimationAPI.QuickTweenOptions}
     */
    x(this, En, { duration: 1, ease: "cubicOut" });
    /**
     * Stores the subscribers.
     *
     * @type {import('svelte/store').Subscriber<import('./types').Action.DraggableOptionsStore>[]}
     */
    x(this, Jr, []);
    Object.defineProperty(this, "tween", {
      get: /* @__PURE__ */ u(() => P(this, or), "get"),
      set: /* @__PURE__ */ u((s) => {
        if (typeof s != "boolean")
          throw new TypeError("'tween' is not a boolean.");
        Ae(this, or, s), X(this, Wi, Yl).call(this);
      }, "set"),
      enumerable: !0
    }), Object.defineProperty(this, "tweenOptions", {
      get: /* @__PURE__ */ u(() => P(this, En), "get"),
      set: /* @__PURE__ */ u((s) => {
        if (!he(s))
          throw new TypeError("'tweenOptions' is not an object.");
        if (s.duration !== void 0) {
          if (!Number.isFinite(s.duration))
            throw new TypeError("'tweenOptions.duration' is not a finite number.");
          s.duration < 0 ? P(this, En).duration = 0 : P(this, En).duration = s.duration;
        }
        if (s.ease !== void 0) {
          if (typeof Pl(s.ease) != "function")
            throw new TypeError("'tweenOptions.ease' is not a function or Svelte easing function name.");
          P(this, En).ease = s.ease;
        }
        X(this, Wi, Yl).call(this);
      }, "set"),
      enumerable: !0
    }), e !== void 0 && (this.tween = e), t !== void 0 && (this.tweenOptions = t), Ae(this, da, P(this, or)), Ae(this, pa, Object.assign({}, P(this, En)));
  }
  /**
   * @returns {number} Get tween duration.
   */
  get tweenDuration() {
    return P(this, En).duration;
  }
  /**
   * @returns {import('#runtime/svelte/easing').EasingReference} Get easing function or easing function name.
   */
  get tweenEase() {
    return P(this, En).ease;
  }
  /**
   * @param {number}   duration - Set tween duration.
   */
  set tweenDuration(e) {
    if (!Number.isFinite(e))
      throw new TypeError("'duration' is not a finite number.");
    e < 0 && (e = 0), P(this, En).duration = e, X(this, Wi, Yl).call(this);
  }
  /**
   * @param {import('#runtime/svelte/easing').EasingReference} ease - Set easing function by name or direct function.
   */
  set tweenEase(e) {
    if (typeof Pl(e) != "function")
      throw new TypeError("'ease' is not a function or Svelte easing function name.");
    P(this, En).ease = e, X(this, Wi, Yl).call(this);
  }
  /**
   * Resets all options data to initial values.
   */
  reset() {
    Ae(this, or, P(this, da)), Ae(this, En, Object.assign({}, P(this, pa))), X(this, Wi, Yl).call(this);
  }
  /**
   * Resets tween enabled state to initial value.
   */
  resetTween() {
    Ae(this, or, P(this, da)), X(this, Wi, Yl).call(this);
  }
  /**
   * Resets tween options to initial values.
   */
  resetTweenOptions() {
    Ae(this, En, Object.assign({}, P(this, pa))), X(this, Wi, Yl).call(this);
  }
  /**
   * Store subscribe method.
   *
   * @param {import('svelte/store').Subscriber<import('./types').Action.DraggableOptionsStore>} handler - Callback
   *        function that is invoked on update / changes. Receives the DraggableOptionsStore instance.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(e) {
    return P(this, Jr).push(e), e(this), () => {
      const t = P(this, Jr).findIndex((s) => s === e);
      t >= 0 && P(this, Jr).splice(t, 1);
    };
  }
};
da = new WeakMap(), pa = new WeakMap(), or = new WeakMap(), En = new WeakMap(), Jr = new WeakMap(), Wi = new WeakSet(), Yl = /* @__PURE__ */ u(function() {
  const e = P(this, Jr);
  if (e.length > 0)
    for (let t = 0; t < e.length; t++)
      e[t](this);
}, "#updateSubscribers"), u(Tw, "DraggableOptionsStore");
let S1 = Tw;
TL.options = (i) => new S1(i);
var ar, ma, Qu, wm;
const tu = class tu {
  /**
   * @param {import('./types-local').AnimationData | null}  [animationData] - Animation data from {@link AnimationAPI}.
   *
   * @param {boolean}        [willFinish] - Promise that tracks animation finished state.
   */
  constructor(e, t = !1) {
    /** @type {import('./types-local').AnimationData} */
    x(this, ar);
    /** @type {Promise<import('#runtime/util/animate').BasicAnimationState>} */
    x(this, ma);
    /** @type {boolean} */
    x(this, Qu);
    Ae(this, ar, e), Ae(this, Qu, t), he(e) && (e.control = this);
  }
  /**
   * Provides a static void / undefined AnimationControl that is automatically resolved.
   *
   * @returns {AnimationControl} Void AnimationControl
   */
  static get voidControl() {
    return P(this, wm);
  }
  /**
   * Get a promise that resolves when animation is finished.
   *
   * @returns {Promise<import('#runtime/util/animate').BasicAnimationState>} Animation finished Promise.
   */
  get finished() {
    return P(this, ma) instanceof Promise || Ae(this, ma, P(this, Qu) ? new Promise((e) => P(this, ar).resolve = e) : Promise.resolve({ cancelled: !1 })), P(this, ma);
  }
  /**
   * Returns whether this animation is currently active / animating.
   *
   * Note: a delayed animation may not be started / active yet. Use {@link AnimationControl.isFinished} to determine
   * if an animation is actually finished.
   *
   * @returns {boolean} Animation active state.
   */
  get isActive() {
    return P(this, ar).active;
  }
  /**
   * Returns whether this animation is completely finished.
   *
   * @returns {boolean} Animation finished state.
   */
  get isFinished() {
    return P(this, ar).finished;
  }
  /**
   * Cancels the animation.
   */
  cancel() {
    const e = P(this, ar);
    e != null && (e.cancelled = !0);
  }
};
ar = new WeakMap(), ma = new WeakMap(), Qu = new WeakMap(), wm = new WeakMap(), u(tu, "AnimationControl"), /**
 * Defines a static empty / void animation control.
 *
 * @type {AnimationControl}
 */
x(tu, wm, new tu(null));
let Wo = tu;
var xu, Ns, ef, Ss, ha, ga, tf, Ci, gl;
const ct = class ct {
  /**
   * @returns {number} Time of last `rAF` callback.
   */
  static get timeFrame() {
    return P(this, ga);
  }
  /**
   * @returns {number} Time of `performance.now()` at last `rAF` callback.
   */
  static get timeNow() {
    return P(this, tf);
  }
  /**
   * Add animation data.
   *
   * @param {import('./types-local').AnimationData}   data -
   */
  static add(e) {
    if (e.cancelled) {
      X(this, Ci, gl).call(this, e);
      return;
    }
    P(ct, Ss).push(e), P(ct, ha) || (Ae(ct, ha, !0), globalThis.requestAnimationFrame(P(this, ef)));
  }
  /**
   * Manage all animation.
   *
   * @param {DOMHighResTimeStamp} timeFrame - rAF callback time.
   */
  static animate(e) {
    if (Ae(ct, ha, !1), Ae(ct, tf, globalThis.performance.now()), Ae(ct, ga, e), !(P(ct, Ns).length === 0 && P(ct, Ss).length === 0)) {
      if (P(ct, Ss).length)
        for (let t = P(ct, Ss).length; --t >= 0; ) {
          const s = P(ct, Ss)[t];
          (s.cancelled || s.el !== void 0 && !s.el.isConnected) && (P(ct, Ss).splice(t, 1), X(this, Ci, gl).call(this, s)), s.active && (s.transformOrigin && s.position.set({ transformOrigin: s.transformOrigin }), s.start = P(ct, ga), P(ct, Ss).splice(t, 1), P(ct, Ns).push(s));
        }
      for (let t = P(ct, Ns).length; --t >= 0; ) {
        const s = P(ct, Ns)[t];
        if (s.cancelled || s.el !== void 0 && !s.el.isConnected) {
          P(ct, Ns).splice(t, 1), X(this, Ci, gl).call(this, s);
          continue;
        }
        if (s.current = e - s.start, s.current >= s.duration) {
          for (let l = s.keys.length; --l >= 0; ) {
            const r = s.keys[l];
            s.newData[r] = s.destination[r];
          }
          s.position.set(s.newData, P(ct, xu)), P(ct, Ns).splice(t, 1), X(this, Ci, gl).call(this, s);
          continue;
        }
        const n = s.ease(s.current / s.duration);
        for (let l = s.keys.length; --l >= 0; ) {
          const r = s.keys[l];
          s.newData[r] = s.interpolate(s.initial[r], s.destination[r], n);
        }
        s.position.set(s.newData, P(ct, xu));
      }
      globalThis.requestAnimationFrame(P(this, ef));
    }
  }
  /**
   * Cancels all animations for given TJSPosition instance.
   *
   * @param {import('../').TJSPosition} position - TJSPosition instance.
   *
   * @param {import('./types-local').AnimationCancelFunction} [cancelFn] - An optional function to control cancelling
   *        animations.
   */
  static cancel(e, t = ct.cancelFn) {
    for (let s = P(ct, Ns).length; --s >= 0; ) {
      const n = P(ct, Ns)[s];
      n.position === e && t(n) && (P(ct, Ns).splice(s, 1), n.cancelled = !0, X(this, Ci, gl).call(this, n));
    }
    for (let s = P(ct, Ss).length; --s >= 0; ) {
      const n = P(ct, Ss)[s];
      n.position === e && t(n) && (P(ct, Ss).splice(s, 1), n.cancelled = !0, X(this, Ci, gl).call(this, n));
    }
  }
  /**
   * Cancels all active and delayed animations.
   */
  static cancelAll() {
    for (let e = P(ct, Ns).length; --e >= 0; ) {
      const t = P(ct, Ns)[e];
      t.cancelled = !0, X(this, Ci, gl).call(this, t);
    }
    for (let e = P(ct, Ss).length; --e >= 0; ) {
      const t = P(ct, Ss)[e];
      t.cancelled = !0, X(this, Ci, gl).call(this, t);
    }
    P(ct, Ns).length = 0, P(ct, Ss).length = 0;
  }
  /**
   * Gets all {@link AnimationControl} instances for a given TJSPosition instance.
   *
   * @param {import('../index.js').TJSPosition} position - TJSPosition instance.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation[]} All scheduled AnimationControl instances for the
   *          given TJSPosition instance.
   */
  static getScheduled(e) {
    const t = [];
    for (let s = P(ct, Ns).length; --s >= 0; ) {
      const n = P(ct, Ns)[s];
      n.position === e && t.push(n.control);
    }
    for (let s = P(ct, Ss).length; --s >= 0; ) {
      const n = P(ct, Ss)[s];
      n.position === e && t.push(n.control);
    }
    return t;
  }
  /**
   * Returns the status of any scheduled or pending animations for the given {@link TJSPosition} instance.
   *
   * @param {import('../index.js').TJSPosition} position - TJSPosition instance.
   *
   * @param {import('./types').AnimationAPI.ScheduleOptions} [options] - Scheduling options.
   *
   * @returns {boolean} True if scheduled / false if not.
   */
  static isScheduled(e, { active: t = !0, pending: s = !0 } = {}) {
    if (t) {
      for (let n = P(ct, Ns).length; --n >= 0; )
        if (P(ct, Ns)[n].position === e)
          return !0;
    }
    if (s) {
      for (let n = P(ct, Ss).length; --n >= 0; )
        if (P(ct, Ss)[n].position === e)
          return !0;
    }
    return !1;
  }
};
xu = new WeakMap(), Ns = new WeakMap(), ef = new WeakMap(), Ss = new WeakMap(), ha = new WeakMap(), ga = new WeakMap(), tf = new WeakMap(), Ci = new WeakSet(), gl = /* @__PURE__ */ u(function(e) {
  e.active = !1, e.finished = !0, e.transformOriginInitial && e.position.set({ transformOrigin: e.transformOriginInitial }), typeof e.cleanup == "function" && e.cleanup(e), typeof e.resolve == "function" && e.resolve({ cancelled: e.cancelled }), e.quickTo || (e.cleanup = void 0, e.control = void 0, e.destination = void 0, e.el = void 0, e.ease = void 0, e.initial = void 0, e.interpolate = void 0, e.keys = void 0, e.newData = void 0, e.position = void 0, e.resolve = void 0);
}, "#cleanupData"), x(ct, Ci), u(ct, "AnimationManager"), /**
 * Cancels all animations except `quickTo` animations.
 *
 * @type {import('./types-local').AnimationCancelFunction}
 */
qe(ct, "cancelFn", /* @__PURE__ */ u((e) => e.quickTo !== !0, "cancelFn")), /**
 * Cancels all animations.
 *
 * @type {import('./types-local').AnimationCancelFunction}
 */
qe(ct, "cancelAllFn", /* @__PURE__ */ u(() => !0, "cancelAllFn")), /**
 * Defines the options used for {@link TJSPosition.set}.
 *
 * @type {Readonly<{immediateElementUpdate: boolean}>}
 */
x(ct, xu, Object.freeze({ immediateElementUpdate: !0 })), /**
 * @type {import('./types-local').AnimationData[]}
 */
x(ct, Ns, []), /**
 * Provides the `this` context for {@link AnimationManager.animate} to be scheduled on rAF.
 *
 * @type {Function}
 */
x(ct, ef, /* @__PURE__ */ u((e) => ct.animate(e), "#animateBound")), /**
 * @type {import('./types-local').AnimationData[]}
 */
x(ct, Ss, []), /**
 * Tracks whether a requestAnimationFrame callback is pending via {@link AnimationManager.add};
 *
 * @type {boolean}
 */
x(ct, ha, !1), /**
 * Time of last `rAF` callback.
 *
 * @type {number}
 */
x(ct, ga), /**
 * Time of `performance.now()` at last `rAF` callback.
 *
 * @type {number}
 */
x(ct, tf);
let vs = ct;
const Ow = class Ow {
  /**
   * @param {object} [opts] - Options.
   *
   * @param {number | 'auto' | 'inherit' | null} [opts.height] -
   *
   * @param {number | null} [opts.left] -
   *
   * @param {number | null} [opts.maxHeight] -
   *
   * @param {number | null} [opts.maxWidth] -
   *
   * @param {number | null} [opts.minHeight] -
   *
   * @param {number | null} [opts.minWidth] -
   *
   * @param {number | null} [opts.rotateX] -
   *
   * @param {number | null} [opts.rotateY] -
   *
   * @param {number | null} [opts.rotateZ] -
   *
   * @param {number | null} [opts.scale] -
   *
   * @param {number | null} [opts.translateX] -
   *
   * @param {number | null} [opts.translateY] -
   *
   * @param {number | null} [opts.translateZ] -
   *
   * @param {number | null} [opts.top] -
   *
   * @param {import('../transform/types').TransformAPI.TransformOrigin | null} [opts.transformOrigin] -
   *
   * @param {number | 'auto' | 'inherit' | null} [opts.width] -
   *
   * @param {number | null} [opts.zIndex] -
   *
   * @param {number | null} [opts.rotation] - Alias for `rotateZ`.
   */
  constructor({
    height: e = void 0,
    left: t = void 0,
    maxHeight: s = void 0,
    maxWidth: n = void 0,
    minHeight: l = void 0,
    minWidth: r = void 0,
    rotateX: o = void 0,
    rotateY: a = void 0,
    rotateZ: c = void 0,
    scale: f = void 0,
    translateX: d = void 0,
    translateY: p = void 0,
    translateZ: m = void 0,
    top: g = void 0,
    transformOrigin: h = void 0,
    width: _ = void 0,
    zIndex: y = void 0,
    rotation: v = void 0
  } = {}) {
    this.height = e, this.left = t, this.maxHeight = s, this.maxWidth = n, this.minHeight = l, this.minWidth = r, this.rotateX = o, this.rotateY = a, this.rotateZ = c, this.scale = f, this.top = g, this.transformOrigin = h, this.translateX = d, this.translateY = p, this.translateZ = m, this.width = _, this.zIndex = y, this.rotation = v;
  }
};
u(Ow, "TJSPositionData");
let ao = Ow;
var $m, sf, Am;
const jo = class jo {
  /**
   * Convenience to copy from source to target of two TJSPositionData like objects. If a target is not supplied a new
   * {@link TJSPositionData} instance is created.
   *
   * @param {Partial<import('./types').Data.TJSPositionData>}  source - The source instance to copy from.
   *
   * @param {import('./types').Data.TJSPositionData}  [target] - Target TJSPositionData like object; if one
   *        is not provided a new instance is created.
   *
   * @returns {import('./types').Data.TJSPositionData} The target instance with all TJSPositionData fields.
   */
  static copyData(e, t = new ao()) {
    return t.height = e.height ?? null, t.left = e.left ?? null, t.maxHeight = e.maxHeight ?? null, t.maxWidth = e.maxWidth ?? null, t.minHeight = e.minHeight ?? null, t.minWidth = e.minWidth ?? null, t.rotateX = e.rotateX ?? null, t.rotateY = e.rotateY ?? null, t.rotateZ = e.rotateZ ?? null, t.scale = e.scale ?? null, t.top = e.top ?? null, t.transformOrigin = e.transformOrigin ?? null, t.translateX = e.translateX ?? null, t.translateY = e.translateY ?? null, t.translateZ = e.translateZ ?? null, t.width = e.width ?? null, t.zIndex = e.zIndex ?? null, t;
  }
  /**
   * Returns the non-aliased animation key.
   *
   * @param {import('../animation/types').AnimationAPI.AnimationKey} key - Animation key / possibly aliased key.
   *
   * @returns {import('../animation/types').AnimationAPI.AnimationKey} Actual non-aliased animation key.
   */
  static getAnimationKey(e) {
    return P(this, sf).get(e) ?? e;
  }
  /**
   * Queries an object by the given key or otherwise returns any numeric default.
   *
   * @param {object}   data - An object to query for the given animation key.
   *
   * @param {import('../animation/types').AnimationAPI.AnimationKey}   key - Animation key.
   *
   * @param {boolean}  [aliased=false] - When use non-aliased key.
   *
   * @returns {*|number|null} Data at key or numeric default.
   */
  static getDataOrDefault(e, t, s = !1) {
    return s && (t = P(this, sf).get(t) ?? t), e[t] ?? P(this, Am)[t];
  }
  /**
   * Tests if the given key is an animation key.
   *
   * @param {unknown}   key - A potential animation key.
   *
   * @returns {key is import('../animation/types').AnimationAPI.AnimationKey} Is animation key.
   */
  static isAnimationKey(e) {
    return P(this, $m).has(e);
  }
  /**
   * Sets numeric defaults for a {@link TJSPositionData} like object.
   *
   * @param {object}   data - A TJSPositionData like object.
   */
  static setNumericDefaults(e) {
    e.rotateX === null && (e.rotateX = 0), e.rotateY === null && (e.rotateY = 0), e.rotateZ === null && (e.rotateZ = 0), e.translateX === null && (e.translateX = 0), e.translateY === null && (e.translateY = 0), e.translateZ === null && (e.translateZ = 0), e.scale === null && (e.scale = 1), e.rotation === null && (e.rotation = 0);
  }
};
$m = new WeakMap(), sf = new WeakMap(), Am = new WeakMap(), u(jo, "TJSPositionDataUtil"), /**
 * Stores the TJSPositionData properties that can be animated.
 *
 * @type {ReadonlySet<string>}
 */
x(jo, $m, Object.freeze(/* @__PURE__ */ new Set([
  // Main keys
  "left",
  "top",
  "maxWidth",
  "maxHeight",
  "minWidth",
  "minHeight",
  "width",
  "height",
  "rotateX",
  "rotateY",
  "rotateZ",
  "scale",
  "translateX",
  "translateY",
  "translateZ",
  "zIndex",
  // Aliases
  "rotation"
]))), /**
 * Stores the TJSPositionData property aliases that can be animated.
 *
 * @type {Readonly<Map<string, string>>}
 */
x(jo, sf, Object.freeze(/* @__PURE__ */ new Map([["rotation", "rotateZ"]]))), /**
 * Provides numeric defaults for all parameters. This is used by {@link TJSPosition.get} to optionally
 * provide numeric defaults.
 *
 * @type {{ [key: string]: number | null }}
 */
x(jo, Am, Object.freeze({
  // Other keys
  height: 0,
  left: 0,
  maxHeight: null,
  maxWidth: null,
  minHeight: null,
  minWidth: null,
  top: 0,
  transformOrigin: null,
  width: 0,
  zIndex: null,
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  scale: 1,
  translateX: 0,
  translateY: 0,
  translateZ: 0,
  rotation: 0
}));
let Ts = jo;
var ba, Em, Sm, qn, Nc, OL, DL, IL;
const Lr = class Lr {
  /**
   * Converts any relative string values for animatable keys to actual updates performed against current data.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative}  data - position data.
   *
   * @param {import('../data/types').Data.TJSPositionData}   position - The source position data.
   *
   * @param {HTMLElement} el - Target positioned element.
   *
   * @returns {import('../data/types').Data.TJSPositionDataRelative} Converted data.
   */
  static process(e, t, s) {
    var r;
    let n, l;
    for (const o in e)
      if (Ts.isAnimationKey(o)) {
        const a = e[o];
        if (typeof a != "string" || a === "auto" || a === "inherit")
          continue;
        const c = o, f = P(this, Em).exec(a);
        let d = !1;
        if (f) {
          const p = P(this, Sm);
          p.operation = f.groups.operation, p.value = parseFloat(f.groups.value), p.unit = f.groups.unit;
          const m = Ts.getDataOrDefault(t, o, !0);
          switch (p.unit) {
            case "%": {
              if (P(this, ba).percentParent.has(o) && (!Number.isFinite(n) && ((r = s == null ? void 0 : s.parentElement) != null && r.isConnected) && (n = s.parentElement.clientHeight, l = s.parentElement.clientWidth), n === void 0 || l === void 0)) {
                console.warn(
                  `TJSPosition - ConvertStringData warning: could not determine parent constraints for key '${o}' with value '${a}'.`
                ), e[o] = void 0;
                continue;
              }
              d = X(this, qn, OL).call(this, c, m, e, t, s, p, n, l);
              break;
            }
            case "%~":
              d = X(this, qn, DL).call(this, c, m, e, t, s, p);
              break;
            case "px":
              d = P(this, ba).numPx.has(o) ? X(this, qn, Nc).call(this, c, m, e, p) : !1;
              break;
            case "rad":
            case "turn":
              d = P(this, ba).rotationRadTurn.has(o) ? X(this, qn, IL).call(this, c, m, e, t, s, p) : !1;
              break;
            default:
              d = X(this, qn, Nc).call(this, c, m, e, p);
              break;
          }
        }
        (!f || !d) && (console.warn(
          `TJSPosition - ConvertStringData warning: malformed key '${o}' with value '${a}'.`
        ), e[o] = void 0);
      }
    return e;
  }
};
ba = new WeakMap(), Em = new WeakMap(), Sm = new WeakMap(), qn = new WeakSet(), Nc = /* @__PURE__ */ u(function(e, t, s, n) {
  if (!n.operation)
    return s[e] = n.value, !0;
  switch (n.operation) {
    case "-=":
      s[e] = t - n.value;
      break;
    case "+=":
      s[e] = t + n.value;
      break;
    case "*=":
      s[e] = t * n.value;
      break;
    default:
      return !1;
  }
  return !0;
}, "#applyResultsValue"), OL = /* @__PURE__ */ u(function(e, t, s, n, l, r, o, a) {
  switch (e) {
    case "left":
    case "maxWidth":
    case "minWidth":
    case "width":
    case "translateX":
      r.value = a * (r.value / 100);
      break;
    case "top":
    case "maxHeight":
    case "minHeight":
    case "height":
    case "translateY":
      r.value = o * (r.value / 100);
      break;
    case "rotateX":
    case "rotateY":
    case "rotateZ":
    case "rotation":
      r.value = 360 * (r.value / 100);
      break;
    default:
      return !1;
  }
  return X(this, qn, Nc).call(this, e, t, s, r);
}, "#handlePercent"), DL = /* @__PURE__ */ u(function(e, t, s, n, l, r) {
  if (r.value = r.value / 100, !r.operation)
    return s[e] = t * r.value, !0;
  switch (r.operation) {
    case "-=":
      s[e] = t - t * r.value;
      break;
    case "+=":
      s[e] = t + t * r.value;
      break;
    case "*=":
      s[e] = t * (t * r.value);
      break;
    default:
      return !1;
  }
  return !0;
}, "#handleRelativePercent"), IL = /* @__PURE__ */ u(function(e, t, s, n, l, r) {
  switch (r.unit) {
    case "rad":
      r.value = GG(r.value);
      break;
    case "turn":
      r.value = 360 * r.value;
      break;
  }
  return X(this, qn, Nc).call(this, e, t, s, r);
}, "#handleRotationRadTurn"), x(Lr, qn), u(Lr, "ConvertStringData"), /**
 * Animation keys for different processing categories.
 *
 * @type {{numPx: Readonly<Set<string>>, percentParent: Readonly<Set<string>>}}
 */
x(Lr, ba, {
  // Animation keys that can be specified in `px` converted to a number.
  numPx: Object.freeze(/* @__PURE__ */ new Set([
    "left",
    "top",
    "maxWidth",
    "maxHeight",
    "minWidth",
    "minHeight",
    "width",
    "height",
    "translateX",
    "translateY",
    "translateZ"
  ])),
  // Animation keys that can be specified in percentage of parent element constraint.
  percentParent: Object.freeze(/* @__PURE__ */ new Set([
    "left",
    "top",
    "maxWidth",
    "maxHeight",
    "minWidth",
    "minHeight",
    "width",
    "height"
  ])),
  // Only rotation animation keys can be specified in `rad` / `turn` converted to a number.
  rotationRadTurn: Object.freeze(/* @__PURE__ */ new Set(["rotateX", "rotateY", "rotateZ", "rotation"]))
}), /**
 * Parses string data values. Relative values must start with leading values '+=', '-=', or '*=' followed by a
 * float / numeric value. IE `+=45` or for percentage '+=10%'. Also handles exact percent value such as `10` or
 * `10%`. Percentage values are based on the current value, parent element constraints, or constraints of the type
 * of value like rotation being bound by 360 degrees.
 *
 * TODO: In the future support more specific CSS unit types.
 *
 * @type {RegExp}
 */
x(Lr, Em, /^(?<operation>[-+*]=)?(?<value>-?\d*\.?\d+)(?<unit>%|%~|px|rad|turn)?$/), /**
 * Stores the results for match groups from `regexStringData`;
 *
 * @type {import('./types-local').StringMatch}
 */
x(Lr, Sm, Object.seal({
  operation: void 0,
  value: void 0,
  unit: void 0
}));
let br = Lr;
var Cm, Tm, Om, Dm;
const Dw = class Dw {
  constructor() {
    /**
     * Stores the calculated bounding rectangle.
     *
     * @type {DOMRect}
     */
    x(this, Cm, new DOMRect());
    /**
     * Stores the individual transformed corner points of the window in screen space clockwise from:
     * top left -> top right -> bottom right -> bottom left.
     *
     * @type {import('#runtime/math/gl-matrix').Vec3[]}
     */
    x(this, Tm, [gt.create(), gt.create(), gt.create(), gt.create()]);
    /**
     * Stores the current gl-matrix Mat4 data.
     *
     * @type {import('#runtime/math/gl-matrix').Mat4}
     */
    x(this, Om, Ye.create());
    /**
     * Stores the pre & post origin translations to apply to matrix transforms.
     *
     * @type {import('#runtime/math/gl-matrix').Mat4[]}
     */
    x(this, Dm, [Ye.create(), Ye.create()]);
    Object.seal(this);
  }
  /**
   * @returns {DOMRect} The bounding rectangle.
   */
  get boundingRect() {
    return P(this, Cm);
  }
  /**
   * @returns {import('#runtime/math/gl-matrix').Vec3[]} The transformed corner points as Vec3 in screen space.
   */
  get corners() {
    return P(this, Tm);
  }
  /**
   * @returns {string} Returns the CSS style string for the transform matrix.
   */
  get css() {
    return `matrix3d(${this.mat4.join(",")})`;
  }
  /**
   * @returns {import('#runtime/math/gl-matrix').Mat4} The transform matrix.
   */
  get mat4() {
    return P(this, Om);
  }
  /**
   * @returns {import('#runtime/math/gl-matrix').Mat4[]} The pre / post translation matrices for origin translation.
   */
  get originTranslations() {
    return P(this, Dm);
  }
};
Cm = new WeakMap(), Tm = new WeakMap(), Om = new WeakMap(), Dm = new WeakMap(), u(Dw, "TJSTransformData");
let rc = Dw;
var _t, Yt, El, pn, Im, nf, Pm, lf, ls, Mm, ti, Bt, Fm, PL;
const Ue = class Ue {
  constructor() {
    /**
     * Stores transform data.
     *
     * @type {Partial<import('../data/types').Data.TJSPositionData>}
     */
    x(this, _t, {});
    /**
     * Stores the transform keys in the order added.
     *
     * @type {string[]}
     */
    x(this, Yt, []);
  }
  /**
   * Returns a list of supported transform origins.
   *
   * @returns {Readonly<import('./types').TransformAPI.TransformOrigin[]>} The supported transform origin strings.
   */
  static get transformOrigins() {
    return P(this, nf);
  }
  /**
   * Returns whether the given string is a {@link TransformAPI.TransformOrigin}.
   *
   * @param {unknown}  origin - A potential transform origin string.
   *
   * @returns {origin is import('./types').TransformAPI.TransformOrigin}
   */
  static isTransformOrigin(e) {
    return P(this, Pm).has(e);
  }
  /**
   * @returns {boolean} Whether there are active transforms in local data.
   */
  get isActive() {
    return P(this, Yt).length > 0;
  }
  /**
   * @returns {number|undefined} Any local rotateX data.
   */
  get rotateX() {
    return P(this, _t).rotateX;
  }
  /**
   * @returns {number|undefined} Any local rotateY data.
   */
  get rotateY() {
    return P(this, _t).rotateY;
  }
  /**
   * @returns {number|undefined} Any local rotateZ data.
   */
  get rotateZ() {
    return P(this, _t).rotateZ;
  }
  /**
   * @returns {number|undefined} Any local rotateZ scale.
   */
  get scale() {
    return P(this, _t).scale;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateX() {
    return P(this, _t).translateX;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateY() {
    return P(this, _t).translateY;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateZ() {
    return P(this, _t).translateZ;
  }
  /**
   * Sets the local rotateX data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateX(e) {
    if (Number.isFinite(e))
      P(this, _t).rotateX === void 0 && P(this, Yt).push("rotateX"), P(this, _t).rotateX = e;
    else {
      if (P(this, _t).rotateX !== void 0) {
        const t = P(this, Yt).findIndex((s) => s === "rotateX");
        t >= 0 && P(this, Yt).splice(t, 1);
      }
      delete P(this, _t).rotateX;
    }
  }
  /**
   * Sets the local rotateY data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateY(e) {
    if (Number.isFinite(e))
      P(this, _t).rotateY === void 0 && P(this, Yt).push("rotateY"), P(this, _t).rotateY = e;
    else {
      if (P(this, _t).rotateY !== void 0) {
        const t = P(this, Yt).findIndex((s) => s === "rotateY");
        t >= 0 && P(this, Yt).splice(t, 1);
      }
      delete P(this, _t).rotateY;
    }
  }
  /**
   * Sets the local rotateZ data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateZ(e) {
    if (Number.isFinite(e))
      P(this, _t).rotateZ === void 0 && P(this, Yt).push("rotateZ"), P(this, _t).rotateZ = e;
    else {
      if (P(this, _t).rotateZ !== void 0) {
        const t = P(this, Yt).findIndex((s) => s === "rotateZ");
        t >= 0 && P(this, Yt).splice(t, 1);
      }
      delete P(this, _t).rotateZ;
    }
  }
  /**
   * Sets the local scale data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set scale(e) {
    if (Number.isFinite(e))
      P(this, _t).scale === void 0 && P(this, Yt).push("scale"), P(this, _t).scale = e;
    else {
      if (P(this, _t).scale !== void 0) {
        const t = P(this, Yt).findIndex((s) => s === "scale");
        t >= 0 && P(this, Yt).splice(t, 1);
      }
      delete P(this, _t).scale;
    }
  }
  /**
   * Sets the local translateX data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateX(e) {
    if (Number.isFinite(e))
      P(this, _t).translateX === void 0 && P(this, Yt).push("translateX"), P(this, _t).translateX = e;
    else {
      if (P(this, _t).translateX !== void 0) {
        const t = P(this, Yt).findIndex((s) => s === "translateX");
        t >= 0 && P(this, Yt).splice(t, 1);
      }
      delete P(this, _t).translateX;
    }
  }
  /**
   * Sets the local translateY data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateY(e) {
    if (Number.isFinite(e))
      P(this, _t).translateY === void 0 && P(this, Yt).push("translateY"), P(this, _t).translateY = e;
    else {
      if (P(this, _t).translateY !== void 0) {
        const t = P(this, Yt).findIndex((s) => s === "translateY");
        t >= 0 && P(this, Yt).splice(t, 1);
      }
      delete P(this, _t).translateY;
    }
  }
  /**
   * Sets the local translateZ data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateZ(e) {
    if (Number.isFinite(e))
      P(this, _t).translateZ === void 0 && P(this, Yt).push("translateZ"), P(this, _t).translateZ = e;
    else {
      if (P(this, _t).translateZ !== void 0) {
        const t = P(this, Yt).findIndex((s) => s === "translateZ");
        t >= 0 && P(this, Yt).splice(t, 1);
      }
      delete P(this, _t).translateZ;
    }
  }
  /**
   * Returns the matrix3d CSS transform for the given position / transform data.
   *
   * @param {object} [data] - Optional position data otherwise use local stored transform data.
   *
   * @returns {string} The CSS matrix3d string.
   */
  getCSS(e = P(this, _t)) {
    return `matrix3d(${this.getMat4(e, P(Ue, lf)).join(",")})`;
  }
  /**
   * Returns the matrix3d CSS transform for the given position / transform data.
   *
   * @param {object} [data] - Optional position data otherwise use local stored transform data.
   *
   * @returns {string} The CSS matrix3d string.
   */
  getCSSOrtho(e = P(this, _t)) {
    return `matrix3d(${this.getMat4Ortho(e, P(Ue, lf)).join(",")})`;
  }
  /**
   * Collects all data including a bounding rect, transform matrix, and points array of the given
   * {@link TJSPositionData} instance with the applied local transform data.
   *
   * @param {import('../data/types').Data.TJSPositionData} position - The position data to process.
   *
   * @param {import('./types').TransformAPI.TransformData} [output] - Optional TJSTransformData output instance.
   *
   * @param {object} [validationData] - Optional validation data for adjustment parameters.
   *
   * @returns {import('./types').TransformAPI.TransformData} The output TJSTransformData instance.
   */
  getData(e, t = new rc(), s = {}) {
    var _;
    const n = s.width ?? 0, l = s.height ?? 0, r = s.offsetTop ?? s.marginTop ?? 0, o = s.offsetLeft ?? s.marginLeft ?? 0;
    e.top += r, e.left += o;
    const a = Number.isFinite(e.width) ? e.width : n, c = Number.isFinite(e.height) ? e.height : l, f = t.corners;
    if (this.hasTransform(e)) {
      f[0][0] = f[0][1] = f[0][2] = 0, f[1][0] = a, f[1][1] = f[1][2] = 0, f[2][0] = a, f[2][1] = c, f[2][2] = 0, f[3][0] = 0, f[3][1] = c, f[3][2] = 0;
      const y = this.getMat4(e, t.mat4), v = X(_ = Ue, Fm, PL).call(_, e.transformOrigin, a, c, t.originTranslations);
      P(Ue, Im) === e.transformOrigin ? (gt.transformMat4(f[0], f[0], y), gt.transformMat4(f[1], f[1], y), gt.transformMat4(f[2], f[2], y), gt.transformMat4(f[3], f[3], y)) : (gt.transformMat4(f[0], f[0], v[0]), gt.transformMat4(f[0], f[0], y), gt.transformMat4(f[0], f[0], v[1]), gt.transformMat4(f[1], f[1], v[0]), gt.transformMat4(f[1], f[1], y), gt.transformMat4(f[1], f[1], v[1]), gt.transformMat4(f[2], f[2], v[0]), gt.transformMat4(f[2], f[2], y), gt.transformMat4(f[2], f[2], v[1]), gt.transformMat4(f[3], f[3], v[0]), gt.transformMat4(f[3], f[3], y), gt.transformMat4(f[3], f[3], v[1])), f[0][0] = e.left + f[0][0], f[0][1] = e.top + f[0][1], f[1][0] = e.left + f[1][0], f[1][1] = e.top + f[1][1], f[2][0] = e.left + f[2][0], f[2][1] = e.top + f[2][1], f[3][0] = e.left + f[3][0], f[3][1] = e.top + f[3][1];
    } else
      f[0][0] = e.left, f[0][1] = e.top, f[1][0] = e.left + a, f[1][1] = e.top, f[2][0] = e.left + a, f[2][1] = e.top + c, f[3][0] = e.left, f[3][1] = e.top + c, Ye.identity(t.mat4);
    let d = Number.MIN_SAFE_INTEGER, p = Number.MIN_SAFE_INTEGER, m = Number.MAX_SAFE_INTEGER, g = Number.MAX_SAFE_INTEGER;
    for (let y = 4; --y >= 0; )
      f[y][0] > d && (d = f[y][0]), f[y][0] < m && (m = f[y][0]), f[y][1] > p && (p = f[y][1]), f[y][1] < g && (g = f[y][1]);
    const h = t.boundingRect;
    return h.x = m, h.y = g, h.width = d - m, h.height = p - g, e.top -= r, e.left -= o, t;
  }
  /**
   * Creates a transform matrix based on local data applied in order it was added.
   *
   * If no data object is provided then the source is the local transform data. If another data object is supplied
   * then the stored local transform order is applied then all remaining transform keys are applied. This allows the
   * construction of a transform matrix in advance of setting local data and is useful in collision detection.
   *
   * @param {import('../data/types').Data.TJSPositionData}   [data] - TJSPositionData instance or local transform data.
   *
   * @param {import('#runtime/math/gl-matrix').Mat4}  [output] - The output mat4 instance.
   *
   * @returns {import('#runtime/math/gl-matrix').Mat4} Transform matrix.
   */
  getMat4(e = P(this, _t), t = Ye.create()) {
    const s = Ye.identity(t);
    let n = 0;
    const l = P(this, Yt);
    for (let r = 0; r < l.length; r++) {
      const o = l[r];
      switch (o) {
        case "rotateX":
          n |= P(Ue, pn).rotateX, Ye.multiply(s, s, Ye.fromXRotation(P(Ue, ls), Yn(e[o])));
          break;
        case "rotateY":
          n |= P(Ue, pn).rotateY, Ye.multiply(s, s, Ye.fromYRotation(P(Ue, ls), Yn(e[o])));
          break;
        case "rotateZ":
          n |= P(Ue, pn).rotateZ, Ye.multiply(s, s, Ye.fromZRotation(P(Ue, ls), Yn(e[o])));
          break;
        case "scale":
          n |= P(Ue, pn).scale, P(Ue, ti)[0] = P(Ue, ti)[1] = e[o], Ye.multiply(s, s, Ye.fromScaling(P(Ue, ls), P(Ue, ti)));
          break;
        case "translateX":
          n |= P(Ue, pn).translateX, P(Ue, Bt)[0] = e.translateX, P(Ue, Bt)[1] = 0, P(Ue, Bt)[2] = 0, Ye.multiply(s, s, Ye.fromTranslation(P(Ue, ls), P(Ue, Bt)));
          break;
        case "translateY":
          n |= P(Ue, pn).translateY, P(Ue, Bt)[0] = 0, P(Ue, Bt)[1] = e.translateY, P(Ue, Bt)[2] = 0, Ye.multiply(s, s, Ye.fromTranslation(P(Ue, ls), P(Ue, Bt)));
          break;
        case "translateZ":
          n |= P(Ue, pn).translateZ, P(Ue, Bt)[0] = 0, P(Ue, Bt)[1] = 0, P(Ue, Bt)[2] = e.translateZ, Ye.multiply(s, s, Ye.fromTranslation(P(Ue, ls), P(Ue, Bt)));
          break;
      }
    }
    if (e !== P(this, _t))
      for (let r = 0; r < P(Ue, El).length; r++) {
        const o = P(Ue, El)[r];
        if (!(e[o] === null || (n & P(Ue, pn)[o]) > 0))
          switch (o) {
            case "rotateX":
              Ye.multiply(s, s, Ye.fromXRotation(P(Ue, ls), Yn(e[o])));
              break;
            case "rotateY":
              Ye.multiply(s, s, Ye.fromYRotation(P(Ue, ls), Yn(e[o])));
              break;
            case "rotateZ":
              Ye.multiply(s, s, Ye.fromZRotation(P(Ue, ls), Yn(e[o])));
              break;
            case "scale":
              P(Ue, ti)[0] = P(Ue, ti)[1] = e[o], Ye.multiply(s, s, Ye.fromScaling(P(Ue, ls), P(Ue, ti)));
              break;
            case "translateX":
              P(Ue, Bt)[0] = e[o], P(Ue, Bt)[1] = 0, P(Ue, Bt)[2] = 0, Ye.multiply(s, s, Ye.fromTranslation(P(Ue, ls), P(Ue, Bt)));
              break;
            case "translateY":
              P(Ue, Bt)[0] = 0, P(Ue, Bt)[1] = e[o], P(Ue, Bt)[2] = 0, Ye.multiply(s, s, Ye.fromTranslation(P(Ue, ls), P(Ue, Bt)));
              break;
            case "translateZ":
              P(Ue, Bt)[0] = 0, P(Ue, Bt)[1] = 0, P(Ue, Bt)[2] = e[o], Ye.multiply(s, s, Ye.fromTranslation(P(Ue, ls), P(Ue, Bt)));
              break;
          }
      }
    return s;
  }
  /**
   * Provides an orthographic enhancement to convert left / top positional data to a translate operation.
   *
   * This transform matrix takes into account that the remaining operations are , but adds any left / top attributes from passed in data to
   * translate X / Y.
   *
   * If no data object is provided then the source is the local transform data. If another data object is supplied
   * then the stored local transform order is applied then all remaining transform keys are applied. This allows the
   * construction of a transform matrix in advance of setting local data and is useful in collision detection.
   *
   * @param {Partial<import('../data/types').Data.TJSPositionData>}   [data] - TJSPositionData instance or local
   *        transform data.
   *
   * @param {import('#runtime/math/gl-matrix').Mat4}  [output] - The output mat4 instance.
   *
   * @returns {import('#runtime/math/gl-matrix').Mat4} Transform matrix.
   */
  getMat4Ortho(e = P(this, _t), t = Ye.create()) {
    const s = Ye.identity(t);
    if (P(Ue, Bt)[0] = (e.left ?? 0) + (e.translateX ?? 0), P(Ue, Bt)[1] = (e.top ?? 0) + (e.translateY ?? 0), P(Ue, Bt)[2] = e.translateZ ?? 0, Ye.multiply(s, s, Ye.fromTranslation(P(Ue, ls), P(Ue, Bt))), e.scale !== null && (P(Ue, ti)[0] = P(Ue, ti)[1] = e.scale, Ye.multiply(s, s, Ye.fromScaling(P(Ue, ls), P(Ue, ti)))), e.rotateX === null && e.rotateY === null && e.rotateZ === null)
      return s;
    let n = 0;
    const l = P(this, Yt);
    for (let r = 0; r < l.length; r++) {
      const o = l[r];
      switch (o) {
        case "rotateX":
          n |= P(Ue, pn).rotateX, Ye.multiply(s, s, Ye.fromXRotation(P(Ue, ls), Yn(e[o])));
          break;
        case "rotateY":
          n |= P(Ue, pn).rotateY, Ye.multiply(s, s, Ye.fromYRotation(P(Ue, ls), Yn(e[o])));
          break;
        case "rotateZ":
          n |= P(Ue, pn).rotateZ, Ye.multiply(s, s, Ye.fromZRotation(P(Ue, ls), Yn(e[o])));
          break;
      }
    }
    if (e !== P(this, _t))
      for (let r = 0; r < P(Ue, El).length; r++) {
        const o = P(Ue, El)[r];
        if (!(e[o] === null || (n & P(Ue, pn)[o]) > 0))
          switch (o) {
            case "rotateX":
              Ye.multiply(s, s, Ye.fromXRotation(P(Ue, ls), Yn(e[o])));
              break;
            case "rotateY":
              Ye.multiply(s, s, Ye.fromYRotation(P(Ue, ls), Yn(e[o])));
              break;
            case "rotateZ":
              Ye.multiply(s, s, Ye.fromZRotation(P(Ue, ls), Yn(e[o])));
              break;
          }
      }
    return s;
  }
  /**
   * Tests an object if it contains transform keys and the values are finite numbers.
   *
   * @param {import('../data/types').Data.TJSPositionData} data - An object to test for transform data.
   *
   * @returns {boolean} Whether the given TJSPositionData has transforms.
   */
  hasTransform(e) {
    for (const t of P(Ue, El))
      if (Number.isFinite(e[t]))
        return !0;
    return !1;
  }
  /**
   * Resets internal data from the given object containing valid transform keys.
   *
   * @param {object}   data - An object with transform data.
   */
  reset(e) {
    for (const t in e)
      if (P(Ue, El).includes(t))
        if (Number.isFinite(e[t]))
          P(this, _t)[t] = e[t];
        else {
          const s = P(this, Yt).findIndex((n) => n === t);
          s >= 0 && P(this, Yt).splice(s, 1), delete P(this, _t)[t];
        }
  }
};
_t = new WeakMap(), Yt = new WeakMap(), El = new WeakMap(), pn = new WeakMap(), Im = new WeakMap(), nf = new WeakMap(), Pm = new WeakMap(), lf = new WeakMap(), ls = new WeakMap(), Mm = new WeakMap(), ti = new WeakMap(), Bt = new WeakMap(), Fm = new WeakSet(), PL = /* @__PURE__ */ u(function(e, t, s, n) {
  const l = P(Ue, Mm);
  switch (e) {
    case "top left":
      l[0] = l[1] = 0, Ye.fromTranslation(n[0], l), Ye.fromTranslation(n[1], l);
      break;
    case "top center":
      l[0] = -t * 0.5, l[1] = 0, Ye.fromTranslation(n[0], l), l[0] = t * 0.5, Ye.fromTranslation(n[1], l);
      break;
    case "top right":
      l[0] = -t, l[1] = 0, Ye.fromTranslation(n[0], l), l[0] = t, Ye.fromTranslation(n[1], l);
      break;
    case "center left":
      l[0] = 0, l[1] = -s * 0.5, Ye.fromTranslation(n[0], l), l[1] = s * 0.5, Ye.fromTranslation(n[1], l);
      break;
    case null:
    case "center":
      l[0] = -t * 0.5, l[1] = -s * 0.5, Ye.fromTranslation(n[0], l), l[0] = t * 0.5, l[1] = s * 0.5, Ye.fromTranslation(n[1], l);
      break;
    case "center right":
      l[0] = -t, l[1] = -s * 0.5, Ye.fromTranslation(n[0], l), l[0] = t, l[1] = s * 0.5, Ye.fromTranslation(n[1], l);
      break;
    case "bottom left":
      l[0] = 0, l[1] = -s, Ye.fromTranslation(n[0], l), l[1] = s, Ye.fromTranslation(n[1], l);
      break;
    case "bottom center":
      l[0] = -t * 0.5, l[1] = -s, Ye.fromTranslation(n[0], l), l[0] = t * 0.5, l[1] = s, Ye.fromTranslation(n[1], l);
      break;
    case "bottom right":
      l[0] = -t, l[1] = -s, Ye.fromTranslation(n[0], l), l[0] = t, l[1] = s, Ye.fromTranslation(n[1], l);
      break;
    default:
      Ye.identity(n[0]), Ye.identity(n[1]);
      break;
  }
  return n;
}, "#getOriginTranslation"), x(Ue, Fm), u(Ue, "TJSTransforms"), /**
 * Defines the keys of TJSPositionData that are transform keys.
 *
 * @type {string[]}
 */
x(Ue, El, Object.freeze([
  "rotateX",
  "rotateY",
  "rotateZ",
  "scale",
  "translateX",
  "translateY",
  "translateZ"
])), /**
 * Defines bitwise keys for transforms used in {@link TJSTransforms.getMat4}.
 *
 * @type {object}
 */
x(Ue, pn, Object.freeze({
  rotateX: 1,
  rotateY: 2,
  rotateZ: 4,
  scale: 8,
  translateX: 16,
  translateY: 32,
  translateZ: 64
})), /**
 * Defines the default transform origin.
 *
 * @type {Readonly<import('./types').TransformAPI.TransformOrigin>}
 */
x(Ue, Im, "top left"), /**
 * Defines the valid transform origins.
 *
 * @type {Readonly<import('./types').TransformAPI.TransformOrigin[]>}
 */
x(Ue, nf, Object.freeze([
  "top left",
  "top center",
  "top right",
  "center left",
  "center",
  "center right",
  "bottom left",
  "bottom center",
  "bottom right"
])), /**
 * Defines a valid Set of transform origins.
 *
 * @type {ReadonlySet<import('./types').TransformAPI.TransformOrigin>}
 */
x(Ue, Pm, Object.freeze(new Set(P(Ue, nf)))), // Temporary variables --------------------------------------------------------------------------------------------
/** @type {import('#runtime/math/gl-matrix').Mat4} */
x(Ue, lf, Ye.create()), /** @type {import('#runtime/math/gl-matrix').Mat4} */
x(Ue, ls, Ye.create()), /** @type {import('#runtime/math/gl-matrix').Vec3} */
x(Ue, Mm, gt.create()), /** @type {number[]} */
x(Ue, ti, [1, 1, 1]), /** @type {number[]} */
x(Ue, Bt, [0, 0, 0]);
let el = Ue;
var Cs, _a, ol, Cd, Td;
const Lo = class Lo {
  /**
   * Provides a tween from given position data to the current position.
   *
   * @param {import('../').TJSPosition} position - The target position instance.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} fromData - The starting position.
   *
   * @param {import('./types').AnimationAPI.TweenOptions} options - Tween options.
   *
   * @param {import('./types-local').AnimationCleanupFunction} [cleanup] - Custom animation cleanup function.
   *
   * @returns {import('./AnimationControl').AnimationControl | null} An AnimationControl instance or null if none
   *          created.
   */
  static from(e, t, s = {}, n) {
    var _, y;
    if (!he(t))
      throw new TypeError("AnimationAPI.from error: 'fromData' is not an object.");
    const l = e.parent;
    if (l !== void 0 && typeof ((_ = l == null ? void 0 : l.options) == null ? void 0 : _.positionable) == "boolean" && !((y = l == null ? void 0 : l.options) != null && y.positionable))
      return null;
    let { delay: r = 0, duration: o = 1, ease: a = "cubicOut", strategy: c, transformOrigin: f } = s;
    if (c !== void 0 && X(this, ol, Td).call(this, e, c) === null)
      return null;
    const d = ot.isFocusTarget(l) ? l : l == null ? void 0 : l.elementTarget, p = ot.isFocusTarget(d) && d.isConnected ? d : void 0;
    if (!Number.isFinite(r) || r < 0)
      throw new TypeError("AnimationScheduler.from error: 'delay' is not a positive number.");
    if (!Number.isFinite(o) || o < 0)
      throw new TypeError("AnimationScheduler.from error: 'duration' is not a positive number.");
    if (a = Pl(a, P(this, _a)), typeof a != "function")
      throw new TypeError(
        "AnimationScheduler.from error: 'ease' is not a function or valid Svelte easing function name."
      );
    const m = {}, g = {};
    e.get(P(this, Cs)), f = el.isTransformOrigin(f) ? f : void 0;
    const h = f !== void 0 ? P(this, Cs).transformOrigin : void 0;
    for (const v in t) {
      const k = Ts.getAnimationKey(v);
      P(this, Cs)[k] !== void 0 && t[v] !== P(this, Cs)[k] && (m[v] = t[v], g[v] = P(this, Cs)[k]);
    }
    return br.process(m, P(this, Cs), p), X(this, ol, Cd).call(this, e, m, g, o, p, r, a, Rc, f, h, n);
  }
  /**
   * Provides a tween from given position data to the given position.
   *
   * @param {import('../').TJSPosition} position - The target position instance.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} fromData - The starting position.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} toData - The ending position.
   *
   * @param {import('./types').AnimationAPI.TweenOptions} options - Tween options.
   *
   * @param {import('./types-local').AnimationCleanupFunction} [cleanup] - Custom animation cleanup function.
   *
   * @returns {import('./AnimationControl').AnimationControl | null} An AnimationControl instance or null if none
   *          created.
   */
  static fromTo(e, t, s, n = {}, l) {
    var y, v;
    if (!he(t))
      throw new TypeError("AnimationScheduler.fromTo error: 'fromData' is not an object.");
    if (!he(s))
      throw new TypeError("AnimationScheduler.fromTo error: 'toData' is not an object.");
    const r = e.parent;
    if (r !== void 0 && typeof ((y = r == null ? void 0 : r.options) == null ? void 0 : y.positionable) == "boolean" && !((v = r == null ? void 0 : r.options) != null && v.positionable))
      return null;
    let { delay: o = 0, duration: a = 1, ease: c = "cubicOut", strategy: f, transformOrigin: d } = n;
    if (f !== void 0 && X(this, ol, Td).call(this, e, f) === null)
      return null;
    const p = ot.isFocusTarget(r) ? r : r == null ? void 0 : r.elementTarget, m = ot.isFocusTarget(p) && p.isConnected ? p : void 0;
    if (!Number.isFinite(o) || o < 0)
      throw new TypeError("AnimationScheduler.fromTo error: 'delay' is not a positive number.");
    if (!Number.isFinite(a) || a < 0)
      throw new TypeError("AnimationScheduler.fromTo error: 'duration' is not a positive number.");
    if (c = Pl(c, P(this, _a)), typeof c != "function")
      throw new TypeError(
        "AnimationScheduler.fromTo error: 'ease' is not a function or valid Svelte easing function name."
      );
    const g = {}, h = {};
    e.get(P(this, Cs)), d = el.isTransformOrigin(d) ? d : void 0;
    const _ = d !== void 0 ? P(this, Cs).transformOrigin : void 0;
    for (const k in t) {
      if (s[k] === void 0) {
        console.warn(`AnimationScheduler.fromTo warning: skipping key ('${k}') from 'fromData' as it is missing in 'toData'.`);
        continue;
      }
      const S = Ts.getAnimationKey(k);
      P(this, Cs)[S] !== void 0 && (g[k] = t[k], h[k] = s[k]);
    }
    return br.process(g, P(this, Cs), m), br.process(h, P(this, Cs), m), X(this, ol, Cd).call(this, e, g, h, a, m, o, c, Rc, d, _, l);
  }
  /**
   * Provides a tween to given position data from the current position.
   *
   * @param {import('../').TJSPosition} position - The target position instance.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} toData - The destination position.
   *
   * @param {import('./types').AnimationAPI.TweenOptions} options - Tween options.
   *
   * @param {import('./types-local').AnimationCleanupFunction} [cleanup] - Custom animation cleanup function.
   *
   * @returns {import('./AnimationControl').AnimationControl | null} An AnimationControl instance or null if none
   *          created.
   */
  static to(e, t, s = {}, n) {
    var _, y;
    if (!he(t))
      throw new TypeError("AnimationScheduler.to error: 'toData' is not an object.");
    const l = e.parent;
    if (l !== void 0 && typeof ((_ = l == null ? void 0 : l.options) == null ? void 0 : _.positionable) == "boolean" && !((y = l == null ? void 0 : l.options) != null && y.positionable))
      return null;
    let { delay: r = 0, duration: o = 1, ease: a = "cubicOut", strategy: c, transformOrigin: f } = s;
    if (c !== void 0 && X(this, ol, Td).call(this, e, c) === null)
      return null;
    const d = ot.isFocusTarget(l) ? l : l == null ? void 0 : l.elementTarget, p = ot.isFocusTarget(d) && d.isConnected ? d : void 0;
    if (!Number.isFinite(r) || r < 0)
      throw new TypeError("AnimationScheduler.to error: 'delay' is not a positive number.");
    if (!Number.isFinite(o) || o < 0)
      throw new TypeError("AnimationScheduler.to error: 'duration' is not a positive number.");
    if (a = Pl(a, P(this, _a)), typeof a != "function")
      throw new TypeError(
        "AnimationScheduler.to error: 'ease' is not a function or valid Svelte easing function name."
      );
    const m = {}, g = {};
    e.get(P(this, Cs)), f = el.isTransformOrigin(f) ? f : void 0;
    const h = f !== void 0 ? P(this, Cs).transformOrigin : void 0;
    for (const v in t) {
      const k = Ts.getAnimationKey(v);
      P(this, Cs)[k] !== void 0 && t[v] !== P(this, Cs)[k] && (g[v] = t[v], m[v] = P(this, Cs)[k]);
    }
    return br.process(g, P(this, Cs), p), X(this, ol, Cd).call(this, e, m, g, o, p, r, a, Rc, f, h, n);
  }
};
Cs = new WeakMap(), _a = new WeakMap(), ol = new WeakSet(), Cd = /* @__PURE__ */ u(function(e, t, s, n, l, r, o, a = Rc, c, f, d) {
  Ts.setNumericDefaults(t), Ts.setNumericDefaults(s);
  for (const h in t)
    Number.isFinite(t[h]) || delete t[h];
  const p = Object.keys(t), m = Object.assign({}, t);
  if (p.length === 0)
    return null;
  const g = {
    active: !0,
    cleanup: d,
    cancelled: !1,
    control: void 0,
    current: 0,
    destination: s,
    duration: n * 1e3,
    // Internally the AnimationManager works in ms.
    ease: o,
    el: l,
    finished: !1,
    initial: t,
    interpolate: a,
    keys: p,
    newData: m,
    position: e,
    resolve: void 0,
    start: void 0,
    transformOrigin: c,
    transformOriginInitial: f,
    quickTo: !1
  };
  return r > 0 && (g.active = !1, setTimeout(() => g.active = !0, r * 1e3)), vs.add(g), new Wo(g, !0);
}, "#addAnimation"), Td = /* @__PURE__ */ u(function(e, t) {
  switch (t) {
    case "cancel":
      vs.isScheduled(e) && vs.cancel(e);
      break;
    case "cancelAll":
      vs.isScheduled(e) && vs.cancel(e, vs.cancelAllFn);
      break;
    case "exclusive":
      if (vs.isScheduled(e))
        return null;
      break;
    default:
      return console.warn("AnimationScheduler error: 'strategy' is not 'cancel', 'cancelAll', or 'exclusive'."), null;
  }
}, "#handleStrategy"), x(Lo, ol), u(Lo, "AnimationScheduler"), /**
 * Used to copy data from a TJSPosition instance.
 *
 * @type {import('../data/types').Data.TJSPositionData}
 */
x(Lo, Cs, {}), x(Lo, _a, Object.freeze({ default: !1 }));
let Ii = Lo;
var rf, of, si;
const Bo = class Bo {
  /**
   * @param {import('../').TJSPosition}       position -
   *
   * @param {import('../data/types').Data.TJSPositionData}   data -
   */
  constructor(e, t) {
    /** @type {import('../data/types').Data.TJSPositionData} */
    x(this, of);
    /** @type {import('../').TJSPosition} */
    x(this, si);
    Ae(this, si, e), Ae(this, of, t), Object.seal(this);
  }
  /**
   * Returns if there are scheduled animations whether active or pending for this TJSPosition instance.
   *
   * @returns {boolean} Are there scheduled animations.
   */
  get isScheduled() {
    return vs.isScheduled(P(this, si));
  }
  /**
   * Cancels all animation instances for this TJSPosition instance.
   */
  cancel() {
    vs.cancel(P(this, si), vs.cancelAllFn);
  }
  /**
   * Returns all currently scheduled AnimationControl instances for this TJSPosition instance.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation[]} All currently scheduled animation controls for
   *          this TJSPosition instance.
   */
  getScheduled() {
    return vs.getScheduled(P(this, si));
  }
  /**
   * Provides a tween from given position data to the current position.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} fromData - The starting position.
   *
   * @param {import('./types').AnimationAPI.TweenOptions} [options] - Optional tween parameters.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation}  A control object that can cancel animation and
   *          provides a `finished` Promise.
   */
  from(e, t) {
    const s = Ii.from(P(this, si), e, t);
    return s || Wo.voidControl;
  }
  /**
   * Provides a tween from given position data to the given position.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} fromData - The starting position.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} toData - The ending position.
   *
   * @param {import('./types').AnimationAPI.TweenOptions} [options] - Optional tween parameters.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation}  A control object that can cancel animation and
   *          provides a `finished` Promise.
   */
  fromTo(e, t, s) {
    const n = Ii.fromTo(P(this, si), e, t, s);
    return n || Wo.voidControl;
  }
  /**
   * Provides a tween to given position data from the current position.
   *
   * @param {import('../data/types').Data.TJSPositionDataRelative} toData - The destination position.
   *
   * @param {import('./types').AnimationAPI.TweenOptions} [options] - Optional tween parameters.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation}  A control object that can cancel animation and
   *          provides a `finished` Promise.
   */
  to(e, t) {
    const s = Ii.to(P(this, si), e, t);
    return s || Wo.voidControl;
  }
  /**
   * Returns a function that provides an optimized way to constantly update a to-tween.
   *
   * @param {Iterable<import('./types').AnimationAPI.AnimationKey>}  keys - The keys for quickTo.
   *
   * @param {import('./types').AnimationAPI.QuickTweenOptions} [options] - Optional quick tween parameters.
   *
   * @returns {import('./types').AnimationAPI.QuickToCallback} quick-to tween function.
   */
  quickTo(e, t = {}) {
    var m, g;
    if (!Nt(e))
      throw new TypeError("AnimationAPI.quickTo error: 'keys' is not an iterable list.");
    const s = P(this, si).parent;
    if (s !== void 0 && typeof ((m = s == null ? void 0 : s.options) == null ? void 0 : m.positionable) == "boolean" && !((g = s == null ? void 0 : s.options) != null && g.positionable))
      throw new Error("AnimationAPI.quickTo error: 'parent' is not positionable.");
    let { duration: n = 1, ease: l = "cubicOut" } = t;
    if (!Number.isFinite(n) || n < 0)
      throw new TypeError("AnimationAPI.quickTo error: 'duration' is not a positive number.");
    if (l = Pl(l, P(Bo, rf)), typeof l != "function")
      throw new TypeError(
        "AnimationAPI.quickTo error: 'ease' is not a function or valid Svelte easing function name."
      );
    const r = {}, o = {}, a = P(this, of);
    for (const h of e) {
      if (typeof h != "string")
        throw new TypeError(`AnimationAPI.quickTo error: key ('${h}') is not a string.`);
      if (!Ts.isAnimationKey(h))
        throw new Error(`AnimationAPI.quickTo error: key ('${h}') is not animatable.`);
      const _ = Ts.getDataOrDefault(a, h, !0);
      _ !== null && (o[h] = _, r[h] = _);
    }
    const c = [...e];
    Object.freeze(c);
    const f = Object.assign({}, r), d = {
      active: !0,
      cancelled: !1,
      control: void 0,
      current: 0,
      destination: o,
      duration: n * 1e3,
      // Internally the AnimationManager works in ms.
      ease: l,
      el: void 0,
      finished: !0,
      // Note: start in finished state to add to AnimationManager on first callback.
      initial: r,
      interpolate: Rc,
      keys: e,
      newData: f,
      position: P(this, si),
      resolve: void 0,
      start: void 0,
      quickTo: !0
    }, p = (
      /** @type {import('./types').AnimationAPI.QuickToCallback} */
      /* @__PURE__ */ u((...h) => {
        const _ = h.length;
        if (_ === 0)
          return;
        for (let v = c.length; --v >= 0; ) {
          const k = c[v], S = Ts.getAnimationKey(k);
          a[S] !== void 0 && (r[k] = a[S]);
        }
        if (he(h[0])) {
          const v = h[0];
          for (const k in v)
            o[k] !== void 0 && (o[k] = v[k]);
        } else
          for (let v = 0; v < _ && v < c.length; v++) {
            const k = c[v];
            o[k] !== void 0 && (o[k] = h[v]);
          }
        Ts.setNumericDefaults(r), Ts.setNumericDefaults(o);
        const y = ot.isFocusTarget(s) ? s : s == null ? void 0 : s.elementTarget;
        if (d.el = ot.isFocusTarget(y) && y.isConnected ? y : void 0, br.process(o, a, d.el), d.finished)
          d.cancelled = !1, d.finished = !1, d.active = !0, d.current = 0, vs.add(d);
        else {
          const v = globalThis.performance.now();
          d.cancelled = !1, d.current = 0, d.start = v + (vs.timeNow - v);
        }
      }, "quickToCB")
    );
    return p.keys = c, p.options = (h) => {
      let { duration: _, ease: y } = h;
      if (_ !== void 0 && (!Number.isFinite(_) || _ < 0))
        throw new TypeError("AnimationAPI.quickTo.options error: 'duration' is not a positive number.");
      if (y = Pl(y, P(Bo, rf)), y !== void 0 && typeof y != "function")
        throw new TypeError(
          "AnimationAPI.quickTo.options error: 'ease' is not a function or valid Svelte easing function name."
        );
      return _ >= 0 && (d.duration = _ * 1e3), y && (d.ease = y), p;
    }, p;
  }
};
rf = new WeakMap(), of = new WeakMap(), si = new WeakMap(), u(Bo, "AnimationAPI"), x(Bo, rf, Object.freeze({ default: !1 }));
let pu = Bo;
var cr, Zr, Rm;
const su = class su {
  /**
   * @param {Set<import('./AnimationControl').AnimationControl>} animationControls - An array of AnimationControl
   *        instances.
   */
  constructor(e) {
    /** @type {Set<import('./AnimationControl').AnimationControl>} */
    x(this, cr);
    /** @type {Promise<import('#runtime/util/animate').BasicAnimationState>} */
    x(this, Zr);
    Ae(this, cr, e);
  }
  /**
   * Provides a static void / undefined AnimationGroupControl that is automatically resolved.
   *
   * @returns {AnimationGroupControl} Void AnimationGroupControl
   */
  static get voidControl() {
    return P(this, Rm);
  }
  /**
   * Get a promise that resolves when all animations are finished.
   *
   * @returns {Promise<import('#runtime/util/animate').BasicAnimationState>} Finished Promise for all animations.
   */
  get finished() {
    const e = P(this, cr);
    if (!(P(this, Zr) instanceof Promise))
      if (e == null || e.size === 0)
        Ae(
          this,
          Zr,
          /** @type {Promise<import('#runtime/util/animate').BasicAnimationState>} */
          Promise.resolve({ cancelled: !1 })
        );
      else {
        const t = [];
        for (const s of e)
          t.push(s.finished);
        Ae(this, Zr, Promise.allSettled(t).then((s) => ({ cancelled: s.some((l) => l.status === "rejected" || l.status === "fulfilled" && l.value.cancelled) })));
      }
    return P(this, Zr);
  }
  /**
   * Returns whether there are active animation instances for this group.
   *
   * Note: a delayed animation may not be started / active yet. Use {@link AnimationGroupControl.isFinished} to
   * determine if all animations in the group are finished.
   *
   * @returns {boolean} Are there active animation instances.
   */
  get isActive() {
    const e = P(this, cr);
    if (e == null || e.size === 0)
      return !1;
    for (const t of e)
      if (t.isActive)
        return !0;
    return !1;
  }
  /**
   * Returns whether all animations in the group are finished.
   *
   * @returns {boolean} Are all animation instances finished.
   */
  get isFinished() {
    const e = P(this, cr);
    if (e == null || e.size === 0)
      return !0;
    for (const t of e)
      if (!t.isFinished)
        return !1;
    return !0;
  }
  /**
   * Cancels the all animations.
   */
  cancel() {
    const e = P(this, cr);
    if (!(e == null || e.size === 0))
      for (const t of e)
        t.cancel();
  }
};
cr = new WeakMap(), Zr = new WeakMap(), Rm = new WeakMap(), u(su, "AnimationGroupControl"), /**
 * Defines a static empty / void animation control.
 *
 * @type {AnimationGroupControl}
 */
x(su, Rm, new su(null));
let un = su;
var js, Zs;
const Nm = class Nm {
  /**
   * Cancels any animation for given PositionGroup data.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - The position group to cancel.
   */
  static cancel(e) {
    if (Nt(e)) {
      let t = -1;
      for (const s of e) {
        t++;
        const n = X(this, js, Zs).call(this, s);
        if (!n) {
          console.warn(`AnimationGroupAPI.cancel warning: No TJSPosition instance found at index: ${t}.`);
          continue;
        }
        vs.cancel(n);
      }
    } else {
      const t = X(this, js, Zs).call(this, e);
      if (!t) {
        console.warn("AnimationGroupAPI.cancel warning: No TJSPosition instance found.");
        return;
      }
      vs.cancel(t);
    }
  }
  /**
   * Cancels all TJSPosition animation.
   */
  static cancelAll() {
    vs.cancelAll();
  }
  /**
   * Gets all animation controls for the given position group data.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - A position group.
   *
   * @returns {{
   *    position: import('../').TJSPosition,
   *    entry: import('../types').TJSPositionTypes.Positionable | undefined,
   *    controls: import('#runtime/util/animate').BasicAnimation[]
   * }[]} Results array.
   */
  static getScheduled(e) {
    const t = [];
    if (Nt(e)) {
      let s = -1;
      for (const n of e) {
        s++;
        const l = X(this, js, Zs).call(this, n);
        if (!l) {
          console.warn(`AnimationGroupAPI.getScheduled warning: No TJSPosition instance found at index: ${s}.`);
          continue;
        }
        const r = vs.getScheduled(l);
        t.push({ position: l, entry: l !== n ? n : void 0, controls: r });
      }
    } else {
      const s = X(this, js, Zs).call(this, e);
      if (!s)
        return console.warn("AnimationGroupAPI.getScheduled warning: No TJSPosition instance found."), t;
      const n = vs.getScheduled(s);
      t.push({
        position: s,
        entry: s !== e ? e : void 0,
        controls: n
      });
    }
    return t;
  }
  /**
   * Provides a type guard to test in the given key is an {@link AnimationAPI.AnimationKey}.
   *
   * @param {unknown}  key - A key value to test.
   *
   * @returns {key is import('./types').AnimationAPI.AnimationKey} Whether the given key is an animation key.
   */
  static isAnimationKey(e) {
    return Ts.isAnimationKey(e);
  }
  /**
   * Returns the status _for the entire position group_ specified if all position instances of the group are scheduled.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - A position group.
   *
   * @param {import('./types').AnimationAPI.ScheduleOptions} [options] - Options.
   *
   * @returns {boolean} True if all are scheduled / false if just one position instance in the group is not scheduled.
   */
  static isScheduled(e, t) {
    if (Nt(e)) {
      let s = -1;
      for (const n of e) {
        s++;
        const l = X(this, js, Zs).call(this, n);
        if (!l) {
          console.warn(`AnimationGroupAPI.isScheduled warning: No TJSPosition instance found at index: ${s}.`);
          continue;
        }
        if (!vs.isScheduled(l, t))
          return !1;
      }
    } else {
      const s = X(this, js, Zs).call(this, e);
      if (!s)
        return console.warn("AnimationGroupAPI.isScheduled warning: No TJSPosition instance found."), !1;
      if (!vs.isScheduled(s, t))
        return !1;
    }
    return !0;
  }
  /**
   * Provides the `from` animation tween for one or more positionable instances as a group.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - A position group.
   *
   * @param {(
   *    import('../data/types').Data.TJSPositionDataRelative |
   *    import('./types').AnimationAPI.GroupDataCallback
   * )} fromData - A position data object assigned to all positionable instances or a callback function invoked for
   *        unique data for each instance.
   *
   * @param {(
   *    import('./types').AnimationAPI.TweenOptions |
   *    import('./types').AnimationAPI.GroupTweenOptionsCallback
   * )} [options] - Tween options assigned to all positionable instances or a callback function invoked for unique
   *        options for each instance.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation} Basic animation control.
   */
  static from(e, t, s) {
    if (!he(t) && typeof t != "function")
      throw new TypeError("AnimationGroupAPI.from error: 'fromData' is not an object or function.");
    if (s !== void 0 && !he(s) && typeof s != "function")
      throw new TypeError("AnimationGroupAPI.from error: 'options' is not an object or function.");
    const n = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ u((m) => n.delete(m.control), "cleanupFn");
    let r = -1, o;
    const a = typeof t == "function", c = typeof s == "function", f = a || c;
    f && (o = { index: r, position: void 0, entry: void 0 });
    let d = t, p = s;
    if (Nt(e))
      for (const m of e) {
        r++;
        const g = X(this, js, Zs).call(this, m);
        if (!g) {
          console.warn(`AnimationGroupAPI.from warning: No TJSPosition instance found at index: ${r}.`);
          continue;
        }
        if (f && (o.index = r, o.position = g, o.entry = g !== m ? m : void 0), a) {
          if (d = t(o), d == null)
            continue;
          if (!he(d))
            throw new TypeError(`AnimationGroupAPI.from error: 'fromData' callback function iteration(${r}) failed to return an object.`);
        }
        if (c) {
          if (p = s(o), p == null)
            continue;
          if (!he(p))
            throw new TypeError(`AnimationGroupAPI.from error: 'options' callback function iteration(${r}) failed to return an object.`);
        }
        const h = Ii.from(g, d, p, l);
        h && n.add(h);
      }
    else {
      const m = X(this, js, Zs).call(this, e);
      if (!m)
        return console.warn("AnimationGroupAPI.from warning: No TJSPosition instance found."), un.voidControl;
      if (f && (o.index = 0, o.position = m, o.entry = m !== e ? e : void 0), a) {
        if (d = t(o), d == null)
          return un.voidControl;
        if (!he(d))
          throw new TypeError(
            "AnimationGroupAPI.from error: 'fromData' callback function failed to return an object."
          );
      }
      if (c) {
        if (p = s(o), p == null)
          return un.voidControl;
        if (!he(p))
          throw new TypeError(
            "AnimationGroupAPI.from error: 'options' callback function failed to return an object."
          );
      }
      const g = Ii.from(m, d, p, l);
      g && n.add(g);
    }
    return new un(n);
  }
  /**
   * Provides the `fromTo` animation tween for one or more positionable instances as a group.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - A position group.
   *
   * @param {(
   *    import('../data/types').Data.TJSPositionDataRelative |
   *    import('./types').AnimationAPI.GroupDataCallback
   * )} fromData - A position data object assigned to all positionable instances or a callback function invoked for
   *        unique data for each instance.
   *
   * @param {(
   *    import('../data/types').Data.TJSPositionDataRelative |
   *    import('./types').AnimationAPI.GroupDataCallback
   * )} toData - A position data object assigned to all positionable instances or a callback function invoked for
   *        unique data for each instance.
   *
   * @param {(
   *    import('./types').AnimationAPI.TweenOptions |
   *    import('./types').AnimationAPI.GroupTweenOptionsCallback
   * )} [options] - Tween options assigned to all positionable instances or a callback function invoked for unique
   *        options for each instance.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation} Basic animation control.
   */
  static fromTo(e, t, s, n) {
    if (!he(t) && typeof t != "function")
      throw new TypeError("AnimationGroupAPI.fromTo error: 'fromData' is not an object or function.");
    if (!he(s) && typeof s != "function")
      throw new TypeError("AnimationGroupAPI.fromTo error: 'toData' is not an object or function.");
    if (n !== void 0 && !he(n) && typeof n != "function")
      throw new TypeError("AnimationGroupAPI.fromTo error: 'options' is not an object or function.");
    const l = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ u((_) => l.delete(_.control), "cleanupFn");
    let o = -1, a;
    const c = typeof t == "function", f = typeof s == "function", d = typeof n == "function", p = c || f || d;
    p && (a = { index: o, position: void 0, entry: void 0 });
    let m = t, g = s, h = n;
    if (Nt(e))
      for (const _ of e) {
        o++;
        const y = X(this, js, Zs).call(this, _);
        if (!y) {
          console.warn(`AnimationGroupAPI.fromTo warning: No TJSPosition instance found at index: ${o}.`);
          continue;
        }
        if (p && (a.index = o, a.position = y, a.entry = y !== _ ? _ : void 0), c) {
          if (m = t(a), m == null)
            continue;
          if (!he(m))
            throw new TypeError(`AnimationGroupAPI.fromTo error: 'fromData' callback function iteration(${o}) failed to return an object.`);
        }
        if (f) {
          if (g = s(a), g == null)
            continue;
          if (!he(g))
            throw new TypeError(`AnimationGroupAPI.fromTo error: 'toData' callback function iteration(${o}) failed to return an object.`);
        }
        if (d) {
          if (h = n(a), h == null)
            continue;
          if (!he(h))
            throw new TypeError(`AnimationGroupAPI.fromTo error: 'options' callback function iteration(${o}) failed to return an object.`);
        }
        const v = Ii.fromTo(
          y,
          m,
          g,
          h,
          r
        );
        v && l.add(v);
      }
    else {
      const _ = X(this, js, Zs).call(this, e);
      if (!_)
        return console.warn("AnimationGroupAPI.fromTo warning: No TJSPosition instance found."), un.voidControl;
      if (p && (a.index = 0, a.position = _, a.entry = _ !== e ? e : void 0), c) {
        if (m = t(a), m == null)
          return un.voidControl;
        if (!he(m))
          throw new TypeError(
            "AnimationGroupAPI.fromTo error: 'fromData' callback function failed to return an object."
          );
      }
      if (f) {
        if (g = s(a), g == null)
          return un.voidControl;
        if (!he(g))
          throw new TypeError(
            "AnimationGroupAPI.fromTo error: 'toData' callback function failed to return an object."
          );
      }
      if (d) {
        if (h = n(a), h == null)
          return un.voidControl;
        if (!he(h))
          throw new TypeError(
            "AnimationGroupAPI.fromTo error: 'options' callback function failed to return an object."
          );
      }
      const y = Ii.fromTo(
        _,
        m,
        g,
        h,
        r
      );
      y && l.add(y);
    }
    return new un(l);
  }
  /**
   * Provides the `to` animation tween for one or more positionable instances as a group.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - A position group.
   *
   * @param {(
   *    import('../data/types').Data.TJSPositionDataRelative |
   *    import('./types').AnimationAPI.GroupDataCallback
   * )} toData - A position data object assigned to all positionable instances or a callback function invoked for
   *        unique data for each instance.
   *
   * @param {(
   *    import('./types').AnimationAPI.TweenOptions |
   *    import('./types').AnimationAPI.GroupTweenOptionsCallback
   * )} [options] - Tween options assigned to all positionable instances or a callback function invoked for unique
   *        options for each instance.
   *
   * @returns {import('#runtime/util/animate').BasicAnimation} Basic animation control.
   */
  static to(e, t, s) {
    if (!he(t) && typeof t != "function")
      throw new TypeError("AnimationGroupAPI.to error: 'toData' is not an object or function.");
    if (s !== void 0 && !he(s) && typeof s != "function")
      throw new TypeError("AnimationGroupAPI.to error: 'options' is not an object or function.");
    const n = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ u((m) => n.delete(m.control), "cleanupFn");
    let r = -1, o;
    const a = typeof t == "function", c = typeof s == "function", f = a || c;
    f && (o = { index: r, position: void 0, entry: void 0 });
    let d = t, p = s;
    if (Nt(e))
      for (const m of e) {
        r++;
        const g = X(this, js, Zs).call(this, m);
        if (!g) {
          console.warn(`AnimationGroupAPI.to warning: No TJSPosition instance found at index: ${r}.`);
          continue;
        }
        if (f && (o.index = r, o.position = g, o.entry = g !== m ? m : void 0), a) {
          if (d = t(o), d == null)
            continue;
          if (!he(d))
            throw new TypeError(`AnimationGroupAPI.to error: 'toData' callback function iteration(${r}) failed to return an object.`);
        }
        if (c) {
          if (p = s(o), p == null)
            continue;
          if (!he(p))
            throw new TypeError(`AnimationGroupAPI.to error: 'options' callback function iteration(${r}) failed to return an object.`);
        }
        const h = Ii.to(g, d, p, l);
        h && n.add(h);
      }
    else {
      const m = X(this, js, Zs).call(this, e);
      if (!m)
        return console.warn("AnimationGroupAPI.to warning: No TJSPosition instance found."), un.voidControl;
      if (f && (o.index = 0, o.position = m, o.entry = m !== e ? e : void 0), a) {
        if (d = t(o), d == null)
          return un.voidControl;
        if (!he(d))
          throw new TypeError(
            "AnimationGroupAPI.to error: 'toData' callback function failed to return an object."
          );
      }
      if (c) {
        if (p = s(o), p == null)
          return un.voidControl;
        if (!he(p))
          throw new TypeError(
            "AnimationGroupAPI.to error: 'options' callback function failed to return an object."
          );
      }
      const g = Ii.to(m, d, p, l);
      g && n.add(g);
    }
    return new un(n);
  }
  /**
   * Provides the `quickTo` animation tweening function for one or more positionable instances as a group.
   *
   * @param {import('../types').TJSPositionTypes.PositionGroup} positionGroup - A position group.
   *
   * @param {Iterable<import('./types').AnimationAPI.AnimationKey>}  keys - Animation keys to target.
   *
   * @param {(
   *    import('./types').AnimationAPI.QuickTweenOptions |
   *    import('./types').AnimationAPI.GroupQuickTweenOptionsCallback
   * )} [options] - Quick tween options assigned to all positionable instances or a callback function invoked for
   *        unique options for each instance.
   *
   * @returns {import('./types').AnimationAPI.GroupQuickToCallback | undefined} quick-to tween function.
   */
  static quickTo(e, t, s) {
    if (!Nt(t))
      throw new TypeError("AnimationGroupAPI.quickTo error: 'keys' is not an iterable list.");
    if (s !== void 0 && !he(s) && typeof s != "function")
      throw new TypeError("AnimationGroupAPI.quickTo error: 'options' is not an object or function.");
    const n = [];
    let l = -1;
    const r = typeof s == "function", o = { index: l, position: void 0, entry: void 0 };
    let a = he(s) ? s : void 0;
    if (Nt(e))
      for (const d of e) {
        l++;
        const p = X(this, js, Zs).call(this, d);
        if (!p) {
          console.warn(`AnimationGroupAPI.quickTo warning: No TJSPosition instance found at index: ${l}.`);
          continue;
        }
        if (o.index = l, o.position = p, o.entry = p !== d ? d : void 0, r) {
          if (a = s(o), a == null)
            continue;
          if (!he(a))
            throw new TypeError(`AnimationGroupAPI.quickTo error: 'options' callback function iteration(${l}) failed to return an object.`);
        }
        n.push(p.animate.quickTo(t, a));
      }
    else {
      const d = X(this, js, Zs).call(this, e);
      if (!d) {
        console.warn("AnimationGroupAPI.quickTo warning: No TJSPosition instance found.");
        return;
      }
      if (o.index = 0, o.position = d, o.entry = d !== e ? e : void 0, r) {
        if (a = s(o), a == null)
          return;
        if (!he(a))
          throw new TypeError(
            "AnimationGroupAPI.quickTo error: 'options' callback function failed to return an object."
          );
      }
      n.push(d.animate.quickTo(t, a));
    }
    const c = [...t];
    Object.freeze(c);
    const f = /* @__PURE__ */ u((...d) => {
      if (d.length !== 0)
        if (typeof d[0] == "function") {
          const m = d[0];
          l = -1;
          let g = 0;
          if (Nt(e))
            for (const h of e) {
              l++;
              const _ = X(this, js, Zs).call(this, h);
              if (!_)
                continue;
              o.index = l, o.position = _, o.entry = _ !== h ? h : void 0;
              const y = m(o);
              if (y == null)
                continue;
              const v = Nt(y);
              if (!Number.isFinite(y) && !v && !he(y))
                throw new TypeError(`AnimationGroupAPI.quickTo error: 'toData' callback function iteration(${l}) failed to return a finite number, iterable list, or object.`);
              v ? n[g++](...y) : n[g++](y);
            }
          else {
            const h = X(this, js, Zs).call(this, e);
            if (!h)
              return;
            o.index = 0, o.position = h, o.entry = h !== e ? e : void 0;
            const _ = m(o);
            if (_ == null)
              return;
            const y = Nt(_);
            if (!Number.isFinite(_) && !y && !he(_))
              throw new TypeError(`AnimationGroupAPI.quickTo error: 'toData' callback function iteration(${l}) failed to return a finite number, iterable list, or object.`);
            y ? n[g++](..._) : n[g++](_);
          }
        } else
          for (let m = n.length; --m >= 0; )
            n[m](...d);
    }, "quickToCB");
    return f.keys = c, f.options = (d) => {
      if (d !== void 0 && !he(d))
        throw new TypeError("AnimationGroupAPI.quickTo error: 'options' is not an object.");
      if (he(d))
        for (let p = n.length; --p >= 0; )
          n[p].options(d);
      return f;
    }, f;
  }
};
js = new WeakSet(), Zs = /* @__PURE__ */ u(function(e) {
  var t;
  return he(e) ? e.animate instanceof pu ? e : ((t = e.position) == null ? void 0 : t.animate) instanceof pu ? e.position : null : null;
}, "#getPosition"), x(Nm, js), u(Nm, "AnimationGroupAPI");
let np = Nm;
Object.seal(np);
var af, mn, nn, cf;
const Iw = class Iw {
  constructor(e, t, s) {
    /** @type {import('../data/types').Data.TJSPositionData} */
    x(this, af);
    /**
     * @type {Map<string, import('../data/types').Data.TJSPositionDataExtra>}
     */
    x(this, mn, /* @__PURE__ */ new Map());
    /** @type {import('../').TJSPosition} */
    x(this, nn);
    /** @type {import('../transform').TJSTransforms} */
    x(this, cf);
    Ae(this, nn, e), Ae(this, af, t), Ae(this, cf, s), Object.seal(this);
  }
  /**
   * Clears all saved position data except any default state.
   */
  clear() {
    for (const e of P(this, mn).keys())
      e !== "#defaultData" && P(this, mn).delete(e);
  }
  /**
   * Returns any stored save state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Saved data name.
   *
   * @returns {import('../data/types').Data.TJSPositionDataExtra | undefined} Any saved position data.
   */
  get({ name: e }) {
    if (typeof e != "string")
      throw new TypeError("TJSPosition - get error: 'name' is not a string.");
    return P(this, mn).get(e);
  }
  /**
   * Returns any associated default position data.
   *
   * @returns {import('../data/types').Data.TJSPositionDataExtra | undefined} Any saved default position data.
   */
  getDefault() {
    return P(this, mn).get("#defaultData");
  }
  /**
   * @returns {IterableIterator<string>} The saved position data names / keys.
   */
  keys() {
    return P(this, mn).keys();
  }
  /**
   * Removes and returns any position data by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Name to remove and retrieve.
   *
   * @returns {import('../data/types').Data.TJSPositionDataExtra | undefined} Any saved position data.
   */
  remove({ name: e }) {
    if (typeof e != "string")
      throw new TypeError("TJSPosition - remove: 'name' is not a string.");
    const t = P(this, mn).get(e);
    return P(this, mn).delete(e), t;
  }
  /**
   * Resets position instance to default data and invokes set.
   *
   * @param {object}   [options] - Optional parameters.
   *
   * @param {boolean}  [options.keepZIndex=false] - When true keeps current z-index.
   *
   * @param {boolean}  [options.invokeSet=true] - When true invokes set method.
   *
   * @returns {boolean} Operation successful.
   */
  reset({ keepZIndex: e = !1, invokeSet: t = !0 } = {}) {
    var r, o, a, c;
    const s = P(this, mn).get("#defaultData");
    if (!he(s))
      return !1;
    P(this, nn).animate.isScheduled && P(this, nn).animate.cancel();
    const n = P(this, nn).zIndex, l = Object.assign({}, s);
    return e && (l.zIndex = n), P(this, cf).reset(l), (o = (r = P(this, nn).parent) == null ? void 0 : r.reactive) != null && o.minimized && ((c = (a = P(this, nn).parent) == null ? void 0 : a.maximize) == null || c.call(a, { animate: !1, duration: 0 })), t && setTimeout(() => P(this, nn).set(l), 0), !0;
  }
  /**
   * Restores a saved positional state returning the data. Several optional parameters are available to control
   * whether the restore action occurs silently (no store / inline styles updates), animates to the stored data, or
   * simply sets the stored data. Restoring via {@link AnimationAPI.to} allows specification of the duration and
   * easing along with configuring a Promise to be returned if awaiting the end of the animation.
   *
   * @param {object}            options - Parameters
   *
   * @param {string}            options.name - Saved data set name.
   *
   * @param {boolean}           [options.remove=false] - Deletes data set.
   *
   * @param {Iterable<string>}  [options.properties] - Specific properties to set / animate.
   *
   * @param {boolean}           [options.silent] - Set position data directly; no store or style updates.
   *
   * @param {boolean}           [options.async=false] - If animating return a Promise that resolves with any saved
   *        data.
   *
   * @param {boolean}           [options.animateTo=false] - Animate to restore data.
   *
   * @param {number}            [options.duration=0.1] - Duration in seconds.
   *
   * @param {import('#runtime/svelte/easing').EasingReference} [options.ease='linear'] - Easing function name or
   *        function.
   *
   * @returns {(
   *    import('../data/types').Data.TJSPositionDataExtra |
   *    Promise<import('../data/types').Data.TJSPositionDataExtra | undefined> |
   *    undefined
   * )} Any saved position data.
   */
  restore({
    name: e,
    remove: t = !1,
    properties: s,
    silent: n = !1,
    async: l = !1,
    animateTo: r = !1,
    duration: o = 0.1,
    ease: a = "linear"
  }) {
    if (typeof e != "string")
      throw new TypeError("TJSPosition - restore error: 'name' is not a string.");
    const c = P(this, mn).get(e);
    if (c) {
      t && P(this, mn).delete(e);
      let f = c;
      if (Nt(s)) {
        f = {};
        for (const d of s)
          f[d] = c[d];
      }
      if (n) {
        for (const d in f)
          P(this, af)[d] = f[d];
        return c;
      } else if (r) {
        if (f.transformOrigin !== P(this, nn).transformOrigin && (P(this, nn).transformOrigin = f.transformOrigin), l)
          return P(this, nn).animate.to(f, { duration: o, ease: a }).finished.then(() => c);
        P(this, nn).animate.to(f, { duration: o, ease: a });
      } else
        P(this, nn).set(f);
    }
    return l ? Promise.resolve(c) : c;
  }
  /**
   * Saves current position state with the opportunity to add extra data to the saved state. Simply include
   * extra properties in `options` to save extra data.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - name to index this saved data.
   *
   * @param {import('../types').TJSPositionTypes.OptionsGet} [optionsGet] - Additional options for
   *        {@link TJSPosition.get} when serializing position state. By default, `nullable` values are included.
   *
   * @returns {import('../data/types').Data.TJSPositionDataExtra} Current position data plus any extra data stored.
   */
  save({ name: e, ...t }, s) {
    if (typeof e != "string")
      throw new TypeError("TJSPosition - save error: 'name' is not a string.");
    const n = P(this, nn).get(t, s);
    return P(this, mn).set(e, n), n;
  }
  /**
   * Directly sets a saved position state. Simply include extra properties in `options` to set extra data.
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.name - name to index this saved data.
   */
  set({ name: e, ...t }) {
    if (typeof e != "string")
      throw new TypeError("TJSPosition - set error: 'name' is not a string.");
    P(this, mn).set(e, t);
  }
};
af = new WeakMap(), mn = new WeakMap(), nn = new WeakMap(), cf = new WeakMap(), u(Iw, "PositionStateAPI");
let C1 = Iw;
var uf, ff, df, ya, Ti, ur, va, Sl, Rr;
const Pw = class Pw {
  /**
   * @param {object}      [options] - Initial options.
   *
   * @param {boolean}     [options.constrain=true] - Initial constrained state.
   *
   * @param {HTMLElement} [options.element] - Target element.
   *
   * @param {boolean}     [options.enabled=true] - Enabled state.
   *
   * @param {boolean}     [options.lock=false] - Lock parameters from being set.
   *
   * @param {number}      [options.width] - Manual width.
   *
   * @param {number}      [options.height] - Manual height.
   */
  constructor({ constrain: e = !0, element: t, enabled: s = !0, lock: n = !1, width: l, height: r } = {}) {
    x(this, Sl);
    /**
     * When true constrains the min / max width or height to element.
     *
     * @type {boolean}
     */
    x(this, uf);
    /**
     * @type {HTMLElement}
     */
    x(this, ff);
    /**
     * When true the validator is active.
     *
     * @type {boolean}
     */
    x(this, df);
    /**
     * Provides a manual setting of the element height. As things go `offsetHeight` causes a browser layout and is not
     * performance oriented. If manually set this height is used instead of `offsetHeight`.
     *
     * @type {number}
     */
    x(this, ya);
    /**
     * Set from an optional value in the constructor to lock accessors preventing modification.
     */
    x(this, Ti);
    /**
     * Stores the subscribers.
     *
     * @type {import('svelte/store').Subscriber<SystemBase>[]}
     */
    x(this, ur, []);
    /**
     * Provides a manual setting of the element width. As things go `offsetWidth` causes a browser layout and is not
     * performance oriented. If manually set this width is used instead of `offsetWidth`.
     *
     * @type {number}
     */
    x(this, va);
    this.constrain = e, this.element = t, this.enabled = s, this.width = l, this.height = r, Ae(this, Ti, typeof n == "boolean" ? n : !1);
  }
  /**
   * @returns {boolean} The current constrain state.
   */
  get constrain() {
    return P(this, uf);
  }
  /**
   * @returns {HTMLElement | undefined | null} Target element.
   */
  get element() {
    return P(this, ff);
  }
  /**
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return P(this, df);
  }
  /**
   * @returns {number} Get manual height.
   */
  get height() {
    return P(this, ya);
  }
  /**
   * @return {boolean} Get locked state.
   */
  get locked() {
    return P(this, Ti);
  }
  /**
   * @returns {number} Get manual width.
   */
  get width() {
    return P(this, va);
  }
  /**
   * @param {boolean}  constrain - New constrain state.
   */
  set constrain(e) {
    if (!P(this, Ti)) {
      if (typeof e != "boolean")
        throw new TypeError("'constrain' is not a boolean.");
      Ae(this, uf, e), X(this, Sl, Rr).call(this);
    }
  }
  /**
   * @param {HTMLElement | undefined | null} element - Set target element.
   */
  set element(e) {
    if (!P(this, Ti)) {
      if (e == null || ot.isFocusTarget(e))
        Ae(this, ff, e);
      else
        throw new TypeError("'element' is not a HTMLElement, undefined, or null.");
      X(this, Sl, Rr).call(this);
    }
  }
  /**
   * @param {boolean}  enabled - New enabled state.
   */
  set enabled(e) {
    if (!P(this, Ti)) {
      if (typeof e != "boolean")
        throw new TypeError("'enabled' is not a boolean.");
      Ae(this, df, e), X(this, Sl, Rr).call(this);
    }
  }
  /**
   * @param {number}   height - Set manual height.
   */
  set height(e) {
    if (!P(this, Ti)) {
      if (e === void 0 || Number.isFinite(e))
        Ae(this, ya, e);
      else
        throw new TypeError("'height' is not a finite number or undefined.");
      X(this, Sl, Rr).call(this);
    }
  }
  /**
   * @param {number}   width - Set manual width.
   */
  set width(e) {
    if (!P(this, Ti)) {
      if (e === void 0 || Number.isFinite(e))
        Ae(this, va, e);
      else
        throw new TypeError("'width' is not a finite number or undefined.");
      X(this, Sl, Rr).call(this);
    }
  }
  /**
   * Set manual width & height.
   *
   * @param {number}   width - New manual width.
   *
   * @param {number}   height - New manual height.
   */
  setDimension(e, t) {
    if (!P(this, Ti)) {
      if (e === void 0 || Number.isFinite(e))
        Ae(this, va, e);
      else
        throw new TypeError("'width' is not a finite number or undefined.");
      if (t === void 0 || Number.isFinite(t))
        Ae(this, ya, t);
      else
        throw new TypeError("'height' is not a finite number or undefined.");
      X(this, Sl, Rr).call(this);
    }
  }
  /**
   * @param {import('svelte/store').Subscriber<SystemBase>} handler - Callback
   *        function that is invoked on update / changes. Receives a copy of the TJSPositionData.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(e) {
    return P(this, ur).push(e), e(this), () => {
      const t = P(this, ur).findIndex((s) => s === e);
      t >= 0 && P(this, ur).splice(t, 1);
    };
  }
};
uf = new WeakMap(), ff = new WeakMap(), df = new WeakMap(), ya = new WeakMap(), Ti = new WeakMap(), ur = new WeakMap(), va = new WeakMap(), Sl = new WeakSet(), /**
 * Updates subscribers on changes.
 */
Rr = /* @__PURE__ */ u(function() {
  for (let e = 0; e < P(this, ur).length; e++)
    P(this, ur)[e](this);
}, "#updateSubscribers"), u(Pw, "SystemBase");
let mu = Pw;
const Mw = class Mw extends mu {
  /**
   * Get the left constraint based on any manual target values or the browser inner width.
   *
   * @param {number}   width - Target width.
   *
   * @returns {number} Calculated left constraint.
   */
  getLeft(e) {
    var s;
    return ((this.width ?? ((s = this.element) == null ? void 0 : s.offsetWidth) ?? globalThis.innerWidth) - e) / 2;
  }
  /**
   * Get the top constraint based on any manual target values or the browser inner height.
   *
   * @param {number}   height - Target height.
   *
   * @returns {number} Calculated top constraint.
   */
  getTop(e) {
    var s;
    return ((this.height ?? ((s = this.element) == null ? void 0 : s.offsetHeight) ?? globalThis.innerHeight) - e) / 2;
  }
};
u(Mw, "Centered");
let ip = Mw;
var pf, rs, Fn, Ki;
const jm = class jm {
  /**
   */
  constructor() {
    /** @type {boolean} */
    x(this, pf, !0);
    /**
     * @type {import('./types').ValidatorAPI.ValidatorData[]}
     */
    x(this, rs);
    /**
     * @type {Map<import('./types').ValidatorAPI.ValidationFn, import('svelte/store').Unsubscriber>}
     */
    x(this, Fn, /* @__PURE__ */ new Map());
    x(this, Ki);
    Ae(this, rs, []), Object.seal(this);
  }
  /**
   * @returns {[AdapterValidators, import('./types').ValidatorAPI.ValidatorData[]]} Returns this and internal storage
   * for validator adapter.
   */
  static create(e) {
    const t = new jm();
    return Ae(t, Ki, e), [t, P(t, rs)];
  }
  /**
   * @returns {boolean} Returns the enabled state.
   */
  get enabled() {
    return P(this, pf);
  }
  /**
   * @returns {number} Returns the length of the validators array.
   */
  get length() {
    return P(this, rs).length;
  }
  /**
   * @param {boolean}  enabled - Sets enabled state.
   */
  set enabled(e) {
    if (typeof e != "boolean")
      throw new TypeError("'enabled' is not a boolean.");
    Ae(this, pf, e);
  }
  /**
   * Provides an iterator for validators.
   *
   * @yields {import('./types').ValidatorAPI.ValidatorData}
   * @returns {IterableIterator<import('./types').ValidatorAPI.ValidatorData>} iterator.
   */
  *[Symbol.iterator]() {
    if (P(this, rs).length !== 0)
      for (const e of P(this, rs))
        yield { ...e };
  }
  /**
   * Adds the given validators.
   *
   * @param {...(
   *    import('./types').ValidatorAPI.ValidatorFn |
   *    import('./types').ValidatorAPI.ValidatorData
   * )}   validators - Validators to add.
   */
  add(...e) {
    let t = 0;
    for (const s of e) {
      const n = typeof s;
      if (n !== "function" && n !== "object" || s === null)
        throw new TypeError("AdapterValidator error: 'validator' is not a function or object.");
      let l, r;
      switch (n) {
        case "function":
          l = {
            id: void 0,
            validate: s,
            weight: 1
          }, r = s.subscribe;
          break;
        case "object":
          if (typeof s.validate != "function")
            throw new TypeError("AdapterValidator error: 'validate' attribute is not a function.");
          if (s.weight !== void 0 && typeof s.weight != "number" || s.weight < 0 || s.weight > 1)
            throw new TypeError(
              "AdapterValidator error: 'weight' attribute is not a number between '0 - 1' inclusive."
            );
          l = {
            id: s.id !== void 0 ? s.id : void 0,
            validate: s.validate.bind(s),
            weight: s.weight || 1
          }, r = s.validate.subscribe ?? s.subscribe;
          break;
      }
      const o = P(this, rs).findIndex((a) => l.weight < a.weight);
      if (o >= 0 ? P(this, rs).splice(o, 0, l) : P(this, rs).push(l), typeof r == "function") {
        const a = r.call(s, P(this, Ki));
        if (typeof a != "function")
          throw new TypeError(
            "AdapterValidator error: Validator has subscribe function, but no unsubscribe function is returned."
          );
        if (P(this, Fn).has(l.validate))
          throw new Error(
            "AdapterValidator error: Validator added already has an unsubscribe function registered."
          );
        P(this, Fn).set(l.validate, a), t++;
      }
    }
    t < e.length && P(this, Ki).call(this);
  }
  /**
   * Clears / removes all validators.
   */
  clear() {
    P(this, rs).length = 0;
    for (const e of P(this, Fn).values())
      e();
    P(this, Fn).clear(), P(this, Ki).call(this);
  }
  /**
   * Removes one or more given validators.
   *
   * @param {...(
   *    import('./types').ValidatorAPI.ValidatorFn |
   *    import('./types').ValidatorAPI.ValidatorData
   * )}   validators - Validators to remove.
   */
  remove(...e) {
    const t = P(this, rs).length;
    if (t !== 0) {
      for (const s of e) {
        const n = typeof s == "function" ? s : he(s) ? s.validate : void 0;
        if (n) {
          for (let l = P(this, rs).length; --l >= 0; )
            if (P(this, rs)[l].validate === n) {
              P(this, rs).splice(l, 1);
              let r;
              typeof (r = P(this, Fn).get(n)) == "function" && (r(), P(this, Fn).delete(n));
            }
        }
      }
      t !== P(this, rs).length && P(this, Ki).call(this);
    }
  }
  /**
   * Remove validators by the provided callback. The callback takes 3 parameters: `id`, `validator`, and `weight`.
   * Any truthy value returned will remove that validator.
   *
   * @param {import('./types').ValidatorAPI.RemoveByCallback} callback - Callback function to evaluate each validator
   *        entry.
   */
  removeBy(e) {
    const t = P(this, rs).length;
    if (t !== 0) {
      if (typeof e != "function")
        throw new TypeError("AdapterValidator error: 'callback' is not a function.");
      Ae(this, rs, P(this, rs).filter((s) => {
        const n = e.call(e, { ...s });
        if (n) {
          let l;
          typeof (l = P(this, Fn).get(s.validate)) == "function" && (l(), P(this, Fn).delete(s.validate));
        }
        return !n;
      })), t !== P(this, rs).length && P(this, Ki).call(this);
    }
  }
  /**
   * Removes any validators with matching IDs.
   *
   * @param {...any}   ids - IDs to remove.
   */
  removeById(...e) {
    const t = P(this, rs).length;
    t !== 0 && (Ae(this, rs, P(this, rs).filter((s) => {
      let n = !1;
      for (const l of e)
        n |= s.id === l;
      if (n) {
        let l;
        typeof (l = P(this, Fn).get(s.validate)) == "function" && (l(), P(this, Fn).delete(s.validate));
      }
      return !n;
    })), t !== P(this, rs).length && P(this, Ki).call(this));
  }
};
pf = new WeakMap(), rs = new WeakMap(), Fn = new WeakMap(), Ki = new WeakMap(), u(jm, "AdapterValidators");
let T1 = jm;
var Lm;
const nu = class nu extends mu {
  /**
   * Provides a validator that respects transforms in positional data constraining the position to within the target
   * elements bounds.
   *
   * @param {import('./types').ValidatorAPI.ValidationData}   valData - The associated validation data for position
   *        updates.
   *
   * @returns {import('../../data/types').Data.TJSPositionData} Potentially adjusted position data.
   */
  validate(e) {
    var o, a;
    if (!this.enabled)
      return e.position;
    const t = this.width ?? ((o = this.element) == null ? void 0 : o.offsetWidth) ?? globalThis.innerWidth, s = this.height ?? ((a = this.element) == null ? void 0 : a.offsetHeight) ?? globalThis.innerHeight;
    if (typeof e.position.width == "number") {
      const c = e.maxWidth ?? (this.constrain ? t : Number.MAX_SAFE_INTEGER);
      e.position.width = ep(e.width, e.minWidth, c);
    }
    if (typeof e.position.height == "number") {
      const c = e.maxHeight ?? (this.constrain ? s : Number.MAX_SAFE_INTEGER);
      e.position.height = ep(e.height, e.minHeight, c);
    }
    const n = e.transforms.getData(e.position, P(nu, Lm), e), l = n.boundingRect.x, r = n.boundingRect.y;
    return n.boundingRect.bottom + e.marginTop > s && (n.boundingRect.y += s - n.boundingRect.bottom - e.marginTop), n.boundingRect.right + e.marginLeft > t && (n.boundingRect.x += t - n.boundingRect.right - e.marginLeft), n.boundingRect.top - e.marginTop < 0 && (n.boundingRect.y += Math.abs(n.boundingRect.top - e.marginTop)), n.boundingRect.left - e.marginLeft < 0 && (n.boundingRect.x += Math.abs(n.boundingRect.left - e.marginLeft)), e.position.left -= l - n.boundingRect.x, e.position.top -= r - n.boundingRect.y, e.position;
  }
};
Lm = new WeakMap(), u(nu, "TransformBounds"), x(nu, Lm, new rc());
let lp = nu;
const Fw = class Fw {
  constructor() {
    this.left = !1, this.top = !1, this.width = !1, this.height = !1, this.maxHeight = !1, this.maxWidth = !1, this.minHeight = !1, this.minWidth = !1, this.zIndex = !1, this.transform = !1, this.transformOrigin = !1;
  }
  hasChange() {
    return this.left || this.top || this.width || this.height || this.maxHeight || this.maxWidth || this.minHeight || this.minWidth || this.zIndex || this.transform || this.transformOrigin;
  }
  set(e) {
    this.left = e, this.top = e, this.width = e, this.height = e, this.maxHeight = e, this.maxWidth = e, this.minHeight = e, this.minWidth = e, this.zIndex = e, this.transform = e, this.transformOrigin = e;
  }
};
u(Fw, "PositionChangeSet");
let O1 = Fw;
const Rw = class Rw {
  constructor() {
    this.data = void 0, this.dataSubscribers = Object.seal(new ao()), this.dimensionData = Object.seal({ width: 0, height: 0 }), this.changeSet = void 0, this.options = void 0, this.queued = !1, this.styleCache = void 0, this.transforms = void 0, this.transformData = new rc(), this.subscribers = void 0, this.storeDimension = Mt(this.dimensionData), this.storeTransform = Mt(this.transformData, () => (this.options.transformSubscribed = !0, () => this.options.transformSubscribed = !1)), this.queued = !1;
  }
};
u(Rw, "UpdateElementData");
let D1 = Rw;
var Bm, ji, I1, P1, M1;
const kn = class kn {
  /**
   * Potentially adds the given element and internal updateData instance to the list.
   *
   * @param {HTMLElement}       el - An HTMLElement instance.
   *
   * @param {import('./').UpdateElementData} updateData - An UpdateElementData instance.
   *
   * @returns {Promise<number>} The unified next frame update promise. Returns `currentTime`.
   */
  static add(e, t) {
    if (this.listCntr < this.list.length) {
      const s = this.list[this.listCntr];
      s[0] = e, s[1] = t;
    } else
      this.list.push([e, t]);
    return this.listCntr++, t.queued = !0, this.updatePromise || (this.updatePromise = this.wait()), this.updatePromise;
  }
  /**
   * Await on `nextAnimationFrame` and iterate over list map invoking callback functions.
   *
   * @returns {Promise<number>} The next frame Promise / currentTime from nextAnimationFrame.
   */
  static async wait() {
    var t, s, n;
    const e = await CL();
    this.updatePromise = void 0;
    for (let l = this.listCntr; --l >= 0; ) {
      const r = this.list[l], o = r[0], a = r[1];
      r[0] = void 0, r[1] = void 0, a.queued = !1, o.isConnected && (a.options.ortho ? X(t = kn, ji, P1).call(t, o, a) : X(s = kn, ji, I1).call(s, o, a), (a.options.calculateTransform || a.options.transformSubscribed) && X(n = kn, ji, M1).call(n, o, a), this.updateSubscribers(a));
    }
    return this.listCntr = 0, e;
  }
  /**
   * Potentially immediately updates the given element.
   *
   * @param {HTMLElement}       el - An HTMLElement instance.
   *
   * @param {import('./').UpdateElementData} updateData - An UpdateElementData instance.
   */
  static immediate(e, t) {
    var s, n, l;
    e.isConnected && (t.options.ortho ? X(s = kn, ji, P1).call(s, e, t) : X(n = kn, ji, I1).call(n, e, t), (t.options.calculateTransform || t.options.transformSubscribed) && X(l = kn, ji, M1).call(l, e, t), this.updateSubscribers(t));
  }
  /**
   * @param {import('./').UpdateElementData} updateData - Data change set.
   */
  static updateSubscribers(e) {
    const t = e.data, s = e.changeSet;
    if (!s.hasChange())
      return;
    const n = Ts.copyData(t, e.dataSubscribers), l = e.subscribers;
    if (l.length > 0)
      for (let r = 0; r < l.length; r++)
        l[r](n);
    (s.width || s.height) && (e.dimensionData.width = t.width, e.dimensionData.height = t.height, e.storeDimension.set(e.dimensionData)), s.set(!1);
  }
};
Bm = new WeakMap(), ji = new WeakSet(), I1 = /* @__PURE__ */ u(function(e, t) {
  const s = t.changeSet, n = t.data;
  s.left && (e.style.left = `${n.left}px`), s.top && (e.style.top = `${n.top}px`), s.zIndex && (e.style.zIndex = typeof n.zIndex == "number" ? `${n.zIndex}` : null), s.width && (e.style.width = typeof n.width == "number" ? `${n.width}px` : n.width), s.height && (e.style.height = typeof n.height == "number" ? `${n.height}px` : n.height), s.transformOrigin && (e.style.transformOrigin = n.transformOrigin), s.transform && (e.style.transform = t.transforms.isActive ? t.transforms.getCSS() : null);
}, "#updateElement"), P1 = /* @__PURE__ */ u(function(e, t) {
  const s = t.changeSet, n = t.data;
  s.zIndex && (e.style.zIndex = typeof n.zIndex == "number" ? `${n.zIndex}` : null), s.width && (e.style.width = typeof n.width == "number" ? `${n.width}px` : n.width), s.height && (e.style.height = typeof n.height == "number" ? `${n.height}px` : n.height), s.transformOrigin && (e.style.transformOrigin = n.transformOrigin), (s.left || s.top || s.transform) && (e.style.transform = t.transforms.getCSSOrtho(n));
}, "#updateElementOrtho"), M1 = /* @__PURE__ */ u(function(e, t) {
  const s = P(this, Bm);
  s.height = t.data.height !== "auto" && t.data.height !== "inherit" ? t.data.height : t.styleCache.offsetHeight, s.width = t.data.width !== "auto" && t.data.height !== "inherit" ? t.data.width : t.styleCache.offsetWidth, s.marginLeft = t.styleCache.marginLeft, s.marginTop = t.styleCache.marginTop, t.transforms.getData(t.data, t.transformData, s), t.storeTransform.set(t.transformData);
}, "#updateTransform"), x(kn, ji), u(kn, "UpdateElementManager"), /**
 * Stores the active list of all TJSPosition instances currently updating. The list entries are recycled between
 * updates.
 *
 * @type {[HTMLElement, import('./').UpdateElementData][]}
 */
qe(kn, "list", []), /**
 * Tracks the current position in the list.
 *
 * @type {number}
 */
qe(kn, "listCntr", 0), qe(kn, "updatePromise"), // Internal Implementation ----------------------------------------------------------------------------------------
/**
 * Temporary data for validation.
 *
 * @type {{width, marginTop, height, marginLeft}}
 */
x(kn, Bm, Object.seal({
  height: void 0,
  width: void 0,
  marginLeft: void 0,
  marginTop: void 0
}));
let Xc = kn;
const Nw = class Nw {
  constructor() {
    this.el = void 0, this.computed = void 0, this.marginLeft = void 0, this.marginTop = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.minHeight = void 0, this.minWidth = void 0, this.hasWillChange = !1, this.resizeObserved = Object.seal({
      contentHeight: void 0,
      contentWidth: void 0,
      offsetHeight: void 0,
      offsetWidth: void 0
    });
    const e = Mt(this.resizeObserved);
    this.stores = {
      element: Mt(this.el),
      resizeContentHeight: Tt(e, "contentHeight"),
      resizeContentWidth: Tt(e, "contentWidth"),
      resizeObserved: e,
      resizeObservable: Mt(!1),
      resizeOffsetHeight: Tt(e, "offsetHeight"),
      resizeOffsetWidth: Tt(e, "offsetWidth")
    };
  }
  /**
   * Returns the cached offsetHeight from any attached `resizeObserver` action otherwise gets the offsetHeight from
   * the element directly. The more optimized path is using `resizeObserver` as getting it from the element
   * directly is more expensive and alters the execution order of an animation frame.
   *
   * @returns {number} The element offsetHeight.
   */
  get offsetHeight() {
    if (ot.isFocusTarget(this.el))
      return this.resizeObserved.offsetHeight !== void 0 ? this.resizeObserved.offsetHeight : this.el.offsetHeight;
    throw new Error("TJSPositionStyleCache - get offsetHeight error: no element assigned.");
  }
  /**
   * Returns the cached offsetWidth from any attached `resizeObserver` action otherwise gets the offsetWidth from
   * the element directly. The more optimized path is using `resizeObserver` as getting it from the element
   * directly is more expensive and alters the execution order of an animation frame.
   *
   * @returns {number} The element offsetHeight.
   */
  get offsetWidth() {
    if (ot.isFocusTarget(this.el))
      return this.resizeObserved.offsetWidth !== void 0 ? this.resizeObserved.offsetWidth : this.el.offsetWidth;
    throw new Error("TJSPositionStyleCache - get offsetWidth error: no element assigned.");
  }
  /**
   * @param {HTMLElement} el -
   *
   * @returns {boolean} Does element match cached element.
   */
  hasData(e) {
    return this.el === e;
  }
  /**
   * Resets the style cache.
   */
  reset() {
    ot.isFocusTarget(this.el) && this.el.isConnected && !this.hasWillChange && (this.el.style.willChange = null), this.el = void 0, this.computed = void 0, this.marginLeft = void 0, this.marginTop = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.minHeight = void 0, this.minWidth = void 0, this.hasWillChange = !1, this.resizeObserved.contentHeight = void 0, this.resizeObserved.contentWidth = void 0, this.resizeObserved.offsetHeight = void 0, this.resizeObserved.offsetWidth = void 0, this.stores.element.set(void 0);
  }
  /**
   * Updates the style cache with new data from the given element.
   *
   * @param {HTMLElement} el - An HTML element.
   */
  update(e) {
    this.el = e, this.computed = globalThis.getComputedStyle(e), this.marginLeft = yt.pixels(e.style.marginLeft) ?? yt.pixels(this.computed.marginLeft), this.marginTop = yt.pixels(e.style.marginTop) ?? yt.pixels(this.computed.marginTop), this.maxHeight = yt.pixels(e.style.maxHeight) ?? yt.pixels(this.computed.maxHeight), this.maxWidth = yt.pixels(e.style.maxWidth) ?? yt.pixels(this.computed.maxWidth), this.minHeight = yt.pixels(e.style.minHeight) ?? yt.pixels(this.computed.minHeight), this.minWidth = yt.pixels(e.style.minWidth) ?? yt.pixels(this.computed.minWidth);
    const t = e.style.willChange !== "" ? e.style.willChange : this.computed.willChange;
    this.hasWillChange = t !== "" && t !== "auto", this.stores.element.set(e);
  }
};
u(Nw, "TJSPositionStyleCache");
let F1 = Nw;
var qm, Gm, Rt, zm, ka, Rn, fr, mf, hf, os, ln, Qr, xr, Oi, wa, dr, gf, eo, Hm, Um, Vm, ML;
const Xn = class Xn {
  /**
   * @param {(
   *    import('./types').TJSPositionTypes.PositionParent |
   *    import('./types').TJSPositionTypes.OptionsCtorAll
   * )} [parentOrOptions] - A  potential parent element or object w/ `elementTarget` accessor. You may also forego
   *    setting the parent and pass in the options object.
   *
   * @param {import('./types').TJSPositionTypes.OptionsCtorAll}  [options] - The options object.
   */
  constructor(e, t) {
    x(this, Vm);
    /**
     * Stores all position data / properties.
     *
     * @type {TJSPositionData}
     */
    x(this, Rt, Object.seal(new ao()));
    /**
     * Provides the animation API.
     *
     * @type {import('./animation/types').AnimationAPI}
     */
    x(this, zm, new pu(this, P(this, Rt)));
    /**
     * Provides a way to turn on / off the position handling.
     *
     * @type {boolean}
     */
    x(this, ka, !0);
    /**
     * Stores ongoing options that are set in the constructor or by transform store subscription.
     *
     * @type {import('./types-local').OptionsInternal}
     */
    x(this, Rn, {
      calculateTransform: !1,
      initial: void 0,
      ortho: !0,
      transformSubscribed: !1
    });
    /**
     * The associated parent for positional data tracking. Used in validators.
     *
     * @type {import('./types').TJSPositionTypes.PositionParent}
     */
    x(this, fr);
    /**
     * Stores the style attributes that changed on update.
     *
     * @type {PositionChangeSet}
     */
    x(this, mf, new O1());
    /**
     * Tracks the current state if this position instance is a candidate for resize observation by the `resizeObserver`
     * action. This is `true` when `width` or `height` is `auto` or `inherit`.
     *
     * @type {boolean}
     */
    x(this, hf, !1);
    /**
     * @type {import('./types').TJSPositionTypes.Stores}
     */
    x(this, os);
    /**
     * Stores an instance of the computer styles for the target element.
     *
     * @type {TJSPositionStyleCache}
     */
    x(this, ln);
    /**
     * Stores the subscribers.
     *
     * @type {import('svelte/store').Subscriber<import('./data/types').Data.TJSPositionData>[]}
     */
    x(this, Qr, []);
    /**
     * @type {TJSTransforms}
     */
    x(this, xr, new el());
    /**
     * @type {UpdateElementData}
     */
    x(this, Oi);
    /**
     * Stores the UpdateElementManager wait promise.
     *
     * @type {Promise}
     */
    x(this, wa);
    /**
     * @type {AdapterValidators}
     */
    x(this, dr);
    /**
     * @type {import('./system/validators/types').ValidatorAPI.ValidatorData[]}
     */
    x(this, gf);
    /**
     * @type {PositionStateAPI}
     */
    x(this, eo, new C1(this, P(this, Rt), P(this, xr)));
    W7(e) ? t = e : Ae(
      this,
      fr,
      /** @type {import('./types').TJSPositionTypes.PositionParent} */
      e
    ), Ae(this, ln, new F1());
    const s = new D1();
    if (s.changeSet = P(this, mf), s.data = P(this, Rt), s.options = P(this, Rn), s.styleCache = P(this, ln), s.subscribers = P(this, Qr), s.transforms = P(this, xr), Ae(this, Oi, s), typeof (t == null ? void 0 : t.calculateTransform) == "boolean" && (P(this, Rn).calculateTransform = t.calculateTransform), typeof (t == null ? void 0 : t.ortho) == "boolean" && (P(this, Rn).ortho = t.ortho), Ae(this, os, Object.freeze({
      // The main properties for manipulating TJSPosition.
      height: Tt(this, "height"),
      left: Tt(this, "left"),
      rotateX: Tt(this, "rotateX"),
      rotateY: Tt(this, "rotateY"),
      rotateZ: Tt(this, "rotateZ"),
      scale: Tt(this, "scale"),
      top: Tt(this, "top"),
      transformOrigin: Tt(this, "transformOrigin"),
      translateX: Tt(this, "translateX"),
      translateY: Tt(this, "translateY"),
      translateZ: Tt(this, "translateZ"),
      width: Tt(this, "width"),
      zIndex: Tt(this, "zIndex"),
      // Stores that control validation when width / height is not `auto`.
      maxHeight: Tt(this, "maxHeight"),
      maxWidth: Tt(this, "maxWidth"),
      minHeight: Tt(this, "minHeight"),
      minWidth: Tt(this, "minWidth"),
      // Readable stores based on updates or from resize observer changes.
      dimension: { subscribe: s.storeDimension.subscribe },
      element: { subscribe: P(this, ln).stores.element.subscribe },
      resizeContentHeight: { subscribe: P(this, ln).stores.resizeContentHeight.subscribe },
      resizeContentWidth: { subscribe: P(this, ln).stores.resizeContentWidth.subscribe },
      resizeObservable: { subscribe: P(this, ln).stores.resizeObservable.subscribe },
      resizeOffsetHeight: { subscribe: P(this, ln).stores.resizeOffsetHeight.subscribe },
      resizeOffsetWidth: { subscribe: P(this, ln).stores.resizeOffsetWidth.subscribe },
      transform: { subscribe: s.storeTransform.subscribe },
      // Protected store that should only be set by resizeObserver action.
      resizeObserved: P(this, ln).stores.resizeObserved
    })), Object.defineProperty(P(this, os).transformOrigin, "values", {
      get: /* @__PURE__ */ u(() => Xn.transformOrigins, "get")
    }), Yc(P(this, os).resizeObserved, (n) => {
      const l = P(this, fr), r = ot.isFocusTarget(l) ? l : l == null ? void 0 : l.elementTarget;
      ot.isFocusTarget(r) && Number.isFinite(n == null ? void 0 : n.offsetWidth) && Number.isFinite(n == null ? void 0 : n.offsetHeight) && this.set();
    }), [Pg(this, dr)._, Pg(this, gf)._] = T1.create(() => this.set()), t != null && t.initial) {
      const n = t.initial;
      if (typeof (n == null ? void 0 : n.getLeft) != "function" || typeof (n == null ? void 0 : n.getTop) != "function")
        throw new Error(
          "'options.initial' position helper does not contain 'getLeft' and / or 'getTop' functions."
        );
      P(this, Rn).initial = n;
    }
    if (t != null && t.validator)
      if (Nt(t == null ? void 0 : t.validator))
        this.validators.add(...t.validator);
      else {
        const n = t.validator;
        this.validators.add(n);
      }
    Object.seal(this), he(t) && this.set(t);
  }
  /**
   * @returns {import('./animation/types').AnimationGroupAPI} Public Animation API.
   */
  static get Animate() {
    return np;
  }
  /**
   * @returns {import('./data/types').Data.TJSPositionDataConstructor} TJSPositionData constructor.
   */
  static get Data() {
    return ao;
  }
  /**
   * @returns {Readonly<import('./types').TJSPositionTypes.PositionInitial>} TJSPosition default initial helpers.
   */
  static get Initial() {
    return P(this, qm);
  }
  /**
   * @returns {import('./system/types').System.SystemBaseConstructor} `SystemBase` constructor.
   */
  static get SystemBase() {
    return mu;
  }
  /**
   * Returns TJSTransformData class / constructor.
   *
   * @returns {import('./transform/types').TransformAPI.TransformDataConstructor} TransformData class /
   *          constructor.
   */
  static get TransformData() {
    return rc;
  }
  /**
   * Returns default validators.
   *
   * @returns {Readonly<import('./types').TJSPositionTypes.PositionValidators>} Available validators.
   */
  static get Validators() {
    return P(this, Gm);
  }
  /**
   * Returns a list of supported transform origins.
   *
   * @returns {Readonly<import('./transform/types').TransformAPI.TransformOrigin[]>} The supported transform origin
   *          strings.
   */
  static get transformOrigins() {
    return el.transformOrigins;
  }
  /**
   * Convenience to copy from source to target of two TJSPositionData like objects. If a target is not supplied a new
   * {@link TJSPositionData} instance is created.
   *
   * @param {Partial<import('./data/types').Data.TJSPositionData>}  source - The source instance to copy from.
   *
   * @param {import('./data/types').Data.TJSPositionData}  [target] - Target TJSPositionData like object; if one is not
   *        provided a new instance is created.
   *
   * @returns {import('./data/types').Data.TJSPositionData} The target instance with all TJSPositionData fields.
   */
  static copyData(e, t) {
    return Ts.copyData(e, t);
  }
  /**
   * Returns a duplicate of a given position instance copying any options and validators. The position parent is not
   * copied and a new one must be set manually via the {@link TJSPosition.parent} setter.
   *
   * @param {TJSPosition} position - A position instance.
   *
   * @param {import('./types').TJSPositionTypes.OptionsCtorAll}   [options] - Unique new options to set.
   *
   * @returns {TJSPosition} A duplicate position instance.
   */
  static duplicate(e, t = {}) {
    if (!(e instanceof Xn))
      throw new TypeError("'position' is not an instance of TJSPosition.");
    const s = new Xn(t);
    return Ae(s, Rn, Object.assign({}, P(e, Rn), t)), P(s, dr).add(...P(e, dr)), s.set(P(e, Rt)), s;
  }
  /**
   * Returns the animation API.
   *
   * @returns {import('./animation/types').AnimationAPI} Animation API.
   */
  get animate() {
    return P(this, zm);
  }
  /**
   * Returns the dimension data for the readable store.
   *
   * @returns {Readonly<{width: number | 'auto' | 'inherit', height: number | 'auto' | 'inherit'}>} Dimension data.
   */
  get dimension() {
    return P(this, Oi).dimensionData;
  }
  /**
   * Returns the enabled state.
   *
   * @returns {boolean} Enabled state.
   */
  get enabled() {
    return P(this, ka);
  }
  /**
   * Returns the current HTMLElement being positioned.
   *
   * @returns {HTMLElement | undefined} Current HTMLElement being positioned.
   */
  get element() {
    return P(this, ln).el;
  }
  /**
   * Returns a promise that is resolved on the next element update with the time of the update.
   *
   * @returns {Promise<number>} Promise resolved on element update.
   */
  get elementUpdated() {
    return P(this, wa);
  }
  /**
   * Returns the associated {@link TJSPositionTypes.PositionParent} instance.
   *
   * @returns {import('./types').TJSPositionTypes.PositionParent} The current position parent instance.
   */
  get parent() {
    return P(this, fr);
  }
  /**
   * Returns the state API.
   *
   * @returns {import('./state/types').PositionStateAPI} TJSPosition state API.
   */
  get state() {
    return P(this, eo);
  }
  /**
   * Returns the derived writable stores for individual data variables.
   *
   * @returns {import('./types').TJSPositionTypes.Stores} Derived / writable stores.
   */
  get stores() {
    return P(this, os);
  }
  /**
   * Returns the transform data for the readable store.
   *
   * @returns {import('./transform/types').TransformAPI.TransformData} Transform Data.
   */
  get transform() {
    return P(this, Oi).transformData;
  }
  /**
   * Returns the validators.
   *
   * @returns {import('./system/validators/types').ValidatorAPI} validators.
   */
  get validators() {
    return P(this, dr);
  }
  /**
   * Sets the enabled state.
   *
   * @param {boolean}  enabled - New enabled state.
   */
  set enabled(e) {
    if (typeof e != "boolean")
      throw new TypeError("'enabled' is not a boolean.");
    Ae(this, ka, e);
  }
  /**
   * Sets the associated {@link TJSPositionTypes.PositionParent} instance. Resets the style cache and default data.
   *
   * @param {import('./types').TJSPositionTypes.PositionParent | undefined} parent - A PositionParent instance or
   *        undefined to disassociate
   */
  set parent(e) {
    if (e !== void 0 && !ot.isFocusTarget(e) && !he(e))
      throw new TypeError("'parent' is not an HTMLElement, object, or undefined.");
    Ae(this, fr, e), P(this, eo).remove({ name: "#defaultData" }), P(this, ln).reset(), e && this.set(P(this, Rt));
  }
  // Data accessors ----------------------------------------------------------------------------------------------------
  /**
   * @returns {number | 'auto' | 'inherit' | null} height
   */
  get height() {
    return P(this, Rt).height;
  }
  /**
   * @returns {number | null} left
   */
  get left() {
    return P(this, Rt).left;
  }
  /**
   * @returns {number | null} maxHeight
   */
  get maxHeight() {
    return P(this, Rt).maxHeight;
  }
  /**
   * @returns {number | null} maxWidth
   */
  get maxWidth() {
    return P(this, Rt).maxWidth;
  }
  /**
   * @returns {number | null} minHeight
   */
  get minHeight() {
    return P(this, Rt).minHeight;
  }
  /**
   * @returns {number | null} minWidth
   */
  get minWidth() {
    return P(this, Rt).minWidth;
  }
  /**
   * @returns {number | null} rotateX
   */
  get rotateX() {
    return P(this, Rt).rotateX;
  }
  /**
   * @returns {number | null} rotateY
   */
  get rotateY() {
    return P(this, Rt).rotateY;
  }
  /**
   * @returns {number | null} rotateZ
   */
  get rotateZ() {
    return P(this, Rt).rotateZ;
  }
  /**
   * @returns {number | null} alias for rotateZ
   */
  get rotation() {
    return P(this, Rt).rotateZ;
  }
  /**
   * @returns {number | null} scale
   */
  get scale() {
    return P(this, Rt).scale;
  }
  /**
   * @returns {number | null} top
   */
  get top() {
    return P(this, Rt).top;
  }
  /**
   * @returns {import('./transform/types').TransformAPI.TransformOrigin | null} transformOrigin
   */
  get transformOrigin() {
    return P(this, Rt).transformOrigin;
  }
  /**
   * @returns {number | null} translateX
   */
  get translateX() {
    return P(this, Rt).translateX;
  }
  /**
   * @returns {number | null} translateY
   */
  get translateY() {
    return P(this, Rt).translateY;
  }
  /**
   * @returns {number | null} translateZ
   */
  get translateZ() {
    return P(this, Rt).translateZ;
  }
  /**
   * @returns {number | 'auto' | 'inherit' | null} width
   */
  get width() {
    return P(this, Rt).width;
  }
  /**
   * @returns {number | null} z-index
   */
  get zIndex() {
    return P(this, Rt).zIndex;
  }
  /**
   * @param {number | 'auto' | 'inherit' | null} height -
   */
  set height(e) {
    P(this, os).height.set(e);
  }
  /**
   * @param {number | string | null} left -
   */
  set left(e) {
    P(this, os).left.set(e);
  }
  /**
   * @param {number | string | null} maxHeight -
   */
  set maxHeight(e) {
    P(this, os).maxHeight.set(e);
  }
  /**
   * @param {number | string | null} maxWidth -
   */
  set maxWidth(e) {
    P(this, os).maxWidth.set(e);
  }
  /**
   * @param {number | string | null} minHeight -
   */
  set minHeight(e) {
    P(this, os).minHeight.set(e);
  }
  /**
   * @param {number | string | null} minWidth -
   */
  set minWidth(e) {
    P(this, os).minWidth.set(e);
  }
  /**
   * @param {number | string | null} rotateX -
   */
  set rotateX(e) {
    P(this, os).rotateX.set(e);
  }
  /**
   * @param {number | string | null} rotateY -
   */
  set rotateY(e) {
    P(this, os).rotateY.set(e);
  }
  /**
   * @param {number | string | null} rotateZ -
   */
  set rotateZ(e) {
    P(this, os).rotateZ.set(e);
  }
  /**
   * @param {number | string | null} rotateZ - alias for rotateZ
   */
  set rotation(e) {
    P(this, os).rotateZ.set(e);
  }
  /**
   * @param {number | string | null} scale -
   */
  set scale(e) {
    P(this, os).scale.set(e);
  }
  /**
   * @param {number | string | null} top -
   */
  set top(e) {
    P(this, os).top.set(e);
  }
  /**
   * @param {import('./transform/types').TransformAPI.TransformOrigin} transformOrigin -
   */
  set transformOrigin(e) {
    el.transformOrigins.includes(e) && P(this, os).transformOrigin.set(e);
  }
  /**
   * @param {number | string | null} translateX -
   */
  set translateX(e) {
    P(this, os).translateX.set(e);
  }
  /**
   * @param {number | string | null} translateY -
   */
  set translateY(e) {
    P(this, os).translateY.set(e);
  }
  /**
   * @param {number | string | null} translateZ -
   */
  set translateZ(e) {
    P(this, os).translateZ.set(e);
  }
  /**
   * @param {number | 'auto' | 'inherit' | null} width -
   */
  set width(e) {
    P(this, os).width.set(e);
  }
  /**
   * @param {number | string | null} zIndex -
   */
  set zIndex(e) {
    P(this, os).zIndex.set(e);
  }
  /**
   * Assigns current position data to given object `data` object. By default, `null` position data is not assigned.
   * Other options allow configuration of the data assigned including setting default numeric values for any properties
   * that are null.
   *
   * @param {object}  [data] - Target to assign current position data.
   *
   * @param {import('./types').TJSPositionTypes.OptionsGet}   [options] - Defines options for specific keys and
   *        substituting null for numeric default values. By default, nullable keys are included.
   *
   * @returns {Partial<import('./data/types').Data.TJSPositionData>} Passed in object with current position data.
   */
  get(e = {}, t) {
    const s = t == null ? void 0 : t.keys, n = t == null ? void 0 : t.exclude, l = (t == null ? void 0 : t.nullable) ?? !0, r = (t == null ? void 0 : t.numeric) ?? !1;
    if (Nt(s)) {
      for (const o of s)
        e[o] = r ? Ts.getDataOrDefault(this, o) : this[o], !l && e[o] === null && delete e[o];
      if (Nt(n))
        for (const o of n)
          delete e[o];
      return e;
    } else {
      if (e = Object.assign(e, P(this, Rt)), Nt(n))
        for (const o of n)
          delete e[o];
      if (r && Ts.setNumericDefaults(e), !l)
        for (const o in e)
          e[o] === null && delete e[o];
      return e;
    }
  }
  /**
   * @returns {import('./data/types').Data.TJSPositionData} Current position data.
   */
  toJSON() {
    return Object.assign({}, P(this, Rt));
  }
  /**
   * All calculation and updates of position are implemented in {@link TJSPosition}. This allows position to be fully
   * reactive and in control of updating inline styles for a connected {@link HTMLElement}.
   *
   * The initial set call with a target element will always set width / height as this is necessary for correct
   * calculations.
   *
   * When a target element is present updated styles are applied after validation. To modify the behavior of set
   * implement one or more validator functions and add them via the validator API available from
   * {@link TJSPosition.validators}.
   *
   * Updates to any target element are decoupled from the underlying TJSPosition data. This method returns this
   * instance that you can then await on the target element inline style update by using
   * {@link TJSPosition.elementUpdated}.
   *
   * Relative updates to any property of {@link TJSPositionData} are possible by specifying properties as strings.
   * This string should be in the form of '+=', '-=', or '*=' and float / numeric value. IE '+=0.2'.
   * {@link TJSPosition.set} will apply the `addition`, `subtraction`, or `multiplication` operation specified against
   * the current value of the given property. Please see {@link Data.TJSPositionDataRelative} for a detailed
   * description.
   *
   * @param {import('./data/types').Data.TJSPositionDataRelative} [position] - TJSPosition data to set.
   *
   * @param {import('./types').TJSPositionTypes.OptionsSet} [options] - Additional options.
   *
   * @returns {TJSPosition} This TJSPosition instance.
   */
  set(e = {}, t) {
    var g, h;
    if (!he(e))
      throw new TypeError("TJSPosition - set error: 'position' is not an object.");
    const s = P(this, fr);
    if (!P(this, ka))
      return this;
    if (s !== void 0 && typeof ((g = s == null ? void 0 : s.options) == null ? void 0 : g.positionable) == "boolean" && !((h = s == null ? void 0 : s.options) != null && h.positionable))
      return this;
    const n = (t == null ? void 0 : t.immediateElementUpdate) ?? !1, l = P(this, Rt), r = P(this, xr), o = ot.isFocusTarget(s) ? s : s == null ? void 0 : s.elementTarget, a = ot.isFocusTarget(o) && o.isConnected ? o : void 0, c = P(this, mf), f = P(this, ln);
    if (a && (f.hasData(a) || (f.update(a), f.hasWillChange, c.set(!0), P(this, Oi).queued = !1), br.process(e, P(this, Rt), a), e = X(this, Vm, ML).call(this, e, s, a, f), e === null))
      return this;
    Number.isFinite(e.left) && (e.left = Math.round(e.left), l.left !== e.left && (l.left = e.left, c.left = !0)), Number.isFinite(e.top) && (e.top = Math.round(e.top), l.top !== e.top && (l.top = e.top, c.top = !0)), (Number.isFinite(e.maxHeight) || e.maxHeight === null) && (e.maxHeight = typeof e.maxHeight == "number" ? Math.round(e.maxHeight) : null, l.maxHeight !== e.maxHeight && (l.maxHeight = e.maxHeight, c.maxHeight = !0)), (Number.isFinite(e.maxWidth) || e.maxWidth === null) && (e.maxWidth = typeof e.maxWidth == "number" ? Math.round(e.maxWidth) : null, l.maxWidth !== e.maxWidth && (l.maxWidth = e.maxWidth, c.maxWidth = !0)), (Number.isFinite(e.minHeight) || e.minHeight === null) && (e.minHeight = typeof e.minHeight == "number" ? Math.round(e.minHeight) : null, l.minHeight !== e.minHeight && (l.minHeight = e.minHeight, c.minHeight = !0)), (Number.isFinite(e.minWidth) || e.minWidth === null) && (e.minWidth = typeof e.minWidth == "number" ? Math.round(e.minWidth) : null, l.minWidth !== e.minWidth && (l.minWidth = e.minWidth, c.minWidth = !0)), (Number.isFinite(e.rotateX) || e.rotateX === null) && l.rotateX !== e.rotateX && (l.rotateX = r.rotateX = e.rotateX, c.transform = !0), (Number.isFinite(e.rotateY) || e.rotateY === null) && l.rotateY !== e.rotateY && (l.rotateY = r.rotateY = e.rotateY, c.transform = !0), (Number.isFinite(e.rotateZ) || e.rotateZ === null) && l.rotateZ !== e.rotateZ && (l.rotateZ = r.rotateZ = e.rotateZ, c.transform = !0), (Number.isFinite(e.scale) || e.scale === null) && (e.scale = typeof e.scale == "number" ? ep(e.scale, 0, 1e3) : null, l.scale !== e.scale && (l.scale = r.scale = e.scale, c.transform = !0)), (typeof e.transformOrigin == "string" && el.transformOrigins.includes(
      e.transformOrigin
    ) || e.transformOrigin === null) && l.transformOrigin !== e.transformOrigin && (l.transformOrigin = e.transformOrigin, c.transformOrigin = !0), (Number.isFinite(e.translateX) || e.translateX === null) && l.translateX !== e.translateX && (l.translateX = r.translateX = e.translateX, c.transform = !0), (Number.isFinite(e.translateY) || e.translateY === null) && l.translateY !== e.translateY && (l.translateY = r.translateY = e.translateY, c.transform = !0), (Number.isFinite(e.translateZ) || e.translateZ === null) && l.translateZ !== e.translateZ && (l.translateZ = r.translateZ = e.translateZ, c.transform = !0), Number.isFinite(e.zIndex) && (e.zIndex = Math.round(e.zIndex), l.zIndex !== e.zIndex && (l.zIndex = e.zIndex, c.zIndex = !0));
    const d = e.width === "auto" || e.width === "inherit";
    (Number.isFinite(e.width) || d || e.width === null) && (e.width = typeof e.width == "number" ? Math.round(e.width) : e.width, l.width !== e.width && (l.width = e.width, c.width = !0));
    const p = e.height === "auto" || e.height === "inherit";
    (Number.isFinite(e.height) || p || e.height === null) && (e.height = typeof e.height == "number" ? Math.round(e.height) : e.height, l.height !== e.height && (l.height = e.height, c.height = !0));
    const m = d || p;
    if (P(this, hf) !== m && (Ae(this, hf, m), P(this, ln).stores.resizeObservable.set(m)), a) {
      const _ = P(this, eo).getDefault();
      he(_) || P(this, eo).save({ name: "#defaultData", ...Object.assign({}, l) }), n ? (Xc.immediate(a, P(this, Oi)), Ae(this, wa, Promise.resolve(globalThis.performance.now()))) : P(this, Oi).queued || Ae(this, wa, Xc.add(a, P(this, Oi)));
    } else
      Xc.updateSubscribers(P(this, Oi));
    return this;
  }
  /**
   * @param {import('svelte/store').Subscriber<Readonly<import('./data/types').Data.TJSPositionData>>} handler -
   *        Callback function that is invoked on update / changes. Receives a readonly copy of the TJSPositionData.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(e) {
    return P(this, Qr).push(e), e(Object.assign({}, P(this, Rt))), () => {
      const t = P(this, Qr).findIndex((s) => s === e);
      t >= 0 && P(this, Qr).splice(t, 1);
    };
  }
  /**
   * Provides the {@link Writable} store `update` method. Receive and return a {@link TJSPositionData} instance to
   * update the position state. You may manipulate numeric properties by providing relative adjustments described in
   * {@link TJSPositionDataRelative}.
   *
   * @param {import('svelte/store').Updater<import('./data/types').Data.TJSPositionDataRelative>} updater -
   */
  update(e) {
    const t = e(this.get());
    if (!he(t))
      throw new TypeError("'result' of 'updater' is not an object.");
    this.set(t);
  }
};
qm = new WeakMap(), Gm = new WeakMap(), Rt = new WeakMap(), zm = new WeakMap(), ka = new WeakMap(), Rn = new WeakMap(), fr = new WeakMap(), mf = new WeakMap(), hf = new WeakMap(), os = new WeakMap(), ln = new WeakMap(), Qr = new WeakMap(), xr = new WeakMap(), Oi = new WeakMap(), wa = new WeakMap(), dr = new WeakMap(), gf = new WeakMap(), eo = new WeakMap(), Hm = new WeakMap(), Um = new WeakMap(), Vm = new WeakSet(), /**
 * @param {import('./data/types').Data.TJSPositionDataRelative} data -
 *
 * @param {object} parent -
 *
 * @param {HTMLElement} el -
 *
 * @param {TJSPositionStyleCache} styleCache -
 *
 * @returns {null | import('./data/types').Data.TJSPositionData} Updated position data or null if validation fails.
 */
ML = /* @__PURE__ */ u(function({
  // Directly supported parameters
  left: e,
  top: t,
  maxWidth: s,
  maxHeight: n,
  minWidth: l,
  minHeight: r,
  width: o,
  height: a,
  rotateX: c,
  rotateY: f,
  rotateZ: d,
  scale: p,
  transformOrigin: m,
  translateX: g,
  translateY: h,
  translateZ: _,
  zIndex: y,
  // Aliased parameters
  rotation: v,
  ...k
} = {}, S, D, I) {
  var B, z, q, U, H;
  let M = Ts.copyData(P(this, Rt), P(Xn, Hm));
  if (o !== void 0 || D.style.width === "") {
    const V = o === null || Number.isFinite(o);
    if (o === "auto" || M.width === "auto" && !V)
      M.width = "auto", o = I.offsetWidth;
    else if (o === "inherit" || M.width === "inherit" && !V)
      M.width = "inherit", o = I.offsetWidth;
    else {
      const Y = Number.isFinite(o) ? o : M.width;
      M.width = o = Number.isFinite(Y) ? Math.round(Y) : I.offsetWidth;
    }
  } else
    o = Number.isFinite(M.width) ? M.width : I.offsetWidth;
  if (a !== void 0 || D.style.height === "") {
    const V = a === null || Number.isFinite(a);
    if (a === "auto" || M.height === "auto" && !V)
      M.height = "auto", a = I.offsetHeight;
    else if (a === "inherit" || M.height === "inherit" && !V)
      M.height = "inherit", a = I.offsetHeight;
    else {
      const Y = Number.isFinite(a) ? a : M.height;
      M.height = a = Number.isFinite(Y) ? Math.round(Y) : I.offsetHeight;
    }
  } else
    a = Number.isFinite(M.height) ? M.height : I.offsetHeight;
  Number.isFinite(e) ? M.left = e : Number.isFinite(M.left) || (M.left = typeof ((z = (B = P(this, Rn)) == null ? void 0 : B.initial) == null ? void 0 : z.getLeft) == "function" ? P(this, Rn).initial.getLeft(o) : 0), Number.isFinite(t) ? M.top = t : Number.isFinite(M.top) || (M.top = typeof ((U = (q = P(this, Rn)) == null ? void 0 : q.initial) == null ? void 0 : U.getTop) == "function" ? P(this, Rn).initial.getTop(a) : 0), (Number.isFinite(n) || n === null) && (M.maxHeight = Number.isFinite(n) ? Math.round(n) : null), (Number.isFinite(s) || s === null) && (M.maxWidth = Number.isFinite(s) ? Math.round(s) : null), (Number.isFinite(r) || r === null) && (M.minHeight = Number.isFinite(r) ? Math.round(r) : null), (Number.isFinite(l) || l === null) && (M.minWidth = Number.isFinite(l) ? Math.round(l) : null), (Number.isFinite(c) || c === null) && (M.rotateX = c), (Number.isFinite(f) || f === null) && (M.rotateY = f), d !== M.rotateZ && (Number.isFinite(d) || d === null) ? M.rotateZ = d : v !== M.rotateZ && (Number.isFinite(v) || v === null) && (M.rotateZ = v), (Number.isFinite(g) || g === null) && (M.translateX = g), (Number.isFinite(h) || h === null) && (M.translateY = h), (Number.isFinite(_) || _ === null) && (M.translateZ = _), (Number.isFinite(p) || p === null) && (M.scale = typeof p == "number" ? ep(p, 0, 1e3) : null), (typeof m == "string" || m === null) && (M.transformOrigin = el.transformOrigins.includes(m) ? m : null), (Number.isFinite(y) || y === null) && (M.zIndex = typeof y == "number" ? Math.round(y) : y);
  const L = P(this, gf);
  if (P(this, dr).enabled && L.length) {
    const V = P(Xn, Um);
    V.parent = S, V.el = D, V.computed = I.computed, V.transforms = P(this, xr), V.height = a, V.width = o, V.marginLeft = I.marginLeft, V.marginTop = I.marginTop, V.maxHeight = I.maxHeight ?? M.maxHeight, V.maxWidth = I.maxWidth ?? M.maxWidth;
    const Y = ((H = S == null ? void 0 : S.reactive) == null ? void 0 : H.minimized) ?? !1;
    V.minHeight = Y ? M.minHeight ?? 0 : I.minHeight || (M.minHeight ?? 0), V.minWidth = Y ? M.minWidth ?? 0 : I.minWidth || (M.minWidth ?? 0);
    for (let J = 0; J < L.length; J++)
      if (V.position = M, V.rest = k, M = L[J].validate(V), M === null)
        return null;
  }
  return M;
}, "#updatePosition"), u(Xn, "TJSPosition"), /**
 * Public API for {@link TJSPosition.Initial}.
 *
 * @type {Readonly<import('./types').TJSPositionTypes.PositionInitial>}
 */
x(Xn, qm, Object.freeze({
  browserCentered: new ip({ lock: !0 }),
  Centered: ip
})), /**
 * Public API for {@link TJSPosition.Validators}
 *
 * @type {Readonly<import('./types').TJSPositionTypes.PositionValidators>}
 */
x(Xn, Gm, Object.freeze({
  TransformBounds: lp,
  transformWindow: new lp({ lock: !0 })
})), // Internal Implementation ----------------------------------------------------------------------------------------
/**
 * Temporary data storage for `TJSPosition.#updatePosition`.
 *
 * @type {TJSPositionData}
 */
x(Xn, Hm, Object.seal(new ao())), /**
 * Temporary data storage for `TJSPosition.#updatePosition`.
 *
 * @type {import('./system/validators/types').ValidatorAPI.ValidationData}
 */
x(Xn, Um, Object.seal({
  position: void 0,
  parent: void 0,
  el: void 0,
  computed: void 0,
  transforms: void 0,
  height: void 0,
  width: void 0,
  marginLeft: void 0,
  marginTop: void 0,
  maxHeight: void 0,
  maxWidth: void 0,
  minHeight: void 0,
  minWidth: void 0,
  rest: void 0
}));
let Jc = Xn;
var to, bf, _s, Cl, $a, Aa, Ea, so, Sa, Yi, Wm, Tl, Ca, Od;
const iu = class iu extends Application {
  /**
   * @param {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplicationOptions} options - The options for the application.
   *
   * @inheritDoc
   */
  constructor(t = {}) {
    super(t);
    x(this, Ca);
    /**
     * Stores the first mounted component which follows the application shell contract.
     *
     * @type {import('./internal/state-svelte/types').MountedAppShell[] | null[]} Application shell.
     */
    x(this, to, [null]);
    /**
     * Stores and manages application state for saving / restoring / serializing.
     *
     * @type {ApplicationState}
     */
    x(this, bf);
    /**
     * Stores the target element which may not necessarily be the main element.
     *
     * @type {HTMLElement}
     */
    x(this, _s, null);
    /**
     * Stores the content element which is set for application shells.
     *
     * @type {HTMLElement}
     */
    x(this, Cl, null);
    /**
     * On initial render gating of `setPosition` invoked by `Application._render` occurs, so that percentage values
     * can correctly be positioned with initial helper constraints (centered).
     *
     * @type {boolean}
     */
    x(this, $a, !1);
    /**
     * Stores initial z-index from `_renderOuter` to set to target element / Svelte component.
     *
     * @type {number}
     */
    x(this, Aa, 95);
    /**
     * Stores on mount state which is checked in _render to trigger onSvelteMount callback.
     *
     * @type {boolean}
     */
    x(this, Ea, !1);
    /**
     * The position store.
     *
     * @type {TJSPosition}
     */
    x(this, so);
    /**
     * Contains the Svelte stores and reactive accessors.
     *
     * @type {SvelteReactive}
     */
    x(this, Sa);
    /**
     * Stores SvelteData entries with instantiated Svelte components.
     *
     * @type {import('./internal/state-svelte/types').SvelteData[]}
     */
    x(this, Yi, []);
    /**
     * Provides a helper class that combines multiple methods for interacting with the mounted components tracked in
     * #svelteData.
     *
     * @type {GetSvelteData}
     */
    x(this, Wm, new v1(P(this, to), P(this, Yi)));
    /**
     * Contains methods to interact with the Svelte stores.
     *
     * @type {import('./internal/state-reactive/SvelteReactive').SvelteReactiveStores}
     */
    x(this, Tl);
    Ae(this, bf, new _1(this)), Ae(this, so, new Jc(this, {
      ...this.position,
      ...this.options,
      initial: this.options.positionInitial,
      ortho: this.options.positionOrtho,
      validator: this.options.positionValidator
    })), delete this.position, Object.defineProperty(this, "position", {
      get: /* @__PURE__ */ u(() => P(this, so), "get"),
      set: /* @__PURE__ */ u((s) => {
        he(s) && P(this, so).set(s);
      }, "set")
    }), Ae(this, Sa, new $1(this)), Ae(this, Tl, P(this, Sa).initialize());
  }
  /**
   * Specifies the default options that SvelteApplication supports.
   *
   * @returns {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplicationOptions} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   *
   * @internal
   */
  static get defaultOptions() {
    return tl(super.defaultOptions, {
      defaultCloseAnimation: !0,
      // If false the default slide close animation is not run.
      draggable: !0,
      // If true then application shells are draggable.
      focusAuto: !0,
      // When true auto-management of app focus is enabled.
      focusKeep: !1,
      // When `focusAuto` and `focusKeep` is true; keeps internal focus.
      focusSource: void 0,
      // Stores any A11yFocusSource data that is applied when app is closed.
      focusTrap: !0,
      // When true focus trapping / wrapping is enabled keeping focus inside app.
      headerButtonNoClose: !1,
      // If true then the close header button is removed.
      headerButtonNoLabel: !1,
      // If true then header button labels are removed for application shells.
      headerIcon: void 0,
      // Sets a header icon given an image URL.
      headerNoTitleMinimized: !1,
      // If true then header title is hidden when application is minimized.
      minHeight: MIN_WINDOW_HEIGHT,
      // Assigned to position. Number specifying minimum window height.
      minWidth: MIN_WINDOW_WIDTH,
      // Assigned to position. Number specifying minimum window width.
      positionable: !0,
      // If false then `position.set` does not take effect.
      positionInitial: Jc.Initial.browserCentered,
      // A helper for initial position placement.
      positionOrtho: !0,
      // When true TJSPosition is optimized for orthographic use.
      positionValidator: Jc.Validators.transformWindow,
      // A function providing the default validator.
      sessionStorage: void 0,
      // An instance of WebStorage (session) to share across SvelteApplications.
      svelte: void 0,
      // A Svelte configuration object.
      transformOrigin: "top left"
      // By default, 'top / left' respects rotation when minimizing.
    });
  }
  /**
   * Returns the content element if an application shell is mounted.
   *
   * @returns {HTMLElement} Content element.
   */
  get elementContent() {
    return P(this, Cl);
  }
  /**
   * Returns the target element or main element if no target defined.
   *
   * @returns {HTMLElement} Target element.
   */
  get elementTarget() {
    return P(this, _s);
  }
  /**
   * Returns the reactive accessors & Svelte stores for SvelteApplication.
   *
   * @returns {import('./internal/state-reactive/types').SvelteReactive} The reactive accessors & Svelte stores.
   */
  get reactive() {
    return P(this, Sa);
  }
  /**
   * Returns the application state manager.
   *
   * @returns {import('./internal/state-app/types').ApplicationState} The application state manager.
   */
  get state() {
    return P(this, bf);
  }
  /**
   * Returns the Svelte helper class w/ various methods to access mounted Svelte components.
   *
   * @returns {import('./internal/state-svelte/types').GetSvelteData} GetSvelteData
   */
  get svelte() {
    return P(this, Wm);
  }
  /**
   * In this case of when a template is defined in app options `html` references the inner HTML / template. However,
   * to activate classic v1 tabs for a Svelte component the element target is passed as an array simulating JQuery as
   * the element is retrieved immediately and the core listeners use standard DOM queries.
   *
   * @protected
   * @ignore
   * @internal
   */
  _activateCoreListeners(t) {
    var s;
    super._activateCoreListeners(typeof this.options.template == "string" ? t : [this.popOut ? (s = P(this, _s)) == null ? void 0 : s.firstChild : P(this, _s)]);
  }
  /**
   * Provide an override to set this application as the active window regardless of z-index. Changes behaviour from
   * Foundry core.
   *
   * @param {object} [opts] - Optional parameters.
   *
   * @param {boolean} [opts.focus=true] - When true and the active element is not contained in the app `elementTarget`
   *        is focused..
   *
   * @param {boolean} [opts.force=false] - Force bring to top; will increment z-index by popOut order.
   *
   * @ignore
   * @internal
   */
  bringToTop({ focus: t = !0, force: s = !1 } = {}) {
    if (this.reactive.activeWindow !== globalThis)
      return;
    (s || this.popOut) && super.bringToTop();
    const n = this.elementTarget, l = document.activeElement;
    t && n && l !== n && !(n != null && n.contains(l)) && (ot.isFocusTarget(l) && l.blur(), n == null || n.focus()), globalThis.ui.activeWindow = this;
  }
  /**
   * Note: This method is fully overridden and duplicated as Svelte components need to be destroyed manually and the
   * best visual result is to destroy them after the default slide up animation occurs, but before the element
   * is removed from the DOM.
   *
   * If you destroy the Svelte components before the slide up animation the Svelte elements are removed immediately
   * from the DOM. The purpose of overriding ensures the slide up animation is always completed before
   * the Svelte components are destroyed and then the element is removed from the DOM.
   *
   * Close the application and unregisters references to it within UI mappings.
   * This function returns a Promise which resolves once the window closing animation concludes.
   *
   * @param {object}   [options] - Optional parameters.
   *
   * @param {boolean}  [options.force] - Force close regardless of render state.
   *
   * @returns {Promise<void>}    A Promise which resolves once the application is closed.
   *
   * @ignore
   * @internal
   */
  async close(t = {}) {
    var a;
    const s = Application.RENDER_STATES;
    if (!t.force && ![s.RENDERED, s.ERROR].includes(this._state))
      return;
    const n = P(this, _s);
    if (!n) {
      this._state = s.CLOSED;
      return;
    }
    if (((a = n == null ? void 0 : n.ownerDocument) == null ? void 0 : a.defaultView) !== globalThis)
      return;
    this._state = s.CLOSING, P(this, Tl).unsubscribe();
    const l = n.querySelector(".window-content");
    if (l) {
      l.style.overflow = "hidden";
      for (let c = l.children.length; --c >= 0; )
        l.children[c].style.overflow = "hidden";
    }
    for (const c of this.constructor._getInheritanceChain())
      Hooks.call(`close${c.name}`, this, $(n));
    if (typeof this.options.defaultCloseAnimation == "boolean" ? this.options.defaultCloseAnimation : !0) {
      n.style.minHeight = "0";
      const { paddingBottom: c, paddingTop: f } = globalThis.getComputedStyle(n);
      await n.animate([
        { maxHeight: `${n.clientHeight}px`, paddingTop: f, paddingBottom: c },
        { maxHeight: 0, paddingTop: 0, paddingBottom: 0 }
      ], { duration: 250, easing: "ease-in", fill: "forwards" }).finished;
    }
    const o = [];
    for (const c of P(this, Yi)) {
      o.push(Ws.outroAndDestroy(c.component));
      const f = c.config.eventbus;
      he(f) && typeof f.off == "function" && (f.off(), c.config.eventbus = void 0);
    }
    await Promise.allSettled(o), xd.delete(this), P(this, Yi).length = 0, n.remove(), this.position.state.restore({
      name: "#beforeMinimized",
      properties: ["width", "height"],
      silent: !0,
      remove: !0
    }), P(this, to)[0] = null, this._element = null, Ae(this, Cl, null), Ae(this, _s, null), delete globalThis.ui.windows[this.appId], this._minimized = !1, this._scrollPositions = null, this._state = s.CLOSED, Ae(this, Ea, !1), P(this, Tl).uiStateUpdate((c) => tl(c, { minimized: this._minimized })), ot.applyFocusSource(this.options.focusSource), delete this.options.focusSource;
  }
  /**
   * Inject the Svelte components defined in `this.options.svelte`. The Svelte component can attach to the existing
   * pop-out of Application or provide no template and render into a document fragment which is then attached to the
   * DOM.
   *
   * @protected
   * @ignore
   * @internal
   */
  _injectHTML(t) {
    var r, o, a, c;
    if (this.popOut && t.length === 0 && Nt(this.options.svelte))
      throw new Error(
        "SvelteApplication - _injectHTML - A popout app with no template can only support one Svelte component."
      );
    this.reactive.updateHeaderButtons();
    const s = /* @__PURE__ */ u(() => {
      let f = 0;
      return (d) => d != null && f++ > 0 ? (X(this, Ca, Od).call(this), !0) : !1;
    }, "elementRootUpdate");
    if (Nt(this.options.svelte))
      for (const f of this.options.svelte) {
        const d = J3({
          app: this,
          template: t[0],
          config: f,
          elementRootUpdate: s
        });
        if (E1(d.component)) {
          if (this.svelte.applicationShell !== null)
            throw new Error(
              `SvelteApplication - _injectHTML - An application shell is already mounted; offending config:
                    ${JSON.stringify(f)}`
            );
          P(this, to)[0] = d.component, Ws.isHMRProxy(d.component) && Array.isArray((o = (r = d.component) == null ? void 0 : r.$$) == null ? void 0 : o.on_hmr) && d.component.$$.on_hmr.push(() => () => X(this, Ca, Od).call(this));
        }
        P(this, Yi).push(d);
      }
    else if (he(this.options.svelte)) {
      const f = J3({
        app: this,
        template: t[0],
        config: this.options.svelte,
        elementRootUpdate: s
      });
      if (E1(f.component)) {
        if (this.svelte.applicationShell !== null)
          throw new Error(
            `SvelteApplication - _injectHTML - An application shell is already mounted; offending config:
                 ${JSON.stringify(this.options.svelte)}`
          );
        P(this, to)[0] = f.component, Ws.isHMRProxy(f.component) && Array.isArray((c = (a = f.component) == null ? void 0 : a.$$) == null ? void 0 : c.on_hmr) && f.component.$$.on_hmr.push(() => () => X(this, Ca, Od).call(this));
      }
      P(this, Yi).push(f);
    }
    const n = t.length && t[0] instanceof DocumentFragment;
    let l = !0;
    for (const f of P(this, Yi))
      if (!f.injectHTML) {
        l = !1;
        break;
      }
    if (l && super._injectHTML(t), this.svelte.applicationShell !== null)
      this._element = $(this.svelte.applicationShell.elementRoot), Ae(this, Cl, ad(this.svelte.applicationShell, "elementContent") ? this.svelte.applicationShell.elementContent : null), Ae(this, _s, ad(this.svelte.applicationShell, "elementTarget") ? this.svelte.applicationShell.elementTarget : null);
    else if (n) {
      for (const f of P(this, Yi))
        if (ot.isFocusTarget(f.element)) {
          this._element = $(f.element);
          break;
        }
    }
    if (P(this, _s) === null && Ae(this, _s, typeof this.options.selectorTarget == "string" ? this._element[0].querySelector(this.options.selectorTarget) : this._element[0]), P(this, _s) === null || P(this, _s) === void 0)
      throw new Error(`SvelteApplication - _injectHTML: Target element '${this.options.selectorTarget}' not found.`);
    typeof this.options.positionable == "boolean" && this.options.positionable && (P(this, _s).style.zIndex = typeof this.options.zIndex == "number" ? this.options.zIndex : P(this, Aa) ?? 95), P(this, Tl).subscribe();
  }
  /**
   * Provides a mechanism to update the UI options store for maximized.
   *
   * Note: the sanity check is duplicated from {@link Application.maximize} the store is updated _before_
   * performing the rest of animations. This allows application shells to remove / show any resize handlers
   * correctly. Extra constraint data is stored in a saved position state in {@link SvelteApplication.minimize}
   * to animate the content area.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.animate=true] - When true perform default maximizing animation.
   *
   * @param {number}   [opts.duration=0.1] - Controls content area animation duration in seconds.
   */
  async maximize({ animate: t = !0, duration: s = 0.1 } = {}) {
    var f, d;
    if (!this.popOut || [!1, null].includes(this._minimized))
      return;
    this._minimized = null;
    const n = s * 1e3, l = this.elementTarget, r = l.querySelector(".window-header"), o = l.querySelector(".window-content"), a = this.position.state.get({ name: "#beforeMinimized" });
    t && await this.position.state.restore({
      name: "#beforeMinimized",
      async: !0,
      animateTo: !0,
      properties: ["width"],
      duration: 0.1
    }), l.classList.remove("minimized");
    for (let p = r.children.length; --p >= 0; )
      r.children[p].style.display = null;
    o.style.display = null;
    let c;
    t ? { constraints: c } = this.position.state.restore({
      name: "#beforeMinimized",
      animateTo: !0,
      properties: ["height"],
      remove: !0,
      duration: s
    }) : { constraints: c } = this.position.state.remove({ name: "#beforeMinimized" }), await o.animate([
      { maxHeight: 0, paddingTop: 0, paddingBottom: 0, offset: 0 },
      { ...c, offset: 1 },
      { maxHeight: "100%", offset: 1 }
    ], { duration: n, fill: "forwards" }).finished, this.position.set({
      minHeight: a.minHeight ?? ((f = this.options) == null ? void 0 : f.minHeight) ?? MIN_WINDOW_HEIGHT,
      minWidth: a.minWidth ?? ((d = this.options) == null ? void 0 : d.minWidth) ?? MIN_WINDOW_WIDTH
    }), l.style.minWidth = null, l.style.minHeight = null, this._minimized = !1, setTimeout(() => {
      o.style.overflow = null;
      for (let p = o.children.length; --p >= 0; )
        o.children[p].style.overflow = null;
    }, 50), P(this, Tl).uiStateUpdate((p) => tl(p, { minimized: !1 }));
  }
  /**
   * Provides a mechanism to update the UI options store for minimized.
   *
   * Note: the sanity check is duplicated from {@link Application.minimize} the store is updated _before_
   * performing the rest of animations. This allows application shells to remove / show any resize handlers
   * correctly. Extra constraint data is stored in a saved position state in {@link SvelteApplication.minimize}
   * to animate the content area.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.animate=true] - When true perform default minimizing animation.
   *
   * @param {number}   [opts.duration=0.1] - Controls content area animation duration in seconds.
   */
  async minimize({ animate: t = !0, duration: s = 0.1 } = {}) {
    if (!this.rendered || !this.popOut || [!0, null].includes(this._minimized))
      return;
    P(this, Tl).uiStateUpdate((h) => tl(h, { minimized: !0 })), this._minimized = null;
    const n = s * 1e3, l = this.elementTarget, r = l.querySelector(".window-header"), o = l.querySelector(".window-content"), a = this.position.minWidth, c = this.position.minHeight;
    if (this.position.set({ minWidth: 100, minHeight: 30 }), l.style.minWidth = "100px", l.style.minHeight = "30px", o) {
      o.style.overflow = "hidden";
      for (let h = o.children.length; --h >= 0; )
        o.children[h].style.overflow = "hidden";
    }
    const { paddingBottom: f, paddingTop: d } = globalThis.getComputedStyle(o), p = {
      maxHeight: `${o.clientHeight}px`,
      paddingTop: d,
      paddingBottom: f
    };
    t ? o.animate([
      p,
      { maxHeight: 0, paddingTop: 0, paddingBottom: 0 }
    ], { duration: n, fill: "forwards" }).finished.then(() => o.style.display = "none") : setTimeout(() => o.style.display = "none", n);
    const m = this.position.state.save({ name: "#beforeMinimized", constraints: p });
    m.minWidth = a, m.minHeight = c;
    const g = r.offsetHeight;
    this.position.minHeight = g, t && await this.position.animate.to({ height: g }, { duration: s }).finished;
    for (let h = r.children.length; --h >= 0; ) {
      const _ = r.children[h].className;
      if (!(_.includes("window-title") || _.includes("close"))) {
        if (_.includes("keep-minimized")) {
          r.children[h].style.display = "block";
          continue;
        }
        r.children[h].style.display = "none";
      }
    }
    t && await this.position.animate.to({ width: MIN_WINDOW_WIDTH }, { duration: 0.1 }).finished, l.classList.add("minimized"), this._minimized = !0;
  }
  /**
   * Provides a callback after all Svelte components are initialized.
   *
   * @param {import('./internal/state-svelte/types').MountedAppShell} [mountedAppShell] - The mounted app shell
   *        elements.
   */
  onSvelteMount(t) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * Provides a callback after the main application shell is remounted. This may occur during HMR / hot module
   * replacement or directly invoked from the `elementRootUpdate` callback passed to the application shell component
   * context.
   *
   * @param {import('./internal/state-svelte/types').MountedAppShell} [mountedAppShell] - The mounted app shell
   *        elements.
   */
  onSvelteRemount(t) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * Override replacing HTML as Svelte components control the rendering process. Only potentially change the outer
   * application frame / title for pop-out applications.
   *
   * @protected
   * @ignore
   * @internal
   */
  _replaceHTML(t, s) {
    t.length && this.reactive.updateHeaderButtons();
  }
  /**
   * Provides an override verifying that a new Application being rendered for the first time doesn't have a
   * corresponding DOM element already loaded. This is a check that only occurs when `this._state` is
   * `Application.RENDER_STATES.NONE`. It is useful in particular when SvelteApplication has a static ID
   * explicitly set in `this.options.id` and long intro / outro transitions are assigned. If a new application
   * sharing this static ID attempts to open / render for the first time while an existing DOM element sharing
   * this static ID exists then the initial render is cancelled below rather than crashing later in the render
   * cycle {@link TJSPosition.set}.
   *
   * @protected
   * @ignore
   * @internal
   */
  async _render(t = !1, s = {}) {
    var l, r, o, a, c, f, d, p, m, g, h, _;
    he(s == null ? void 0 : s.focusSource) && (this.options.focusSource = s.focusSource);
    const n = this.reactive.activeWindow;
    try {
      if (this._state === Application.RENDER_STATES.NONE && ot.isFocusTarget(n.document.querySelector(`#${this.id}`))) {
        console.warn(`SvelteApplication - _render: A DOM element already exists for CSS ID '${this.id}'. Cancelling initial render for new application with appId '${this.appId}'.`);
        return;
      }
    } catch {
      console.warn(`SvelteApplication - _render: Potentially malformed application ID '${this.id}'. Cancelling initial render for new application with appId '${this.appId}'.`);
      return;
    }
    Ae(this, $a, !0), await super._render(t, s), Ae(this, $a, !1), ![Application.RENDER_STATES.CLOSING, Application.RENDER_STATES.RENDERING].includes(this._state) && (!t && this._state <= Application.RENDER_STATES.NONE || (this._minimized || P(this, so).set({
      left: typeof ((l = this.options) == null ? void 0 : l.left) == "string" ? this.options.left : void 0,
      height: typeof ((r = this.options) == null ? void 0 : r.height) == "string" ? this.options.height : void 0,
      maxHeight: typeof ((o = this.options) == null ? void 0 : o.maxHeight) == "string" ? this.options.maxHeight : void 0,
      maxWidth: typeof ((a = this.options) == null ? void 0 : a.maxWidth) == "string" ? this.options.maxWidth : void 0,
      minHeight: typeof ((c = this.options) == null ? void 0 : c.minHeight) == "string" ? this.options.minHeight : void 0,
      minWidth: typeof ((f = this.options) == null ? void 0 : f.minWidth) == "string" ? this.options.minWidth : void 0,
      rotateX: typeof ((d = this.options) == null ? void 0 : d.rotateX) == "string" ? this.options.rotateX : void 0,
      rotateY: typeof ((p = this.options) == null ? void 0 : p.rotateY) == "string" ? this.options.rotateY : void 0,
      rotateZ: typeof ((m = this.options) == null ? void 0 : m.rotateZ) == "string" ? this.options.rotateZ : void 0,
      rotation: typeof ((g = this.options) == null ? void 0 : g.rotation) == "string" ? this.options.rotation : void 0,
      top: typeof ((h = this.options) == null ? void 0 : h.top) == "string" ? this.options.top : void 0,
      width: typeof ((_ = this.options) == null ? void 0 : _.width) == "string" ? this.options.width : void 0,
      ...s
    }), P(this, Ea) || (xd.add(this), this.onSvelteMount({
      elementRoot: (
        /** @type {HTMLElement} */
        this._element[0]
      ),
      elementContent: P(this, Cl),
      elementTarget: P(this, _s)
    }), Ae(this, Ea, !0))));
  }
  /**
   * Render the inner application content. Only render a template if one is defined otherwise provide an empty
   * JQuery element per the core Foundry API.
   *
   * @protected
   * @ignore
   * @internal
   */
  async _renderInner(t) {
    const s = this.reactive.activeWindow, n = typeof this.template == "string" ? await renderTemplate(this.template, t) : s.document.createDocumentFragment();
    return $(n);
  }
  /**
   * Stores the initial z-index set in `_renderOuter` which is used in `_injectHTML` to set the target element
   * z-index after the Svelte component is mounted.
   *
   * @protected
   * @ignore
   * @internal
   */
  async _renderOuter() {
    const t = await super._renderOuter();
    return Ae(this, Aa, t[0].style.zIndex), t;
  }
  /**
   * All calculation and updates of position are implemented in {@link TJSPosition.set}. This allows position to be
   * fully reactive and in control of updating inline styles for the application.
   *
   * This method remains for backward compatibility with Foundry. If you have a custom override quite likely you need
   * to update to using the {@link TJSPosition.validators} / ValidatorAPI functionality.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/store/position').Data.TJSPositionDataRelative}   [position] - TJSPosition data.
   *
   * @returns {TJSPosition} The updated position object for the application containing the new values.
   * @ignore
   */
  setPosition(t) {
    return P(this, $a) ? this.position : this.position.set(t);
  }
};
to = new WeakMap(), bf = new WeakMap(), _s = new WeakMap(), Cl = new WeakMap(), $a = new WeakMap(), Aa = new WeakMap(), Ea = new WeakMap(), so = new WeakMap(), Sa = new WeakMap(), Yi = new WeakMap(), Wm = new WeakMap(), Tl = new WeakMap(), Ca = new WeakSet(), /**
 * This method is invoked by the `elementRootUpdate` callback that is added to the external context passed to
 * Svelte components. When invoked it updates the local element roots tracked by SvelteApplication.
 *
 * This method may also be invoked by HMR / hot module replacement via `svelte-hmr`.
 */
Od = /* @__PURE__ */ u(function() {
  var s;
  const t = this.svelte.applicationShell;
  t !== null && (this._element = $(t.elementRoot), Ae(this, Cl, ad(t, "elementContent") ? t.elementContent : null), Ae(this, _s, ad(t, "elementTarget") ? t.elementTarget : null), P(this, _s) === null && Ae(this, _s, typeof this.options.selectorTarget == "string" ? this._element[0].querySelector(this.options.selectorTarget) : this._element[0]), typeof this.options.positionable == "boolean" && this.options.positionable && (P(this, _s).style.zIndex = typeof this.options.zIndex == "number" ? this.options.zIndex : P(this, Aa) ?? 95, Mg(iu.prototype, this, "bringToTop").call(this), this.position.set(this.position.get())), Mg(iu.prototype, this, "_activateCoreListeners").call(this, [this.popOut ? (s = P(this, _s)) == null ? void 0 : s.firstChild : P(this, _s)]), this.onSvelteRemount({
    elementRoot: (
      /** @type {HTMLElement} */
      this._element[0]
    ),
    elementContent: P(this, Cl),
    elementTarget: P(this, _s)
  }));
}, "#updateApplicationShell"), u(iu, "SvelteApplication");
let Gs = iu;
var _f, N1;
const Km = class Km {
  static initialize() {
    Hooks.on("PopOut:loading", (e, t) => {
      e instanceof Gs && (e.position.enabled = !1, e.state.save({
        name: "#beforePopout",
        headerButtonNoClose: e.reactive.headerButtonNoClose
      }), e.reactive.activeWindow = t, e.reactive.headerButtonNoClose = !0);
    }), Hooks.on("PopOut:popin", (e) => X(this, _f, N1).call(this, e)), Hooks.on("PopOut:close", (e) => X(this, _f, N1).call(this, e));
  }
};
_f = new WeakSet(), N1 = /* @__PURE__ */ u(function(e) {
  if (e instanceof Gs) {
    e.position.enabled = !0;
    const t = e.state.remove({ name: "#beforePopout" });
    t && (e.reactive.headerButtonNoClose = (t == null ? void 0 : t.headerButtonNoClose) ?? !1), e.reactive.activeWindow = void 0;
  }
}, "#handleRejoin"), x(Km, _f), u(Km, "PopoutSupport");
let R1 = Km;
function oc(i, { delay: e = 0, duration: t = 400, easing: s = Ec } = {}) {
  const n = +getComputedStyle(i).opacity;
  return {
    delay: e,
    duration: t,
    easing: s,
    css: /* @__PURE__ */ u((l) => `opacity: ${l * n}`, "css")
  };
}
u(oc, "fade");
function hu(i, { delay: e = 0, duration: t = 400, easing: s = SL, axis: n = "y" } = {}) {
  const l = getComputedStyle(i), r = +l.opacity, o = n === "y" ? "height" : "width", a = parseFloat(l[o]), c = n === "y" ? ["top", "bottom"] : ["left", "right"], f = c.map(
    (y) => `${y[0].toUpperCase()}${y.slice(1)}`
  ), d = parseFloat(l[`padding${f[0]}`]), p = parseFloat(l[`padding${f[1]}`]), m = parseFloat(l[`margin${f[0]}`]), g = parseFloat(l[`margin${f[1]}`]), h = parseFloat(
    l[`border${f[0]}Width`]
  ), _ = parseFloat(
    l[`border${f[1]}Width`]
  );
  return {
    delay: e,
    duration: t,
    easing: s,
    css: /* @__PURE__ */ u((y) => `overflow: hidden;opacity: ${Math.min(y * 20, 1) * r};${o}: ${y * a}px;padding-${c[0]}: ${y * d}px;padding-${c[1]}: ${y * p}px;margin-${c[0]}: ${y * m}px;margin-${c[1]}: ${y * g}px;border-${c[0]}-width: ${y * h}px;border-${c[1]}-width: ${y * _}px;`, "css")
  };
}
u(hu, "slide");
const bz = new sp({ docKey: "#__trl-root-styles", version: 1 });
var Nn, no, Hs, vo, FL, Ym, RL, L1;
const Ql = class Ql {
  constructor() {
    x(this, Ym);
    /** @type {Map<HTMLElement, import('./types-local').ResizeObserverSubscriber[]>} */
    x(this, Nn, /* @__PURE__ */ new Map());
    /** @type {ResizeObserver} */
    x(this, no);
    Ae(this, no, new ResizeObserver((e) => {
      var t;
      for (const s of e) {
        const n = P(this, Nn).get(s == null ? void 0 : s.target);
        if (Array.isArray(n)) {
          const l = s.contentRect.width, r = s.contentRect.height;
          for (const o of n)
            X(t = Ql, vo, L1).call(t, o, l, r);
        }
      }
    }));
  }
  /**
   * Add an {@link HTMLElement} and {@link ResizeObserverData.ResizeTarget} instance for monitoring. Create cached
   * style attributes for the given element include border & padding dimensions for offset width / height calculations.
   *
   * @param {HTMLElement}    el - The element to observe.
   *
   * @param {import('./types').ResizeObserverData.ResizeTarget} target - A target that contains one of several
   *        mechanisms for updating resize data.
   */
  add(e, t) {
    var g;
    if (!(e instanceof HTMLElement))
      throw new TypeError("ResizeObserverManager.add error: 'el' is not a HTMLElement.");
    if (X(this, Ym, RL).call(this, e, t))
      return;
    const s = X(g = Ql, vo, FL).call(g, t);
    if (s === 0)
      throw new Error("ResizeObserverManager.add error: 'target' is not a valid ResizeObserverManager target.");
    const n = globalThis.getComputedStyle(e), l = yt.pixels(e.style.borderBottom) ?? yt.pixels(n.borderBottom) ?? 0, r = yt.pixels(e.style.borderLeft) ?? yt.pixels(n.borderLeft) ?? 0, o = yt.pixels(e.style.borderRight) ?? yt.pixels(n.borderRight) ?? 0, a = yt.pixels(e.style.borderTop) ?? yt.pixels(n.borderTop) ?? 0, c = yt.pixels(e.style.paddingBottom) ?? yt.pixels(n.paddingBottom) ?? 0, f = yt.pixels(e.style.paddingLeft) ?? yt.pixels(n.paddingLeft) ?? 0, d = yt.pixels(e.style.paddingRight) ?? yt.pixels(n.paddingRight) ?? 0, p = yt.pixels(e.style.paddingTop) ?? yt.pixels(n.paddingTop) ?? 0, m = {
      updateType: s,
      target: t,
      // Stores most recent contentRect.width and contentRect.height values from ResizeObserver.
      contentWidth: 0,
      contentHeight: 0,
      // Convenience data for total border & padding for offset width & height calculations.
      styles: {
        additionalWidth: r + o + f + d,
        additionalHeight: a + l + p + c
      }
    };
    P(this, Nn).has(e) ? P(this, Nn).get(e).push(m) : P(this, Nn).set(e, [m]), P(this, no).observe(e);
  }
  /**
   * Clears and unobserves all currently tracked elements and managed targets.
   */
  clear() {
    for (const e of P(this, Nn).keys())
      P(this, no).unobserve(e);
    P(this, Nn).clear();
  }
  /**
   * Removes all {@link ResizeObserverData.ResizeTarget} instances for the given element from monitoring when just an
   * element is provided otherwise removes a specific target from the monitoring map. If no more targets remain then
   * the element is removed from monitoring.
   *
   * @param {HTMLElement} el - Element to remove from monitoring.
   *
   * @param {import('./types').ResizeObserverData.ResizeTarget} [target] - A specific target to remove from monitoring.
   */
  remove(e, t = void 0) {
    const s = P(this, Nn).get(e);
    if (Array.isArray(s)) {
      if (t !== void 0) {
        const n = s.findIndex((l) => l.target === t);
        n >= 0 && s.splice(n, 1);
      } else
        s.length = 0;
      s.length === 0 && (P(this, Nn).delete(e), P(this, no).unobserve(e));
    }
  }
  /**
   * Provides a function that when invoked with an element updates the cached styles for each subscriber of the
   * element.
   *
   * The style attributes cached to calculate offset height / width include border & padding dimensions. You only need
   * to update the cache if you change border or padding attributes of the element.
   *
   * @param {HTMLElement} el - A HTML element.
   */
  updateCache(e) {
    var s;
    const t = P(this, Nn).get(e);
    if (Array.isArray(t)) {
      const n = globalThis.getComputedStyle(e), l = yt.pixels(e.style.borderBottom) ?? yt.pixels(n.borderBottom) ?? 0, r = yt.pixels(e.style.borderLeft) ?? yt.pixels(n.borderLeft) ?? 0, o = yt.pixels(e.style.borderRight) ?? yt.pixels(n.borderRight) ?? 0, a = yt.pixels(e.style.borderTop) ?? yt.pixels(n.borderTop) ?? 0, c = yt.pixels(e.style.paddingBottom) ?? yt.pixels(n.paddingBottom) ?? 0, f = yt.pixels(e.style.paddingLeft) ?? yt.pixels(n.paddingLeft) ?? 0, d = yt.pixels(e.style.paddingRight) ?? yt.pixels(n.paddingRight) ?? 0, p = yt.pixels(e.style.paddingTop) ?? yt.pixels(n.paddingTop) ?? 0, m = r + o + f + d, g = a + l + p + c;
      for (const h of t)
        h.styles.additionalWidth = m, h.styles.additionalHeight = g, X(s = Ql, vo, L1).call(s, h, h.contentWidth, h.contentHeight);
    }
  }
};
Nn = new WeakMap(), no = new WeakMap(), Hs = new WeakMap(), vo = new WeakSet(), FL = /* @__PURE__ */ u(function(e) {
  if (typeof (e == null ? void 0 : e.resizeObserved) == "function")
    return P(this, Hs).resizeObserved;
  if (typeof (e == null ? void 0 : e.setDimension) == "function")
    return P(this, Hs).setDimension;
  if (typeof (e == null ? void 0 : e.setContentBounds) == "function")
    return P(this, Hs).setContentBounds;
  const t = typeof e;
  if (t !== null && (t === "object" || t === "function")) {
    if (Y3(e.resizeObserved))
      return P(this, Hs).storeObject;
    const s = e == null ? void 0 : e.stores;
    if ((he(s) || typeof s == "function") && Y3(s.resizeObserved))
      return P(this, Hs).storesObject;
  }
  return t !== null && t === "object" ? P(this, Hs).attribute : t === "function" ? P(this, Hs).function : P(this, Hs).none;
}, "#getUpdateType"), Ym = new WeakSet(), /**
 * Determines if a given element and target is already being observed.
 *
 * @param {HTMLElement} el - A HTMLElement.
 *
 * @param {import('./types').ResizeObserverData.ResizeTarget} [target] - A specific target to find.
 *
 * @returns {boolean} Whether the target is already being tracked for the given element.
 */
RL = /* @__PURE__ */ u(function(e, t) {
  if (t == null)
    return !1;
  const s = P(this, Nn).get(e);
  return Array.isArray(s) ? s.findIndex((n) => n.target === t) >= 0 : !1;
}, "#hasTarget"), L1 = /* @__PURE__ */ u(function(e, t, s) {
  var a, c, f;
  const n = e.styles;
  e.contentWidth = t, e.contentHeight = s;
  const l = Number.isFinite(t) ? t + n.additionalWidth : void 0, r = Number.isFinite(s) ? s + n.additionalHeight : void 0, o = e.target;
  switch (e.updateType) {
    case P(this, Hs).attribute:
      o.contentWidth = t, o.contentHeight = s, o.offsetWidth = l, o.offsetHeight = r;
      break;
    case P(this, Hs).function:
      o == null || o(l, r, t, s);
      break;
    case P(this, Hs).resizeObserved:
      (a = o.resizeObserved) == null || a.call(o, l, r, t, s);
      break;
    case P(this, Hs).setContentBounds:
      (c = o.setContentBounds) == null || c.call(o, t, s);
      break;
    case P(this, Hs).setDimension:
      (f = o.setDimension) == null || f.call(o, l, r);
      break;
    case P(this, Hs).storeObject:
      o.resizeObserved.update((d) => (d.contentHeight = s, d.contentWidth = t, d.offsetHeight = r, d.offsetWidth = l, d));
      break;
    case P(this, Hs).storesObject:
      o.stores.resizeObserved.update((d) => (d.contentHeight = s, d.contentWidth = t, d.offsetHeight = r, d.offsetWidth = l, d));
      break;
  }
}, "#updateSubscriber"), x(Ql, vo), u(Ql, "ResizeObserverManager"), /**
 * Defines the various shape / update type of the given target.
 *
 * @type {{ [key: string]: number }}
 */
x(Ql, Hs, Object.freeze({
  none: 0,
  attribute: 1,
  function: 2,
  resizeObserved: 3,
  setContentBounds: 4,
  setDimension: 5,
  storeObject: 6,
  storesObject: 7
}));
let j1 = Ql;
const jc = new j1();
function B1(i, e) {
  return jc.add(i, e), {
    /**
     * @param {import('#runtime/util/dom/observer').ResizeObserverData.ResizeTarget} newTarget - A
     *        {@link ResizeObserverManager} target to update with observed width & height changes.
     */
    update: /* @__PURE__ */ u((t) => {
      jc.remove(i, e), e = t, jc.add(i, e);
    }, "update"),
    destroy: /* @__PURE__ */ u(() => {
      jc.remove(i, e);
    }, "destroy")
  };
}
u(B1, "resizeObserver");
B1.updateCache = function(i) {
  jc.updateCache(i);
};
function Xs(i, e) {
  function t() {
    if (he(e))
      for (const s of Object.keys(e))
        i.style.setProperty(`${s}`, e[s]);
  }
  return u(t, "setProperties"), t(), {
    /**
     * @param {{ [key: string]: string | null }}  newProperties - Key / value object of properties to set.
     */
    update: /* @__PURE__ */ u((s) => {
      e = s, t();
    }, "update")
  };
}
u(Xs, "applyStyles");
function NL(i, { action: e, data: t } = {}) {
  let s;
  return typeof e == "function" && (s = e(i, t)), {
    /**
     * @param {import('./types').DynamicActionOptions} newOptions - Defines the new action to dynamically mount.
     */
    update: /* @__PURE__ */ u((n) => {
      var a, c, f;
      if (!he(n)) {
        (a = s == null ? void 0 : s.destroy) == null || a.call(s), e = void 0, t = void 0;
        return;
      }
      const { action: l, data: r } = n;
      if (typeof l != "function") {
        console.warn("dynamicAction.update warning: Aborting as 'action' is not a function.");
        return;
      }
      const o = r !== t;
      o && (t = r), l !== e ? ((c = s == null ? void 0 : s.destroy) == null || c.call(s), e = l, s = e(i, t)) : o && ((f = s == null ? void 0 : s.update) == null || f.call(s, t));
    }, "update"),
    destroy: /* @__PURE__ */ u(() => {
      var n;
      (n = s == null ? void 0 : s.destroy) == null || n.call(s), e = void 0, t = void 0, s = void 0;
    }, "destroy")
  };
}
u(NL, "dynamicAction");
function _z(i, e) {
  const t = Pl(e.easingFade ?? e.easing), s = Pl(e.easingSlide ?? e.easing), n = oc(i), l = hu(i, { axis: e.axis });
  return {
    delay: e.delay ?? 0,
    duration: e.duration ?? 500,
    easing: Ec,
    css: /* @__PURE__ */ u((r) => {
      const o = t(r), a = s(r);
      return `${l.css(a, 1 - a)}; ${n.css(o, 1 - o)}`;
    }, "css")
  };
}
u(_z, "slideFade");
var Xm, Jm;
const lu = class lu {
  /**
   * @returns {() => undefined} Default empty transition.
   */
  static get default() {
    return P(this, Jm);
  }
  /**
   * @returns {{}} Default empty options.
   */
  static get options() {
    return P(this, Xm);
  }
};
Xm = new WeakMap(), Jm = new WeakMap(), u(lu, "TJSDefaultTransition"), x(lu, Xm, {}), x(lu, Jm, /* @__PURE__ */ u(() => {
}, "#default"));
let fs = lu;
var Ta;
const jw = class jw {
  constructor() {
    /** @type {InternalAppStores} */
    x(this, Ta);
    Ae(this, Ta, {
      elementContent: Mt(void 0),
      elementRoot: Mt(void 0)
    }), Object.freeze(P(this, Ta)), Object.seal(this);
  }
  /**
   * @returns {InternalAppStores} The internal context stores for elementContent / elementRoot
   */
  get stores() {
    return P(this, Ta);
  }
};
Ta = new WeakMap(), u(jw, "AppShellContextInternal");
let q1 = jw;
function Q3(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = Q(
        /*label*/
        i[3]
      ), b(e, "class", "svelte-acci"), Z(
        e,
        "has-icon",
        /*icon*/
        i[4] !== void 0
      );
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n & /*label*/
      8 && be(
        t,
        /*label*/
        s[3]
      ), n & /*icon*/
      16 && Z(
        e,
        "has-icon",
        /*icon*/
        s[4] !== void 0
      );
    },
    d(s) {
      s && C(e);
    }
  };
}
u(Q3, "create_if_block$2z");
function yz(i) {
  let e, t, s, n, l, r, o, a = (
    /*label*/
    i[3] && Q3(i)
  );
  return {
    c() {
      e = E("a"), t = new bn(!1), s = $e(), a && a.c(), t.a = s, b(e, "class", n = "header-button " + /*button*/
      i[0].class + " svelte-acci"), b(
        e,
        "aria-label",
        /*label*/
        i[3]
      ), b(e, "tabindex", "0"), b(e, "role", "button"), Z(
        e,
        "keep-minimized",
        /*keepMinimized*/
        i[2]
      );
    },
    m(c, f) {
      T(c, e, f), t.m(
        /*icon*/
        i[4],
        e
      ), A(e, s), a && a.m(e, null), r || (o = [
        W(e, "click", Ve(st(
          /*onClick*/
          i[5]
        ))),
        W(e, "contextmenu", Ve(st(
          /*onContextMenu*/
          i[6]
        ))),
        W(
          e,
          "keydown",
          /*onKeydown*/
          i[7]
        ),
        W(
          e,
          "keyup",
          /*onKeyup*/
          i[8]
        ),
        Et(l = Xs.call(
          null,
          e,
          /*styles*/
          i[1]
        ))
      ], r = !0);
    },
    p(c, [f]) {
      f & /*icon*/
      16 && t.p(
        /*icon*/
        c[4]
      ), /*label*/
      c[3] ? a ? a.p(c, f) : (a = Q3(c), a.c(), a.m(e, null)) : a && (a.d(1), a = null), f & /*button*/
      1 && n !== (n = "header-button " + /*button*/
      c[0].class + " svelte-acci") && b(e, "class", n), f & /*label*/
      8 && b(
        e,
        "aria-label",
        /*label*/
        c[3]
      ), l && $t(l.update) && f & /*styles*/
      2 && l.update.call(
        null,
        /*styles*/
        c[1]
      ), f & /*button, keepMinimized*/
      5 && Z(
        e,
        "keep-minimized",
        /*keepMinimized*/
        c[2]
      );
    },
    i: se,
    o: se,
    d(c) {
      c && C(e), a && a.d(), r = !1, Me(o);
    }
  };
}
u(yz, "create_fragment$4K");
const vz = /^\s*<.*>$/;
function kz(i, e, t) {
  let s, n, l, r, o, a, { button: c = void 0 } = e;
  function f(g) {
    const h = (c == null ? void 0 : c.onPress) ?? (c == null ? void 0 : c.onclick);
    typeof h == "function" && (h({ button: c, event: g }), t(0, c));
  }
  u(f, "onClick");
  function d(g) {
    (c == null ? void 0 : c.onContextMenu) === "function" && (c.onContextMenu({ button: c, event: g }), t(0, c));
  }
  u(d, "onContextMenu");
  function p(g) {
    g.code === o && (g.preventDefault(), g.stopPropagation());
  }
  u(p, "onKeydown");
  function m(g) {
    if (g.code === o) {
      const h = c.onPress ?? c.onclick;
      typeof h == "function" && (h({ button: c, event: g }), t(0, c)), g.preventDefault(), g.stopPropagation();
    }
  }
  return u(m, "onKeyup"), i.$$set = (g) => {
    "button" in g && t(0, c = g.button);
  }, i.$$.update = () => {
    i.$$.dirty & /*button*/
    1 && t(9, s = he(c) && typeof c.title == "string" ? K(c.title) : ""), i.$$.dirty & /*button, title*/
    513 && t(4, n = he(c) && typeof c.icon != "string" ? void 0 : vz.test(c.icon) ? c.icon : `<i class="${c.icon}" title="${s}"></i>`), i.$$.dirty & /*button*/
    1 && t(3, l = he(c) && typeof c.label == "string" ? K(c.label) : void 0), i.$$.dirty & /*button*/
    1 && t(2, r = he(c) && typeof c.keepMinimized == "boolean" ? c.keepMinimized : !1), i.$$.dirty & /*button*/
    1 && (o = he(c) && typeof c.keyCode == "string" ? c.keyCode : "Enter"), i.$$.dirty & /*button*/
    1 && t(1, a = he(c) && he(c.styles) ? c.styles : void 0);
  }, [
    c,
    a,
    r,
    l,
    n,
    f,
    d,
    p,
    m,
    s
  ];
}
u(kz, "instance$4B");
const Lw = class Lw extends re {
  constructor(e) {
    super(), oe(this, e, kz, yz, le, { button: 0 });
  }
  get button() {
    return this.$$.ctx[0];
  }
  set button(e) {
    this.$$set({ button: e }), Xe();
  }
};
u(Lw, "TJSHeaderButton");
let G1 = Lw;
function x3(i, e, t) {
  const s = i.slice();
  return s[31] = e[t], s;
}
u(x3, "get_each_context$1O");
function eO(i, e, t) {
  const s = i.slice();
  return s[31] = e[t], s;
}
u(eO, "get_each_context_1$p");
function tO(i) {
  let e, t;
  return {
    c() {
      e = E("img"), b(e, "class", "tjs-app-icon keep-minimized svelte-5lh4qo"), ze(e.src, t = /*$storeHeaderIcon*/
      i[6]) || b(e, "src", t), b(e, "alt", "icon");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n[0] & /*$storeHeaderIcon*/
      64 && !ze(e.src, t = /*$storeHeaderIcon*/
      s[6]) && b(e, "src", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(tO, "create_if_block$2y");
function sO(i) {
  let e, t, s;
  const n = [
    /*button*/
    i[31].props
  ];
  var l = (
    /*button*/
    i[31].class
  );
  function r(o, a) {
    let c = {};
    for (let f = 0; f < n.length; f += 1)
      c = Dt(c, n[f]);
    return a !== void 0 && a[0] & /*buttonsLeft*/
    2 && (c = Dt(c, Vt(n, [Jt(
      /*button*/
      o[31].props
    )]))), { props: c };
  }
  return u(r, "switch_props"), l && (e = et(l, r(i))), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(o, a) {
      e && R(e, o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a[0] & /*buttonsLeft*/
      2 && l !== (l = /*button*/
      o[31].class)) {
        if (e) {
          ae();
          const c = e;
          O(c.$$.fragment, 1, 0, () => {
            N(c, 1);
          }), ce();
        }
        l ? (e = et(l, r(o, a)), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const c = a[0] & /*buttonsLeft*/
        2 ? Vt(n, [Jt(
          /*button*/
          o[31].props
        )]) : {};
        e.$set(c);
      }
    },
    i(o) {
      s || (e && w(e.$$.fragment, o), s = !0);
    },
    o(o) {
      e && O(e.$$.fragment, o), s = !1;
    },
    d(o) {
      o && C(t), e && N(e, o);
    }
  };
}
u(sO, "create_each_block_1$p");
function nO(i) {
  let e, t, s;
  const n = [
    /*button*/
    i[31].props
  ];
  var l = (
    /*button*/
    i[31].class
  );
  function r(o, a) {
    let c = {};
    for (let f = 0; f < n.length; f += 1)
      c = Dt(c, n[f]);
    return a !== void 0 && a[0] & /*buttonsRight*/
    4 && (c = Dt(c, Vt(n, [Jt(
      /*button*/
      o[31].props
    )]))), { props: c };
  }
  return u(r, "switch_props"), l && (e = et(l, r(i))), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(o, a) {
      e && R(e, o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a[0] & /*buttonsRight*/
      4 && l !== (l = /*button*/
      o[31].class)) {
        if (e) {
          ae();
          const c = e;
          O(c.$$.fragment, 1, 0, () => {
            N(c, 1);
          }), ce();
        }
        l ? (e = et(l, r(o, a)), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const c = a[0] & /*buttonsRight*/
        4 ? Vt(n, [Jt(
          /*button*/
          o[31].props
        )]) : {};
        e.$set(c);
      }
    },
    i(o) {
      s || (e && w(e.$$.fragment, o), s = !0);
    },
    o(o) {
      e && O(e.$$.fragment, o), s = !1;
    },
    d(o) {
      o && C(t), e && N(e, o);
    }
  };
}
u(nO, "create_each_block$1O");
function iO(i) {
  let e, t, s, n = K(
    /*$storeTitle*/
    i[7]
  ) + "", l, r, o, a, c, f, d, p, m, g, h = typeof /*$storeHeaderIcon*/
  i[6] == "string" && tO(i), _ = ue(
    /*buttonsLeft*/
    i[1]
  ), y = [];
  for (let I = 0; I < _.length; I += 1)
    y[I] = sO(eO(i, _, I));
  const v = /* @__PURE__ */ u((I) => O(y[I], 1, 1, () => {
    y[I] = null;
  }), "out");
  let k = ue(
    /*buttonsRight*/
    i[2]
  ), S = [];
  for (let I = 0; I < k.length; I += 1)
    S[I] = nO(x3(i, k, I));
  const D = /* @__PURE__ */ u((I) => O(S[I], 1, 1, () => {
    S[I] = null;
  }), "out_1");
  return {
    c() {
      e = E("header"), h && h.c(), t = F(), s = E("h4"), l = Q(n), r = F();
      for (let I = 0; I < y.length; I += 1)
        y[I].c();
      o = F(), a = E("span"), c = F();
      for (let I = 0; I < S.length; I += 1)
        S[I].c();
      b(s, "class", "window-title svelte-5lh4qo"), G(
        s,
        "display",
        /*displayHeaderTitle*/
        i[4]
      ), b(a, "class", "tjs-window-header-spacer keep-minimized svelte-5lh4qo"), b(e, "class", "window-header flexrow svelte-5lh4qo");
    },
    m(I, M) {
      T(I, e, M), h && h.m(e, null), A(e, t), A(e, s), A(s, l), A(e, r);
      for (let L = 0; L < y.length; L += 1)
        y[L] && y[L].m(e, null);
      A(e, o), A(e, a), A(e, c);
      for (let L = 0; L < S.length; L += 1)
        S[L] && S[L].m(e, null);
      p = !0, m || (g = [
        W(
          e,
          "pointerdown",
          /*onPointerdown*/
          i[19]
        ),
        Et(f = /*draggable*/
        i[0].call(
          null,
          e,
          /*dragOptions*/
          i[3]
        )),
        Et(d = /*minimizable*/
        i[18].call(
          null,
          e,
          /*$storeMinimizable*/
          i[5]
        ))
      ], m = !0);
    },
    p(I, M) {
      if (typeof /*$storeHeaderIcon*/
      I[6] == "string" ? h ? h.p(I, M) : (h = tO(I), h.c(), h.m(e, t)) : h && (h.d(1), h = null), (!p || M[0] & /*$storeTitle*/
      128) && n !== (n = K(
        /*$storeTitle*/
        I[7]
      ) + "") && be(l, n), M[0] & /*displayHeaderTitle*/
      16 && G(
        s,
        "display",
        /*displayHeaderTitle*/
        I[4]
      ), M[0] & /*buttonsLeft*/
      2) {
        _ = ue(
          /*buttonsLeft*/
          I[1]
        );
        let L;
        for (L = 0; L < _.length; L += 1) {
          const B = eO(I, _, L);
          y[L] ? (y[L].p(B, M), w(y[L], 1)) : (y[L] = sO(B), y[L].c(), w(y[L], 1), y[L].m(e, o));
        }
        for (ae(), L = _.length; L < y.length; L += 1)
          v(L);
        ce();
      }
      if (M[0] & /*buttonsRight*/
      4) {
        k = ue(
          /*buttonsRight*/
          I[2]
        );
        let L;
        for (L = 0; L < k.length; L += 1) {
          const B = x3(I, k, L);
          S[L] ? (S[L].p(B, M), w(S[L], 1)) : (S[L] = nO(B), S[L].c(), w(S[L], 1), S[L].m(e, null));
        }
        for (ae(), L = k.length; L < S.length; L += 1)
          D(L);
        ce();
      }
      f && $t(f.update) && M[0] & /*dragOptions*/
      8 && f.update.call(
        null,
        /*dragOptions*/
        I[3]
      ), d && $t(d.update) && M[0] & /*$storeMinimizable*/
      32 && d.update.call(
        null,
        /*$storeMinimizable*/
        I[5]
      );
    },
    i(I) {
      if (!p) {
        for (let M = 0; M < _.length; M += 1)
          w(y[M]);
        for (let M = 0; M < k.length; M += 1)
          w(S[M]);
        p = !0;
      }
    },
    o(I) {
      y = y.filter(Boolean);
      for (let M = 0; M < y.length; M += 1)
        O(y[M]);
      S = S.filter(Boolean);
      for (let M = 0; M < S.length; M += 1)
        O(S[M]);
      p = !1;
    },
    d(I) {
      I && C(e), h && h.d(), Le(y, I), Le(S, I), m = !1, Me(g);
    }
  };
}
u(iO, "create_key_block$6");
function wz(i) {
  let e = (
    /*draggable*/
    i[0]
  ), t, s, n = iO(i);
  return {
    c() {
      n.c(), t = $e();
    },
    m(l, r) {
      n.m(l, r), T(l, t, r), s = !0;
    },
    p(l, r) {
      r[0] & /*draggable*/
      1 && le(e, e = /*draggable*/
      l[0]) ? (ae(), O(n, 1, 1, se), ce(), n = iO(l), n.c(), w(n, 1), n.m(t.parentNode, t)) : n.p(l, r);
    },
    i(l) {
      s || (w(n), s = !0);
    },
    o(l) {
      O(n), s = !1;
    },
    d(l) {
      l && C(t), n.d(l);
    }
  };
}
u(wz, "create_fragment$4J");
function $z(i, e, t) {
  var ke;
  let s, n, l, r, o, a, c, f, d, p, { draggable: m = void 0 } = e, { draggableOptions: g = void 0 } = e;
  const h = (ke = de("#external")) == null ? void 0 : ke.application, { focusAuto: _, focusKeep: y } = h.reactive.storeAppOptions;
  pe(i, _, (ee) => t(26, n = ee)), pe(i, y, (ee) => t(25, s = ee));
  const { elementRoot: v } = de("#internal").stores;
  pe(i, v, (ee) => t(27, l = ee));
  const k = h.reactive.storeAppOptions.title;
  pe(i, k, (ee) => t(7, p = ee));
  const S = h.reactive.storeAppOptions.draggable;
  pe(i, S, (ee) => t(24, c = ee));
  const D = h.reactive.storeUIState.dragging, I = h.reactive.storeUIState.headerButtons;
  pe(i, I, (ee) => t(21, r = ee));
  const M = h.reactive.storeAppOptions.headerIcon;
  pe(i, M, (ee) => t(6, d = ee));
  const L = h.reactive.storeAppOptions.headerNoTitleMinimized;
  pe(i, L, (ee) => t(23, a = ee));
  const B = h.reactive.storeAppOptions.minimizable;
  pe(i, B, (ee) => t(5, f = ee));
  const z = h.reactive.storeUIState.minimized;
  pe(i, z, (ee) => t(22, o = ee));
  const q = Object.freeze(["tjs-app-icon", "tjs-window-header-spacer", "window-header", "window-title"]);
  let U, H, V, Y;
  function J(ee, ne) {
    const Ee = /* @__PURE__ */ u((me) => {
      (me.target.classList.contains("window-title") || me.target.classList.contains("window-header") || me.target.classList.contains("keep-minimized")) && h._onToggleMinimize(me);
    }, "callback");
    function Pe() {
      ee.addEventListener("dblclick", Ee);
    }
    u(Pe, "activateListeners");
    function ye() {
      ee.removeEventListener("dblclick", Ee);
    }
    return u(ye, "removeListeners"), ne && Pe(), {
      update: /* @__PURE__ */ u((me) => {
        me ? Pe() : ye();
      }, "update"),
      destroy: /* @__PURE__ */ u(() => ye(), "destroy")
    };
  }
  u(J, "minimizable");
  function fe(ee) {
    const ne = l;
    if (h.position.animate.cancel(), n && ot.isFocusTarget(ne) && (ne != null && ne.isConnected))
      if (s) {
        const Ee = h.reactive.activeWindow;
        ot.isFocusTarget(Ee.document.activeElement) && !ne.contains(Ee.document.activeElement) ? ne.focus() : ee.preventDefault();
      } else
        ne.focus();
  }
  return u(fe, "onPointerdown"), i.$$set = (ee) => {
    "draggable" in ee && t(0, m = ee.draggable), "draggableOptions" in ee && t(20, g = ee.draggableOptions);
  }, i.$$.update = () => {
    if (i.$$.dirty[0] & /*draggable*/
    1 && t(0, m = typeof m == "function" ? m : TL), i.$$.dirty[0] & /*draggableOptions, $storeDraggable*/
    17825792 && t(3, U = Object.assign(
      {},
      {
        tween: !0,
        tweenOptions: { duration: 0.06, ease: "cubicOut" }
      },
      he(g) ? g : {},
      {
        position: h.position,
        enabled: c,
        storeDragging: D,
        hasTargetClassList: q
      }
    )), i.$$.dirty[0] & /*$storeHeaderNoTitleMinimized, $storeMinimized*/
    12582912 && t(4, H = a && o ? "none" : null), i.$$.dirty[0] & /*$storeHeaderButtons, buttonsLeft, buttonsRight*/
    2097158) {
      t(1, V = []), t(2, Y = []);
      for (const ee of r)
        (typeof (ee == null ? void 0 : ee.alignLeft) == "boolean" && (ee != null && ee.alignLeft) ? V : Y).push(mi.isConfig(ee == null ? void 0 : ee.svelte) ? { ...ee.svelte } : {
          class: G1,
          props: { button: ee }
        });
    }
  }, [
    m,
    V,
    Y,
    U,
    H,
    f,
    d,
    p,
    _,
    y,
    v,
    k,
    S,
    I,
    M,
    L,
    B,
    z,
    J,
    fe,
    g,
    r,
    o,
    a,
    c
  ];
}
u($z, "instance$4A");
const Bw = class Bw extends re {
  constructor(e) {
    super(), oe(this, e, $z, wz, le, { draggable: 0, draggableOptions: 20 }, null, [-1, -1]);
  }
};
u(Bw, "TJSApplicationHeader");
let rp = Bw;
function Az(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("div"), e.innerHTML = '<i class="fas fa-arrows-alt-h svelte-gtiiil"></i>', b(e, "class", "window-resizable-handle svelte-gtiiil");
    },
    m(l, r) {
      T(l, e, r), i[11](e), s || (n = [
        W(
          e,
          "pointerdown",
          /*onPointerdown*/
          i[6]
        ),
        Et(t = /*resizable*/
        i[7].call(null, e, {
          active: (
            /*$storeResizable*/
            i[1]
          ),
          storeResizing: (
            /*storeResizing*/
            i[5]
          )
        }))
      ], s = !0);
    },
    p(l, [r]) {
      t && $t(t.update) && r & /*$storeResizable*/
      2 && t.update.call(null, {
        active: (
          /*$storeResizable*/
          l[1]
        ),
        storeResizing: (
          /*storeResizing*/
          l[5]
        )
      });
    },
    i: se,
    o: se,
    d(l) {
      l && C(e), i[11](null), s = !1, Me(n);
    }
  };
}
u(Az, "create_fragment$4I");
function Ez(i, e, t) {
  var _;
  let s, n, l, { isResizable: r = !1 } = e;
  const o = (_ = de("#external")) == null ? void 0 : _.application, a = de("#internal").stores.elementRoot;
  pe(i, a, (y) => t(9, s = y));
  const c = o.reactive.storeAppOptions.resizable;
  pe(i, c, (y) => t(1, l = y));
  const f = o.reactive.storeUIState.minimized;
  pe(i, f, (y) => t(10, n = y));
  const d = o.reactive.storeUIState.resizing;
  let p;
  function m() {
    o.position.animate.cancel();
  }
  u(m, "onPointerdown");
  function g(y, { active: v = !0, storeResizing: k = void 0 } = {}) {
    let S = null, D = {}, I = !1;
    const M = {
      resizeDown: ["pointerdown", (H) => z(H), !1],
      resizeMove: ["pointermove", (H) => q(H), !1],
      resizeUp: ["pointerup", (H) => U(H), !1]
    };
    function L() {
      y.addEventListener(...M.resizeDown), t(8, r = !0), y.style.display = "block";
    }
    u(L, "activateListeners");
    function B() {
      typeof (k == null ? void 0 : k.set) == "function" && k.set(!1), y.removeEventListener(...M.resizeDown), y.removeEventListener(...M.resizeMove), y.removeEventListener(...M.resizeUp), y.style.display = "none", t(8, r = !1);
    }
    u(B, "removeListeners"), v ? L() : y.style.display = "none";
    function z(H) {
      H.preventDefault(), I = !1, S = o.position.get(), S.height === "auto" && (S.height = s.clientHeight), S.width === "auto" && (S.width = s.clientWidth), D = { x: H.clientX, y: H.clientY }, y.addEventListener(...M.resizeMove), y.addEventListener(...M.resizeUp), y.setPointerCapture(H.pointerId);
    }
    u(z, "onResizePointerDown");
    function q(H) {
      H.preventDefault(), !I && typeof (k == null ? void 0 : k.set) == "function" && (I = !0, k.set(!0)), o.position.set({
        width: S.width + (H.clientX - D.x),
        height: S.height + (H.clientY - D.y)
      });
    }
    u(q, "onResizePointerMove");
    function U(H) {
      var V;
      I = !1, typeof (k == null ? void 0 : k.set) == "function" && k.set(!1), H.preventDefault(), y.removeEventListener(...M.resizeMove), y.removeEventListener(...M.resizeUp), (V = o == null ? void 0 : o._onResize) == null || V.call(o, H);
    }
    return u(U, "onResizePointerUp"), {
      update: /* @__PURE__ */ u(({ active: H }) => {
        H ? L() : B();
      }, "update"),
      destroy: /* @__PURE__ */ u(() => B(), "destroy")
    };
  }
  u(g, "resizable");
  function h(y) {
    rt[y ? "unshift" : "push"](() => {
      p = y, t(0, p), t(8, r), t(10, n), t(9, s);
    });
  }
  return u(h, "div_binding"), i.$$set = (y) => {
    "isResizable" in y && t(8, r = y.isResizable);
  }, i.$$.update = () => {
    if (i.$$.dirty & /*elementResize, isResizable, $storeMinimized, $storeElementRoot*/
    1793 && p) {
      t(0, p.style.display = r && !n ? "block" : "none", p);
      const y = s;
      y && y.classList[r ? "add" : "remove"]("resizable");
    }
  }, [
    p,
    l,
    a,
    c,
    f,
    d,
    m,
    g,
    r,
    s,
    n,
    h
  ];
}
u(Ez, "instance$4z");
const qw = class qw extends re {
  constructor(e) {
    super(), oe(this, e, Ez, Az, le, { isResizable: 8 });
  }
};
u(qw, "ResizableHandle");
let op = qw;
function Sz(i) {
  let e, t, s;
  return {
    c() {
      e = E("div"), b(e, "class", "tjs-focus-wrap svelte-kjcljd"), b(e, "tabindex", "0");
    },
    m(n, l) {
      T(n, e, l), i[4](e), t || (s = W(
        e,
        "focus",
        /*onFocus*/
        i[1]
      ), t = !0);
    },
    p: se,
    i: se,
    o: se,
    d(n) {
      n && C(e), i[4](null), t = !1, s();
    }
  };
}
u(Sz, "create_fragment$4H");
function Cz(i, e, t) {
  let { elementRoot: s = void 0 } = e, { enabled: n = !0 } = e, l, r;
  function o() {
    if (n && ot.isFocusTarget(s)) {
      const c = ot.getFirstFocusableElement(s, l);
      ot.isFocusTarget(c) && c !== r ? c.focus() : s.focus();
    }
  }
  u(o, "onFocus");
  function a(c) {
    rt[c ? "unshift" : "push"](() => {
      r = c, t(0, r);
    });
  }
  return u(a, "div_binding"), i.$$set = (c) => {
    "elementRoot" in c && t(2, s = c.elementRoot), "enabled" in c && t(3, n = c.enabled);
  }, i.$$.update = () => {
    i.$$.dirty & /*wrapEl*/
    1 && r && (l = /* @__PURE__ */ new Set([r]));
  }, [r, o, s, n, a];
}
u(Cz, "instance$4y");
var Oa;
let jL = (Oa = class extends re {
  constructor(e) {
    super(), oe(this, e, Cz, Sz, le, { elementRoot: 2, enabled: 3 });
  }
}, u(Oa, "TJSFocusWrap"), Oa);
function Tz(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y;
  t = new rp({
    props: {
      draggable: (
        /*draggable*/
        i[6]
      ),
      draggableOptions: (
        /*draggableOptions*/
        i[7]
      )
    }
  });
  const v = (
    /*#slots*/
    i[37].default
  ), k = Gt(
    v,
    i,
    /*$$scope*/
    i[36],
    null
  );
  return o = new op({}), c = new jL({
    props: {
      elementRoot: (
        /*elementRoot*/
        i[1]
      ),
      enabled: (
        /*focusWrapEnabled*/
        i[11]
      )
    }
  }), {
    c() {
      e = E("div"), j(t.$$.fragment), s = F(), n = E("section"), k && k.c(), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment), b(n, "class", "window-content svelte-90z1oq"), b(n, "tabindex", "-1"), b(e, "id", f = /*application*/
      i[10].id), b(e, "class", d = "app window-app " + /*application*/
      i[10].options.classes.join(" ") + " svelte-90z1oq"), b(e, "data-appid", p = /*application*/
      i[10].appId), b(e, "role", "application"), b(e, "tabindex", "-1");
    },
    m(S, D) {
      T(S, e, D), R(t, e, null), A(e, s), A(e, n), k && k.m(n, null), i[40](n), A(e, r), R(o, e, null), A(e, a), R(c, e, null), i[41](e), h = !0, _ || (y = [
        W(
          n,
          "pointerdown",
          /*onPointerdownContent*/
          i[22]
        ),
        Et(l = Xs.call(
          null,
          n,
          /*stylesContent*/
          i[9]
        )),
        Et(
          /*contentResizeObserver*/
          i[18].call(
            null,
            n,
            /*resizeObservedContent*/
            i[23]
          )
        ),
        W(e, "close:popup", Ve(st(
          /*onClosePopup*/
          i[19]
        ))),
        W(
          e,
          "keydown",
          /*onKeydown*/
          i[20],
          !0
        ),
        W(
          e,
          "pointerdown",
          /*onPointerdownApp*/
          i[21]
        ),
        Et(m = Xs.call(
          null,
          e,
          /*stylesApp*/
          i[8]
        )),
        Et(g = NL.call(
          null,
          e,
          /*appResizeObserver*/
          i[12]
        ))
      ], _ = !0);
    },
    p(S, D) {
      const I = {};
      D[0] & /*draggable*/
      64 && (I.draggable = /*draggable*/
      S[6]), D[0] & /*draggableOptions*/
      128 && (I.draggableOptions = /*draggableOptions*/
      S[7]), t.$set(I), k && k.p && (!h || D[1] & /*$$scope*/
      32) && Ht(
        k,
        v,
        S,
        /*$$scope*/
        S[36],
        h ? zt(
          v,
          /*$$scope*/
          S[36],
          D,
          null
        ) : Ut(
          /*$$scope*/
          S[36]
        ),
        null
      ), l && $t(l.update) && D[0] & /*stylesContent*/
      512 && l.update.call(
        null,
        /*stylesContent*/
        S[9]
      );
      const M = {};
      D[0] & /*elementRoot*/
      2 && (M.elementRoot = /*elementRoot*/
      S[1]), D[0] & /*focusWrapEnabled*/
      2048 && (M.enabled = /*focusWrapEnabled*/
      S[11]), c.$set(M), (!h || D[0] & /*application*/
      1024 && f !== (f = /*application*/
      S[10].id)) && b(e, "id", f), (!h || D[0] & /*application*/
      1024 && d !== (d = "app window-app " + /*application*/
      S[10].options.classes.join(" ") + " svelte-90z1oq")) && b(e, "class", d), (!h || D[0] & /*application*/
      1024 && p !== (p = /*application*/
      S[10].appId)) && b(e, "data-appid", p), m && $t(m.update) && D[0] & /*stylesApp*/
      256 && m.update.call(
        null,
        /*stylesApp*/
        S[8]
      ), g && $t(g.update) && D[0] & /*appResizeObserver*/
      4096 && g.update.call(
        null,
        /*appResizeObserver*/
        S[12]
      );
    },
    i(S) {
      h || (w(t.$$.fragment, S), w(k, S), w(o.$$.fragment, S), w(c.$$.fragment, S), h = !0);
    },
    o(S) {
      O(t.$$.fragment, S), O(k, S), O(o.$$.fragment, S), O(c.$$.fragment, S), h = !1;
    },
    d(S) {
      S && C(e), N(t), k && k.d(S), i[40](null), N(o), N(c), i[41](null), _ = !1, Me(y);
    }
  };
}
u(Tz, "create_else_block$N");
function Oz(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k;
  t = new rp({
    props: {
      draggable: (
        /*draggable*/
        i[6]
      ),
      draggableOptions: (
        /*draggableOptions*/
        i[7]
      )
    }
  });
  const S = (
    /*#slots*/
    i[37].default
  ), D = Gt(
    S,
    i,
    /*$$scope*/
    i[36],
    null
  );
  return o = new op({}), c = new jL({
    props: { elementRoot: (
      /*elementRoot*/
      i[1]
    ) }
  }), {
    c() {
      e = E("div"), j(t.$$.fragment), s = F(), n = E("section"), D && D.c(), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment), b(n, "class", "window-content svelte-90z1oq"), b(n, "tabindex", "-1"), b(e, "id", f = /*application*/
      i[10].id), b(e, "class", d = "app window-app " + /*application*/
      i[10].options.classes.join(" ") + " svelte-90z1oq"), b(e, "data-appid", p = /*application*/
      i[10].appId), b(e, "role", "application"), b(e, "tabindex", "-1");
    },
    m(I, M) {
      T(I, e, M), R(t, e, null), A(e, s), A(e, n), D && D.m(n, null), i[38](n), A(e, r), R(o, e, null), A(e, a), R(c, e, null), i[39](e), y = !0, v || (k = [
        W(
          n,
          "pointerdown",
          /*onPointerdownContent*/
          i[22]
        ),
        Et(l = Xs.call(
          null,
          n,
          /*stylesContent*/
          i[9]
        )),
        Et(
          /*contentResizeObserver*/
          i[18].call(
            null,
            n,
            /*resizeObservedContent*/
            i[23]
          )
        ),
        W(e, "close:popup", Ve(st(
          /*onClosePopup*/
          i[19]
        ))),
        W(
          e,
          "keydown",
          /*onKeydown*/
          i[20],
          !0
        ),
        W(
          e,
          "pointerdown",
          /*onPointerdownApp*/
          i[21]
        ),
        Et(m = Xs.call(
          null,
          e,
          /*stylesApp*/
          i[8]
        )),
        Et(g = NL.call(
          null,
          e,
          /*appResizeObserver*/
          i[12]
        ))
      ], v = !0);
    },
    p(I, M) {
      i = I;
      const L = {};
      M[0] & /*draggable*/
      64 && (L.draggable = /*draggable*/
      i[6]), M[0] & /*draggableOptions*/
      128 && (L.draggableOptions = /*draggableOptions*/
      i[7]), t.$set(L), D && D.p && (!y || M[1] & /*$$scope*/
      32) && Ht(
        D,
        S,
        i,
        /*$$scope*/
        i[36],
        y ? zt(
          S,
          /*$$scope*/
          i[36],
          M,
          null
        ) : Ut(
          /*$$scope*/
          i[36]
        ),
        null
      ), l && $t(l.update) && M[0] & /*stylesContent*/
      512 && l.update.call(
        null,
        /*stylesContent*/
        i[9]
      );
      const B = {};
      M[0] & /*elementRoot*/
      2 && (B.elementRoot = /*elementRoot*/
      i[1]), c.$set(B), (!y || M[0] & /*application*/
      1024 && f !== (f = /*application*/
      i[10].id)) && b(e, "id", f), (!y || M[0] & /*application*/
      1024 && d !== (d = "app window-app " + /*application*/
      i[10].options.classes.join(" ") + " svelte-90z1oq")) && b(e, "class", d), (!y || M[0] & /*application*/
      1024 && p !== (p = /*application*/
      i[10].appId)) && b(e, "data-appid", p), m && $t(m.update) && M[0] & /*stylesApp*/
      256 && m.update.call(
        null,
        /*stylesApp*/
        i[8]
      ), g && $t(g.update) && M[0] & /*appResizeObserver*/
      4096 && g.update.call(
        null,
        /*appResizeObserver*/
        i[12]
      );
    },
    i(I) {
      y || (w(t.$$.fragment, I), w(D, I), w(o.$$.fragment, I), w(c.$$.fragment, I), ks(() => {
        y && (_ && _.end(1), h = og(
          e,
          /*inTransition*/
          i[2],
          /*inTransitionOptions*/
          i[4]
        ), h.start());
      }), y = !0);
    },
    o(I) {
      O(t.$$.fragment, I), O(D, I), O(o.$$.fragment, I), O(c.$$.fragment, I), h && h.invalidate(), _ = ag(
        e,
        /*outTransition*/
        i[3],
        /*outTransitionOptions*/
        i[5]
      ), y = !1;
    },
    d(I) {
      I && C(e), N(t), D && D.d(I), i[38](null), N(o), N(c), i[39](null), I && _ && _.end(), v = !1, Me(k);
    }
  };
}
u(Oz, "create_if_block$2x");
function Dz(i) {
  let e, t, s, n;
  const l = [Oz, Tz], r = [];
  function o(a, c) {
    return (
      /*inTransition*/
      a[2] !== fs.default || /*outTransition*/
      a[3] !== fs.default ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(Dz, "create_fragment$4G");
function Iz(i, e, t) {
  var Se;
  let s, n, l, r, o, a, { $$slots: c = {}, $$scope: f } = e, { elementContent: d = void 0 } = e, { elementRoot: p = void 0 } = e, { draggable: m = void 0 } = e, { draggableOptions: g = void 0 } = e, { stylesApp: h = void 0 } = e, { stylesContent: _ = void 0 } = e;
  const y = (Se = de("#external")) == null ? void 0 : Se.application, { focusAuto: v, focusKeep: k, focusTrap: S } = y.reactive.storeAppOptions;
  pe(i, v, (_e) => t(32, l = _e)), pe(i, k, (_e) => t(42, n = _e)), pe(i, S, (_e) => t(34, o = _e));
  const { minimized: D } = y.reactive.storeUIState;
  pe(i, D, (_e) => t(33, r = _e));
  const { resizeObservable: I } = y.position.stores;
  pe(i, I, (_e) => t(35, a = _e));
  let { appOffsetHeight: M = !1 } = e, { appOffsetWidth: L = !1 } = e;
  const B = !!M || !!L;
  let { contentOffsetHeight: z = !1 } = e, { contentOffsetWidth: q = !1 } = e;
  const U = z || q ? B1 : () => null, H = new q1(), V = { ignoreClasses: ["tjs-focus-wrap"] };
  lt("#internal", H);
  let Y, { transition: J = fs.default } = e, { inTransition: fe = fs.default } = e, { outTransition: ke = fs.default } = e, { transitionOptions: ee = void 0 } = e, { inTransitionOptions: ne = fs.options } = e, { outTransitionOptions: Ee = fs.options } = e, Pe = fs.default, ye;
  $o(() => p.focus());
  function me(_e) {
    var xe;
    if (!l)
      return;
    const we = (xe = _e == null ? void 0 : _e.detail) == null ? void 0 : xe.target;
    if (!ot.isFocusTarget(we) || ot.isFocusable(we))
      return;
    const Fe = p.contains(we);
    we === p ? p.focus() : we === d ? d.focus() : Fe && (d.contains(we) ? d.focus() : p.focus());
  }
  u(me, "onClosePopup");
  function Ce(_e) {
    var we, Fe, xe, vt, ps, As;
    if ((_e.target === p || _e.target === d) && KeyboardManager && ((xe = (Fe = KeyboardManager == null ? void 0 : KeyboardManager._getMatchingActions) == null ? void 0 : Fe.call(KeyboardManager, (we = KeyboardManager == null ? void 0 : KeyboardManager.getKeyboardEventContext) == null ? void 0 : we.call(KeyboardManager, _e))) != null && xe.length)) {
      (vt = _e.target) == null || vt.blur();
      return;
    }
    if (Y && _e.shiftKey && _e.code === "Tab") {
      const zs = ot.getFocusableElements(p, V), sn = zs.length > 0 ? zs[0] : void 0, St = zs.length > 0 ? zs[zs.length - 1] : void 0, ws = y.reactive.activeWindow;
      (p === ws.document.activeElement || sn === ws.document.activeElement) && (ot.isFocusTarget(St) && sn !== St && St.focus(), _e.preventDefault(), _e.stopPropagation());
    }
    typeof ((ps = y == null ? void 0 : y.options) == null ? void 0 : ps.popOut) == "boolean" && y.options.popOut && y !== ((As = globalThis.ui) == null ? void 0 : As.activeWindow) && y.bringToTop.call(y);
  }
  u(Ce, "onKeydown");
  function Je() {
    var _e, we;
    typeof ((_e = y == null ? void 0 : y.options) == null ? void 0 : _e.popOut) == "boolean" && y.options.popOut && y !== ((we = globalThis.ui) == null ? void 0 : we.activeWindow) && y.bringToTop.call(y);
  }
  u(Je, "onPointerdownApp");
  function Ne(_e) {
    if (!ot.isFocusable(_e.target) && l)
      if (n) {
        const Fe = y.reactive.activeWindow;
        !p.contains(Fe.document.activeElement) ? d.focus() : _e.preventDefault();
      } else
        d.focus();
  }
  u(Ne, "onPointerdownContent");
  function Re(_e, we) {
    t(27, q = _e), t(26, z = we);
  }
  u(Re, "resizeObservedContent");
  function ge(_e, we, Fe, xe) {
    y.position.stores.resizeObserved.update((vt) => (vt.contentWidth = Fe, vt.contentHeight = xe, vt.offsetWidth = _e, vt.offsetHeight = we, vt)), t(24, M = we), t(25, L = _e);
  }
  u(ge, "resizeObservedApp");
  function je(_e) {
    rt[_e ? "unshift" : "push"](() => {
      d = _e, t(0, d);
    });
  }
  u(je, "section_binding");
  function Be(_e) {
    rt[_e ? "unshift" : "push"](() => {
      p = _e, t(1, p);
    });
  }
  u(Be, "div_binding");
  function Ze(_e) {
    rt[_e ? "unshift" : "push"](() => {
      d = _e, t(0, d);
    });
  }
  u(Ze, "section_binding_1");
  function Ge(_e) {
    rt[_e ? "unshift" : "push"](() => {
      p = _e, t(1, p);
    });
  }
  return u(Ge, "div_binding_1"), i.$$set = (_e) => {
    "elementContent" in _e && t(0, d = _e.elementContent), "elementRoot" in _e && t(1, p = _e.elementRoot), "draggable" in _e && t(6, m = _e.draggable), "draggableOptions" in _e && t(7, g = _e.draggableOptions), "stylesApp" in _e && t(8, h = _e.stylesApp), "stylesContent" in _e && t(9, _ = _e.stylesContent), "appOffsetHeight" in _e && t(24, M = _e.appOffsetHeight), "appOffsetWidth" in _e && t(25, L = _e.appOffsetWidth), "contentOffsetHeight" in _e && t(26, z = _e.contentOffsetHeight), "contentOffsetWidth" in _e && t(27, q = _e.contentOffsetWidth), "transition" in _e && t(28, J = _e.transition), "inTransition" in _e && t(2, fe = _e.inTransition), "outTransition" in _e && t(3, ke = _e.outTransition), "transitionOptions" in _e && t(29, ee = _e.transitionOptions), "inTransitionOptions" in _e && t(4, ne = _e.inTransitionOptions), "outTransitionOptions" in _e && t(5, Ee = _e.outTransitionOptions), "$$scope" in _e && t(36, f = _e.$$scope);
  }, i.$$.update = () => {
    var _e;
    if (i.$$.dirty[1] & /*$resizeObservable*/
    16 && t(12, s = B || a ? {
      action: B1,
      data: ge
    } : void 0), i.$$.dirty[0] & /*elementContent*/
    1 && d != null && de("#internal").stores.elementContent.set(d), i.$$.dirty[0] & /*elementRoot*/
    2 && p != null && de("#internal").stores.elementRoot.set(p), i.$$.dirty[1] & /*$focusAuto, $focusTrap, $minimized*/
    14 && t(11, Y = l && o && !r), i.$$.dirty[0] & /*oldTransition, transition*/
    1342177280 && Pe !== J) {
      const we = typeof J == "function" ? J : fs.default;
      t(2, fe = we), t(3, ke = we), t(30, Pe = we);
    }
    if (i.$$.dirty[0] & /*transitionOptions*/
    536870912 | i.$$.dirty[1] & /*oldTransitionOptions*/
    1 && ye !== ee) {
      const we = ee !== fs.options && he(ee) ? ee : fs.options;
      t(4, ne = we), t(5, Ee = we), t(31, ye = we);
    }
    if (i.$$.dirty[0] & /*inTransition*/
    4 && typeof fe != "function" && t(2, fe = fs.default), i.$$.dirty[0] & /*outTransition, application*/
    1032) {
      typeof ke != "function" && t(3, ke = fs.default);
      const we = (_e = y == null ? void 0 : y.options) == null ? void 0 : _e.defaultCloseAnimation;
      typeof we == "boolean" && we && ke !== fs.default && t(10, y.options.defaultCloseAnimation = !1, y);
    }
    i.$$.dirty[0] & /*inTransitionOptions*/
    16 && (he(ne) || t(4, ne = fs.options)), i.$$.dirty[0] & /*outTransitionOptions*/
    32 && (he(Ee) || t(5, Ee = fs.options));
  }, [
    d,
    p,
    fe,
    ke,
    ne,
    Ee,
    m,
    g,
    h,
    _,
    y,
    Y,
    s,
    v,
    k,
    S,
    D,
    I,
    U,
    me,
    Ce,
    Je,
    Ne,
    Re,
    M,
    L,
    z,
    q,
    J,
    ee,
    Pe,
    ye,
    l,
    r,
    o,
    a,
    f,
    c,
    je,
    Be,
    Ze,
    Ge
  ];
}
u(Iz, "instance$4x");
const Gw = class Gw extends re {
  constructor(e) {
    super(), oe(
      this,
      e,
      Iz,
      Dz,
      le,
      {
        elementContent: 0,
        elementRoot: 1,
        draggable: 6,
        draggableOptions: 7,
        stylesApp: 8,
        stylesContent: 9,
        appOffsetHeight: 24,
        appOffsetWidth: 25,
        contentOffsetHeight: 26,
        contentOffsetWidth: 27,
        transition: 28,
        inTransition: 2,
        outTransition: 3,
        transitionOptions: 29,
        inTransitionOptions: 4,
        outTransitionOptions: 5
      },
      null,
      [-1, -1]
    );
  }
  get elementContent() {
    return this.$$.ctx[0];
  }
  set elementContent(e) {
    this.$$set({ elementContent: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[1];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
  get draggable() {
    return this.$$.ctx[6];
  }
  set draggable(e) {
    this.$$set({ draggable: e }), Xe();
  }
  get draggableOptions() {
    return this.$$.ctx[7];
  }
  set draggableOptions(e) {
    this.$$set({ draggableOptions: e }), Xe();
  }
  get stylesApp() {
    return this.$$.ctx[8];
  }
  set stylesApp(e) {
    this.$$set({ stylesApp: e }), Xe();
  }
  get stylesContent() {
    return this.$$.ctx[9];
  }
  set stylesContent(e) {
    this.$$set({ stylesContent: e }), Xe();
  }
  get appOffsetHeight() {
    return this.$$.ctx[24];
  }
  set appOffsetHeight(e) {
    this.$$set({ appOffsetHeight: e }), Xe();
  }
  get appOffsetWidth() {
    return this.$$.ctx[25];
  }
  set appOffsetWidth(e) {
    this.$$set({ appOffsetWidth: e }), Xe();
  }
  get contentOffsetHeight() {
    return this.$$.ctx[26];
  }
  set contentOffsetHeight(e) {
    this.$$set({ contentOffsetHeight: e }), Xe();
  }
  get contentOffsetWidth() {
    return this.$$.ctx[27];
  }
  set contentOffsetWidth(e) {
    this.$$set({ contentOffsetWidth: e }), Xe();
  }
  get transition() {
    return this.$$.ctx[28];
  }
  set transition(e) {
    this.$$set({ transition: e }), Xe();
  }
  get inTransition() {
    return this.$$.ctx[2];
  }
  set inTransition(e) {
    this.$$set({ inTransition: e }), Xe();
  }
  get outTransition() {
    return this.$$.ctx[3];
  }
  set outTransition(e) {
    this.$$set({ outTransition: e }), Xe();
  }
  get transitionOptions() {
    return this.$$.ctx[29];
  }
  set transitionOptions(e) {
    this.$$set({ transitionOptions: e }), Xe();
  }
  get inTransitionOptions() {
    return this.$$.ctx[4];
  }
  set inTransitionOptions(e) {
    this.$$set({ inTransitionOptions: e }), Xe();
  }
  get outTransitionOptions() {
    return this.$$.ctx[5];
  }
  set outTransitionOptions(e) {
    this.$$set({ outTransitionOptions: e }), Xe();
  }
};
u(Gw, "ApplicationShell");
let Js = Gw;
function Pz(i) {
  let e, t, s, n, l, r, o;
  const a = (
    /*#slots*/
    i[20].default
  ), c = Gt(
    a,
    i,
    /*$$scope*/
    i[19],
    null
  );
  return {
    c() {
      e = E("div"), c && c.c(), b(e, "class", "tjs-glass-pane-background tjs-glass-pane-container svelte-hqedxf"), G(
        e,
        "background",
        /*background*/
        i[5]
      );
    },
    m(f, d) {
      T(f, e, d), c && c.m(e, null), i[26](e), l = !0, r || (o = Et(t = Xs.call(
        null,
        e,
        /*styles*/
        i[7]
      )), r = !0);
    },
    p(f, d) {
      i = f, c && c.p && (!l || d & /*$$scope*/
      524288) && Ht(
        c,
        a,
        i,
        /*$$scope*/
        i[19],
        l ? zt(
          a,
          /*$$scope*/
          i[19],
          d,
          null
        ) : Ut(
          /*$$scope*/
          i[19]
        ),
        null
      ), t && $t(t.update) && d & /*styles*/
      128 && t.update.call(
        null,
        /*styles*/
        i[7]
      ), d & /*background*/
      32 && G(
        e,
        "background",
        /*background*/
        i[5]
      );
    },
    i(f) {
      l || (w(c, f), ks(() => {
        l && (n && n.end(1), s = og(
          e,
          /*inTransition*/
          i[1],
          /*inTransitionOptions*/
          i[3]
        ), s.start());
      }), l = !0);
    },
    o(f) {
      O(c, f), s && s.invalidate(), n = ag(
        e,
        /*outTransition*/
        i[2],
        /*outTransitionOptions*/
        i[4]
      ), l = !1;
    },
    d(f) {
      f && C(e), c && c.d(f), i[26](null), f && n && n.end(), r = !1, o();
    }
  };
}
u(Pz, "create_else_block$M");
function Mz(i) {
  let e, t, s, n, l, r, o, a, c;
  const f = (
    /*#slots*/
    i[20].default
  ), d = Gt(
    f,
    i,
    /*$$scope*/
    i[19],
    null
  );
  return {
    c() {
      e = E("div"), l = F(), r = E("div"), d && d.c(), b(e, "class", "tjs-glass-pane-background svelte-hqedxf"), G(
        e,
        "background",
        /*background*/
        i[5]
      ), b(r, "class", "tjs-glass-pane-container svelte-hqedxf");
    },
    m(p, m) {
      T(p, e, m), i[24](e), T(p, l, m), T(p, r, m), d && d.m(r, null), i[25](r), o = !0, a || (c = Et(t = Xs.call(
        null,
        e,
        /*styles*/
        i[7]
      )), a = !0);
    },
    p(p, m) {
      i = p, t && $t(t.update) && m & /*styles*/
      128 && t.update.call(
        null,
        /*styles*/
        i[7]
      ), m & /*background*/
      32 && G(
        e,
        "background",
        /*background*/
        i[5]
      ), d && d.p && (!o || m & /*$$scope*/
      524288) && Ht(
        d,
        f,
        i,
        /*$$scope*/
        i[19],
        o ? zt(
          f,
          /*$$scope*/
          i[19],
          m,
          null
        ) : Ut(
          /*$$scope*/
          i[19]
        ),
        null
      );
    },
    i(p) {
      o || (ks(() => {
        o && (n && n.end(1), s = og(
          e,
          /*inTransition*/
          i[1],
          /*inTransitionOptions*/
          i[3]
        ), s.start());
      }), w(d, p), o = !0);
    },
    o(p) {
      s && s.invalidate(), n = ag(
        e,
        /*outTransition*/
        i[2],
        /*outTransitionOptions*/
        i[4]
      ), O(d, p), o = !1;
    },
    d(p) {
      p && (C(e), C(l), C(r)), i[24](null), p && n && n.end(), d && d.d(p), i[25](null), a = !1, c();
    }
  };
}
u(Mz, "create_if_block$2w");
function Fz(i) {
  let e, t, s, n, l, r;
  const o = [Mz, Pz], a = [];
  function c(f, d) {
    return (
      /*slotSeparate*/
      f[0] ? 0 : 1
    );
  }
  return u(c, "select_block_type"), t = c(i), s = a[t] = o[t](i), {
    c() {
      e = E("div"), s.c(), b(
        e,
        "id",
        /*id*/
        i[6]
      ), b(e, "class", "tjs-glass-pane svelte-hqedxf"), G(
        e,
        "z-index",
        /*zIndex*/
        i[8]
      );
    },
    m(f, d) {
      T(f, e, d), a[t].m(e, null), i[27](e), n = !0, l || (r = [
        W(
          window,
          "contextmenu",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "dblclick",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "keydown",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "keyup",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "mousedown",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "mousemove",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "mouseup",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "pointerdown",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "pointermove",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "pointerup",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "touchend",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "touchmove",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "touchstart",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          window,
          "wheel",
          /*swallow*/
          i[12],
          !0
        ),
        W(
          e,
          "glasspane:close",
          /*glasspane_close_handler*/
          i[21]
        ),
        W(
          e,
          "glasspane:keydown:escape",
          /*glasspane_keydown_escape_handler*/
          i[22]
        ),
        W(
          e,
          "glasspane:pointerdown",
          /*glasspane_pointerdown_handler*/
          i[23]
        )
      ], l = !0);
    },
    p(f, [d]) {
      let p = t;
      t = c(f), t === p ? a[t].p(f, d) : (ae(), O(a[p], 1, 1, () => {
        a[p] = null;
      }), ce(), s = a[t], s ? s.p(f, d) : (s = a[t] = o[t](f), s.c()), w(s, 1), s.m(e, null)), (!n || d & /*id*/
      64) && b(
        e,
        "id",
        /*id*/
        f[6]
      ), d & /*zIndex*/
      256 && G(
        e,
        "z-index",
        /*zIndex*/
        f[8]
      );
    },
    i(f) {
      n || (w(s), n = !0);
    },
    o(f) {
      O(s), n = !1;
    },
    d(f) {
      f && C(e), a[t].d(), i[27](null), l = !1, Me(r);
    }
  };
}
u(Fz, "create_fragment$4F");
function Rz(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e, { background: l = "#50505080" } = e, { captureInput: r = !0 } = e, { closeOnInput: o = void 0 } = e, { id: a = void 0 } = e, { slotSeparate: c = void 0 } = e, { styles: f = void 0 } = e, { zIndex: d = Number.MAX_SAFE_INTEGER } = e, p, m, g, { transition: h = void 0 } = e, { inTransition: _ = void 0 } = e, { outTransition: y = void 0 } = e, { transitionOptions: v = void 0 } = e, { inTransitionOptions: k = fs.options } = e, { outTransitionOptions: S = fs.options } = e, D, I;
  function M(Y) {
    const J = Y.target;
    (Y == null ? void 0 : Y.type) === "keydown" && (Y == null ? void 0 : Y.code) === "Escape" && g.dispatchEvent(new CustomEvent("glasspane:keydown:escape", { bubbles: !0, cancelable: !0 })), !(J !== g && J !== p && J !== m && g.contains(J instanceof Node ? J : null)) && (r && ((Y == null ? void 0 : Y.type) !== "wheel" && Y.preventDefault(), Y.stopImmediatePropagation()), (Y == null ? void 0 : Y.type) === "pointerdown" && (g.dispatchEvent(new CustomEvent("glasspane:pointerdown", { bubbles: !0, cancelable: !0 })), o && g.dispatchEvent(new CustomEvent("glasspane:close", { bubbles: !0, cancelable: !0 }))));
  }
  u(M, "swallow");
  function L(Y) {
    bt.call(this, i, Y);
  }
  u(L, "glasspane_close_handler");
  function B(Y) {
    bt.call(this, i, Y);
  }
  u(B, "glasspane_keydown_escape_handler");
  function z(Y) {
    bt.call(this, i, Y);
  }
  u(z, "glasspane_pointerdown_handler");
  function q(Y) {
    rt[Y ? "unshift" : "push"](() => {
      p = Y, t(9, p);
    });
  }
  u(q, "div0_binding");
  function U(Y) {
    rt[Y ? "unshift" : "push"](() => {
      m = Y, t(10, m);
    });
  }
  u(U, "div1_binding");
  function H(Y) {
    rt[Y ? "unshift" : "push"](() => {
      p = Y, t(9, p);
    });
  }
  u(H, "div_binding");
  function V(Y) {
    rt[Y ? "unshift" : "push"](() => {
      g = Y, t(11, g);
    });
  }
  return u(V, "div_binding_1"), i.$$set = (Y) => {
    "background" in Y && t(5, l = Y.background), "captureInput" in Y && t(13, r = Y.captureInput), "closeOnInput" in Y && t(14, o = Y.closeOnInput), "id" in Y && t(6, a = Y.id), "slotSeparate" in Y && t(0, c = Y.slotSeparate), "styles" in Y && t(7, f = Y.styles), "zIndex" in Y && t(8, d = Y.zIndex), "transition" in Y && t(15, h = Y.transition), "inTransition" in Y && t(1, _ = Y.inTransition), "outTransition" in Y && t(2, y = Y.outTransition), "transitionOptions" in Y && t(16, v = Y.transitionOptions), "inTransitionOptions" in Y && t(3, k = Y.inTransitionOptions), "outTransitionOptions" in Y && t(4, S = Y.outTransitionOptions), "$$scope" in Y && t(19, n = Y.$$scope);
  }, i.$$.update = () => {
    if (i.$$.dirty & /*slotSeparate*/
    1 && t(0, c = typeof c == "boolean" ? c : !1), i.$$.dirty & /*oldTransition, transition*/
    163840 && D !== h) {
      const Y = typeof h == "function" ? h : void 0;
      t(1, _ = Y), t(2, y = Y), t(17, D = Y);
    }
    if (i.$$.dirty & /*oldTransitionOptions, transitionOptions*/
    327680 && I !== v) {
      const Y = v !== fs.options && he(v) ? v : fs.options;
      t(3, k = Y), t(4, S = Y), t(18, I = Y);
    }
    i.$$.dirty & /*inTransition*/
    2 && typeof _ != "function" && t(1, _ = void 0), i.$$.dirty & /*outTransition*/
    4 && typeof y != "function" && t(2, y = void 0), i.$$.dirty & /*inTransitionOptions*/
    8 && (he(k) || t(3, k = fs.options)), i.$$.dirty & /*outTransitionOptions*/
    16 && (he(S) || t(4, S = fs.options));
  }, [
    c,
    _,
    y,
    k,
    S,
    l,
    a,
    f,
    d,
    p,
    m,
    g,
    M,
    r,
    o,
    h,
    v,
    D,
    I,
    n,
    s,
    L,
    B,
    z,
    q,
    U,
    H,
    V
  ];
}
u(Rz, "instance$4w");
const zw = class zw extends re {
  constructor(e) {
    super(), oe(this, e, Rz, Fz, le, {
      background: 5,
      captureInput: 13,
      closeOnInput: 14,
      id: 6,
      slotSeparate: 0,
      styles: 7,
      zIndex: 8,
      transition: 15,
      inTransition: 1,
      outTransition: 2,
      transitionOptions: 16,
      inTransitionOptions: 3,
      outTransitionOptions: 4
    });
  }
};
u(zw, "TJSGlassPane");
let z1 = zw;
bz.setProperties({
  // Anchor text shadow / header buttons
  "--tjs-default-text-shadow-focus-hover": "0 0 8px var(--color-shadow-primary)",
  // TJSApplicationShell app background.
  "--tjs-app-background": `url("${globalThis.foundry.utils.getRoute("/ui/denim075.png")}")`
}, !1);
function lO(i, e, t) {
  const s = i.slice();
  return s[26] = e[t], s;
}
u(lO, "get_each_context$1N");
function Nz(i) {
  let e, t, s;
  const n = [
    /*dialogProps*/
    i[7]
  ];
  var l = (
    /*dialogClass*/
    i[6]
  );
  function r(o, a) {
    let c = {};
    for (let f = 0; f < n.length; f += 1)
      c = Dt(c, n[f]);
    return a !== void 0 && a & /*dialogProps*/
    128 && (c = Dt(c, Vt(n, [Jt(
      /*dialogProps*/
      o[7]
    )]))), { props: c };
  }
  return u(r, "switch_props"), l && (e = et(l, r(i)), i[16](e)), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(o, a) {
      e && R(e, o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a & /*dialogClass*/
      64 && l !== (l = /*dialogClass*/
      o[6])) {
        if (e) {
          ae();
          const c = e;
          O(c.$$.fragment, 1, 0, () => {
            N(c, 1);
          }), ce();
        }
        l ? (e = et(l, r(o, a)), o[16](e), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const c = a & /*dialogProps*/
        128 ? Vt(n, [Jt(
          /*dialogProps*/
          o[7]
        )]) : {};
        e.$set(c);
      }
    },
    i(o) {
      s || (e && w(e.$$.fragment, o), s = !0);
    },
    o(o) {
      e && O(e.$$.fragment, o), s = !1;
    },
    d(o) {
      o && C(t), i[16](null), e && N(e, o);
    }
  };
}
u(Nz, "create_if_block_3$I");
function jz(i) {
  let e, t;
  return {
    c() {
      e = new bn(!1), t = $e(), e.a = t;
    },
    m(s, n) {
      e.m(
        /*content*/
        i[3],
        s,
        n
      ), T(s, t, n);
    },
    p(s, n) {
      n & /*content*/
      8 && e.p(
        /*content*/
        s[3]
      );
    },
    i: se,
    o: se,
    d(s) {
      s && (C(t), e.d());
    }
  };
}
u(jz, "create_if_block_2$15");
function rO(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n = ue(
    /*buttons*/
    i[1]
  );
  const l = /* @__PURE__ */ u((r) => (
    /*button*/
    r[26].id
  ), "get_key");
  for (let r = 0; r < n.length; r += 1) {
    let o = lO(i, n, r), a = l(o);
    s.set(a, t[r] = aO(a, o));
  }
  return {
    c() {
      e = E("div");
      for (let r = 0; r < t.length; r += 1)
        t[r].c();
      b(e, "class", "dialog-buttons tjs-dialog-buttons svelte-1ez4adq");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < t.length; a += 1)
        t[a] && t[a].m(e, null);
      i[20](e);
    },
    p(r, o) {
      o & /*buttons, onClick, currentButtonId*/
      530 && (n = ue(
        /*buttons*/
        r[1]
      ), t = Lt(t, o, l, 1, r, n, s, e, an, aO, null, lO));
    },
    d(r) {
      r && C(e);
      for (let o = 0; o < t.length; o += 1)
        t[o].d();
      i[20](null);
    }
  };
}
u(rO, "create_if_block$2v");
function oO(i) {
  let e, t = (
    /*button*/
    i[26].icon + ""
  ), s;
  return {
    c() {
      e = new bn(!1), s = $e(), e.a = s;
    },
    m(n, l) {
      e.m(t, n, l), T(n, s, l);
    },
    p(n, l) {
      l & /*buttons*/
      2 && t !== (t = /*button*/
      n[26].icon + "") && e.p(t);
    },
    d(n) {
      n && (C(s), e.d());
    }
  };
}
u(oO, "create_if_block_1$1C");
function aO(i, e) {
  let t, s, n = (
    /*button*/
    e[26].label + ""
  ), l, r, o, a, c, f, d, p, m = (
    /*button*/
    e[26].icon && oO(e)
  );
  function g() {
    return (
      /*click_handler*/
      e[18](
        /*button*/
        e[26]
      )
    );
  }
  u(g, "click_handler");
  function h() {
    return (
      /*focus_handler*/
      e[19](
        /*button*/
        e[26]
      )
    );
  }
  return u(h, "focus_handler"), {
    key: i,
    first: null,
    c() {
      t = E("button"), s = E("span"), m && m.c(), l = Q(n), o = F(), b(s, "title", r = /*button*/
      e[26].title), b(t, "class", a = "dialog-button tjs-dialog-button " + /*button*/
      e[26].id + " svelte-1ez4adq"), t.disabled = c = /*button*/
      e[26].disabled, this.first = t;
    },
    m(_, y) {
      T(_, t, y), A(t, s), m && m.m(s, null), A(s, l), A(t, o), d || (p = [
        W(t, "click", Ve(st(g))),
        W(t, "focus", h),
        Et(f = Xs.call(
          null,
          t,
          /*button*/
          e[26].styles
        ))
      ], d = !0);
    },
    p(_, y) {
      e = _, /*button*/
      e[26].icon ? m ? m.p(e, y) : (m = oO(e), m.c(), m.m(s, l)) : m && (m.d(1), m = null), y & /*buttons*/
      2 && n !== (n = /*button*/
      e[26].label + "") && be(l, n), y & /*buttons*/
      2 && r !== (r = /*button*/
      e[26].title) && b(s, "title", r), y & /*buttons*/
      2 && a !== (a = "dialog-button tjs-dialog-button " + /*button*/
      e[26].id + " svelte-1ez4adq") && b(t, "class", a), y & /*buttons*/
      2 && c !== (c = /*button*/
      e[26].disabled) && (t.disabled = c), f && $t(f.update) && y & /*buttons*/
      2 && f.update.call(
        null,
        /*button*/
        e[26].styles
      );
    },
    d(_) {
      _ && C(t), m && m.d(), d = !1, Me(p);
    }
  };
}
u(aO, "create_each_block$1N");
function Lz(i) {
  let e, t, s, n, l, r;
  const o = [jz, Nz], a = [];
  function c(d, p) {
    return typeof /*content*/
    d[3] == "string" ? 0 : (
      /*dialogClass*/
      d[6] ? 1 : -1
    );
  }
  u(c, "select_block_type"), ~(s = c(i)) && (n = a[s] = o[s](i));
  let f = (
    /*buttons*/
    i[1].length && rO(i)
  );
  return {
    c() {
      e = E("main"), t = E("div"), n && n.c(), l = F(), f && f.c(), b(t, "class", "dialog-content");
    },
    m(d, p) {
      T(d, e, p), A(e, t), ~s && a[s].m(t, null), i[17](t), A(e, l), f && f.m(e, null), r = !0;
    },
    p(d, [p]) {
      let m = s;
      s = c(d), s === m ? ~s && a[s].p(d, p) : (n && (ae(), O(a[m], 1, 1, () => {
        a[m] = null;
      }), ce()), ~s ? (n = a[s], n ? n.p(d, p) : (n = a[s] = o[s](d), n.c()), w(n, 1), n.m(t, null)) : n = null), /*buttons*/
      d[1].length ? f ? f.p(d, p) : (f = rO(d), f.c(), f.m(e, null)) : f && (f.d(1), f = null);
    },
    i(d) {
      r || (w(n), r = !0);
    },
    o(d) {
      O(n), r = !1;
    },
    d(d) {
      d && C(e), ~s && a[s].d(), i[17](null), f && f.d();
    }
  };
}
u(Lz, "create_fragment$4E");
const Bz = /^\s*<.*>$/;
function qz(i, e, t) {
  var H;
  let s, n, l, r, { data: o = void 0 } = e, { preventDefault: a = !1 } = e, { stopPropagation: c = !1 } = e, { dialogComponent: f = void 0 } = e;
  const { elementRoot: d } = de("#internal").stores;
  pe(i, d, (V) => t(15, r = V));
  const p = (H = de("#external")) == null ? void 0 : H.application, m = de("#managedPromise");
  let g, h, _, y, v, k = {}, S = o.default;
  Qt(() => {
    const V = r;
    ot.isFocusTarget(V) && (V.removeEventListener("keydown", I), V.removeEventListener("keyup", M));
  }), $o(() => {
    if (n) {
      const V = ot.getFirstFocusableElement(h);
      ot.isFocusTarget(V) && setTimeout(() => V.focus(), 0);
    }
  });
  function D(V) {
    try {
      let Y;
      const J = V == null ? void 0 : V.onPress;
      switch (typeof J) {
        case "function":
          Y = J({ application: p });
          break;
        case "string":
          f !== void 0 && typeof f[J] == "function" ? Y = f[J]({ application: p }) : f === void 0 ? console.warn("[TRL] TJSDialog warning: 'onPress' defined as a string with no associated content Svelte component.") : typeof (f == null ? void 0 : f[J]) != "function" && console.warn(`[TRL] TJSDialog warning: The content Svelte component does not contain an associated function '${J}'. Did you remember to add '<svelte:options accessors={true} />' and export the function?`);
          break;
      }
      V.autoClose && s && (l && Y === void 0 && (Y = V.id), m.resolve(Y));
    } catch (Y) {
      if ((typeof o.notifyError == "boolean" ? o.notifyError : !0) && globalThis.ui.notifications.error(Y, { console: !1 }), !m.reject(Y))
        throw Y;
    } finally {
      V.autoClose && s && p.close();
    }
  }
  u(D, "onClick");
  function I(V) {
    switch (V.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "Enter":
        V.stopPropagation();
        break;
      case "Tab":
        V.stopPropagation(), setTimeout(
          () => {
            const J = p.reactive.activeWindow.document.activeElement;
            if (ot.isFocusTarget(J) && ot.isFocusTarget(_) && _.contains(J))
              for (let fe = 0; fe < J.classList.length; fe++) {
                const ke = J.classList.item(fe);
                if (ke !== "dialog-button" && ke !== "default" && typeof o.buttons[ke] !== void 0) {
                  t(4, S = ke);
                  break;
                }
              }
          },
          0
        );
        break;
      default:
        a && V.preventDefault(), c && V.stopPropagation();
        break;
    }
  }
  u(I, "onKeydown");
  function M(V) {
    switch (V.code) {
      case "ArrowLeft": {
        V.preventDefault(), V.stopPropagation();
        const J = p.reactive.activeWindow.document.activeElement;
        if (ot.isFocusTarget(_)) {
          if (ot.isFocusTarget(J) && _.contains(J)) {
            const ke = g.findIndex((ee) => ee.id === S);
            g.length && ke > 0 && t(4, S = g[ke - 1].id);
          }
          const fe = _.querySelector(`.${S}`);
          ot.isFocusTarget(fe) && fe.focus();
        }
        break;
      }
      case "ArrowRight": {
        V.preventDefault(), V.stopPropagation();
        const J = p.reactive.activeWindow.document.activeElement;
        if (ot.isFocusTarget(_)) {
          if (ot.isFocusTarget(J) && (_.contains(J) || S === void 0)) {
            const ke = g.findIndex((ee) => ee.id === S);
            g.length && ke < g.length - 1 && t(4, S = g[ke + 1].id);
          }
          const fe = _.querySelector(`.${S}`);
          ot.isFocusTarget(fe) && fe.focus();
        }
        break;
      }
      case "Enter":
        V.preventDefault(), V.stopPropagation();
        break;
      default:
        a && V.preventDefault(), c && V.stopPropagation();
        break;
    }
  }
  u(M, "onKeyup");
  function L(V) {
    rt[V ? "unshift" : "push"](() => {
      f = V, t(0, f);
    });
  }
  u(L, "switch_instance_binding");
  function B(V) {
    rt[V ? "unshift" : "push"](() => {
      h = V, t(5, h);
    });
  }
  u(B, "div_binding");
  const z = /* @__PURE__ */ u((V) => D(V), "click_handler"), q = /* @__PURE__ */ u((V) => t(4, S = V.id), "focus_handler");
  function U(V) {
    rt[V ? "unshift" : "push"](() => {
      _ = V, t(2, _);
    });
  }
  return u(U, "div_binding_1"), i.$$set = (V) => {
    "data" in V && t(10, o = V.data), "preventDefault" in V && t(11, a = V.preventDefault), "stopPropagation" in V && t(12, c = V.stopPropagation), "dialogComponent" in V && t(0, f = V.dialogComponent);
  }, i.$$.update = () => {
    if (i.$$.dirty & /*$elementRoot*/
    32768 && r) {
      const V = r;
      ot.isFocusTarget(V) && (V.addEventListener("keydown", I), V.addEventListener("keyup", M));
    }
    if (i.$$.dirty & /*data*/
    1024 && t(13, s = typeof o.autoClose == "boolean" ? o.autoClose : !0), i.$$.dirty & /*data*/
    1024 && t(14, n = typeof o.focusFirst == "boolean" ? o.focusFirst : !1), i.$$.dirty & /*data*/
    1024 && t(1, g = he(o.buttons) ? Object.keys(o.buttons).reduce(
      (V, Y) => {
        const J = o.buttons[Y], fe = typeof J.icon != "string" ? void 0 : Bz.test(J.icon) ? J.icon : `<i class="${J.icon}"></i>`, ke = typeof J.autoClose == "boolean" ? J.autoClose : !0, ee = typeof J.disabled == "boolean" ? J.disabled : !1, ne = typeof J.label == "string" ? `${fe !== void 0 ? " " : ""}${K(J.label)}` : "", Ee = typeof J.title == "string" ? K(J.title) : void 0;
        return (typeof J.condition == "function" ? J.condition.call(J) : J.condition ?? !0) && V.push({
          ...J,
          id: Y,
          autoClose: ke,
          icon: fe,
          label: ne,
          title: Ee,
          disabled: ee
        }), V;
      },
      []
    ) : []), i.$$.dirty & /*buttons, currentButtonId*/
    18 && (g.find((V) => V.id === S) || t(4, S = void 0)), i.$$.dirty & /*focusFirst, buttonsEl, currentButtonId*/
    16404 && !n && ot.isFocusTarget(_)) {
      const V = _.querySelector(`.${S}`);
      ot.isFocusTarget(V) && V.focus();
    }
    if (i.$$.dirty & /*data*/
    1024 && (l = typeof o.resolveId == "boolean" ? o.resolveId : !1), i.$$.dirty & /*content, data*/
    1032 && y !== o.content) {
      t(
        3,
        y = o.content
      );
      try {
        if (Ws.isComponent(y))
          t(6, v = y), t(7, k = {});
        else if (mi.isConfig(y)) {
          const V = mi.parseConfig(y, p);
          t(6, v = V.class), t(7, k = V.props ?? {});
        } else
          t(6, v = void 0), t(7, k = {});
      } catch (V) {
        t(6, v = void 0), t(7, k = {}), t(3, y = V.message), console.error(V);
      }
    }
  }, [
    f,
    g,
    _,
    y,
    S,
    h,
    v,
    k,
    d,
    D,
    o,
    a,
    c,
    s,
    n,
    r,
    L,
    B,
    z,
    q,
    U
  ];
}
u(qz, "instance$4v");
const Hw = class Hw extends re {
  constructor(e) {
    super(), oe(this, e, qz, Lz, le, {
      data: 10,
      preventDefault: 11,
      stopPropagation: 12,
      dialogComponent: 0
    });
  }
};
u(Hw, "DialogContent");
let ap = Hw;
function Gz(i) {
  let e, t, s, n;
  const l = [
    /*appProps*/
    i[6]
  ];
  function r(c) {
    i[16](c);
  }
  u(r, "applicationshell_elementRoot_binding_1");
  function o(c) {
    i[17](c);
  }
  u(o, "applicationshell_elementContent_binding_1");
  let a = {
    $$slots: { default: [Hz] },
    $$scope: { ctx: i }
  };
  for (let c = 0; c < l.length; c += 1)
    a = Dt(a, l[c]);
  return (
    /*elementRoot*/
    i[0] !== void 0 && (a.elementRoot = /*elementRoot*/
    i[0]), /*elementContent*/
    i[1] !== void 0 && (a.elementContent = /*elementContent*/
    i[1]), e = new Js({ props: a }), rt.push(() => Ot(e, "elementRoot", r)), rt.push(() => Ot(e, "elementContent", o)), {
      c() {
        j(e.$$.fragment);
      },
      m(c, f) {
        R(e, c, f), n = !0;
      },
      p(c, f) {
        const d = f & /*appProps*/
        64 ? Vt(l, [Jt(
          /*appProps*/
          c[6]
        )]) : {};
        f & /*$$scope, data, dialogComponent*/
        8388620 && (d.$$scope = { dirty: f, ctx: c }), !t && f & /*elementRoot*/
        1 && (t = !0, d.elementRoot = /*elementRoot*/
        c[0], It(() => t = !1)), !s && f & /*elementContent*/
        2 && (s = !0, d.elementContent = /*elementContent*/
        c[1], It(() => s = !1)), e.$set(d);
      },
      i(c) {
        n || (w(e.$$.fragment, c), n = !0);
      },
      o(c) {
        O(e.$$.fragment, c), n = !1;
      },
      d(c) {
        N(e, c);
      }
    }
  );
}
u(Gz, "create_else_block$L");
function zz(i) {
  let e, t;
  const s = [
    {
      id: `${/*application*/
      i[4].id}-glasspane`
    },
    /*modalProps*/
    i[7],
    { zIndex: (
      /*zIndex*/
      i[8]
    ) }
  ];
  let n = {
    $$slots: { default: [Vz] },
    $$scope: { ctx: i }
  };
  for (let l = 0; l < s.length; l += 1)
    n = Dt(n, s[l]);
  return e = new z1({ props: n }), e.$on(
    "glasspane:close",
    /*glasspane_close_handler*/
    i[13]
  ), e.$on(
    "glasspane:keydown:escape",
    /*glasspane_keydown_escape_handler*/
    i[14]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), t = !0;
    },
    p(l, r) {
      const o = r & /*application, modalProps, zIndex*/
      400 ? Vt(s, [
        r & /*application*/
        16 && {
          id: `${/*application*/
          l[4].id}-glasspane`
        },
        r & /*modalProps*/
        128 && Jt(
          /*modalProps*/
          l[7]
        ),
        r & /*zIndex*/
        256 && { zIndex: (
          /*zIndex*/
          l[8]
        ) }
      ]) : {};
      r & /*$$scope, appProps, elementRoot, elementContent, data, dialogComponent*/
      8388687 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
    },
    i(l) {
      t || (w(e.$$.fragment, l), t = !0);
    },
    o(l) {
      O(e.$$.fragment, l), t = !1;
    },
    d(l) {
      N(e, l);
    }
  };
}
u(zz, "create_if_block$2u");
function Hz(i) {
  let e, t, s;
  function n(r) {
    i[15](r);
  }
  u(n, "dialogcontent_dialogComponent_binding_1");
  let l = { data: (
    /*data*/
    i[3]
  ) };
  return (
    /*dialogComponent*/
    i[2] !== void 0 && (l.dialogComponent = /*dialogComponent*/
    i[2]), e = new ap({ props: l }), rt.push(() => Ot(e, "dialogComponent", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        o & /*data*/
        8 && (a.data = /*data*/
        r[3]), !t && o & /*dialogComponent*/
        4 && (t = !0, a.dialogComponent = /*dialogComponent*/
        r[2], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(Hz, "create_default_slot_2$1b");
function Uz(i) {
  let e, t, s;
  function n(r) {
    i[10](r);
  }
  u(n, "dialogcontent_dialogComponent_binding");
  let l = {
    data: (
      /*data*/
      i[3]
    ),
    stopPropagation: !0
  };
  return (
    /*dialogComponent*/
    i[2] !== void 0 && (l.dialogComponent = /*dialogComponent*/
    i[2]), e = new ap({ props: l }), rt.push(() => Ot(e, "dialogComponent", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        o & /*data*/
        8 && (a.data = /*data*/
        r[3]), !t && o & /*dialogComponent*/
        4 && (t = !0, a.dialogComponent = /*dialogComponent*/
        r[2], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(Uz, "create_default_slot_1$1z");
function Vz(i) {
  let e, t, s, n;
  const l = [
    /*appProps*/
    i[6]
  ];
  function r(c) {
    i[11](c);
  }
  u(r, "applicationshell_elementRoot_binding");
  function o(c) {
    i[12](c);
  }
  u(o, "applicationshell_elementContent_binding");
  let a = {
    $$slots: { default: [Uz] },
    $$scope: { ctx: i }
  };
  for (let c = 0; c < l.length; c += 1)
    a = Dt(a, l[c]);
  return (
    /*elementRoot*/
    i[0] !== void 0 && (a.elementRoot = /*elementRoot*/
    i[0]), /*elementContent*/
    i[1] !== void 0 && (a.elementContent = /*elementContent*/
    i[1]), e = new Js({ props: a }), rt.push(() => Ot(e, "elementRoot", r)), rt.push(() => Ot(e, "elementContent", o)), {
      c() {
        j(e.$$.fragment);
      },
      m(c, f) {
        R(e, c, f), n = !0;
      },
      p(c, f) {
        const d = f & /*appProps*/
        64 ? Vt(l, [Jt(
          /*appProps*/
          c[6]
        )]) : {};
        f & /*$$scope, data, dialogComponent*/
        8388620 && (d.$$scope = { dirty: f, ctx: c }), !t && f & /*elementRoot*/
        1 && (t = !0, d.elementRoot = /*elementRoot*/
        c[0], It(() => t = !1)), !s && f & /*elementContent*/
        2 && (s = !0, d.elementContent = /*elementContent*/
        c[1], It(() => s = !1)), e.$set(d);
      },
      i(c) {
        n || (w(e.$$.fragment, c), n = !0);
      },
      o(c) {
        O(e.$$.fragment, c), n = !1;
      },
      d(c) {
        N(e, c);
      }
    }
  );
}
u(Vz, "create_default_slot$2B");
function Wz(i) {
  let e, t, s, n;
  const l = [zz, Gz], r = [];
  function o(a, c) {
    return (
      /*modal*/
      a[5] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, [c]) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(Wz, "create_fragment$4D");
const Kz = "#50505080";
function Yz(i, e, t) {
  var z;
  let { elementContent: s = void 0 } = e, { elementRoot: n = void 0 } = e, { data: l = {} } = e, { dialogComponent: r = void 0 } = e, { managedPromise: o = void 0 } = e;
  const a = (z = de("#external")) == null ? void 0 : z.application, c = Mt({});
  lt("#managedPromise", o), lt("#dialogOptions", c);
  const f = oc, d = { duration: 200 };
  let p;
  const m = {
    // Stores any transition functions.
    transition: void 0,
    inTransition: void 0,
    outTransition: void 0,
    // Stores properties to set for options for any transitions.
    transitionOptions: void 0,
    inTransitionOptions: void 0,
    outTransitionOptions: void 0,
    // Stores any style overrides for application shell.
    stylesApp: void 0,
    stylesContent: void 0
  }, g = {
    // Background CSS style string.
    background: void 0,
    slotSeparate: void 0,
    styles: void 0,
    // Close modal on glasspane input.
    closeOnInput: void 0,
    // Stores any transition functions.
    transition: void 0,
    inTransition: void 0,
    outTransition: void 0,
    // Stores properties to set for options for any transitions.
    transitionOptions: void 0,
    inTransitionOptions: void 0,
    outTransitionOptions: void 0
  };
  let h;
  p === void 0 && (p = typeof (l == null ? void 0 : l.modal) == "boolean" ? l.modal : !1);
  const _ = a.reactive.activeWindow;
  p || (Qt(() => _.document.removeEventListener("keydown", y)), $o(() => _.document.addEventListener("keydown", y)));
  function y(q) {
    q.code === "Escape" && (q.preventDefault(), q.stopPropagation(), a.close());
  }
  u(y, "onKeydown");
  function v(q) {
    r = q, t(2, r);
  }
  u(v, "dialogcontent_dialogComponent_binding");
  function k(q) {
    n = q, t(0, n);
  }
  u(k, "applicationshell_elementRoot_binding");
  function S(q) {
    s = q, t(1, s);
  }
  u(S, "applicationshell_elementContent_binding");
  const D = /* @__PURE__ */ u(() => a.close(), "glasspane_close_handler"), I = /* @__PURE__ */ u(() => a.close(), "glasspane_keydown_escape_handler");
  function M(q) {
    r = q, t(2, r);
  }
  u(M, "dialogcontent_dialogComponent_binding_1");
  function L(q) {
    n = q, t(0, n);
  }
  u(L, "applicationshell_elementRoot_binding_1");
  function B(q) {
    s = q, t(1, s);
  }
  return u(B, "applicationshell_elementContent_binding_1"), i.$$set = (q) => {
    "elementContent" in q && t(1, s = q.elementContent), "elementRoot" in q && t(0, n = q.elementRoot), "data" in q && t(3, l = q.data), "dialogComponent" in q && t(2, r = q.dialogComponent), "managedPromise" in q && t(9, o = q.managedPromise);
  }, i.$$.update = () => {
    var q, U, H, V, Y, J, fe, ke, ee;
    if (i.$$.dirty & /*elementRoot, modal*/
    33 && ot.isFocusTarget(n) && (n.setAttribute("role", "dialog"), p && n.setAttribute("aria-modal", "true")), i.$$.dirty & /*data, modal, zIndex, application*/
    312 && he(l)) {
      c.set(l);
      const ne = Number.isInteger(l.zIndex) || l.zIndex === null ? l.zIndex : p ? Number.MAX_SAFE_INTEGER : Number.MAX_SAFE_INTEGER - 1;
      h !== ne && t(8, h = ne);
      const Ee = typeof l.draggable == "boolean" ? l.draggable : void 0;
      Ee !== void 0 && a.reactive.draggable !== Ee && t(4, a.reactive.draggable = Ee, a);
      const Pe = typeof l.focusAuto == "boolean" ? l.focusAuto : void 0;
      Pe !== void 0 && a.reactive.focusAuto !== Pe && t(4, a.reactive.focusAuto = Pe, a);
      const ye = typeof l.focusKeep == "boolean" ? l.focusKeep : void 0;
      ye !== void 0 && a.reactive.focusKeep !== ye && t(4, a.reactive.focusKeep = ye, a);
      const me = typeof l.focusTrap == "boolean" ? l.focusTrap : void 0;
      me !== void 0 && a.reactive.focusTrap !== me && t(4, a.reactive.focusTrap = me, a);
      const Ce = typeof l.minimizable == "boolean" ? l.minimizable : void 0;
      Ce !== void 0 && a.reactive.minimizable !== Ce && t(4, a.reactive.minimizable = Ce, a);
      const Je = typeof l.resizable == "boolean" ? l.resizable : void 0;
      Je !== void 0 && a.reactive.resizable !== Je && t(4, a.reactive.resizable = Je, a);
      const Ne = l.title ?? "Dialog";
      Ne !== ((q = a == null ? void 0 : a.options) == null ? void 0 : q.title) && t(4, a.reactive.title = Ne, a), a.position.zIndex !== h && t(4, a.position.zIndex = h, a);
    }
    if (i.$$.dirty & /*data, appProps*/
    72 && he(l == null ? void 0 : l.transition)) {
      const ne = l.transition;
      (ne == null ? void 0 : ne.transition) !== m.transition && t(6, m.transition = ne.transition, m), (ne == null ? void 0 : ne.inTransition) !== m.inTransition && t(6, m.inTransition = ne.inTransition, m), (ne == null ? void 0 : ne.outTransition) !== m.outTransition && t(6, m.outTransition = ne.outTransition, m), (ne == null ? void 0 : ne.transitionOptions) !== m.transitionOptions && t(6, m.transitionOptions = ne.transitionOptions, m), (ne == null ? void 0 : ne.inTransitionOptions) !== m.inTransitionOptions && t(6, m.inTransitionOptions = ne.inTransitionOptions, m), (ne == null ? void 0 : ne.outTransitionOptions) !== m.outTransitionOptions && t(6, m.outTransitionOptions = ne.outTransitionOptions, m);
    }
    if (i.$$.dirty & /*data, modalProps*/
    136) {
      const ne = typeof ((U = l == null ? void 0 : l.modalOptions) == null ? void 0 : U.background) == "string" ? l.modalOptions.background : Kz;
      ne !== g.background && t(7, g.background = ne, g);
    }
    if (i.$$.dirty & /*data, modalProps*/
    136) {
      const ne = typeof ((H = l == null ? void 0 : l.modalOptions) == null ? void 0 : H.slotSeparate) == "boolean" ? l.modalOptions.slotSeparate : void 0;
      ne !== g.slotSeparate && t(7, g.slotSeparate = ne, g);
    }
    if (i.$$.dirty & /*data, modalProps*/
    136) {
      const ne = he((V = l == null ? void 0 : l.modalOptions) == null ? void 0 : V.styles) ? l.modalOptions.styles : void 0;
      ne !== g.styles && t(7, g.styles = ne, g);
    }
    if (i.$$.dirty & /*data, modalProps*/
    136) {
      const ne = typeof ((Y = l == null ? void 0 : l.modalOptions) == null ? void 0 : Y.closeOnInput) == "boolean" ? l.modalOptions.closeOnInput : void 0;
      ne !== g.closeOnInput && t(7, g.closeOnInput = ne, g);
    }
    if (i.$$.dirty & /*data, modalProps*/
    136)
      if (he((J = l == null ? void 0 : l.modalOptions) == null ? void 0 : J.transition)) {
        const ne = l.modalOptions.transition;
        (ne == null ? void 0 : ne.transition) !== g.transition && t(
          7,
          g.transition = typeof (ne == null ? void 0 : ne.transition) == "function" ? ne.transition : f,
          g
        ), (ne == null ? void 0 : ne.inTransition) !== g.inTransition && t(7, g.inTransition = ne.inTransition, g), (ne == null ? void 0 : ne.outTransition) !== g.outTransition && t(7, g.outTransition = ne.outTransition, g), (ne == null ? void 0 : ne.transitionOptions) !== g.transitionOptions && t(
          7,
          g.transitionOptions = he(ne == null ? void 0 : ne.transitionOptions) ? ne.transitionOptions : d,
          g
        ), (ne == null ? void 0 : ne.inTransitionOptions) !== g.inTransitionOptions && t(7, g.inTransitionOptions = ne.inTransitionOptions, g), (ne == null ? void 0 : ne.outTransitionOptions) !== g.outTransitionOptions && t(7, g.outTransitionOptions = ne.outTransitionOptions, g);
      } else {
        const ne = typeof ((ke = (fe = l == null ? void 0 : l.modalOptions) == null ? void 0 : fe.transition) == null ? void 0 : ke.transition) == "function" ? l.modalOptions.transition.transition : f;
        ne !== g.transition && t(7, g.transition = ne, g);
        const Ee = he((ee = l == null ? void 0 : l.modalOptions) == null ? void 0 : ee.transitionOptions) ? l.modalOptions.transitionOptions : d;
        Ee !== g.transitionOptions && t(7, g.transitionOptions = Ee, g);
      }
  }, [
    n,
    s,
    r,
    l,
    a,
    p,
    m,
    g,
    h,
    o,
    v,
    k,
    S,
    D,
    I,
    M,
    L,
    B
  ];
}
u(Yz, "instance$4u");
const Uw = class Uw extends re {
  constructor(e) {
    super(), oe(this, e, Yz, Wz, le, {
      elementContent: 1,
      elementRoot: 0,
      data: 3,
      dialogComponent: 2,
      managedPromise: 9
    });
  }
  get elementContent() {
    return this.$$.ctx[1];
  }
  set elementContent(e) {
    this.$$set({ elementContent: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
  get data() {
    return this.$$.ctx[3];
  }
  set data(e) {
    this.$$set({ data: e }), Xe();
  }
  get dialogComponent() {
    return this.$$.ctx[2];
  }
  set dialogComponent(e) {
    this.$$set({ dialogComponent: e }), Xe();
  }
  get managedPromise() {
    return this.$$.ctx[9];
  }
  set managedPromise(e) {
    this.$$set({ managedPromise: e }), Xe();
  }
};
u(Uw, "DialogShell");
let H1 = Uw;
var Di, Ct;
const qi = class qi {
  constructor() {
    /** @type {{ isProcessing?: boolean, promise?: Promise, reject: Function, resolve: Function }} */
    x(this, Ct);
  }
  /**
   * @returns {boolean} Whether global logging is enabled.
   */
  static get logging() {
    return P(this, Di);
  }
  /**
   * @returns {boolean} Whether there is an active managed Promise.
   */
  get isActive() {
    return P(this, Ct) !== void 0;
  }
  /**
   * @returns {boolean} Whether there is an active managed Promise and resolution is currently being processed.
   */
  get isProcessing() {
    return P(this, Ct) !== void 0 ? P(this, Ct).isProcessing : !1;
  }
  /**
   * Sets global logging enabled state.
   *
   * @param {boolean}  logging - New logging enabled state.
   */
  static set logging(e) {
    if (typeof e != "boolean")
      throw new TypeError("[TRL] ManagedPromise.logging error: 'logging' is not a boolean.");
    Ae(this, Di, e);
  }
  // ----------------------------------------------------------------------------------------------------------------
  /**
   * Resolves any current Promise with undefined and creates a new current Promise.
   *
   * @template T
   *
   * @param {object} opts - Options.
   *
   * @param {boolean}  [opts.reuse=false] - When true if there is an existing live Promise it is returned immediately.
   *
   * @returns {Promise<T>} The new current managed Promise.
   */
  create({ reuse: e = !1 } = {}) {
    if (typeof e != "boolean")
      throw new TypeError("[TRL] ManagedPromise.create error: 'reuse' is not a boolean.");
    if (e && P(this, Ct) !== void 0 && P(this, Ct).promise instanceof Promise)
      return P(qi, Di) && console.warn("[TRL] ManagedPromise.create info: Reusing / returning existing managed Promise."), P(this, Ct).promise;
    P(this, Ct) !== void 0 && (P(qi, Di) && console.warn(
      "[TRL] ManagedPromise.create info: Creating a new Promise and resolving existing immediately."
    ), P(this, Ct).resolve(void 0), Ae(this, Ct, void 0));
    const t = new Promise((s, n) => {
      Ae(this, Ct, {
        isProcessing: !1,
        reject: n,
        resolve: s
      });
    });
    return P(this, Ct).promise = t, t;
  }
  /**
   * Gets the current Promise if any.
   *
   * @returns {Promise<any>} Current Promise.
   */
  get() {
    return P(this, Ct) ? P(this, Ct).promise : void 0;
  }
  /**
   * Rejects the current Promise if applicable.
   *
   * @param {*}  [result] - Result to reject.
   *
   * @returns {boolean} Was the promise rejected.
   */
  reject(e = void 0) {
    return P(this, Ct) !== void 0 && P(this, Ct).isProcessing ? (P(qi, Di) && console.warn("[TRL] ManagedPromise.reject info: Currently processing promise."), !0) : P(this, Ct) !== void 0 ? (P(this, Ct).isProcessing = !0, e instanceof Promise ? e.then((t) => {
      P(this, Ct).reject(t), Ae(this, Ct, void 0);
    }).catch((t) => {
      P(this, Ct).reject(t), Ae(this, Ct, void 0);
    }) : (P(this, Ct).reject(e), Ae(this, Ct, void 0)), !0) : (P(qi, Di) && console.warn("[TRL] ManagedPromise.reject warning: No current managed Promise to reject."), !1);
  }
  /**
   * Resolves the current Promise if applicable.
   *
   * @param {*}  [result] - Result to resolve.
   *
   * @returns {boolean} Was the promise resolved.
   */
  resolve(e = void 0) {
    return P(this, Ct) !== void 0 && P(this, Ct).isProcessing ? (P(qi, Di) && console.warn("[TRL] ManagedPromise.resolve info: Currently processing promise."), !0) : P(this, Ct) !== void 0 ? (e instanceof Promise ? (P(this, Ct).isProcessing = !0, e.then((t) => {
      P(this, Ct).resolve(t), Ae(this, Ct, void 0);
    }).catch((t) => {
      P(this, Ct).reject(t), Ae(this, Ct, void 0);
    })) : (P(this, Ct).resolve(e), Ae(this, Ct, void 0)), !0) : (P(qi, Di) && console.warn("[TRL] ManagedPromise.resolve warning: No current managed Promise to resolve."), !1);
  }
};
Di = new WeakMap(), Ct = new WeakMap(), u(qi, "ManagedPromise"), /** @type {boolean} */
x(qi, Di, !1);
let U1 = qi;
var yf, kt, hs, $s;
const Vw = class Vw {
  /**
   * @param {import('../../index.js').SvelteApplication} application - The host Foundry application.
   */
  constructor(e) {
    x(this, hs);
    /**
     * @type {import('../../index.js').SvelteApplication}
     */
    x(this, yf);
    /**
     * Stores the dialog options data.
     *
     * @type {import('./types').TJSDialogOptions}
     */
    x(this, kt, {});
    Ae(this, yf, e), Object.seal(this);
  }
  /**
   * @returns {{ [key: string]: import('./types').TJSDialogButtonData }} The dialog button configuration.
   */
  get buttons() {
    return P(this, kt).buttons;
  }
  /**
   * Set the dialog button configuration.
   *
   * @param {string} buttons - New dialog button configuration.
   */
  set buttons(e) {
    P(this, kt).buttons = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {import('@typhonjs-fvtt/runtime/svelte/util').TJSSvelteConfig | string} The Svelte configuration object or HTML string
   *          content.
   */
  get content() {
    return P(this, kt).content;
  }
  /**
   * Set the Svelte configuration object or HTML string content.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/util').TJSSvelteConfig | string} content - New Svelte configuration object or
   *        HTML string content.
   */
  set content(e) {
    P(this, kt).content = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {string} The default button ID to focus initially.
   */
  get default() {
    return P(this, kt).default;
  }
  /**
   * Set the default button ID to focus initially.
   *
   * @param {string} newDefault - New default button ID to focus initially.
   */
  set default(e) {
    P(this, kt).default = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {boolean} The dialog draggable state; draggable when true.
   */
  get draggable() {
    return P(this, kt).draggable;
  }
  /**
   * Set the dialog state; draggable when true.
   *
   * @param {boolean} draggable - New dialog draggable state; draggable when true.
   */
  set draggable(e) {
    P(this, kt).draggable = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {boolean} When true auto-management of app focus is enabled.
   */
  get focusAuto() {
    return P(this, kt).focusAuto;
  }
  /**
   * Set the dialog auto-management of app focus.
   *
   * @param {boolean} focusAuto - New dialog auto-management of app focus.
   */
  set focusAuto(e) {
    P(this, kt).focusAuto = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {boolean} When true the first focusable element that isn't a button is focused.
   */
  get focusFirst() {
    return P(this, kt).focusFirst;
  }
  /**
   * Set the dialog first focusable element state.
   *
   * @param {boolean} focusFirst - New dialog first focusable element state.
   */
  set focusFirst(e) {
    P(this, kt).focusFirst = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {boolean} When `focusAuto` and `focusKeep` is true; keeps internal focus.
   */
  get focusKeep() {
    return P(this, kt).focusKeep;
  }
  /**
   * Set the dialog `focusKeep` state. When `focusAuto` and `focusKeep` is true; keeps internal focus.
   *
   * @param {boolean} focusKeep - New dialog `focusKeep` state.
   */
  set focusKeep(e) {
    P(this, kt).focusKeep = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {boolean} When true the dialog is minimizable.
   */
  get minimizable() {
    return P(this, kt).minimizable;
  }
  /**
   * Set the dialog `minimizable` state. When true the dialog is minimizable.
   *
   * @param {boolean} minimizable - New dialog `minimizable` state.
   */
  set minimizable(e) {
    P(this, kt).minimizable = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {boolean} When true a modal dialog is displayed.
   */
  get modal() {
    return P(this, kt).modal;
  }
  /**
   * Set the dialog `modal` state. When true a modal dialog is displayed.
   *
   * @param {boolean} modal - New dialog `modal` state.
   */
  set modal(e) {
    P(this, kt).modal = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {import('./types').TJSDialogModalOptions} Additional options for modal dialog display.
   */
  get modalOptions() {
    return P(this, kt).modalOptions;
  }
  /**
   * Set additional options for modal dialog display.
   *
   * @param {import('./types').TJSDialogModalOptions} modalOptions - New additional options for modal dialog display.
   */
  set modalOptions(e) {
    P(this, kt).modalOptions = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {boolean} When true and an error is raised in dialog callback functions post a UI error notification.
   */
  get notifyError() {
    return P(this, kt).notifyError;
  }
  /**
   * Set the dialog `notifyError` state. When true and an error is raised in dialog callback functions post a UI error
   * notification.
   *
   * @param {boolean} notifyError - New dialog `notifyError` state.
   */
  set notifyError(e) {
    P(this, kt).notifyError = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {string | ((data?: { application?: import('../../index.js').TJSDialog }) => any)} Callback invoked when
   *          dialog is closed; no button option selected. When defined as a string any matching function by name
   *          exported from content Svelte component is invoked.
   */
  get onClose() {
    return P(this, kt).onClose;
  }
  /**
   * Set callback invoked when dialog is closed; no button option selected. When defined as a string any matching
   * function by name exported from content Svelte component is invoked..
   *
   * @param {string | ((data?: { application?: import('../../index.js').TJSDialog }) => any)} onClose - New dialog
   *        `onClose` state.
   */
  set onClose(e) {
    P(this, kt).onClose = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {boolean} Dialog `rejectClose` state. When true and a Promise has been created by {@link TJSDialog.wait}
   *          and the Promise is not in the process of being resolved or rejected on close of the dialog any `onClose`
   *          function is invoked and any result that is undefined will cause the Promise to then be rejected..
   */
  get rejectClose() {
    return P(this, kt).rejectClose;
  }
  /**
   * Set the dialog `rejectClose` state.
   *
   * @param {boolean} rejectClose - New dialog `rejectClose` state.
   */
  set rejectClose(e) {
    P(this, kt).rejectClose = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {boolean} When true the dialog is resizable.
   */
  get resizable() {
    return P(this, kt).resizable;
  }
  /**
   * Set the dialog `resizable` state. When true the dialog is resizable.
   *
   * @param {boolean} resizable - New dialog `resizable` state.
   */
  set resizable(e) {
    P(this, kt).resizable = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {boolean} When true and resolving any Promises and there are undefined results from any button callbacks
   *          the button ID is resolved.
   */
  get resolveId() {
    return P(this, kt).resolveId;
  }
  /**
   * Set the dialog `resolveId` state. When true and resolving any Promises and there are undefined results from any
   * button callbacks the button ID is resolved.
   *
   * @param {boolean} resolveId - New dialog `resolveId` state.
   */
  set resolveId(e) {
    P(this, kt).resolveId = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {string} The dialog window title.
   */
  get title() {
    return P(this, kt).title;
  }
  /**
   * Set the dialog window title.
   *
   * @param {string} title - New dialog window title.
   */
  set title(e) {
    P(this, kt).title = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {import('./types').TJSDialogTransitionOptions} Transition options for the dialog.
   */
  get transition() {
    return P(this, kt).transition;
  }
  /**
   * Set transition options for the dialog.
   *
   * @param {import('./types').TJSDialogTransitionOptions} transition - New transition options for the dialog.
   */
  set transition(e) {
    P(this, kt).transition = e, X(this, hs, $s).call(this);
  }
  /**
   * @returns {number | null} A specific z-index for the dialog. Pass null for the dialog to act like other
   *          applications in regard bringing to top when activated.
   */
  get zIndex() {
    return P(this, kt).zIndex;
  }
  /**
   * Set specific z-index for the dialog.
   *
   * @param {number | null} zIndex - New z-index for the dialog.
   */
  set zIndex(e) {
    P(this, kt).zIndex = e, X(this, hs, $s).call(this);
  }
  /**
   * Provides a cloned copy of the dialog data.
   * Note: The content attribute is not cloned as complex / props may be present.
   *
   * @returns {import('./types').TJSDialogOptions} A clone of the dialog data.
   */
  clone() {
    const e = { ...P(this, kt) };
    delete e.content;
    const t = gr(e);
    return t.content = P(this, kt).content, t;
  }
  /**
   * Provides a way to safely get this dialogs data given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {any}      [defaultValue] - A default value returned if the accessor is not found.
   *
   * @returns {any} Value at the accessor.
   */
  get(e, t) {
    return cu(P(this, kt), e, t);
  }
  /**
   * @param {import('./types').TJSDialogOptions} data - Merge provided data object into Dialog data.
   */
  merge(e) {
    tl(P(this, kt), e), X(this, hs, $s).call(this);
  }
  /**
   * Sets the dialog data; this is reactive.
   *
   * @param {import('./types').TJSDialogOptions}   data - Dialog data.
   */
  replace(e) {
    if (!he(e))
      throw new TypeError("TJSDialogData replace error: 'data' is not an object'.");
    Ae(this, kt, {}), this.merge(e);
  }
  /**
   * Provides a way to safely set this dialogs data given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * Automatically the dialog data will be updated in the associated DialogShell Svelte component.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {any}      value - Value to set.
   *
   * @returns {boolean} True if successful.
   */
  set(e, t) {
    const s = K7(P(this, kt), e, t);
    return s && X(this, hs, $s).call(this), s;
  }
};
yf = new WeakMap(), kt = new WeakMap(), hs = new WeakSet(), /**
 * Updates the data in the Svelte dialog component.
 */
$s = /* @__PURE__ */ u(function() {
  const e = P(this, yf).svelte.component(0);
  e != null && e.data && (e.data = this.clone());
}, "#updateComponent"), u(Vw, "TJSDialogData");
let V1 = Vw;
var ni, ii, io, Lc;
const ru = class ru extends Gs {
  /**
   * @param {import('./internal/state-dialog/types').TJSDialogOptions}           data - Dialog options.
   *
   * @param {import('./').SvelteApplicationOptions}   [options] - SvelteApplication options.
   */
  constructor(t, s = {}) {
    super({ popOutModuleDisable: (t == null ? void 0 : t.modal) ?? !1, ...s });
    /** @type {TJSDialogData} */
    x(this, ni);
    /** @type {ManagedPromise} */
    x(this, ii);
    Ae(this, ii, new U1()), Ae(this, ni, new V1(this)), P(this, ni).replace(t), Object.defineProperty(this.svelte, "dialogComponent", {
      get: /* @__PURE__ */ u(() => {
        var n, l;
        return (l = (n = this.svelte) == null ? void 0 : n.applicationShell) == null ? void 0 : l.dialogComponent;
      }, "get")
    });
  }
  /**
   * Default options for TJSDialog. Provides a default width and setting `height` to `auto` to always display dialog
   * content even if it changes. The default `DialogShell` / `svelte` options should not be changed and instead mount
   * the dialog content component by supplying a Svelte configuration object to dialog data `content` field.
   *
   * @returns {import('./').SvelteApplicationOptions} Default options
   */
  static get defaultOptions() {
    return tl(super.defaultOptions, {
      classes: ["dialog", "tjs-dialog"],
      width: 400,
      height: "auto",
      svelte: {
        class: H1,
        intro: !0,
        target: document.body,
        /**
         * `this` is the TJSDialog instance when invoked.
         *
         * @this {TJSDialog}
         *
         * @returns {{data: import('./types').TJSDialogOptions, managedPromise: ManagedPromise}} Props
         */
        props: /* @__PURE__ */ u(function() {
          return {
            data: P(this, ni).clone(),
            managedPromise: P(this, ii)
          };
        }, "props")
      }
    });
  }
  /**
   * Returns the dialog data.
   *
   * @returns {import('./internal/state-dialog/types').TJSDialogData} Dialog data.
   */
  get data() {
    return P(this, ni);
  }
  /**
   * @returns {import('@typhonjs-fvtt/runtime/util/async').ManagedPromise} Returns the managed promise.
   */
  get managedPromise() {
    return P(this, ii);
  }
  /**
   * Close the dialog and un-register references to it within UI mappings.
   * This function returns a Promise which resolves once the window closing animation concludes.
   *
   * @param {object}   [options] - Optional parameters.
   *
   * @param {boolean}  [options.force] - Force close regardless of render state.
   *
   * @returns {Promise<void>} A Promise which resolves once the application is closed with the callback value or
   *                          `true`.
   */
  async close(t) {
    var s;
    try {
      if (P(this, ii).isActive && !P(this, ii).isProcessing) {
        const n = X(s = ru, io, Lc).call(s, P(this, ni).onClose, this, null);
        (typeof P(this, ni).rejectClose == "boolean" ? P(this, ni).rejectClose : !1) && n === null ? P(this, ii).reject(new Error("TJSDialog was closed without a choice being made.")) : P(this, ii).resolve(n);
      }
    } catch (n) {
      if ((typeof P(this, ni).notifyError == "boolean" ? P(this, ni).notifyError : !0) && globalThis.ui.notifications.error(n, { console: !1 }), !P(this, ii).reject(n))
        throw n;
    } finally {
      await super.close(t);
    }
  }
  /**
   * Brings to top or renders this dialog returning a Promise that is resolved any button pressed or when the dialog
   * is closed.
   *
   * Creates an anonymous data defined TJSDialog returning a Promise that can be awaited upon for the user to make a
   * choice.
   *
   * Note: `null` is returned if the dialog is closed without a user making a choice.
   *
   * @template T
   *
   * @param {object}   [options] - Options.
   *
   * @param {boolean}  [options.reuse=false] - When true if there is an existing managed Promise this allows multiple
   *        sources to await on the same result.
   *
   * @returns {Promise<T>} A promise for dialog resolution.
   */
  async wait(t) {
    return this.rendered ? this.bringToTop() : this.render(!0, { focus: !0 }), P(this, ii).create(t);
  }
  // ---------------------------------------------------------------------------------------------------------------
  /**
   * A helper factory method to create simple confirmation dialog windows which consist of simple yes / no prompts.
   * If you require more flexibility, a custom TJSDialog instance is preferred. The default focused button is 'yes'.
   * You can change the default focused button by setting `default` to `yes` or `no`.
   *
   * @template T
   *
   * @param {import('./internal/state-dialog/types').TJSDialogOptions & {
   *    onYes?: string | ((data?: { application?: TJSDialog }) => any),
   *    onNo?: string | ((data?: { application?: TJSDialog }) => any)
   * }} [data] - Confirm dialog options.
   *
   * @param {string|((data?: { application?: TJSDialog }) => any)} [data.onYes] - Callback function upon `yes`; may be
   *        an async function. When defined as a string any matching function by name exported from content Svelte
   *        component is invoked.
   *
   * @param {string|((data?: { application?: TJSDialog }) => any)} [data.onNo] - Callback function upon `no`; may be an
   *        async function. When defined as a string any matching function by name exported from content Svelte
   *        component is invoked.
   *
   * @param {import('./').SvelteApplicationOptions}  [options]  SvelteApplication options passed to the TJSDialog
   *        constructor.
   *
   * @returns {Promise<T>} A promise which resolves with result of yes / no callbacks or true / false.
   *
   * @example
   * const result = await TJSDialog.confirm({
   *  title: 'A Yes or No Question',
   *  content: '<p>Choose wisely.</p>',
   *  onYes: () => 'YES Result',
   *  onNo: () => 'NO Result'
   * });
   *
   * // Logs 'YES result', 'NO Result', or null if the user closed the dialog without making a selection.
   * console.log(result);
   */
  static async confirm({ onYes: t, onNo: s, ...n } = {}, l = {}) {
    const r = tl({
      yes: {
        icon: "fas fa-check",
        label: "Yes"
      },
      no: {
        icon: "fas fa-times",
        label: "No"
      }
    }, n.buttons ?? {});
    return this.wait({
      ...n,
      buttons: tl(r, {
        yes: {
          onPress: /* @__PURE__ */ u(({ application: o }) => X(this, io, Lc).call(this, t, o, !0), "onPress")
        },
        no: {
          onPress: /* @__PURE__ */ u(({ application: o }) => X(this, io, Lc).call(this, s, o, !1), "onPress")
        }
      }),
      default: n.default ?? "yes"
    }, l);
  }
  /**
   * A helper factory method to display a basic "prompt" style TJSDialog with a single button.
   *
   * @template T
   *
   * @param {import('./internal/state-dialog/types').TJSDialogOptions & {
   *    onOk?: string | ((data?: { application?: TJSDialog }) => any),
   *    label?: string,
   *    icon?: string
   * }} [data] - Prompt dialog options that includes any TJSDialog options along with the following optional fields:
   *
   * @param {string|((data?: { application?: TJSDialog }) => any)} [data.onOk] - Callback function upon `ok`; may be
   *        an async function. When defined as a string any matching function by name exported from content Svelte
   *        component is invoked.
   *
   * @param {string}   [data.label] - The OK prompt button text.
   *
   * @param {string}   [data.icon="fas fa-check"] - Set another icon besides `fas fa-check` for button.
   *
   * @param {import('./').SvelteApplicationOptions}  [options]  SvelteApplication options passed to the TJSDialog
   *        constructor.
   *
   * @returns {Promise<T>} The returned value from the provided callback function or `true` if the button
   *          is pressed.
   *
   * @example
   * const result = await TJSDialog.prompt({
   *  title: 'Are you OK?',
   *  content: '<p>Are you OK?.</p>',
   *  label: 'Feeling Fine!',
   *  onOk: () => 'OK'
   * });
   *
   * // Logs 'OK' or null if the user closed the dialog without making a selection.
   * console.log(result);
   */
  static async prompt({ onOk: t, label: s, icon: n = "fas fa-check", ...l } = {}, r = {}) {
    return this.wait({
      ...l,
      buttons: {
        ok: {
          icon: n,
          label: s,
          onPress: /* @__PURE__ */ u(({ application: o }) => X(this, io, Lc).call(this, t, o, !0), "onPress")
        }
      },
      default: "ok"
    }, r);
  }
  /**
   * Creates an anonymous data defined TJSDialog returning a Promise that can be awaited upon for the user to make a
   * choice.
   *
   * Note: By default `null` is returned if the dialog is closed without a user making a choice.
   *
   * @template T
   *
   * @param {import('./internal/state-dialog/types').TJSDialogOptions}  data - Dialog data passed to the TJSDialog constructor.
   *
   * @param {import('./').SvelteApplicationOptions}  [options]  SvelteApplication options passed to the TJSDialog
   *        constructor.
   *
   * @returns {Promise<T>} A Promise that resolves to the chosen result.
   */
  static async wait(t, s = {}) {
    if (!he(t))
      throw new TypeError("TJSDialog.wait error: 'data' is not an object'.");
    return new this({ ...t }, s).wait();
  }
};
ni = new WeakMap(), ii = new WeakMap(), io = new WeakSet(), Lc = /* @__PURE__ */ u(function(t, s, n = void 0) {
  var r;
  let l = n;
  switch (typeof t) {
    case "function":
      l = t({ application: s });
      break;
    case "string": {
      const o = (r = s == null ? void 0 : s.svelte) == null ? void 0 : r.dialogComponent;
      o !== void 0 && typeof (o == null ? void 0 : o[t]) == "function" ? l = o == null ? void 0 : o[t]({ application: s }) : o === void 0 ? console.warn("[TRL] TJSDialog warning: 'onPress' defined as a string with no associated content Svelte component.") : typeof (o == null ? void 0 : o[t]) != "function" && console.warn(`[TRL] TJSDialog warning: The content Svelte component does not contain an associated function '${t}'. Did you remember to add '<svelte:options accessors={true} />' and export the function?`);
      break;
    }
  }
  return l;
}, "#invokeFn"), x(ru, io), u(ru, "TJSDialog");
let Un = ru;
R1.initialize();
var vf, W1;
const Ww = class Ww extends Un {
  constructor(t, s, n = {}, l = {}) {
    super(
      {
        title: t,
        content: {
          class: s,
          props: { ...n }
        },
        zIndex: null
      },
      {
        classes: ["a5e-sheet"],
        width: l.width ?? 420,
        height: l.height ?? "auto",
        resizable: l.resizable ?? !1
      }
    );
    x(this, vf);
    this.data.content.props.dialog = this, this.promise = new Promise((r) => {
      this.resolve = r;
    });
  }
  /** @inheritdoc */
  close(t) {
    return X(this, vf, W1).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return X(this, vf, W1).call(this, t), super.close();
  }
};
vf = new WeakSet(), W1 = /* @__PURE__ */ u(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), u(Ww, "GenericDialog");
let ac = Ww;
function LL(i, e, t) {
  const s = {}, n = /* @__PURE__ */ new Map();
  return e.forEach(({ id: l, grant: r }) => {
    const o = t.get(l);
    if (r.grantType === "feature") {
      const c = r.getApplyData(i, o), d = ((o == null ? void 0 : o.uuids) ?? r.features.base.map(({ uuid: p }) => p) ?? []).map((p) => ({ uuid: p, type: "feature" }));
      n.set(l, d), foundry.utils.mergeObject(s, c ?? {});
      return;
    }
    if (r.grantType === "item") {
      const c = r.getApplyData(i, o), f = (o == null ? void 0 : o.uuids) ?? r.items.base.map(({ uuid: m }) => m) ?? [], p = [...r.items.base, ...r.items.options].reduce((m, { uuid: g, quantityOverride: h }) => (f.includes(g) && m.push({ uuid: g, type: "object", quantity: h }), m), []);
      n.set(l, p), foundry.utils.mergeObject(s, c ?? {});
      return;
    }
    let a;
    o ? a = r.getApplyData(i, o) : a = r.getApplyData(i), Object.entries(a ?? {}).forEach(([c, f]) => {
      if (!Array.isArray(f)) return;
      const d = foundry.utils.getProperty(s, c) ?? [], p = [.../* @__PURE__ */ new Set([...d, ...f])];
      a[c] = p;
    }), foundry.utils.mergeObject(s, a);
  }), { updateData: s, documentData: n };
}
u(LL, "prepareApplyData");
function cO(i, e, t) {
  const s = i.slice();
  return s[7] = e[t].classes, s[8] = e[t].display, s[9] = e[t].handler, s[10] = e[t].label, s[11] = e[t].tooltip, s;
}
u(cO, "get_each_context$1M");
function uO(i) {
  let e, t, s = K(
    /*heading*/
    i[1]
  ) + "", n, l, r = (
    /*buttons*/
    i[0].length && fO(i)
  );
  return {
    c() {
      e = E("header"), t = E("h3"), n = Q(s), l = F(), r && r.c(), b(t, "class", "a5e-field-wrapper__heading"), b(e, "class", "a5e-field-wrapper__header");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(t, n), A(e, l), r && r.m(e, null);
    },
    p(o, a) {
      a & /*heading*/
      2 && s !== (s = K(
        /*heading*/
        o[1]
      ) + "") && be(n, s), /*buttons*/
      o[0].length ? r ? r.p(o, a) : (r = fO(o), r.c(), r.m(e, null)) : r && (r.d(1), r = null);
    },
    d(o) {
      o && C(e), r && r.d();
    }
  };
}
u(uO, "create_if_block_2$14");
function fO(i) {
  let e, t = ue(
    /*buttons*/
    i[0]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = pO(cO(i, t, n));
  return {
    c() {
      e = E("div");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "a5e-field-wrapper__header-button-wrapper");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*buttons*/
      1) {
        t = ue(
          /*buttons*/
          n[0]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = cO(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = pO(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(fO, "create_if_block_3$H");
function dO(i) {
  let e, t = K(
    /*label*/
    i[10] ?? ""
  ) + "", s, n, l, r, o, a;
  return {
    c() {
      e = E("button"), s = Q(t), n = F(), b(e, "class", l = `a5e-field-wrapper__header-button ${/*classes*/
      i[7]}`), b(e, "data-tooltip", r = /*tooltip*/
      i[11]), b(e, "data-tooltip-direction", "UP");
    },
    m(c, f) {
      T(c, e, f), A(e, s), A(e, n), o || (a = W(e, "click", Ve(st(function() {
        $t(
          /*handler*/
          i[9]
        ) && i[9].apply(this, arguments);
      }))), o = !0);
    },
    p(c, f) {
      i = c, f & /*buttons*/
      1 && t !== (t = K(
        /*label*/
        i[10] ?? ""
      ) + "") && be(s, t), f & /*buttons*/
      1 && l !== (l = `a5e-field-wrapper__header-button ${/*classes*/
      i[7]}`) && b(e, "class", l), f & /*buttons*/
      1 && r !== (r = /*tooltip*/
      i[11]) && b(e, "data-tooltip", r);
    },
    d(c) {
      c && C(e), o = !1, a();
    }
  };
}
u(dO, "create_if_block_4$z");
function pO(i) {
  let e, t = (
    /*display*/
    (i[8] ?? !0) && dO(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*display*/
      s[8] ?? !0 ? t ? t.p(s, n) : (t = dO(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(pO, "create_each_block$1M");
function mO(i) {
  let e, t = K(
    /*hint*/
    i[2]
  ) + "", s;
  return {
    c() {
      e = E("small"), s = Q(t), b(e, "class", "a5e-field-wrapper__hint");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*hint*/
      4 && t !== (t = K(
        /*hint*/
        n[2]
      ) + "") && be(s, t);
    },
    d(n) {
      n && C(e);
    }
  };
}
u(mO, "create_if_block_1$1B");
function hO(i) {
  let e, t, s, n = K(
    /*warning*/
    i[4]
  ) + "", l;
  return {
    c() {
      e = E("small"), t = E("i"), s = F(), l = Q(n), b(t, "class", "fa-solid fa-circle-exclamation"), b(e, "class", "a5e-field-wrapper__warning");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(e, s), A(e, l);
    },
    p(r, o) {
      o & /*warning*/
      16 && n !== (n = K(
        /*warning*/
        r[4]
      ) + "") && be(l, n);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(hO, "create_if_block$2t");
function Xz(i) {
  let e, t, s, n, l, r = (
    /*heading*/
    i[1] && uO(i)
  );
  const o = (
    /*#slots*/
    i[6].default
  ), a = Gt(
    o,
    i,
    /*$$scope*/
    i[5],
    null
  );
  let c = (
    /*hint*/
    i[2] && mO(i)
  ), f = (
    /*showWarning*/
    i[3] && hO(i)
  );
  return {
    c() {
      e = E("section"), r && r.c(), t = F(), a && a.c(), s = F(), c && c.c(), n = F(), f && f.c(), b(e, "class", "a5e-field-wrapper");
    },
    m(d, p) {
      T(d, e, p), r && r.m(e, null), A(e, t), a && a.m(e, null), A(e, s), c && c.m(e, null), A(e, n), f && f.m(e, null), l = !0;
    },
    p(d, [p]) {
      /*heading*/
      d[1] ? r ? r.p(d, p) : (r = uO(d), r.c(), r.m(e, t)) : r && (r.d(1), r = null), a && a.p && (!l || p & /*$$scope*/
      32) && Ht(
        a,
        o,
        d,
        /*$$scope*/
        d[5],
        l ? zt(
          o,
          /*$$scope*/
          d[5],
          p,
          null
        ) : Ut(
          /*$$scope*/
          d[5]
        ),
        null
      ), /*hint*/
      d[2] ? c ? c.p(d, p) : (c = mO(d), c.c(), c.m(e, n)) : c && (c.d(1), c = null), /*showWarning*/
      d[3] ? f ? f.p(d, p) : (f = hO(d), f.c(), f.m(e, null)) : f && (f.d(1), f = null);
    },
    i(d) {
      l || (w(a, d), l = !0);
    },
    o(d) {
      O(a, d), l = !1;
    },
    d(d) {
      d && C(e), r && r.d(), a && a.d(d), c && c.d(), f && f.d();
    }
  };
}
u(Xz, "create_fragment$4C");
function Jz(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e, { buttons: l = [] } = e, { heading: r = "" } = e, { hint: o = "" } = e, { showWarning: a = !1 } = e, { warning: c = "" } = e;
  return i.$$set = (f) => {
    "buttons" in f && t(0, l = f.buttons), "heading" in f && t(1, r = f.heading), "hint" in f && t(2, o = f.hint), "showWarning" in f && t(3, a = f.showWarning), "warning" in f && t(4, c = f.warning), "$$scope" in f && t(5, n = f.$$scope);
  }, [l, r, o, a, c, n, s];
}
u(Jz, "instance$4t");
const Kw = class Kw extends re {
  constructor(e) {
    super(), oe(this, e, Jz, Xz, le, {
      buttons: 0,
      heading: 1,
      hint: 2,
      showWarning: 3,
      warning: 4
    });
  }
};
u(Kw, "FieldWrapper");
let ie = Kw;
function Zz(i) {
  let e, t, s = K(
    /*label*/
    i[1]
  ) + "", n, l, r;
  return {
    c() {
      e = E("li"), t = E("button"), n = Q(s), b(t, "class", "tag svelte-7v3o5h"), b(
        t,
        "style",
        /*style*/
        i[6]
      ), t.disabled = /*disabled*/
      i[0], t.value = /*value*/
      i[5], b(
        t,
        "data-tooltip",
        /*tooltipText*/
        i[4]
      ), b(
        t,
        "data-tooltip-direction",
        /*tooltipDirection*/
        i[3]
      ), Z(
        t,
        "tag--tight",
        /*tight*/
        i[2]
      );
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(t, n), l || (r = [
        W(t, "click", st(
          /*click_handler*/
          i[14]
        )),
        W(t, "auxclick", st(
          /*auxclick_handler*/
          i[15]
        ))
      ], l = !0);
    },
    p(o, [a]) {
      a & /*label*/
      2 && s !== (s = K(
        /*label*/
        o[1]
      ) + "") && be(n, s), a & /*style*/
      64 && b(
        t,
        "style",
        /*style*/
        o[6]
      ), a & /*disabled*/
      1 && (t.disabled = /*disabled*/
      o[0]), a & /*value*/
      32 && (t.value = /*value*/
      o[5]), a & /*tooltipText*/
      16 && b(
        t,
        "data-tooltip",
        /*tooltipText*/
        o[4]
      ), a & /*tooltipDirection*/
      8 && b(
        t,
        "data-tooltip-direction",
        /*tooltipDirection*/
        o[3]
      ), a & /*tight*/
      4 && Z(
        t,
        "tag--tight",
        /*tight*/
        o[2]
      );
    },
    i: se,
    o: se,
    d(o) {
      o && C(e), l = !1, Me(r);
    }
  };
}
u(Zz, "create_fragment$4B");
function Qz(i, e, t, s) {
  return i ? "green" : s ? "disabled" : e ? "red" : t ? "orange" : "default";
}
u(Qz, "getColor");
function xz(i, e, t) {
  let s, n, l, { active: r = !1 } = e, { disabled: o = !1 } = e, { optionStyles: a = "" } = e, { orange: c = !1 } = e, { red: f = !1 } = e, { label: d = "" } = e, { tight: p = !1 } = e, { tooltipDirection: m = "UP" } = e, { tooltipText: g = "" } = e, { value: h = "" } = e;
  function _(S) {
    return S === "red" ? `
                --tag-font-color: hsl(0, 58%, 100%);
                --tag-background-color: var(--a5e-color-error);
                --tag-border-color: hsl(0, 58%, 28%);
                --tag-hover-background-color: var(--a5e-color-error);
                --tag-hover-font-color: var(--color-hover, hsl(0, 58%, 100%));
            ` : S === "orange" ? `
                --tag-font-color: hsl(36, 58%, 100%);
                --tag-background-color: var(--a5e-color-warning);
                --tag-border-color: hsl(36, 58%, 28%);
                --tag-hover-background-color: var(--a5e-color-warning);
                --tag-hover-font-color: var(--color-hover, hsl(36, 58%, 100%));
            ` : S === "green" ? `
                --tag-font-color: hsl(190, 21%, 100%);
                --tag-background-color: var(--a5e-color-primary);
                --tag-border-color: hsl(190, 21%, 28%);
                --tag-hover-background-color: var(--a5e-color-primary);
                --tag-hover-font-color: var(--color-hover, hsl(190, 21%, 100%));
            ` : S === "disabled" ? `
                --tag-font-color: hsl(0, 0%, 100%);
                --tag-background-color: var(--a5e-color-disabled);
                --tag-border-color: hsl(0, 0%, 60%);
                --tag-hover-background-color: var(--a5e-color-disabled);
                --tag-hover-font-color: var(--color-hover, hsl(0, 0%, 100%));
            ` : `
            --tag-font-color: inherit;
            --tag-background-color: transparent;
            --tag-border-color: #706b55;
            --tag-hover-background-color: #d8d4c6;
            --tag-hover-font-color: var(--color-hover, inherit);
        `;
  }
  u(_, "getColorData");
  const y = ft(), v = /* @__PURE__ */ u(() => y("tagToggle", h), "click_handler"), k = /* @__PURE__ */ u(() => y("tagToggleAux", h), "auxclick_handler");
  return i.$$set = (S) => {
    "active" in S && t(8, r = S.active), "disabled" in S && t(0, o = S.disabled), "optionStyles" in S && t(9, a = S.optionStyles), "orange" in S && t(10, c = S.orange), "red" in S && t(11, f = S.red), "label" in S && t(1, d = S.label), "tight" in S && t(2, p = S.tight), "tooltipDirection" in S && t(3, m = S.tooltipDirection), "tooltipText" in S && t(4, g = S.tooltipText), "value" in S && t(5, h = S.value);
  }, i.$$.update = () => {
    i.$$.dirty & /*active, red, orange, disabled*/
    3329 && t(13, s = Qz(r, f, c, o)), i.$$.dirty & /*color*/
    8192 && t(12, n = _(s)), i.$$.dirty & /*colorStyles, optionStyles*/
    4608 && t(6, l = `${n} ${a}`);
  }, [
    o,
    d,
    p,
    m,
    g,
    h,
    l,
    y,
    r,
    a,
    c,
    f,
    n,
    s,
    v,
    k
  ];
}
u(xz, "instance$4s");
const Yw = class Yw extends re {
  constructor(e) {
    super(), oe(this, e, xz, Zz, le, {
      active: 8,
      disabled: 0,
      optionStyles: 9,
      orange: 10,
      red: 11,
      label: 1,
      tight: 2,
      tooltipDirection: 3,
      tooltipText: 4,
      value: 5
    });
  }
};
u(Yw, "Tag");
let po = Yw;
function gu(i, e) {
  if (!Array.isArray(i) || !Array.isArray(e)) return !1;
  const t = Array.from(i).sort(), s = Array.from(e).sort();
  return t.length === s.length && t.every((n, l) => n === s[l]);
}
u(gu, "arraysAreEqual");
function gO(i, e, t) {
  const s = i.slice();
  return s[20] = e[t][0], s[21] = e[t][1], s;
}
u(gO, "get_each_context$1L");
function bO(i) {
  var s, n, l;
  let e, t;
  return e = new po({
    props: {
      active: (
        /*selected*/
        i[0].includes(
          /*value*/
          i[20]
        )
      ),
      label: (
        /*label*/
        i[21]
      ),
      optionStyles: (
        /*optionStyles*/
        i[7]
      ),
      value: (
        /*value*/
        i[20]
      ),
      red: (
        /*red*/
        (s = i[9]) == null ? void 0 : s.includes(
          /*value*/
          i[20]
        )
      ),
      orange: (
        /*orange*/
        (n = i[8]) == null ? void 0 : n.includes(
          /*value*/
          i[20]
        )
      ),
      disabled: (
        /*disabledOptions*/
        i[2].includes(
          /*value*/
          i[20]
        ) || /*disabled*/
        i[1] && !/*selected*/
        i[0].includes(
          /*value*/
          i[20]
        )
      ),
      tooltipText: (
        /*tooltipData*/
        ((l = i[11]) == null ? void 0 : l[
          /*value*/
          i[20]
        ]) ?? ""
      )
    }
  }), e.$on(
    "tagToggle",
    /*tagToggle_handler*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(r, o) {
      R(e, r, o), t = !0;
    },
    p(r, o) {
      var c, f, d;
      const a = {};
      o & /*selected, options*/
      65 && (a.active = /*selected*/
      r[0].includes(
        /*value*/
        r[20]
      )), o & /*options*/
      64 && (a.label = /*label*/
      r[21]), o & /*optionStyles*/
      128 && (a.optionStyles = /*optionStyles*/
      r[7]), o & /*options*/
      64 && (a.value = /*value*/
      r[20]), o & /*red, options*/
      576 && (a.red = /*red*/
      (c = r[9]) == null ? void 0 : c.includes(
        /*value*/
        r[20]
      )), o & /*orange, options*/
      320 && (a.orange = /*orange*/
      (f = r[8]) == null ? void 0 : f.includes(
        /*value*/
        r[20]
      )), o & /*disabledOptions, options, disabled, selected*/
      71 && (a.disabled = /*disabledOptions*/
      r[2].includes(
        /*value*/
        r[20]
      ) || /*disabled*/
      r[1] && !/*selected*/
      r[0].includes(
        /*value*/
        r[20]
      )), o & /*tooltipData, options*/
      2112 && (a.tooltipText = /*tooltipData*/
      ((d = r[11]) == null ? void 0 : d[
        /*value*/
        r[20]
      ]) ?? ""), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      O(e.$$.fragment, r), t = !1;
    },
    d(r) {
      N(e, r);
    }
  };
}
u(bO, "create_each_block$1L");
function eH(i) {
  let e, t, s, n = ue(
    /*options*/
    i[6]
  ), l = [];
  for (let o = 0; o < n.length; o += 1)
    l[o] = bO(gO(i, n, o));
  const r = /* @__PURE__ */ u((o) => O(l[o], 1, 1, () => {
    l[o] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let o = 0; o < l.length; o += 1)
        l[o].c();
      b(e, "class", t = "u-flex u-flex-wrap u-gap-sm u-list-style-none u-m-0 u-p-0 u-text-xs u-w-full " + /*listClasses*/
      i[5]);
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < l.length; c += 1)
        l[c] && l[c].m(e, null);
      s = !0;
    },
    p(o, a) {
      if (a & /*selected, options, optionStyles, red, orange, disabledOptions, disabled, tooltipData, updateSelection*/
      11207) {
        n = ue(
          /*options*/
          o[6]
        );
        let c;
        for (c = 0; c < n.length; c += 1) {
          const f = gO(o, n, c);
          l[c] ? (l[c].p(f, a), w(l[c], 1)) : (l[c] = bO(f), l[c].c(), w(l[c], 1), l[c].m(e, null));
        }
        for (ae(), c = n.length; c < l.length; c += 1)
          r(c);
        ce();
      }
      (!s || a & /*listClasses*/
      32 && t !== (t = "u-flex u-flex-wrap u-gap-sm u-list-style-none u-m-0 u-p-0 u-text-xs u-w-full " + /*listClasses*/
      o[5])) && b(e, "class", t);
    },
    i(o) {
      if (!s) {
        for (let a = 0; a < n.length; a += 1)
          w(l[a]);
        s = !0;
      }
    },
    o(o) {
      l = l.filter(Boolean);
      for (let a = 0; a < l.length; a += 1)
        O(l[a]);
      s = !1;
    },
    d(o) {
      o && C(e), Le(l, o);
    }
  };
}
u(eH, "create_default_slot$2A");
function tH(i) {
  let e, t, s;
  return e = new ie({
    props: {
      buttons: (
        /*buttons*/
        i[14]
      ),
      heading: (
        /*heading*/
        i[3]
      ),
      hint: (
        /*hint*/
        i[4]
      ),
      showWarning: (
        /*showWarning*/
        i[10]
      ),
      warning: (
        /*warning*/
        i[12]
      ),
      $$slots: { default: [eH] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-header-item-justification", "flex-start"), G(t, "--a5e-field-wrapper-header-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*heading*/
      8 && (r.heading = /*heading*/
      n[3]), l & /*hint*/
      16 && (r.hint = /*hint*/
      n[4]), l & /*showWarning*/
      1024 && (r.showWarning = /*showWarning*/
      n[10]), l & /*warning*/
      4096 && (r.warning = /*warning*/
      n[12]), l & /*$$scope, listClasses, options, selected, optionStyles, red, orange, disabledOptions, disabled, tooltipData*/
      16780263 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(tH, "create_fragment$4A");
function sH(i, e, t) {
  let { disabled: s = !1 } = e, { disabledOptions: n = [] } = e, { heading: l = "" } = e, { hint: r = "" } = e, { listClasses: o = "" } = e, { options: a = [] } = e, { optionStyles: c = "" } = e, { orange: f = [] } = e, { red: d = [] } = e, { selected: p = [] } = e, { showToggleAllButton: m = !1 } = e, { showWarning: g = !1 } = e, { tooltipData: h = {} } = e, { warning: _ = "" } = e;
  function y() {
    return m ? [
      {
        classes: "u-text-xs",
        label: "+ Toggle All",
        handler: k
      }
    ] : [];
  }
  u(y, "getButtons");
  function v(M) {
    const L = new Set(p);
    L.has(M) ? L.delete(M) : L.add(M), S("updateSelection", [...L]);
  }
  u(v, "updateSelection");
  function k() {
    const M = a.map(([B]) => B);
    gu(M, p) ? t(0, p = []) : t(0, p = M), S("updateSelection", p);
  }
  u(k, "toggleAll");
  const S = ft(), D = y(), I = /* @__PURE__ */ u(({ detail: M }) => v(M), "tagToggle_handler");
  return i.$$set = (M) => {
    "disabled" in M && t(1, s = M.disabled), "disabledOptions" in M && t(2, n = M.disabledOptions), "heading" in M && t(3, l = M.heading), "hint" in M && t(4, r = M.hint), "listClasses" in M && t(5, o = M.listClasses), "options" in M && t(6, a = M.options), "optionStyles" in M && t(7, c = M.optionStyles), "orange" in M && t(8, f = M.orange), "red" in M && t(9, d = M.red), "selected" in M && t(0, p = M.selected), "showToggleAllButton" in M && t(15, m = M.showToggleAllButton), "showWarning" in M && t(10, g = M.showWarning), "tooltipData" in M && t(11, h = M.tooltipData), "warning" in M && t(12, _ = M.warning);
  }, [
    p,
    s,
    n,
    l,
    r,
    o,
    a,
    c,
    f,
    d,
    g,
    h,
    _,
    v,
    D,
    m,
    I
  ];
}
u(sH, "instance$4r");
const Xw = class Xw extends re {
  constructor(e) {
    super(), oe(this, e, sH, tH, le, {
      disabled: 1,
      disabledOptions: 2,
      heading: 3,
      hint: 4,
      listClasses: 5,
      options: 6,
      optionStyles: 7,
      orange: 8,
      red: 9,
      selected: 0,
      showToggleAllButton: 15,
      showWarning: 10,
      tooltipData: 11,
      warning: 12
    });
  }
};
u(Xw, "CheckboxGroup");
let tt = Xw;
function _O(i, e, t) {
  const s = i.slice();
  return s[15] = e[t][0], s[16] = e[t][1], s;
}
u(_O, "get_each_context$1K");
function yO(i) {
  var s, n, l;
  let e, t;
  return e = new po({
    props: {
      active: (
        /*selected*/
        i[7] === /*value*/
        i[15] || /*selected*/
        ((s = i[7]) == null ? void 0 : s.toString()) === /*value*/
        ((n = i[15]) == null ? void 0 : n.toString())
      ),
      label: (
        /*label*/
        i[16]
      ),
      optionStyles: (
        /*optionStyles*/
        i[5]
      ),
      value: (
        /*value*/
        i[15]
      ),
      disabled: (
        /*disabled*/
        i[1].includes(
          /*value*/
          i[15]
        )
      ),
      tooltipText: (
        /*tooltipData*/
        ((l = i[9]) == null ? void 0 : l[
          /*value*/
          i[15]
        ]) ?? ""
      )
    }
  }), e.$on(
    "tagToggle",
    /*tagToggle_handler*/
    i[13]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(r, o) {
      R(e, r, o), t = !0;
    },
    p(r, o) {
      var c, f, d;
      const a = {};
      o & /*selected, options*/
      192 && (a.active = /*selected*/
      r[7] === /*value*/
      r[15] || /*selected*/
      ((c = r[7]) == null ? void 0 : c.toString()) === /*value*/
      ((f = r[15]) == null ? void 0 : f.toString())), o & /*options*/
      64 && (a.label = /*label*/
      r[16]), o & /*optionStyles*/
      32 && (a.optionStyles = /*optionStyles*/
      r[5]), o & /*options*/
      64 && (a.value = /*value*/
      r[15]), o & /*disabled, options*/
      66 && (a.disabled = /*disabled*/
      r[1].includes(
        /*value*/
        r[15]
      )), o & /*tooltipData, options*/
      576 && (a.tooltipText = /*tooltipData*/
      ((d = r[9]) == null ? void 0 : d[
        /*value*/
        r[15]
      ]) ?? ""), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      O(e.$$.fragment, r), t = !1;
    },
    d(r) {
      N(e, r);
    }
  };
}
u(yO, "create_each_block$1K");
function nH(i) {
  let e, t, s, n = ue(
    /*options*/
    i[6]
  ), l = [];
  for (let o = 0; o < n.length; o += 1)
    l[o] = yO(_O(i, n, o));
  const r = /* @__PURE__ */ u((o) => O(l[o], 1, 1, () => {
    l[o] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let o = 0; o < l.length; o += 1)
        l[o].c();
      b(e, "class", t = "radio-group " + /*listClasses*/
      i[4] + " svelte-15gj0ph");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < l.length; c += 1)
        l[c] && l[c].m(e, null);
      s = !0;
    },
    p(o, a) {
      if (a & /*selected, options, optionStyles, disabled, tooltipData, updateSelection*/
      2786) {
        n = ue(
          /*options*/
          o[6]
        );
        let c;
        for (c = 0; c < n.length; c += 1) {
          const f = _O(o, n, c);
          l[c] ? (l[c].p(f, a), w(l[c], 1)) : (l[c] = yO(f), l[c].c(), w(l[c], 1), l[c].m(e, null));
        }
        for (ae(), c = n.length; c < l.length; c += 1)
          r(c);
        ce();
      }
      (!s || a & /*listClasses*/
      16 && t !== (t = "radio-group " + /*listClasses*/
      o[4] + " svelte-15gj0ph")) && b(e, "class", t);
    },
    i(o) {
      if (!s) {
        for (let a = 0; a < n.length; a += 1)
          w(l[a]);
        s = !0;
      }
    },
    o(o) {
      l = l.filter(Boolean);
      for (let a = 0; a < l.length; a += 1)
        O(l[a]);
      s = !1;
    },
    d(o) {
      o && C(e), Le(l, o);
    }
  };
}
u(nH, "create_default_slot$2z");
function iH(i) {
  let e, t, s;
  return e = new ie({
    props: {
      buttons: (
        /*buttons*/
        i[0]
      ),
      heading: (
        /*heading*/
        i[2]
      ),
      hint: (
        /*hint*/
        i[3]
      ),
      showWarning: (
        /*showWarning*/
        i[8]
      ),
      warning: (
        /*warning*/
        i[10]
      ),
      $$slots: { default: [nH] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-header-item-justification", "flex-start"), G(t, "--a5e-field-wrapper-header-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*buttons*/
      1 && (r.buttons = /*buttons*/
      n[0]), l & /*heading*/
      4 && (r.heading = /*heading*/
      n[2]), l & /*hint*/
      8 && (r.hint = /*hint*/
      n[3]), l & /*showWarning*/
      256 && (r.showWarning = /*showWarning*/
      n[8]), l & /*warning*/
      1024 && (r.warning = /*warning*/
      n[10]), l & /*$$scope, listClasses, options, selected, optionStyles, disabled, tooltipData*/
      525042 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(iH, "create_fragment$4z");
function lH(i, e, t) {
  let { allowDeselect: s = !0 } = e, { buttons: n = [] } = e, { disabled: l = [] } = e, { heading: r = "" } = e, { hint: o = "" } = e, { listClasses: a = "" } = e, { optionStyles: c = "" } = e, { options: f = [] } = e, { selected: d = "" } = e, { showWarning: p = !1 } = e, { tooltipData: m = {} } = e, { warning: g = "" } = e;
  const h = ft();
  function _(v) {
    s ? h("updateSelection", v === d ? "" : v) : h("updateSelection", v);
  }
  u(_, "updateSelection");
  const y = /* @__PURE__ */ u(({ detail: v }) => _(v), "tagToggle_handler");
  return i.$$set = (v) => {
    "allowDeselect" in v && t(12, s = v.allowDeselect), "buttons" in v && t(0, n = v.buttons), "disabled" in v && t(1, l = v.disabled), "heading" in v && t(2, r = v.heading), "hint" in v && t(3, o = v.hint), "listClasses" in v && t(4, a = v.listClasses), "optionStyles" in v && t(5, c = v.optionStyles), "options" in v && t(6, f = v.options), "selected" in v && t(7, d = v.selected), "showWarning" in v && t(8, p = v.showWarning), "tooltipData" in v && t(9, m = v.tooltipData), "warning" in v && t(10, g = v.warning);
  }, [
    n,
    l,
    r,
    o,
    a,
    c,
    f,
    d,
    p,
    m,
    g,
    _,
    s,
    y
  ];
}
u(lH, "instance$4q");
const Jw = class Jw extends re {
  constructor(e) {
    super(), oe(this, e, lH, iH, le, {
      allowDeselect: 12,
      buttons: 0,
      disabled: 1,
      heading: 2,
      hint: 3,
      listClasses: 4,
      optionStyles: 5,
      options: 6,
      selected: 7,
      showWarning: 8,
      tooltipData: 9,
      warning: 10
    });
  }
};
u(Jw, "RadioGroup");
let Ke = Jw;
function vO(i, e, t) {
  const s = i.slice();
  return s[8] = e[t].classes, s[9] = e[t].display, s[10] = e[t].handler, s[11] = e[t].htmlString, s[12] = e[t].label, s[13] = e[t].tooltip, s;
}
u(vO, "get_each_context$1J");
function kO(i) {
  let e, t, s = K(
    /*heading*/
    i[2]
  ) + "", n, l, r, o = (
    /*headerButtons*/
    i[0].length && wO(i)
  );
  return {
    c() {
      e = E("header"), t = E("h3"), n = Q(s), l = F(), o && o.c(), b(t, "class", "a5e-section-header__heading"), b(e, "class", r = "a5e-section-header " + /*headerClasses*/
      i[1]);
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(t, n), A(e, l), o && o.m(e, null);
    },
    p(a, c) {
      c & /*heading*/
      4 && s !== (s = K(
        /*heading*/
        a[2]
      ) + "") && be(n, s), /*headerButtons*/
      a[0].length ? o ? o.p(a, c) : (o = wO(a), o.c(), o.m(e, null)) : o && (o.d(1), o = null), c & /*headerClasses*/
      2 && r !== (r = "a5e-section-header " + /*headerClasses*/
      a[1]) && b(e, "class", r);
    },
    d(a) {
      a && C(e), o && o.d();
    }
  };
}
u(kO, "create_if_block_2$13");
function wO(i) {
  let e, t = ue(
    /*headerButtons*/
    i[0]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = AO(vO(i, t, n));
  return {
    c() {
      e = E("div");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "a5e-section-header__button-wrapper");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*headerButtons*/
      1) {
        t = ue(
          /*headerButtons*/
          n[0]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = vO(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = AO(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(wO, "create_if_block_3$G");
function $O(i) {
  let e, t, s, n, l, r;
  function o(f, d) {
    return (
      /*htmlString*/
      f[11] ? aH : (
        /*label*/
        f[12] ? oH : rH
      )
    );
  }
  u(o, "select_block_type");
  let a = o(i), c = a(i);
  return {
    c() {
      e = E("button"), c.c(), t = F(), b(e, "class", s = `a5e-section-header__button ${/*classes*/
      i[8]}`), b(e, "data-tooltip", n = /*tooltip*/
      i[13]), b(e, "data-tooltip-direction", "UP");
    },
    m(f, d) {
      T(f, e, d), c.m(e, null), A(e, t), l || (r = W(e, "click", Ve(function() {
        $t(
          /*handler*/
          i[10]
        ) && i[10].apply(this, arguments);
      })), l = !0);
    },
    p(f, d) {
      i = f, a === (a = o(i)) && c ? c.p(i, d) : (c.d(1), c = a(i), c && (c.c(), c.m(e, t))), d & /*headerButtons*/
      1 && s !== (s = `a5e-section-header__button ${/*classes*/
      i[8]}`) && b(e, "class", s), d & /*headerButtons*/
      1 && n !== (n = /*tooltip*/
      i[13]) && b(e, "data-tooltip", n);
    },
    d(f) {
      f && C(e), c.d(), l = !1, r();
    }
  };
}
u($O, "create_if_block_4$y");
function rH(i) {
  let e = K("") + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p: se,
    d(s) {
      s && C(t);
    }
  };
}
u(rH, "create_else_block$K");
function oH(i) {
  let e = K(
    /*label*/
    i[12]
  ) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*headerButtons*/
      1 && e !== (e = K(
        /*label*/
        s[12]
      ) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(oH, "create_if_block_6$k");
function aH(i) {
  let e, t = (
    /*htmlString*/
    i[11] + ""
  ), s;
  return {
    c() {
      e = new bn(!1), s = $e(), e.a = s;
    },
    m(n, l) {
      e.m(t, n, l), T(n, s, l);
    },
    p(n, l) {
      l & /*headerButtons*/
      1 && t !== (t = /*htmlString*/
      n[11] + "") && e.p(t);
    },
    d(n) {
      n && (C(s), e.d());
    }
  };
}
u(aH, "create_if_block_5$n");
function AO(i) {
  let e, t = (
    /*display*/
    (i[9] ?? !0) && $O(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*display*/
      s[9] ?? !0 ? t ? t.p(s, n) : (t = $O(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(AO, "create_each_block$1J");
function EO(i) {
  let e, t = K(
    /*hint*/
    i[3]
  ) + "", s;
  return {
    c() {
      e = E("small"), s = Q(t), b(e, "class", "a5e-section__hint");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*hint*/
      8 && t !== (t = K(
        /*hint*/
        n[3]
      ) + "") && be(s, t);
    },
    d(n) {
      n && C(e);
    }
  };
}
u(EO, "create_if_block_1$1A");
function SO(i) {
  let e, t, s, n = K(
    /*warning*/
    i[5]
  ) + "", l;
  return {
    c() {
      e = E("small"), t = E("i"), s = F(), l = Q(n), b(t, "class", "fa-solid fa-circle-exclamation"), b(e, "class", "a5e-section__warning");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(e, s), A(e, l);
    },
    p(r, o) {
      o & /*warning*/
      32 && n !== (n = K(
        /*warning*/
        r[5]
      ) + "") && be(l, n);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(SO, "create_if_block$2s");
function cH(i) {
  let e, t, s, n, l, r, o = (
    /*heading*/
    i[2] && kO(i)
  ), a = (
    /*hint*/
    i[3] && EO(i)
  ), c = (
    /*showWarning*/
    i[4] && SO(i)
  );
  const f = (
    /*#slots*/
    i[7].default
  ), d = Gt(
    f,
    i,
    /*$$scope*/
    i[6],
    null
  );
  return {
    c() {
      e = E("section"), o && o.c(), t = F(), s = E("div"), a && a.c(), n = F(), c && c.c(), l = F(), d && d.c(), b(s, "class", "a5e-section__body"), b(e, "class", "a5e-section");
    },
    m(p, m) {
      T(p, e, m), o && o.m(e, null), A(e, t), A(e, s), a && a.m(s, null), A(s, n), c && c.m(s, null), A(s, l), d && d.m(s, null), r = !0;
    },
    p(p, [m]) {
      /*heading*/
      p[2] ? o ? o.p(p, m) : (o = kO(p), o.c(), o.m(e, t)) : o && (o.d(1), o = null), /*hint*/
      p[3] ? a ? a.p(p, m) : (a = EO(p), a.c(), a.m(s, n)) : a && (a.d(1), a = null), /*showWarning*/
      p[4] ? c ? c.p(p, m) : (c = SO(p), c.c(), c.m(s, l)) : c && (c.d(1), c = null), d && d.p && (!r || m & /*$$scope*/
      64) && Ht(
        d,
        f,
        p,
        /*$$scope*/
        p[6],
        r ? zt(
          f,
          /*$$scope*/
          p[6],
          m,
          null
        ) : Ut(
          /*$$scope*/
          p[6]
        ),
        null
      );
    },
    i(p) {
      r || (w(d, p), r = !0);
    },
    o(p) {
      O(d, p), r = !1;
    },
    d(p) {
      p && C(e), o && o.d(), a && a.d(), c && c.d(), d && d.d(p);
    }
  };
}
u(cH, "create_fragment$4y");
function uH(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e, { headerButtons: l = [] } = e, { headerClasses: r = "" } = e, { heading: o = "" } = e, { hint: a = "" } = e, { showWarning: c = !1 } = e, { warning: f = "" } = e;
  return i.$$set = (d) => {
    "headerButtons" in d && t(0, l = d.headerButtons), "headerClasses" in d && t(1, r = d.headerClasses), "heading" in d && t(2, o = d.heading), "hint" in d && t(3, a = d.hint), "showWarning" in d && t(4, c = d.showWarning), "warning" in d && t(5, f = d.warning), "$$scope" in d && t(6, n = d.$$scope);
  }, [
    l,
    r,
    o,
    a,
    c,
    f,
    n,
    s
  ];
}
u(uH, "instance$4p");
const Zw = class Zw extends re {
  constructor(e) {
    super(), oe(this, e, uH, cH, le, {
      headerButtons: 0,
      headerClasses: 1,
      heading: 2,
      hint: 3,
      showWarning: 4,
      warning: 5
    });
  }
};
u(Zw, "Section");
let De = Zw;
function fH(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [mH] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope*/
      8192 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(fH, "create_if_block_2$12");
function dH(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [hH] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, rollFormula*/
      8196 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(dH, "create_if_block_1$1z");
function pH(i) {
  let e, t, s = (
    /*cls*/
    i[0].averageHP + ""
  ), n;
  return {
    c() {
      e = E("div"), t = Q("Average: "), n = Q(s), b(e, "class", "roll-formula-preview svelte-19bb735");
    },
    m(l, r) {
      T(l, e, r), A(e, t), A(e, n);
    },
    p(l, r) {
      r & /*cls*/
      1 && s !== (s = /*cls*/
      l[0].averageHP + "") && be(n, s);
    },
    i: se,
    o: se,
    d(l) {
      l && C(e);
    }
  };
}
u(pH, "create_if_block$2r");
function mH(i) {
  let e, t, s;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--small a5e-input--slim"), b(e, "type", "number"), b(e, "min", "0"), e.value = /*customHp*/
      i[6] ?? 0;
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "change",
        /*change_handler_1*/
        i[11]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(mH, "create_default_slot_2$1a");
function hH(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--small a5e-input--slim"), b(e, "type", "text"), e.value = t = /*rollFormula*/
      i[2] ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*rollFormula*/
      4 && t !== (t = /*rollFormula*/
      l[2] ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(hH, "create_default_slot_1$1y");
function gH(i) {
  let e, t, s, n, l, r;
  e = new Ke({
    props: {
      options: Object.entries(
        /*classHPTypes*/
        i[5]
      ),
      selected: (
        /*leveledHpType*/
        i[1]
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[9]
  );
  const o = [pH, dH, fH], a = [];
  function c(f, d) {
    return (
      /*leveledHpType*/
      f[1] === "average" ? 0 : (
        /*leveledHpType*/
        f[1] === "roll" ? 1 : (
          /*leveledHpType*/
          f[1] === "custom" ? 2 : -1
        )
      )
    );
  }
  return u(c, "select_block_type"), ~(s = c(i)) && (n = a[s] = o[s](i)), {
    c() {
      j(e.$$.fragment), t = F(), n && n.c(), l = $e();
    },
    m(f, d) {
      R(e, f, d), T(f, t, d), ~s && a[s].m(f, d), T(f, l, d), r = !0;
    },
    p(f, d) {
      const p = {};
      d & /*leveledHpType*/
      2 && (p.selected = /*leveledHpType*/
      f[1]), e.$set(p);
      let m = s;
      s = c(f), s === m ? ~s && a[s].p(f, d) : (n && (ae(), O(a[m], 1, 1, () => {
        a[m] = null;
      }), ce()), ~s ? (n = a[s], n ? n.p(f, d) : (n = a[s] = o[s](f), n.c()), w(n, 1), n.m(l.parentNode, l)) : n = null);
    },
    i(f) {
      r || (w(e.$$.fragment, f), w(n), r = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(n), r = !1;
    },
    d(f) {
      f && (C(t), C(l)), N(e, f), ~s && a[s].d(f);
    }
  };
}
u(gH, "create_default_slot$2y");
function bH(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Hit Points Configuration",
      $$slots: { default: [gH] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, cls, leveledHpType, rollFormula*/
      8199 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(bH, "create_fragment$4x");
function _H(i, e, t) {
  var _, y, v;
  let { cls: s } = e, { classLevel: n } = e, { clsReturnData: l } = e;
  function r() {
    return `1d${s.hitDice.size}`;
  }
  u(r, "getHpRollFormula");
  function o(k) {
    typeof k == "string" ? t(7, l.hpFormula = k, l) : t(7, l.hpValue = k, l), t(7, l.leveledHpType = f, l);
  }
  u(o, "updateHpValue");
  function a(k) {
    t(1, f = k), f === "average" ? o(s.averageHP) : f === "roll" ? o(r()) : f === "custom" && o(p);
  }
  u(a, "updateLeveledHpType");
  const { classHPTypes: c } = CONFIG.A5E;
  let f = "average", d = r(), p = ((v = (y = (_ = s.system) == null ? void 0 : _.hp) == null ? void 0 : y.levels) == null ? void 0 : v[n]) ?? 0;
  f === "average" ? o(s.averageHP) : f === "roll" && o(r());
  const m = /* @__PURE__ */ u(({ detail: k }) => {
    a(k);
  }, "updateSelection_handler"), g = /* @__PURE__ */ u(({ target: k }) => {
    t(2, d = k == null ? void 0 : k.value), o(d);
  }, "change_handler"), h = /* @__PURE__ */ u(({ target: k }) => {
    o(Number(k == null ? void 0 : k.value));
  }, "change_handler_1");
  return i.$$set = (k) => {
    "cls" in k && t(0, s = k.cls), "classLevel" in k && t(8, n = k.classLevel), "clsReturnData" in k && t(7, l = k.clsReturnData);
  }, [
    s,
    f,
    d,
    o,
    a,
    c,
    p,
    l,
    n,
    m,
    g,
    h
  ];
}
u(_H, "instance$4o");
const Qw = class Qw extends re {
  constructor(e) {
    super(), oe(this, e, _H, bH, le, { cls: 0, classLevel: 8, clsReturnData: 7 });
  }
};
u(Qw, "ClassHitPointsSelection");
let K1 = Qw;
function CO(i, e, t) {
  const s = i.slice();
  return s[32] = e[t].grant, s[33] = e[t].id, s;
}
u(CO, "get_each_context$1I");
function TO(i) {
  let e, t = (
    /*showSpellAbilitySelection*/
    i[10]()
  ), s, n, l, r = (
    /*clsLevel*/
    i[2] > 1 && /*item*/
    i[0].type === "class" && OO(i)
  ), o = t && yH(i), a = (
    /*archetypeChoices*/
    i[12].length && kH(i)
  );
  return {
    c() {
      r && r.c(), e = F(), o && o.c(), s = F(), a && a.c(), n = $e();
    },
    m(c, f) {
      r && r.m(c, f), T(c, e, f), o && o.m(c, f), T(c, s, f), a && a.m(c, f), T(c, n, f), l = !0;
    },
    p(c, f) {
      /*clsLevel*/
      c[2] > 1 && /*item*/
      c[0].type === "class" ? r ? (r.p(c, f), f[0] & /*clsLevel, item*/
      5 && w(r, 1)) : (r = OO(c), r.c(), w(r, 1), r.m(e.parentNode, e)) : r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce()), t && o.p(c, f), /*archetypeChoices*/
      c[12].length && a.p(c, f);
    },
    i(c) {
      l || (w(r), w(o), w(a), l = !0);
    },
    o(c) {
      O(r), O(o), O(a), l = !1;
    },
    d(c) {
      c && (C(e), C(s), C(n)), r && r.d(c), o && o.d(c), a && a.d(c);
    }
  };
}
u(TO, "create_if_block_1$1y");
function OO(i) {
  let e, t, s;
  function n(r) {
    i[20](r);
  }
  u(n, "classhitpointsselection_clsReturnData_binding");
  let l = {
    cls: (
      /*cls*/
      i[1]
    ),
    classLevel: (
      /*clsLevel*/
      i[2]
    )
  };
  return (
    /*clsReturnData*/
    i[5] !== void 0 && (l.clsReturnData = /*clsReturnData*/
    i[5]), e = new K1({ props: l }), rt.push(() => Ot(e, "clsReturnData", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        o[0] & /*cls*/
        2 && (a.cls = /*cls*/
        r[1]), o[0] & /*clsLevel*/
        4 && (a.classLevel = /*clsLevel*/
        r[2]), !t && o[0] & /*clsReturnData*/
        32 && (t = !0, a.clsReturnData = /*clsReturnData*/
        r[5], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(OO, "create_if_block_4$x");
function yH(i) {
  let e, t;
  return e = new De({
    props: {
      heading: "Spellcasting Config",
      $$slots: { default: [vH] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*spellCastingOptions, spellcastingAbility*/
      192 | n[1] & /*$$scope*/
      32 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(yH, "create_if_block_3$F");
function vH(i) {
  let e, t;
  return e = new Ke({
    props: {
      options: (
        /*spellCastingOptions*/
        i[7]
      ),
      allowDeselect: !1,
      selected: (
        /*spellcastingAbility*/
        i[6] || ""
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[21]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*spellCastingOptions*/
      128 && (l.options = /*spellCastingOptions*/
      s[7]), n[0] & /*spellcastingAbility*/
      64 && (l.selected = /*spellcastingAbility*/
      s[6] || ""), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(vH, "create_default_slot_2$19");
function kH(i) {
  let e, t;
  return e = new De({
    props: {
      heading: "Archetype Selection",
      $$slots: { default: [wH] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*clsReturnData*/
      32 | n[1] & /*$$scope*/
      32 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(kH, "create_if_block_2$11");
function wH(i) {
  let e, t;
  return e = new Ke({
    props: {
      options: (
        /*archetypeChoices*/
        i[12]
      ),
      allowDeselect: !1,
      selected: (
        /*clsReturnData*/
        i[5].archetype || ""
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[22]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*clsReturnData*/
      32 && (l.selected = /*clsReturnData*/
      s[5].archetype || ""), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(wH, "create_default_slot_1$1x");
function DO(i) {
  let e, t;
  return e = new De({
    props: {
      heading: "Optional Grants Selection",
      $$slots: { default: [$H] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*optionalGrants, selectedOptionalGrants*/
      520 | n[1] & /*$$scope*/
      32 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(DO, "create_if_block$2q");
function $H(i) {
  let e, t;
  return e = new tt({
    props: {
      options: (
        /*optionalGrants*/
        i[9].map(MO)
      ),
      selected: (
        /*selectedOptionalGrants*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[23]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*optionalGrants*/
      512 && (l.options = /*optionalGrants*/
      s[9].map(MO)), n[0] & /*selectedOptionalGrants*/
      8 && (l.selected = /*selectedOptionalGrants*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u($H, "create_default_slot$2x");
function IO(i) {
  var a, c, f, d;
  let e, t, s;
  const n = [
    /*grant*/
    (c = (a = i[32]).getSelectionComponentProps) == null ? void 0 : c.call(
      a,
      /*applyData*/
      i[4].get(
        /*id*/
        i[33]
      ) ?? {}
    ),
    { grant: (
      /*grant*/
      i[32]
    ) }
  ];
  function l(...p) {
    return (
      /*updateSelection_handler_3*/
      i[24](
        /*id*/
        i[33],
        ...p
      )
    );
  }
  u(l, "updateSelection_handler_3");
  var r = (
    /*grant*/
    (d = (f = i[32]).getSelectionComponent) == null ? void 0 : d.call(f)
  );
  function o(p, m) {
    var h, _;
    let g = {};
    for (let y = 0; y < n.length; y += 1)
      g = Dt(g, n[y]);
    return m !== void 0 && m[0] & /*configurableGrants, applyData*/
    272 && (g = Dt(g, Vt(n, [
      Jt(
        /*grant*/
        (_ = (h = p[32]).getSelectionComponentProps) == null ? void 0 : _.call(
          h,
          /*applyData*/
          p[4].get(
            /*id*/
            p[33]
          ) ?? {}
        )
      ),
      m[0] & /*configurableGrants*/
      256 && { grant: (
        /*grant*/
        p[32]
      ) }
    ]))), { props: g };
  }
  return u(o, "switch_props"), r && (e = et(r, o(i)), e.$on("updateSelection", l)), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(p, m) {
      e && R(e, p, m), T(p, t, m), s = !0;
    },
    p(p, m) {
      var g, h, _, y;
      if (i = p, m[0] & /*configurableGrants*/
      256 && r !== (r = /*grant*/
      (h = (g = i[32]).getSelectionComponent) == null ? void 0 : h.call(g))) {
        if (e) {
          ae();
          const v = e;
          O(v.$$.fragment, 1, 0, () => {
            N(v, 1);
          }), ce();
        }
        r ? (e = et(r, o(i, m)), e.$on("updateSelection", l), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (r) {
        const v = m[0] & /*configurableGrants, applyData*/
        272 ? Vt(n, [
          Jt(
            /*grant*/
            (y = (_ = i[32]).getSelectionComponentProps) == null ? void 0 : y.call(
              _,
              /*applyData*/
              i[4].get(
                /*id*/
                i[33]
              ) ?? {}
            )
          ),
          m[0] & /*configurableGrants*/
          256 && { grant: (
            /*grant*/
            i[32]
          ) }
        ]) : {};
        e.$set(v);
      }
    },
    i(p) {
      s || (e && w(e.$$.fragment, p), s = !0);
    },
    o(p) {
      e && O(e.$$.fragment, p), s = !1;
    },
    d(p) {
      p && C(t), e && N(e, p);
    }
  };
}
u(IO, "create_each_block$1I");
function PO(i) {
  let e, t, s = ue(
    /*configurableGrants*/
    i[8]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = IO(CO(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o[0] & /*configurableGrants, applyData*/
      272) {
        s = ue(
          /*configurableGrants*/
          r[8]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = CO(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = IO(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(PO, "create_key_block$5");
function AH(i) {
  var g;
  let e, t, s, n, l = (
    /*applyData*/
    i[4]
  ), r, o, a, c, f, d = (
    /*cls*/
    i[1] && /*cls*/
    ((g = i[1]) == null ? void 0 : g.type) === "class" && TO(i)
  ), p = (
    /*optionalGrants*/
    i[9].length && DO(i)
  ), m = PO(i);
  return {
    c() {
      e = E("article"), t = E("section"), d && d.c(), s = F(), p && p.c(), n = F(), m.c(), r = F(), o = E("button"), o.textContent = "Submit", b(t, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(e, "class", "svelte-acasvl");
    },
    m(h, _) {
      T(h, e, _), A(e, t), d && d.m(t, null), A(t, s), p && p.m(t, null), A(t, n), m.m(t, null), A(t, r), A(t, o), a = !0, c || (f = W(o, "click", st(
        /*onSubmit*/
        i[11]
      )), c = !0);
    },
    p(h, _) {
      var y;
      /*cls*/
      h[1] && /*cls*/
      ((y = h[1]) == null ? void 0 : y.type) === "class" ? d ? (d.p(h, _), _[0] & /*cls*/
      2 && w(d, 1)) : (d = TO(h), d.c(), w(d, 1), d.m(t, s)) : d && (ae(), O(d, 1, 1, () => {
        d = null;
      }), ce()), /*optionalGrants*/
      h[9].length ? p ? (p.p(h, _), _[0] & /*optionalGrants*/
      512 && w(p, 1)) : (p = DO(h), p.c(), w(p, 1), p.m(t, n)) : p && (ae(), O(p, 1, 1, () => {
        p = null;
      }), ce()), _[0] & /*applyData*/
      16 && le(l, l = /*applyData*/
      h[4]) ? (ae(), O(m, 1, 1, se), ce(), m = PO(h), m.c(), w(m, 1), m.m(t, r)) : m.p(h, _);
    },
    i(h) {
      a || (w(d), w(p), w(m), a = !0);
    },
    o(h) {
      O(d), O(p), O(m), a = !1;
    },
    d(h) {
      h && C(e), d && d.d(), p && p.d(), m.d(h), c = !1, f();
    }
  };
}
u(AH, "create_fragment$4w");
const MO = /* @__PURE__ */ u((i) => [i._id, i.label], "func$f");
function EH(i, e, t) {
  let s, n, l, r, o, { allGrants: a, dialog: c, optionalGrantsProp: f, actor: d, item: p, cls: m, charLevel: g, clsLevel: h } = (
    // @ts-ignore
    de("#external").application
  ), { allGrants: _ = a, dialog: y = c, optionalGrantsProp: v = f, actor: k = d, item: S = p, cls: D = m, charLevel: I = g, clsLevel: M = h } = e;
  lt("actor", k), lt("item", S);
  function L() {
    return _.reduce(
      (Ne, Re) => {
        var ge;
        return (ge = Re.grantedBy) != null && ge.id || Ne.add(Re._id), Ne;
      },
      /* @__PURE__ */ new Set()
    );
  }
  u(L, "getStartingSelectedGrants");
  function B() {
    return v.filter((Ne) => {
      var Re;
      return !((Re = Ne.grantedBy) != null && Re.id);
    });
  }
  u(B, "getStartingOptionalGrants");
  function z() {
    const Ne = L();
    _.forEach((Re) => {
      Re.grantType === "feature" && s.has(Re._id) && Ne.add(Re._id);
    }), t(9, l = v.filter((Re) => {
      var Be, Ze;
      if (!((Be = Re.grantedBy) != null && Be.id)) return !0;
      if (!Ne.has(Re.grantedBy.id)) return !1;
      const ge = ((Ze = s.get(Re.grantedBy.id)) == null ? void 0 : Ze.uuids) ?? [];
      return !!(Re.grantedBy.selectionId ? ge.includes(Re.grantedBy.selectionId) : !1);
    })), t(18, fe = /* @__PURE__ */ new Set([...Ne, ...ke])), t(19, n = q(fe, ke)), t(8, r = n.filter((Re) => Re.requiresConfig));
  }
  u(z, "updateActiveGrants");
  function q(Ne, Re) {
    const ge = [];
    return _.forEach((je) => {
      var _e;
      const { grantedBy: Be } = je;
      if (Be != null && Be.id && !Ne.has(Be.id)) return;
      const Ze = ((_e = s.get((Be == null ? void 0 : Be.id) ?? "")) == null ? void 0 : _e.uuids) ?? [], Ge = Be != null && Be.selectionId ? Ze.includes(Be.selectionId) : !0;
      if (Be != null && Be.id && Ze && !Ge || je.optional) return;
      let Se = !1;
      je.requiresConfig() && (Se = !0), ge.push({ grant: je, requiresConfig: Se, id: je._id }), Ne.add(je._id);
    }), l.forEach((je) => {
      var _e;
      const { grantedBy: Be } = je;
      if (Be != null && Be.id && !Ne.has(Be.id))
        return;
      const Ze = ((_e = s.get((Be == null ? void 0 : Be.id) ?? "")) == null ? void 0 : _e.uuids) ?? [], Ge = Be != null && Be.selectionId ? Ze.includes(Be.selectionId) : !0;
      if (Be != null && Be.id && !Ge || !Re.includes(je._id)) return;
      let Se = !1;
      je.requiresConfig() && (Se = !0), ge.push({ grant: je, requiresConfig: Se, id: je._id }), Ne.add(je._id);
    }), ge;
  }
  u(q, "getApplicableGrants");
  function U() {
    if (!D) return [];
    if (M !== D.system.archetypeLevel) return [];
    if ((S == null ? void 0 : S.type) === "archetype") return [];
    const Ne = D == null ? void 0 : D.slug;
    return game.packs.reduce(
      (ge, je) => {
        if (je.metadata.type !== "Item") return ge;
        const Be = je.index.reduce(
          (Ze, Ge) => {
            var Se;
            return Ge.type !== "archetype" || ((Se = Ge.system) == null ? void 0 : Se.class) !== Ne || Ze.push([Ge.uuid, Ge.name || ""]), Ze;
          },
          []
        );
        return ge.push(...Be), ge;
      },
      []
    ).sort((ge, je) => ge[1].localeCompare(je[1]));
  }
  u(U, "getArchetypeChoices");
  function H() {
    var Ne, Re, ge, je, Be, Ze;
    return M === 1 && ((ge = (Re = (Ne = D == null ? void 0 : D.system) == null ? void 0 : Ne.spellcasting) == null ? void 0 : Re.ability) != null && ge.options.length) ? !0 : !((S == null ? void 0 : S.type) !== "archetype" || !((Ze = (Be = (je = S == null ? void 0 : S.system) == null ? void 0 : je.spellcasting) == null ? void 0 : Be.ability) != null && Ze.options.length));
  }
  u(H, "showSpellAbilitySelection");
  function V() {
    var Ne, Re, ge, je, Be, Ze, Ge, Se;
    return M === 1 ? ((je = (ge = (Re = (Ne = D == null ? void 0 : D.system) == null ? void 0 : Ne.spellcasting) == null ? void 0 : Re.ability) == null ? void 0 : ge.options) == null ? void 0 : je[0]) ?? "" : (S == null ? void 0 : S.type) !== "archetype" ? "" : ((Se = (Ge = (Ze = (Be = S == null ? void 0 : S.system) == null ? void 0 : Be.spellcasting) == null ? void 0 : Ze.ability) == null ? void 0 : Ge.options) == null ? void 0 : Se[0]) ?? "";
  }
  u(V, "getSpellCastingAbility");
  function Y() {
    var Ne, Re, ge, je, Be, Ze, Ge, Se;
    return M === 1 ? (je = (ge = (Re = (Ne = D == null ? void 0 : D.system) == null ? void 0 : Ne.spellcasting) == null ? void 0 : Re.ability) == null ? void 0 : ge.options) == null ? void 0 : je.map((_e) => [_e, CONFIG.A5E.abilities[_e]]) : (S == null ? void 0 : S.type) !== "archetype" ? [] : (Se = (Ge = (Ze = (Be = S == null ? void 0 : S.system) == null ? void 0 : Be.spellcasting) == null ? void 0 : Ze.ability) == null ? void 0 : Ge.options) == null ? void 0 : Se.map((_e) => [_e, CONFIG.A5E.abilities[_e]]);
  }
  u(Y, "getSpellCastingOptions");
  function J() {
    const { updateData: Ne, documentData: Re } = LL(k, n, s) ?? {};
    t(5, ee.spellcastingAbility = ne || "", ee), y.submit({
      success: !0,
      updateData: Ne,
      documentData: Re,
      clsReturnData: ee
    });
  }
  u(J, "onSubmit");
  let fe = L(), ke = [], ee = {}, ne = V(), Ee = U();
  function Pe(Ne) {
    ee = Ne, t(5, ee);
  }
  u(Pe, "classhitpointsselection_clsReturnData_binding");
  const ye = /* @__PURE__ */ u(({ detail: Ne }) => t(6, ne = Ne), "updateSelection_handler"), me = /* @__PURE__ */ u(({ detail: Ne }) => t(5, ee.archetype = Ne, ee), "updateSelection_handler_1"), Ce = /* @__PURE__ */ u(({ detail: Ne }) => t(3, ke = Ne), "updateSelection_handler_2"), Je = /* @__PURE__ */ u((Ne, { detail: Re }) => {
    s.set(Ne, Re), t(4, s);
  }, "updateSelection_handler_3");
  return i.$$set = (Ne) => {
    "allGrants" in Ne && t(13, _ = Ne.allGrants), "dialog" in Ne && t(14, y = Ne.dialog), "optionalGrantsProp" in Ne && t(15, v = Ne.optionalGrantsProp), "actor" in Ne && t(16, k = Ne.actor), "item" in Ne && t(0, S = Ne.item), "cls" in Ne && t(1, D = Ne.cls), "charLevel" in Ne && t(17, I = Ne.charLevel), "clsLevel" in Ne && t(2, M = Ne.clsLevel);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*activeGrants, selectedOptionalGrants*/
    262152 && t(19, n = q(fe, ke)), i.$$.dirty[0] & /*grants*/
    524288 && t(8, r = n.filter((Ne) => Ne.requiresConfig)), i.$$.dirty[0] & /*selectedOptionalGrants, applyData*/
    24 && z();
  }, t(4, s = /* @__PURE__ */ new Map()), t(9, l = B()), t(7, o = Y()), [
    S,
    D,
    M,
    ke,
    s,
    ee,
    ne,
    o,
    r,
    l,
    H,
    J,
    Ee,
    _,
    y,
    v,
    k,
    I,
    fe,
    n,
    Pe,
    ye,
    me,
    Ce,
    Je
  ];
}
u(EH, "instance$4n");
const xw = class xw extends re {
  constructor(e) {
    super(), oe(
      this,
      e,
      EH,
      AH,
      le,
      {
        allGrants: 13,
        dialog: 14,
        optionalGrantsProp: 15,
        actor: 16,
        item: 0,
        cls: 1,
        charLevel: 17,
        clsLevel: 2
      },
      null,
      [-1, -1]
    );
  }
  get allGrants() {
    return this.$$.ctx[13];
  }
  set allGrants(e) {
    this.$$set({ allGrants: e }), Xe();
  }
  get dialog() {
    return this.$$.ctx[14];
  }
  set dialog(e) {
    this.$$set({ dialog: e }), Xe();
  }
  get optionalGrantsProp() {
    return this.$$.ctx[15];
  }
  set optionalGrantsProp(e) {
    this.$$set({ optionalGrantsProp: e }), Xe();
  }
  get actor() {
    return this.$$.ctx[16];
  }
  set actor(e) {
    this.$$set({ actor: e }), Xe();
  }
  get item() {
    return this.$$.ctx[0];
  }
  set item(e) {
    this.$$set({ item: e }), Xe();
  }
  get cls() {
    return this.$$.ctx[1];
  }
  set cls(e) {
    this.$$set({ cls: e }), Xe();
  }
  get charLevel() {
    return this.$$.ctx[17];
  }
  set charLevel(e) {
    this.$$set({ charLevel: e }), Xe();
  }
  get clsLevel() {
    return this.$$.ctx[2];
  }
  set clsLevel(e) {
    this.$$set({ clsLevel: e }), Xe();
  }
};
u(xw, "GrantApplicationDialog");
let Y1 = xw;
function cg() {
  return {
    armor: {
      label: "A5E.ArmorPlural",
      config: Object.entries(CONFIG.A5E.armor),
      propertyKey: "system.proficiencies.armor"
    },
    tradition: {
      label: "A5E.ManeuverTraditionPlural",
      config: Object.entries(CONFIG.A5E.maneuverTraditions),
      propertyKey: "system.proficiencies.traditions"
    },
    skill: {
      label: "A5E.SkillPlural",
      config: Object.entries(CONFIG.A5E.skills),
      propertyKey: ""
    },
    savingThrow: {
      label: "A5E.SavingThrowPlural",
      config: Object.entries(CONFIG.A5E.abilities),
      propertyKey: ""
    },
    tool: {
      label: "A5E.ToolPlural",
      config: CONFIG.A5E.tools,
      propertyKey: "system.proficiencies.tools"
    },
    weapon: {
      label: "A5E.Weapons",
      config: CONFIG.A5E.weapons,
      propertyKey: "system.proficiencies.weapons"
    }
  };
}
u(cg, "prepareProficiencyConfigObject");
function ug() {
  return {
    alignment: {
      label: "A5E.Alignment",
      config: Object.entries(CONFIG.A5E.alignments),
      propertyKey: "system.traits.alignment"
    },
    conditionImmunities: {
      label: "A5E.ConditionImmunities",
      config: Object.entries(CONFIG.A5E.conditions),
      propertyKey: "system.traits.conditionImmunities"
    },
    creatureTypes: {
      label: "A5E.CreatureTypesLabel",
      config: Object.entries(CONFIG.A5E.creatureTypes),
      propertyKey: "system.details.creatureTypes"
    },
    damageImmunities: {
      label: "A5E.DamageImmunities",
      config: Object.entries(CONFIG.A5E.damageTypes),
      propertyKey: "system.traits.damageImmunities"
    },
    damageResistances: {
      label: "A5E.DamageResistances",
      config: Object.entries(CONFIG.A5E.damageTypes),
      propertyKey: "system.traits.damageResistances"
    },
    damageVulnerabilities: {
      label: "A5E.DamageVulnerabilities",
      config: Object.entries(CONFIG.A5E.damageTypes),
      propertyKey: "system.traits.damageVulnerabilities"
    },
    languages: {
      label: "A5E.Languages",
      config: Object.entries(CONFIG.A5E.languages),
      propertyKey: "system.proficiencies.languages"
    },
    size: {
      label: "A5E.Size",
      config: Object.entries(CONFIG.A5E.actorSizes),
      propertyKey: "system.traits.size"
    }
  };
}
u(ug, "prepareTraitGrantConfigObject");
async function SH(i, e = {}) {
  var p;
  const { relative: t, invalid: s = !1, parent: n = null } = e, l = i.map((m) => foundry.utils.parseUuid(m, { relative: t })), r = [], o = [], a = /* @__PURE__ */ new Map();
  for (const { collection: m, documentId: g, documentType: h, doc: _ } of l)
    m instanceof CompendiumCollection ? h === "Folder" ? o.push(m.folders.get(g)) : (a.has(m) || a.set(m, []), (p = a.get(m)) == null || p.push(g)) : r.push(_ ?? (m == null ? void 0 : m.get(g, { invalid: s })));
  const c = [...a.entries()].map(([m, g]) => ({
    collection: m,
    query: { _id__in: g }
  }));
  return (await Promise.all(c.map(({ collection: m, query: g }) => m.getDocuments(g)))).flat().concat(r, o).reduce((m, g) => {
    if (!g)
      return m.push(void 0), m;
    const h = new Item.implementation(g.toObject(), { parent: n, keepId: !0 });
    return h.updateSource({ "flags.core.sourceId": g.uuid }), m.push(h), m;
  }, []);
}
u(SH, "fromUuidMulti");
var ds, Bc, BL, Dd, J1, qL, Po;
const e$ = class e$ extends Map {
  constructor(t) {
    super();
    x(this, ds);
    qe(this, "actor");
    qe(this, "allowedTypes", ["feature", "archetype", "background", "class", "culture", "heritage"]);
    qe(this, "grantedFeatureDocuments", /* @__PURE__ */ new Map());
    this.actor = t;
    const s = this.actor.system.grants ?? {};
    Object.entries(s).forEach(([n, l]) => {
      l.grantId ?? (l.grantId = n);
      let r = vi[l.grantType];
      r || console.warn(`Grant ${n} has no class mapping.`), r ?? (r = vi.base);
      const o = new r(l, { parent: t }), a = `${o.itemUuid.split(".").at(-1)}.${n}`;
      this.set(a, o);
    }), [...this.values()].forEach((n) => {
      if (!(n instanceof vi.feature)) return;
      const { documentIds: l } = n;
      l.forEach((r) => {
        var o;
        this.grantedFeatureDocuments.has(r) || this.grantedFeatureDocuments.set(r, []), (o = this.grantedFeatureDocuments.get(r)) == null || o.push(n.grantId);
      });
    });
  }
  byType(t) {
    return [...this.values()].filter((s) => s.grantType === t);
  }
  // *************************************************************
  // Data Retrieval Methods
  // *************************************************************
  getGrantedTraits(t) {
    return this.byType("trait").reduce((n, l) => (l.traitData.traitType !== t || (n[l.grantId] = {
      itemId: l.itemUuid,
      traits: l.traitData.traits
    }), n), {});
  }
  // *************************************************************
  // Update Methods
  // *************************************************************
  async createInitialGrants(t, s = !1) {
    var g, h;
    if (!t || !this.allowedTypes.includes(t.type)) return;
    const n = [], l = [], o = Object.keys(this.actor.levels.classes).length ? this.actor.levels.character + 1 : this.actor.levels.character;
    let a;
    t.type === "class" ? a = t.slug : t.type === "archetype" ? a = t.system.class : a = ((g = t.system.classes) == null ? void 0 : g.slugify({ strict: !0 })) || "";
    const c = (((h = this.actor.levels.classes) == null ? void 0 : h[a]) ?? 0) + 1, f = [...t.grants.values()];
    f.forEach((_) => {
      _.grantedBy = { id: "", selectionId: "" };
    });
    const d = (await Promise.all(f.map((_) => X(this, ds, Dd).call(this, _, o)))).flat().filter((_) => !!_), p = f.concat(d);
    p.forEach((_) => {
      if (this.has(X(this, ds, Bc).call(this, _))) return;
      const { levelType: y } = _;
      if (y === "character") {
        if (_.level > o) return;
        if (t.type === "class") {
          let v = _;
          for (; v = p.find((k) => {
            var S;
            return k._id === ((S = v == null ? void 0 : v.grantedBy) == null ? void 0 : S.id);
          }), !(!v || v.levelType === "class"); )
            ;
          if (!v && _.level !== o) return;
        }
      }
      y === "class" && _.level > c || (_.optional && l.push(_), n.push(_));
    });
    let m = null;
    t.type === "class" ? m = t : t.type === "archetype" && (m = this.actor.classes[t.system.class]), await X(this, ds, J1).call(this, n, l, {
      item: t,
      cls: m,
      charLevel: o,
      clsLevel: c,
      useUpdateSource: s
    });
  }
  async createLeveledGrants(t = 0, s = 0, n = null) {
    var m, g, h, _;
    const l = s - t, r = Math.sign(l), o = this.actor.levels.character + l, a = (((m = this.actor.levels.classes) == null ? void 0 : m[(n == null ? void 0 : n.slug) || ""]) ?? 1) + l;
    if (r === 0) return !1;
    if (r === -1) {
      const y = (n == null ? void 0 : n.slug) || "";
      return a < 1 ? (await ((g = n == null ? void 0 : n.sheet) == null ? void 0 : g.close()), n == null || n.delete(), !0) : (await this.removeGrantsByClassLevel(a, y), await this.removeGrantsByLevel(o));
    }
    const c = [], f = [], d = this.actor.items.filter(
      (y) => this.allowedTypes.includes(y.type)
    );
    for await (const y of d) {
      let v;
      y.type === "class" ? v = y.slug : y.type === "archetype" ? v = y.system.class : v = ((h = y.system.classes) == null ? void 0 : h.slugify({ strict: !0 })) || "";
      let k = ((_ = this.actor.levels.classes) == null ? void 0 : _[v]) ?? 1;
      v === (n == null ? void 0 : n.slug) && (k += l);
      const S = [...y.grants.values()];
      S.forEach((M) => {
        M.grantedBy = { id: "", selectionId: "" };
      });
      const D = (await Promise.all(S.map((M) => X(this, ds, Dd).call(this, M, o)))).flat().filter((M) => !!M), I = S.concat(D);
      I.forEach((M) => {
        var U, H, V;
        let L = !1;
        if ((U = M.grantedBy) != null && U.id) {
          const Y = y.grants.get(M.grantedBy.id) ?? c.find((J) => {
            var fe;
            return J._id === ((fe = M.grantedBy) == null ? void 0 : fe.id);
          });
          L = X(this, ds, BL).call(this, Y);
        }
        if (this.has(X(this, ds, Bc).call(this, M)) && !L || [...this.values()].find((Y) => {
          var J;
          return Y.grantId === ((J = M.grantedBy) == null ? void 0 : J.id);
        }) && !L) return;
        const { levelType: z } = M;
        if (z === "character") {
          if (M.level > o) return;
          if (y.type === "class") {
            let Y = M;
            for (; Y = I.find((J) => {
              var fe;
              return J._id === ((fe = Y == null ? void 0 : Y.grantedBy) == null ? void 0 : fe.id);
            }), !(!Y || Y.levelType === "class"); )
              ;
            if (!Y && M.level !== o) return;
          }
        }
        if (z === "class" && M.level > k || c.find((Y) => X(this, ds, Bc).call(this, Y) === X(this, ds, Bc).call(this, M))) return;
        const q = c.find((Y) => {
          var J;
          return Y._id === ((J = M.grantedBy) == null ? void 0 : J.id);
        });
        if (!((H = M.grantedBy) != null && H.id && !q)) {
          if (M.optional) {
            if (!(z === "class" ? M.level === k : M.level === o) && !((V = M.grantedBy) != null && V.id) && !L) return;
            f.push(M);
          }
          c.push(M);
        }
      });
    }
    return await X(this, ds, J1).call(this, c, f, {
      cls: n,
      item: n,
      charLevel: o,
      clsLevel: a,
      useUpdateSource: !1
    });
  }
  async removeGrantsByItem(t) {
    const s = {};
    for (const [, n] of this)
      n.itemUuid === t && (s[`system.grants.-=${n.grantId}`] = null, foundry.utils.mergeObject(s, X(this, ds, Po).call(this, n)));
    await this.actor.update(s);
  }
  async removeGrantsByClassLevel(t, s) {
    const n = {};
    for (const [, o] of this) {
      const a = fromUuidSync(o.itemUuid);
      a && ["class", "feature"].includes(a.type) && (a.type === "class" && a.slug !== s || a.type === "feature" && a.system.classes !== s || o.level > t && (n[`system.grants.-=${o.grantId}`] = null, foundry.utils.mergeObject(n, X(this, ds, Po).call(this, o))));
    }
    try {
      await this.actor.update(n);
    } catch (o) {
      return console.error(o), !1;
    }
    const l = this.actor.classes[s];
    if (!l || t > l.system.archetypeLevel) return !0;
    const { archetype: r } = l;
    return r && r.delete(), !0;
  }
  async removeGrantsByLevel(t) {
    const s = {};
    for (const [, n] of this)
      n.level > t && (s[`system.grants.-=${n.grantId}`] = null, foundry.utils.mergeObject(s, X(this, ds, Po).call(this, n)));
    try {
      await this.actor.update(s);
    } catch (n) {
      return console.error(n), !1;
    }
    return !0;
  }
  async removeGrant(t) {
    const s = [...this.values()].find((l) => l.grantId === t);
    if (!s) return;
    const n = {
      [`system.grants.-=${t}`]: null,
      ...X(this, ds, Po).call(this, s)
    };
    await this.actor.update(n);
  }
  async removeAll() {
    const t = {};
    for (const [, s] of this)
      t[`system.grants.-=${s.grantId}`] = null, foundry.utils.mergeObject(t, X(this, ds, Po).call(this, s));
    await this.actor.update(t);
  }
};
ds = new WeakSet(), Bc = /* @__PURE__ */ u(function(t) {
  var s;
  return `${((s = t.parent) == null ? void 0 : s.id) || ""}.${t._id}`;
}, "#getFullId"), BL = /* @__PURE__ */ u(function(t) {
  if (!t || t.grantType !== "feature") return !1;
  const { features: s } = t;
  return s.base.concat(s.options).some((n) => !n.limitedReselection || n.selectionLimit > 1);
}, "#isReSelectable"), Dd = /* @__PURE__ */ u(async function(t, s) {
  var a;
  if (t.grantType !== "feature") return [];
  if (t.level > s) return [];
  const n = [...t.features.base, ...t.features.options].map((c) => c.uuid);
  let l;
  try {
    l = await SH(n, { parent: this.actor });
  } catch (c) {
    throw console.error(c), console.warn(`Possible causes: ${n.join(", ")}`), (a = ui.notifications) == null || a.error(`Grant ${t.label} has an invalid document reference.`), new Error(c);
  }
  l = l.filter((c) => {
    var f;
    return c ? !0 : ((f = ui.notifications) == null || f.error(`Grant ${t.label} has an invalid document reference.`), console.warn(`Possible causes: ${n.join(", ")}`), !1);
  });
  const r = l.flatMap(
    (c) => [...c.grants.values()].map((f) => {
      const d = !!t.features.options.length;
      return f.grantedBy = {
        id: t._id,
        selectionId: d ? c.flags.core.sourceId : ""
      }, f;
    })
  ), o = (await Promise.all(r.map((c) => X(this, ds, Dd).call(this, c, s)))).flat().filter((c) => !!c);
  return r.concat(o);
}, "#getSubGrants"), J1 = /* @__PURE__ */ u(async function(t, s, n) {
  var d, p, m, g, h, _, y, v, k, S, D, I, M, L;
  if (!t.length && !n.cls) return !1;
  const l = [...t].some((B) => B.requiresConfig()), r = n.cls && n.item.type === "class", o = (h = (g = (m = (p = (d = n.item) == null ? void 0 : d.system) == null ? void 0 : p.spellcasting) == null ? void 0 : m.ability) == null ? void 0 : g.options) == null ? void 0 : h.length, a = l || !!s.length || r || o;
  let c;
  if (a) {
    const B = new ac(
      `${this.actor.name} - Apply Grants (${((_ = n.item) == null ? void 0 : _.name) ?? ((y = n.cls) == null ? void 0 : y.name)})`,
      Y1,
      {
        actor: this.actor,
        allGrants: t,
        optionalGrantsProp: s,
        ...n
      }
    );
    if (await B.render(!0), c = await B.promise, !(c != null && c.success))
      return n != null && n.item && n.useUpdateSource && !n.cls && n.item.delete(), !1;
  } else {
    const B = t.map((U) => ({ id: U._id, grant: U })), { updateData: z, documentData: q } = LL(this.actor, B, /* @__PURE__ */ new Map());
    c = {
      success: !0,
      updateData: z,
      documentData: q,
      clsReturnData: {}
    };
  }
  if (c.documentData.size) {
    const B = {};
    for await (const [z, q] of c.documentData) {
      const U = (await Promise.all(
        q.map(
          async ({
            uuid: H,
            type: V,
            quantity: Y
          }) => {
            var fe;
            const J = (fe = await fromUuid(H)) == null ? void 0 : fe.toObject();
            return J ? (J._stats.compendiumSource = H, V === "feature" || !Y || (J.system.quantity = Y), J) : null;
          }
        )
      )).filter((H) => !!H);
      try {
        if (((v = q[0]) == null ? void 0 : v.type) === "object") {
          const H = (await this.actor.createEmbeddedDocuments("Item", U)).map(
            (V) => V.id
          );
          B[`system.grants.${z}.documentIds`] = H;
        } else if (((k = q[0]) == null ? void 0 : k.type) === "feature") {
          const H = U.map((ke) => ke._id), Y = this.actor.items.filter((ke) => H.includes(ke.id)).map((ke) => ke.id), J = U.filter((ke) => !Y.includes(ke._id)), fe = (await this.actor.createEmbeddedDocuments("Item", J, {
            noGrant: !0,
            keepId: !0
          })).map((ke) => ke.id);
          B[`system.grants.${z}.documentIds`] = [...fe, ...Y];
        }
      } catch (H) {
        return console.error(H), !1;
      }
    }
    foundry.utils.mergeObject(c.updateData, B);
  }
  const f = c.clsReturnData.archetype;
  if (f) {
    const B = await Item.fromDropData({ uuid: f });
    if (B) {
      const z = B.toObject();
      this.actor.createEmbeddedDocuments("Item", [z]);
    }
  }
  if (c.updateData && await this.actor.update(c.updateData), n.cls && ((S = n.item) == null ? void 0 : S.type) === "class") {
    const { clsReturnData: B } = c, { leveledHpType: z, hpFormula: q, hpValue: U } = B;
    let H;
    if (z === "roll" && q) {
      const J = await new Roll(q).roll();
      H = J.total, X(this, ds, qL).call(this, n.cls, J);
    } else ["custom", "average"].includes(z) && U ? H = U : H = n.cls.system.classLevels === 1 && n.charLevel === 1 ? n.cls.system.hp.levels[1] : n.cls.averageHP;
    const V = B.spellcastingAbility || n.cls.system.spellcasting.ability.options[0] || n.cls.system.spellcasting.ability.base;
    if (await (n.useUpdateSource ? n.cls.updateSource.bind(n.cls) : n.cls.update.bind(n.cls))({
      [`system.hp.levels.${n.charLevel}`]: H,
      "system.spellcasting.ability.value": V
    }), V !== "none" && n.clsLevel === 1) {
      this.actor.system.classes.startingClass === n.item.slug && this.actor.update({ "system.attributes.spellcasting": V });
      const J = {
        ability: V,
        name: `${n.cls.name} Spell Book`,
        showSpellSlots: !1
      }, fe = ((I = (D = n.cls) == null ? void 0 : D.casting) == null ? void 0 : I.resource) || "slots";
      if (fe === "slots" ? J.showSpellSlots = !0 : fe === "points" ? J.showSpellPoints = !0 : fe === "inventions" ? J.showSpellInventions = !0 : fe === "artifactCharges" ? J.showArtifactCharges = !0 : J.showSpellSlots = !0, Object.keys(this.actor.classes).length > 1)
        this.actor.spellBooks.add(J);
      else {
        const ke = (M = this.actor.spellBooks.first()) == null ? void 0 : M._id;
        this.actor.update({ [`system.spellBooks.${ke}`]: J });
      }
    }
  }
  if (n.item && ((L = n.item) == null ? void 0 : L.type) === "archetype") {
    const B = n.item, z = c.clsReturnData.spellcastingAbility || B.system.spellcasting.ability.options[0] || B.system.spellcasting.ability.base;
    await (n.useUpdateSource ? B.updateSource.bind(B) : B.update.bind(B))({
      "system.spellcasting.ability.value": z
    });
  }
  return !0;
}, "#applyGrants"), qL = /* @__PURE__ */ u(function(t, s) {
  var r, o;
  const n = `Hit Dice Roll - ${t.name}`, l = {
    author: (r = game.user) == null ? void 0 : r.id,
    speaker: ChatMessage.getSpeaker({ actor: this.actor }),
    sound: CONFIG.sounds.dice,
    rolls: [s],
    flags: {
      a5e: {
        actorId: this.actor.uuid,
        img: ((o = this.actor.token) == null ? void 0 : o.img) ?? this.actor.img,
        name: this.actor.name,
        title: n
      }
    }
  };
  ChatMessage.create(l);
}, "#createRolledHpCard"), Po = /* @__PURE__ */ u(function(t) {
  const s = {};
  if (t instanceof vi.bonus && t.bonusId && (s[`system.bonuses.${t.type}.-=${t.bonusId}`] = null), t instanceof vi.exertion && t.exertionData.exertionType === "bonus" && (s[`system.bonuses.exertion.-=${t.exertionData.bonusId}`] = null), t instanceof vi.feature || t instanceof vi.item) {
    let n;
    if (t instanceof vi.feature) {
      const { grantedFeatureDocuments: r } = this, { documentIds: o } = t;
      n = o.reduce((a, c) => {
        var f;
        return r.has(c) && ((f = r.get(c)) == null ? void 0 : f.length) === 1 && a.push(c), a;
      }, []);
    } else
      n = t.documentIds;
    if (!(n != null && n.length)) return s;
    const l = this.actor.items.reduce((r, o) => (n.includes(o.id) && r.push(o.id), r), []);
    this.actor.deleteEmbeddedDocuments("Item", l);
  }
  if (t instanceof vi.proficiency) {
    const { keys: n, proficiencyType: l } = t.proficiencyData;
    if (l === "savingThrow")
      n.forEach((r) => {
        s[`system.abilities.${r}.save.proficient`] = !1;
      });
    else if (l === "skill")
      n.forEach((r) => {
        s[`system.skills.${r}.proficient`] = 0;
      });
    else {
      const r = cg(), { propertyKey: o } = r[l] ?? {};
      if (!o) return {};
      const a = new Set(n), c = new Set(
        foundry.utils.getProperty(this.actor, o) ?? []
      );
      s[o] = [...c.difference(a)];
    }
  }
  if (t instanceof vi.skillSpecialty) {
    const { skill: n } = t.specialtyData, l = new Set(
      foundry.utils.getProperty(this.actor, `system.skills.${n}.specialties`) ?? []
    ), r = new Set(t.specialtyData.specialties);
    s[`system.skills.${n}.specialties`] = [...l.difference(r)];
  }
  if (t instanceof vi.trait) {
    const n = ug(), { propertyKey: l } = n[t.traitData.traitType] ?? {};
    if (!l) return {};
    const r = new Set(t.traitData.traits), o = new Set(
      foundry.utils.getProperty(this.actor, l) ?? []
    );
    t.traitData.traitType === "size" ? s[l] = "" : s[l] = [...o.difference(r)];
  }
  return s;
}, "#getRemoveUpdates"), u(e$, "ActorGrantsManger");
let X1 = e$;
var jn, en;
const t$ = class t$ {
  constructor(e) {
    x(this, jn);
    x(this, en);
    Ae(this, jn, e), Ae(this, en, P(this, jn).system.bonuses ?? {});
  }
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  //  Utility Helpers
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  getDefaultSelections(e, t = {}) {
    let s;
    return e === "abilities" && t.abilityKey ? s = this.prepareAbilityBonuses(t.abilityKey, t.abilityType ?? "check") : e === "attacks" && t.item && t.attackType ? s = this.prepareAttackBonuses(t.item, t.attackType) : e === "damage" && t.item && t.rolls ? s = this.prepareGlobalDamageBonuses(t.item, t.rolls) : e === "healing" && t.item && t.rolls ? s = this.prepareGlobalHealingBonuses(t.item, t.rolls) : e === "initiative" && (t.skillKey || t.abilityKey) ? s = this.prepareInitiativeBonuses({
      abilityKey: t.abilityKey,
      skillKey: t.skillKey
    }) : e === "skills" && t.skillKey && (s = this.prepareSkillBonuses(t.skillKey, t.abilityKey, "check", !1)), s ? (s = { bonuses: s }, Object.values(s ?? {}).flat().reduce((l, [r, o]) => (o.formula && (o.default ?? !0) && l.push(r), l), [])) : [];
  }
  getDefaultSelectionsFromBonuses(e) {
    return Object.values(e ?? {}).flat().reduce((t, [s, n]) => (["generic", "healing", "damage"].includes(n.type) && !n.formula || (n.default ?? !0) && t.push(s), t), []);
  }
  getSelectedBonusesFormula(e, t) {
    const s = P(this, en)[e];
    return t.map((l) => {
      var r;
      return (r = s[l]) == null ? void 0 : r.formula;
    }).join(" + ").trim();
  }
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // Formula Wrappers
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  /**
   * Wrapper for {@link getAbilityBonuses} that returns a formula string instead of an array.
   *
   * @param abilityKey
   * @param type
   * @param selectedBonuses
   * @returns
   */
  getAbilityBonusesFormula(e, t = "check") {
    return this.prepareAbilityBonuses(e, t).map(([, l]) => {
      var a;
      const r = ((a = P(this, jn)._source.system.abilities[e]) == null ? void 0 : a.value) ?? 0;
      return l.formula.trim().replace("@original", r.toString());
    }).join(" + ").trim();
  }
  /**
   * Wrapper for {@link getGlobalAbilityBonuses} that returns a formula string instead of an array.
   * @param type
   * @returns
   */
  getGlobalAbilityBonusesFormula(e = "check") {
    return this.prepareGlobalAbilityBonuses(e).map(([, n]) => n.formula).join(" + ").trim();
  }
  /**
   * Wrapper for {@link getAttackBonuses} that returns a formula string instead of an array.
   * @param item
   * @param type
   * @returns
   */
  getAttackBonusFormula(e, t = "meleeWeaponAttack") {
    return this.prepareAttackBonuses(e, t).map(([, l]) => l.formula).join(" + ").trim();
  }
  getExertionBonusFormula() {
    const e = P(this, en).exertion ?? {};
    return Object.values(e).reduce((s, n) => {
      const l = n.formula.trim();
      return l && s.push(l), s;
    }, []).join(" + ").trim();
  }
  getHitPointsBonusFormula() {
    return this.prepareHitPointsBonuses().map(([, s]) => {
      let { formula: n } = s;
      return s.context.perLevel && (n = `(${n}) * @level`), n;
    }).join(" + ").trim();
  }
  getHitPointsBonusPerLevelFormula() {
    return this.prepareHitPointsBonuses().reduce((s, [, n]) => {
      const { formula: l } = n;
      return n.context.perLevel && s.push(l), s;
    }, []).join(" + ").trim();
  }
  /**
   * Wrapper for {@link getInitiativeBonuses} that returns a formula string instead of an array.
   * @param ablKey
   * @param skillKey
   * @returns
   */
  getInitiativeBonusFormula({
    abilityKey: e,
    skillKey: t
  } = {}) {
    return this.prepareInitiativeBonuses({ abilityKey: e, skillKey: t }).map(([, l]) => l.formula).join(" + ").trim();
  }
  getMovementBonusFormula(e) {
    return this.prepareMovementBonuses(e).map(([, n]) => {
      var o;
      const l = ((o = P(this, jn)._source.system.attributes.movement[e]) == null ? void 0 : o.distance) ?? 0;
      return n.formula.trim().replace("@original", l.toString());
    }).join(" + ").trim();
  }
  getSensesBonusFormula(e) {
    const t = this.prepareSensesBonuses(e);
    let s = !1;
    const n = t.map(([, l]) => {
      var a;
      const r = ((a = P(this, jn)._source.system.attributes.senses[e]) == null ? void 0 : a.distance) ?? 0;
      return l.unit === "unlimited" && (s = !0), l.formula.trim().replace("@original", r.toString());
    });
    return s ? "unlimited" : n.join(" + ").trim();
  }
  /**
   * Wrapper for {@link getSkillBonuses} that returns a formula string instead of an array.
   * @param skillKey              The skill key to get bonuses for.
   * @param abilityKey            The ability key to get bonuses for. If not provided, the default
   * @param type                  The type of bonus to get. Can be either 'check' or 'passive'.
   * @param includeAbilityBonuses Whether or not to include ability bonuses in the formula.
   * @param selectedBonuses       Whether or not to include only selected bonuses.
   * @returns
   */
  getSkillBonusesFormula(e, t, s = "check", n = !1) {
    var a;
    const r = this.prepareSkillBonuses(e, t, s, n).map(([, c]) => {
      var p;
      const f = ((p = P(this, jn)._source.system.skills[e]) == null ? void 0 : p.value) ?? 0;
      return c.formula.trim().replace("@original", f.toString());
    }), o = P(this, jn).system.skills[e];
    if (s === "passive" && (o != null && o.expertiseDice)) {
      const c = ((a = game.settings.storage.get("world")) == null ? void 0 : a.getItem("a5e.useNPCExpertisePassiveRulesForCharacters")) ?? !1;
      if (P(this, jn).type === "character" && !c)
        r.push("3");
      else {
        const f = CONFIG.A5E.expertiseDiceSidesMap[o.expertiseDice ?? 0];
        r.push((f / 2).toString());
      }
    }
    return r.join(" + ").trim();
  }
  /**
   * Wrapper for {@link getGlobalSkillBonuses} that returns a formula string instead of an array.
   *
   * @param type
   * @returns
   */
  getGlobalSkillBonusesFormula(e = "check") {
    return this.prepareGlobalSkillBonuses(e).map(([, n]) => n.formula).join(" + ").trim();
  }
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // Bonuses Prepare Functions
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  prepareAbilityBonuses(e, t = "check") {
    const s = P(this, en).abilities ?? {}, n = P(this, jn).system.abilities[e];
    if (!n) return [];
    const l = n.save.proficient ?? !1, r = {};
    return Object.entries(s).filter(([, { context: a, formula: c }]) => {
      if (!c) return !1;
      const { abilities: f, requiresProficiency: d, types: p } = a ?? {
        abilities: [],
        requiresProficiency: !1,
        types: []
      };
      return !(!(f != null && f.includes(e)) || !(p != null && p.includes(t)) || d && !l);
    }).map(([a, c]) => {
      if (!c.label) {
        const f = game.i18n.format("A5E.bonuses.labels.abilityBonusSpecific", {
          ability: game.i18n.localize(CONFIG.A5E.abilities[e] ?? "")
        });
        r[e] ?? (r[e] = 0), r[e] += 1, c.defaultLabel = `${f} #${r[e]}`;
      }
      return [a, c];
    });
  }
  prepareGlobalAbilityBonuses(e = "check") {
    const t = P(this, en).abilities ?? {};
    let s = 0;
    return Object.entries(t).filter(([, { context: l, formula: r }]) => {
      if (!r) return !1;
      const { abilities: o, requiresProficiency: a, types: c } = l ?? {
        abilities: [],
        requiresProficiency: !1,
        types: []
      };
      return !(!(c != null && c.includes(e)) || a || !gu(o, Object.keys(CONFIG.A5E.abilities)));
    }).map(([l, r]) => {
      if (!r.label) {
        const o = game.i18n.localize("A5E.bonuses.labels.abilityBonusGlobal");
        s += 1, r.defaultLabel = `${o} #${s[l]}`;
      }
      return [l, r];
    });
  }
  prepareAttackBonuses(e, t = "meleeWeaponAttack") {
    const s = P(this, en).attacks, n = e.isType("spell") ? e.system.level : null, l = {};
    return Object.entries(s).filter(([, { context: o, formula: a }]) => {
      if (!a) return !1;
      const { attackTypes: c, spellLevels: f } = o ?? { attackTypes: [], spellLevels: [] };
      return !(!(c != null && c.includes(t)) || n !== null && (f != null && f.length) && !(f != null && f.includes(`${n}`)));
    }).map(([o, a]) => {
      if (!a.label) {
        const c = game.i18n.format("A5E.bonuses.labels.attackBonusSpecific", {
          attackType: game.i18n.localize(CONFIG.A5E.attackTypes[t] ?? "")
        });
        l[t] ?? (l[t] = 0), l[t] += 1, a.defaultLabel = `${c} #${l[t]}`;
      }
      return [o, a];
    });
  }
  prepareHitPointsBonuses() {
    const e = P(this, en).hitPoint ?? {};
    return Object.entries(e).reduce((t, [s, n]) => (n.formula && (n.formula = n.formula.trim(), t.push([s, n])), t), []);
  }
  /**
   *
   * @returns
   */
  prepareGlobalDamageBonuses(e, t) {
    const s = t.attack ?? [], n = t.damage ?? [], l = e.isType("spell") ? e.system.level : null;
    if (!Array.isArray(s)) return [];
    if (!s.length) return [];
    const { attackType: r } = s[0][1] ?? {}, o = new Set(n.map(([, { damageType: d }]) => d)), a = P(this, en).damage ?? {}, c = {};
    return Object.entries(a).filter(([, { context: d, formula: p }]) => {
      if (!p) return !1;
      const { attackTypes: m, spellLevels: g } = d ?? { attackTypes: [], spellLevels: [] }, h = new Set(d.damageTypes ?? []);
      return !(m != null && m.length && !m.includes(r || "meleeWeaponAttack") || l !== null && g.length && !g.includes(`${l}`) || h.size && !h.intersects(o));
    }).map(([d, p]) => {
      var m;
      if (!p.label) {
        const g = game.i18n.format("A5E.DamageBonusSpecific", {
          damageType: game.i18n.localize(CONFIG.A5E.damageTypes[p.damageType] ?? "")
        });
        c[m = p.damageType] ?? (c[m] = 0), c[p.damageType] += 1, p.defaultLabel = `${g} #${c[p.damageType]}`;
      }
      return [d, p];
    });
  }
  prepareGlobalHealingBonuses(e, t) {
    const s = P(this, en).healing, n = {}, l = t.healing ?? [], r = e.isType("spell") ? e.system.level : null;
    if (!l.length) return [];
    const o = new Set(l.map(([, { healingType: c }]) => c));
    return Object.entries(s).filter(([, { context: c, formula: f }]) => {
      if (!f) return !1;
      const { spellLevels: d } = c ?? { spellLevels: [] }, p = new Set(c.healingTypes ?? []);
      return !(p.size && !p.intersects(o) || r !== null && d.length && !d.includes(`${r}`));
    }).map(([c, f]) => {
      const d = f.healingType || "healing";
      if (!f.label) {
        const p = game.i18n.localize(CONFIG.A5E.healingTypes[d]);
        n[d] ?? (n[d] = 0), n[d] += 1, f.defaultLabel = `${p} #${n[d]}`;
      }
      return [c, f];
    });
  }
  prepareInitiativeBonuses({
    abilityKey: e,
    skillKey: t
  } = {}) {
    const s = P(this, en).initiative;
    let n = 0;
    return e = e === "none" ? void 0 : e, t = t === "none" ? void 0 : t, Object.entries(s).filter(([, { context: r, formula: o }]) => {
      if (!o) return !1;
      const { abilities: a, skills: c } = r ?? { abilities: [], skills: [] };
      return !(e && (a != null && a.length) && !a.includes(e) || t && (c != null && c.length) && !c.includes(t));
    }).map(([r, o]) => {
      if (!o.label) {
        const a = game.i18n.localize("A5E.bonuses.labels.initiativeBonus");
        n += 1, o.defaultLabel = `${a} #${n}`;
      }
      return [r, o];
    });
  }
  prepareMovementBonuses(e) {
    const t = P(this, en).movement;
    return Object.entries(t).filter(([, { context: n, formula: l }]) => {
      if (!l) return !1;
      const { movementTypes: r } = n ?? { movementTypes: [] };
      return !!(r != null && r.includes(e));
    }).map(([n, l]) => {
      if (!l.label) {
        const r = game.i18n.format("A5E.bonuses.labels.movementBonus", {
          movementType: game.i18n.localize(CONFIG.A5E.movementAbbreviations[e] ?? "")
        });
        l.defaultLabel = r;
      }
      return [n, l];
    });
  }
  prepareSensesBonuses(e) {
    const t = P(this, en).senses;
    return Object.entries(t).filter(([, { context: n, formula: l, unit: r }]) => {
      if (!l && r !== "unlimited") return !1;
      const { senses: o } = n ?? { senses: [] };
      return !!(o != null && o.includes(e));
    }).map(([n, l]) => {
      if (!l.label) {
        const r = game.i18n.format("A5E.bonuses.labels.sensesBonus", {
          sense: game.i18n.localize(CONFIG.A5E.senses[e] ?? "")
        });
        l.defaultLabel = r;
      }
      return [n, l];
    });
  }
  prepareSkillBonuses(e, t, s = "check", n = !1) {
    const l = P(this, en).skills, r = P(this, jn).system.skills[e], o = {};
    if (!r) return [];
    const a = r.ability, f = Object.entries(l).filter(([, { context: p, formula: m }]) => {
      if (!m) return !1;
      const { skills: g = [], passiveOnly: h = !1, requiresProficiency: _ = !1 } = p ?? {};
      return !(!g.includes(e) || s !== "passive" && h || _ && r.proficient === 0);
    }).map(([p, m]) => {
      if (!m.label) {
        const g = game.i18n.format("A5E.bonuses.labels.skillBonusSpecific", {
          skill: game.i18n.localize(CONFIG.A5E.skills[e] ?? "")
        });
        o[e] ?? (o[e] = 0), o[e] += 1, m.defaultLabel = `${g} #${o[e]}`;
      }
      return [p, m];
    });
    return n ? [...this.prepareAbilityBonuses(
      t ?? a,
      "check"
    ), ...f] : f;
  }
  prepareGlobalSkillBonuses(e = "check") {
    const t = P(this, en).skills;
    let s = 0;
    return Object.entries(t).filter(([, { context: l, formula: r }]) => {
      if (!r) return !1;
      const { passiveOnly: o, requiresProficiency: a } = l ?? {
        passiveOnly: !1,
        requiresProficiency: !1
      };
      return !(a || e !== "passive" && o || !gu(l.skills, Object.keys(CONFIG.A5E.skills)));
    }).map(([l, r]) => {
      if (!r.label) {
        const o = game.i18n.localize("A5E.bonuses.labels.skillBonusGlobal");
        s += 1, r.defaultLabel = `${o} #${s[l]}`;
      }
      return [l, r];
    });
  }
};
jn = new WeakMap(), en = new WeakMap(), u(t$, "BonusesManager");
let Z1 = t$;
const { fields: Kl } = foundry.data, CH = /* @__PURE__ */ u(() => ({
  name: new Kl.StringField({ required: !0, nullable: !1, initial: "New Spell Book" }),
  img: new Kl.StringField({ required: !0, initial: "icons/svg/book.svg" }),
  ability: new Kl.StringField({ required: !0, initial: "default" }),
  disableSpellConsumers: new Kl.BooleanField({
    required: !0,
    nullable: !1,
    initial: !1
  }),
  showArtifactCharges: new Kl.BooleanField({ required: !0, nullable: !1, initial: !1 }),
  showSpellInventions: new Kl.BooleanField({ required: !0, nullable: !1, initial: !1 }),
  showSpellPoints: new Kl.BooleanField({ required: !0, nullable: !1, initial: !1 }),
  showSpellSlots: new Kl.BooleanField({ required: !0, nullable: !1, initial: !0 })
}), "spellBookSchema");
var kf, Q1, Da;
let TH = (Da = class extends foundry.abstract.DataModel {
  constructor(t, s = {}) {
    super(t, s);
    x(this, kf);
    qe(this, "spells", new foundry.utils.Collection());
  }
  static defineSchema() {
    return {
      ...CH()
    };
  }
  // ======================================
  // Getters
  // ======================================
  get spellIds() {
    return this.spells.map((t) => t.id);
  }
  // ======================================
  // Data Preparation
  // ======================================
  prepareBaseData() {
    const t = this.parent;
    if (this.spells = new foundry.utils.Collection(), !!t) {
      for (const s of t.items)
        s.isType("spell") && s.system.spellBook === this._id && this.spells.set(s.id || "", s);
      this.slug = `spellbook-${this.name}`.slugify({ strict: !0 }), this.prepareSpellBookStats();
    }
  }
  prepareSpellBookStats() {
    const t = this.parent;
    if (!t) return;
    let { ability: s } = this;
    this.ability === "default" && (s = t.system.attributes.spellcasting), s || (s = "int");
    const n = mt(
      [
        8,
        // @ts-expect-error
        t.system.attributes.prof,
        t.system.bonuses.spellDC || 0,
        t.system.abilities[s].check.mod
      ].join(" + "),
      t.getRollData()
    ) || 10, { abilities: l } = t.system, r = l[s].check.mod, o = {
      ability: this.ability,
      dc: n,
      mod: r
    };
    this.stats = o;
  }
  // ======================================
  // API Methods
  // ======================================
  addSpell(t) {
    const s = this.parent;
    if (!s) return;
    const n = X(this, kf, Q1).call(this, t);
    n && s.createEmbeddedDocuments("Item", [n]);
  }
  addSpells(t) {
    const s = this.parent;
    if (!s) return;
    const n = t.map((l) => X(this, kf, Q1).call(this, l));
    s.createEmbeddedDocuments("Item", n);
  }
  async delete() {
    const { spellIds: t } = this;
    await this.parent.deleteEmbeddedDocuments("Item", t);
    const s = this._id;
    this.parent.update({
      [`system.spellBooks.-=${s}`]: null
    });
  }
}, kf = new WeakSet(), Q1 = /* @__PURE__ */ u(function(t) {
  if (!this.parent) return null;
  const n = t.toObject();
  return n.system.spellBook = this._id, n;
}, "#updateSpellData"), u(Da, "SpellBook"), Da);
const s$ = class s$ extends Map {
  constructor(t) {
    super();
    qe(this, "actor");
    this.actor = t;
    const s = this.actor.system.spellBooks ?? {};
    Object.entries(s ?? {}).forEach(([n, l]) => {
      const r = new TH(l, { parent: this.actor });
      r._id = n, this.set(n, r), this.actor.system.spellBooks[n] = r;
    });
  }
  async add(t) {
    const s = (t == null ? void 0 : t._id) ?? foundry.utils.randomID();
    return await this.actor.update({
      [`system.spellBooks.${s}`]: t
    }), s;
  }
  remove(t) {
    const s = this.get(t);
    s && s.delete();
  }
  removeAll() {
    this.forEach((t) => t.delete());
  }
  first() {
    return this.values().next().value;
  }
  getSpellDCString(t = !1) {
    return this.size <= 1 && t ? "" : [...this.values()].map((n) => {
      const { dc: l, ability: r } = n.stats;
      return `${n.name} ( ${l} ${r.capitalize()} )`;
    }).join(", ");
  }
};
u(s$, "SpellBookManager");
let x1 = s$;
var Ls, Ia, pr, as, Ps, GL, zL, HL, UL, VL, WL, KL, YL, XL;
const n$ = class n$ {
  constructor(e, t) {
    x(this, Ps);
    x(this, Ls);
    x(this, Ia);
    x(this, pr);
    x(this, as);
    Ae(this, Ls, e), Ae(this, Ia, t), Ae(this, pr, t.restType ?? "short"), Ae(this, as, { actor: {}, effects: [], items: [] });
  }
  get restTypes() {
    return P(this, pr) === "long" ? ["shortRest", "recharge", "round", "turn", "minute", "hour", "longRest", "day"] : ["shortRest", "recharge", "round", "turn", "minute", "hour"];
  }
  async restoreResources() {
    const { consumeSupply: e, haven: t, recoverStrifeAndFatigue: s, restType: n } = P(this, Ia);
    P(this, pr) === "long" && (X(this, Ps, GL).call(this), X(this, Ps, VL).call(this), X(this, Ps, WL).call(this), await X(this, Ps, XL).call(this)), e && X(this, Ps, zL).call(this), X(this, Ps, UL).call(this), X(this, Ps, HL).call(this), X(this, Ps, YL).call(this), X(this, Ps, KL).call(this), await P(this, Ls).update(P(this, as).actor), await P(this, Ls).updateEmbeddedDocuments("Item", P(this, as).items), Hooks.callAll("a5e.restCompleted", this, {
      consumeSupply: e,
      haven: t,
      restType: n,
      recoverStrifeAndFatigue: s
    });
  }
};
Ls = new WeakMap(), Ia = new WeakMap(), pr = new WeakMap(), as = new WeakMap(), Ps = new WeakSet(), GL = /* @__PURE__ */ u(function() {
  const { haven: e, recoverStrifeAndFatigue: t } = P(this, Ia), { strife: s, fatigue: n } = P(this, Ls).system.attributes;
  P(this, as).actor["system.attributes.inebriated"] = 0, t ? e ? (P(this, as).actor["system.attributes.fatigue"] = Math.max(n - 1, 0), P(this, as).actor["system.attributes.strife"] = Math.max(s - 1, 0)) : (P(this, as).actor["system.attributes.fatigue"] = n === 1 ? 0 : n, P(this, as).actor["system.attributes.strife"] = s === 1 ? 0 : s) : P(this, as).actor["system.attributes.fatigue"] = n + 1;
}, "#adjustStrifeAndFatigue"), zL = /* @__PURE__ */ u(function() {
  P(this, as).actor["system.supply"] = Math.max(P(this, Ls).system.supply - 1, 0);
}, "#consumeSupply"), HL = /* @__PURE__ */ u(function() {
  const { exertion: e } = P(this, Ls).system.attributes;
  e != null && e.recoverOnRest && (P(this, as).actor["system.attributes.exertion.current"] = e.max);
}, "#restoreExertion"), UL = /* @__PURE__ */ u(function() {
  const e = ["primary", "secondary", "tertiary", "quaternary"];
  Object.entries(P(this, Ls).system.resources ?? {}).forEach(([t, s]) => {
    if (!this.restTypes.includes(s.per) || !s.max) return;
    const n = mt(s.max, P(this, Ls).getRollData());
    e.includes(t) ? P(this, as).actor[`system.resources.${t}.value`] = n : P(this, as).actor[`system.resources.classResources.${t}`] = n;
  });
}, "#restoreGenericResources"), VL = /* @__PURE__ */ u(function() {
  const { updates: e, type: t } = P(this, Ls).HitDiceManager.getUpdateData();
  t === "actor" && (P(this, as).actor = foundry.utils.mergeObject(P(this, as).actor, e)), t === "embedded" && (P(this, as).items = P(this, as).items.concat(e));
}, "#restoreHitDice"), WL = /* @__PURE__ */ u(function() {
  const { max: e, bonus: t } = P(this, Ls).system.attributes.hp;
  P(this, as).actor["system.attributes.hp"] = {
    bonus: 0,
    value: e - t,
    temp: 0
  };
}, "#restoreHitPoints"), KL = /* @__PURE__ */ u(function() {
  Array.from(P(this, Ls).items).forEach((t) => {
    const s = P(this, Ls).getRollData(t), { uses: n } = t.system, l = { _id: t.id };
    if (t.actions && t.actions.entries().forEach(([r, o]) => {
      const a = o.uses ?? {};
      !this.restTypes.includes(a == null ? void 0 : a.per) || !(a != null && a.max) || (l[`system.actions.${r}.uses.value`] = mt(
        a.max,
        s
      ));
    }), !this.restTypes.includes(n == null ? void 0 : n.per) || !(n != null && n.max)) {
      if (Object.keys(l).length < 2) return;
      P(this, as).items.push(l);
      return;
    }
    l["system.uses.value"] = mt(n.max, s), P(this, as).items.push(l);
  });
}, "#restoreUses"), YL = /* @__PURE__ */ u(function() {
  var l, r;
  const { spellResources: e } = P(this, Ls).system, t = ((r = (l = P(this, Ls)) == null ? void 0 : l.flags) == null ? void 0 : r.a5e) ?? {}, s = (t == null ? void 0 : t.restoreSpellPointsOnShortRest) ?? !0, n = (t == null ? void 0 : t.restoreSpellSlotsOnShortRest) ?? !1;
  (P(this, pr) === "long" || s) && (P(this, as).actor["system.spellResources.points.current"] = Math.max(
    e.points.max,
    0
  )), (P(this, pr) === "long" || n) && Object.entries(e.slots ?? {}).forEach(([o, { max: a }]) => {
    P(this, as).actor[`system.spellResources.slots.${o}.current`] = Math.max(a, 0);
  });
}, "#restoreSpellResources"), XL = /* @__PURE__ */ u(async function() {
  if (!game.settings.get("a5e", "removeActiveEffectsOnLongRest")) return;
  const e = Array.from(P(this, Ls).effects).filter((t) => t.system.effectType === "onUse");
  e.length && await P(this, Ls).deleteEmbeddedDocuments(
    "ActiveEffect",
    e.map((t) => t.id)
  );
}, "#removeTemporaryActiveEffects"), u(n$, "RestManager");
let cp = n$;
var il, qc, tb;
const i$ = class i$ {
  constructor(e) {
    x(this, il);
    qe(this, "actor");
    qe(this, "overrides");
    qe(this, "ready");
    this.actor = e, this.overrides = /* @__PURE__ */ new Map(), this.overrides.set("abilityCheck.all", []), this.overrides.set("abilitySave.all", []), Object.keys(CONFIG.A5E.abilities).forEach((t) => {
      this.overrides.set(`system.abilities.${t}.check`, []), this.overrides.set(`system.abilities.${t}.save`, []);
    }), this.overrides.set("skillCheck.all", []), Object.keys(CONFIG.A5E.skills).forEach((t) => {
      this.overrides.set(`system.skills.${t}`, []);
    }), this.overrides.set("attack.all", []), Object.keys(CONFIG.A5E.attackTypes).forEach((t) => {
      this.overrides.set(`attackTypes.${t}`, []);
    }), this.overrides.set("concentration", []), this.overrides.set("deathSave", []), this.overrides.set("initiative", []), this.ready = !1;
  }
  initialize() {
    Object.entries(this.actor.system.abilities).forEach(([t, s]) => {
      ["check", "save"].forEach((n) => {
        var l, r, o;
        if ((l = s[n]) != null && l.expertiseDice) {
          const a = (r = s[n]) == null ? void 0 : r.expertiseDice;
          (o = this.overrides.get(`system.abilities.${t}.${n}`)) == null || o.push({
            value: a,
            overrideType: "expertiseDice",
            source: CONFIG.A5E.abilities[t],
            mode: CONFIG.A5E.ACTIVE_EFFECT_MODES.ADD
          });
        }
      });
    }), this.actor.grants.byType("expertiseDice").forEach((t) => {
      const { expertiseType: s, expertiseCount: n, keys: l } = t.expertiseDiceData ?? {}, { name: r } = fromUuidSync(t.itemUuid) ?? {};
      s === "abilityCheck" ? l.forEach((o) => {
        var a;
        (a = this.overrides.get(`system.abilities.${o}.check`)) == null || a.push({
          value: n,
          overrideType: "expertiseDice",
          source: r,
          mode: CONFIG.A5E.ACTIVE_EFFECT_MODES.ADD
        });
      }) : s === "abilitySave" ? l.forEach((o) => {
        var a;
        (a = this.overrides.get(`system.abilities.${o}.save`)) == null || a.push({
          value: n,
          overrideType: "expertiseDice",
          source: r,
          mode: CONFIG.A5E.ACTIVE_EFFECT_MODES.ADD
        });
      }) : s === "attack" && l.forEach((o) => {
        var a;
        (a = this.overrides.get(`attackTypes.${o}`)) == null || a.push({
          value: n,
          overrideType: "expertiseDice",
          source: r,
          mode: CONFIG.A5E.ACTIVE_EFFECT_MODES.ADD
        });
      });
    }), this.actor.grants.byType("rollOverride").forEach((t) => {
      const { rollOverrideType: s, rollMode: n, keys: l } = t.rollOverrideData ?? {}, { name: r } = fromUuidSync(t.itemUuid) ?? {}, o = [];
      s === "abilityCheck" ? l.forEach((a) => o.push(`system.abilities.${a}.check`)) : s === "abilitySave" ? l.forEach((a) => o.push(`system.abilities.${a}.save`)) : s === "skill" ? l.forEach((a) => o.push(`system.skills.${a}`)) : s === "attack" ? l.forEach((a) => o.push(`attackTypes.${a}`)) : s === "concentration" ? o.push("concentration") : s === "deathSave" ? o.push("deathSave") : s === "initiative" && o.push("initiative"), o.forEach((a) => {
        var c;
        (c = this.overrides.get(a)) == null || c.push({ value: n, overrideType: "rollMode", source: r });
      });
    }), this.actor.items.forEach((t) => {
      var s, n;
      t.isType("object") && ((s = t.system) == null ? void 0 : s.objectType) === "armor" && t.system.equippedState === CONFIG.A5E.ARMOR_MODES.OVERRIDE && t.system.ac.grantsDisadvantage && ((n = this.overrides.get("system.skills.ste")) == null || n.push({ value: -1, overrideType: "rollMode", source: t.name }));
    }), this.actor.effects.reduce((t, s) => {
      if (s.disabled || s.changes.length === 0) return t;
      const n = [];
      return s.changes.forEach((l) => {
        if (!l.key.startsWith("flags.a5e.effects.rollMode") && !l.key.startsWith("flags.a5e.effects.expertiseDice"))
          return;
        let r = l.key.replace("flags.a5e.effects.", "");
        const o = r.split(".").shift();
        o === "rollMode" ? r = r.replace("rollMode.", "") : r = r.replace("expertiseDice.", ""), n.push({
          key: r,
          value: parseInt(l.value, 10) || 0,
          mode: l.mode,
          name: s.name,
          type: o
        });
      }), n.length && t.push(...n), t;
    }, []).forEach((t) => {
      var f, d, p, m, g, h, _, y, v, k, S;
      const { key: s, value: n, name: l, type: r, mode: o } = t;
      if (["concentration", "deathSave", "initiative"].includes(s)) {
        (f = this.overrides.get(s)) == null || f.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      if (s === "abilityCheck.all") {
        (d = this.overrides.get("abilityCheck.all")) == null || d.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      if (s === "abilitySave.all") {
        (p = this.overrides.get("abilitySave.all")) == null || p.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      if (s === "skillCheck.all") {
        (m = this.overrides.get("skillCheck.all")) == null || m.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      if (s === "attack.all") {
        (g = this.overrides.get("attack.all")) == null || g.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      if (s === "all" && r === "expertiseDice") {
        (h = this.overrides.get("abilityCheck.all")) == null || h.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        }), (_ = this.overrides.get("abilitySave.all")) == null || _.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        }), (y = this.overrides.get("attack.all")) == null || y.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      const [a, c] = s.split(".");
      if (["abilityCheck", "abilitySave"].includes(a)) {
        const D = a === "abilityCheck" ? "check" : "save";
        (v = this.overrides.get(`system.abilities.${c}.${D}`)) == null || v.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      if (a === "skillCheck") {
        (k = this.overrides.get(`system.skills.${c}`)) == null || k.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      a === "attack" && ((S = this.overrides.get(`attackTypes.${c}`)) == null || S.push({
        value: n,
        overrideType: r,
        source: l,
        mode: o
      }));
    }), this.ready = !0;
  }
  // *********************************************************************************************
  //  Roll Override Methods
  // *********************************************************************************************
  getRollOverride(e, t = 0, s = {}) {
    const n = X(this, il, qc).call(this, e, "rollMode", s);
    if (!(n != null && n.length)) return t;
    const l = n.some((o) => o.value === CONFIG.A5E.ROLL_MODE.ADVANTAGE), r = n.some((o) => o.value === CONFIG.A5E.ROLL_MODE.DISADVANTAGE);
    return l && r ? CONFIG.A5E.ROLL_MODE.NORMAL : !l && !r ? t : l ? X(this, il, tb).call(this, t, CONFIG.A5E.ROLL_MODE.ADVANTAGE) : X(this, il, tb).call(this, t, CONFIG.A5E.ROLL_MODE.DISADVANTAGE);
  }
  getRollOverridesSource(e, t = 0, s = {}) {
    const n = X(this, il, qc).call(this, e, "rollMode", s);
    if (!(n != null && n.length)) return "";
    let l;
    t === CONFIG.A5E.ROLL_MODE.ADVANTAGE ? l = "Advantage" : t === CONFIG.A5E.ROLL_MODE.DISADVANTAGE ? l = "Disadvantage" : l = "Normal";
    const { adv: r, dis: o } = n.reduce(
      (p, m) => (m.value === CONFIG.A5E.ROLL_MODE.ADVANTAGE ? p.adv.push(m.source) : m.value === CONFIG.A5E.ROLL_MODE.DISADVANTAGE && p.dis.push(m.source), p),
      { adv: [], dis: [] }
    );
    let a = "", c = "";
    r.length && (a = `<p> <strong>Advantage:</strong> ${r.join(", ")}</p>`), o.length && (c = `<p> <strong>Disadvantage:</strong> ${o.join(", ")}</p>`);
    const f = this.getRollOverride(e, t);
    let d;
    return f === CONFIG.A5E.ROLL_MODE.ADVANTAGE ? d = "Advantage" : f === CONFIG.A5E.ROLL_MODE.DISADVANTAGE ? d = "Disadvantage" : d = "Normal", `<div class='u-text-xs u-text-left'>
      <p> <strong>Base Roll Mode:</strong> ${l}</p>
      ${a}
      ${c}
      <p> <strong>Result:</strong> ${d}</p>
    </div>
    `;
  }
  // *********************************************************************************************
  //  Expertise Override Methods
  // *********************************************************************************************
  getExpertiseDice(e, t = 0, s = {}) {
    const n = X(this, il, qc).call(this, e, "expertiseDice", s);
    if (!(n != null && n.length)) return t;
    n.sort((r, o) => (o.mode ?? 2) - (r.mode ?? 2));
    let l = t;
    return n.forEach((r) => {
      r.mode === CONFIG.A5E.ACTIVE_EFFECT_MODES.OVERRIDE ? l = r.value : l += r.value;
    }), Math.clamp(l, 0, 5);
  }
  getExpertiseDiceSource(e, t = 0, s = {}) {
    const n = X(this, il, qc).call(this, e, "expertiseDice", s);
    if (!(n != null && n.length)) return "";
    n.sort((a, c) => (c.mode ?? 2) - (a.mode ?? 2));
    const l = t ? `d${CONFIG.A5E.expertiseDiceSidesMap[t]}` : "None", r = n.map(
      (a) => `${a.source} (d${CONFIG.A5E.expertiseDiceSidesMap[a.value]})`
    ), o = this.getExpertiseDice(e, t);
    return `<div class='u-text-xs u-text-left'>
      <p> <strong>Base Die:</strong> ${l}</p>
      <p> <strong>Overrides:</strong> ${r.join(", ")}</p>
      <p> <strong>Total Bonus:</strong> d${CONFIG.A5E.expertiseDiceSidesMap[o]}</p>
      </div>`;
  }
};
il = new WeakSet(), qc = /* @__PURE__ */ u(function(e, t = "rollMode", s = {}) {
  var l, r, o, a, c, f, d, p, m, g, h, _;
  const n = ((l = this.overrides.get(e)) == null ? void 0 : l.filter((y) => y.overrideType === t)) ?? [];
  if (e.includes("abilities") && (e.toLowerCase().includes("check") && ((r = this.overrides.get("abilityCheck.all")) == null || r.forEach((y) => {
    y.overrideType === t && n.push(y);
  })), e.toLowerCase().includes("save") && ((o = this.overrides.get("abilitySave.all")) == null || o.forEach((y) => {
    y.overrideType === t && n.push(y);
  }))), e.includes("skills")) {
    (a = this.overrides.get("skillCheck.all")) == null || a.forEach((v) => {
      v.overrideType === t && n.push(v);
    });
    const y = s.ability || ((c = this.actor.system.skills[e.split(".").pop()]) == null ? void 0 : c.ability) || "";
    y && ((f = this.overrides.get(`system.abilities.${y}.check`)) == null || f.forEach((v) => {
      v.overrideType === t && n.push(v);
    })), (d = this.overrides.get("abilityCheck.all")) == null || d.forEach((v) => {
      v.overrideType === t && n.push(v);
    });
  }
  if (e === "initiative") {
    (p = this.overrides.get("abilityCheck.all")) == null || p.forEach((k) => {
      k.overrideType === t && n.push(k);
    }), (m = this.overrides.get("skillCheck.all")) == null || m.forEach((k) => {
      k.overrideType === t && n.push(k);
    });
    const y = s.ability || "";
    y && ((g = this.overrides.get(`system.abilities.${y}.check`)) == null || g.forEach((k) => {
      k.overrideType === t && n.push(k);
    }));
    const v = s.skill || "";
    v && ((h = this.overrides.get(`system.skills.${v}`)) == null || h.forEach((k) => {
      k.overrideType === t && n.push(k);
    }));
  }
  if (e.includes("attack")) {
    (_ = this.overrides.get("attack.all")) == null || _.forEach((y) => {
      y.overrideType === t && n.push(y);
    });
    try {
      const y = game.settings.get("a5e-flanking", "flankingDND5EMode") ?? !1, v = !!this.actor.getFlag("a5e", "flanking");
      y && v && t === "rollMode" ? n.push({
        overrideType: "rollMode",
        source: "Flanking",
        value: CONFIG.A5E.ROLL_MODE.ADVANTAGE
      }) : !y && v && t === "expertiseDice" && n.push({
        overrideType: "expertiseDice",
        source: "Flanking",
        value: 1
      });
    } catch {
    }
  }
  return n;
}, "#prepareOverrides"), tb = /* @__PURE__ */ u(function(e, t) {
  return (e ^ t) < -1 ? 0 : t;
}, "#determineRollMode"), u(i$, "RollOverrideManager");
let eb = i$;
async function OH(i) {
  const e = foundry.dice.terms;
  return [
    ...i.terms,
    await new e.OperatorTerm({ operator: "+" }).evaluate(),
    await new e.NumericTerm({
      number: i.total,
      options: { flavor: K("A5E.CritDamage") }
    }).evaluate()
  ];
}
u(OH, "doubleRolledDamage");
async function DH(i) {
  const e = foundry.dice.terms, t = i.dice.reduce((n, l) => n + l.total, 0);
  return [
    ...i.terms,
    await new e.OperatorTerm({ operator: "+" }).evaluate(),
    await new e.NumericTerm({
      number: t,
      options: { flavor: K("A5E.CritDamage") }
    }).evaluate()
  ];
}
u(DH, "doubleDiceDamage");
async function IH(i) {
  const e = [...i.terms];
  for await (const t of i.dice) {
    const s = await new foundry.dice.terms.OperatorTerm({ operator: "+" }).evaluate(), n = await new foundry.dice.terms.Die({
      faces: t.faces,
      number: t.number,
      modifiers: t.modifiers,
      options: t.options
    }).evaluate();
    e.push(s, n);
  }
  return e;
}
u(IH, "doubleDiceQuantity");
async function PH(i) {
  const e = foundry.dice.terms, t = [];
  for await (const s of i.terms) {
    if (!(s instanceof e.FunctionTerm || s instanceof e.NumericTerm)) {
      t.push(s);
      continue;
    }
    const n = await new e.NumericTerm({
      number: s.total * 2,
      options: s.options
    }).evaluate();
    t.push(n);
  }
  for await (const s of i.dice) {
    const n = await new e.OperatorTerm({ operator: "+" }).evaluate(), l = await new e.Die({
      faces: s.faces,
      number: s.number,
      modifiers: s.modifiers,
      options: s.options
    }).evaluate();
    t.push(n, l);
  }
  return t;
}
u(PH, "doubleDiceQuantityAndMods");
async function MH(i) {
  const e = await new Roll(i).evaluate();
  return [
    await new foundry.dice.terms.OperatorTerm({ operator: "+" }).evaluate(),
    ...e.terms
  ];
}
u(MH, "getBonusCritDamage");
async function FH(i) {
  const e = i.clone();
  return await e.evaluate({ maximize: !0 }), e.terms;
}
u(FH, "maxDamagePlusRoll");
async function RH(i) {
  const e = i.clone();
  return await e.evaluate({ maximize: !0 }), [
    ...e.terms,
    await new foundry.dice.terms.OperatorTerm({ operator: "+" }).evaluate(),
    ...i.terms
  ];
}
u(RH, "maxDamage");
function bu(i) {
  const e = foundry.dice.terms;
  return i.reduce((t, s, n) => {
    const l = t[t.length - 1], r = /* @__PURE__ */ new Set([l == null ? void 0 : l.operator, s.operator]);
    return n === i.length - 1 && s.operator || (r.has(void 0) ? t.push(s) : r.has("+") && r.has("-") ? t.splice(-1, 1, new e.OperatorTerm({ operator: "-" })) : r.has("-") && r.size === 1 ? t.splice(-1, 1, new e.OperatorTerm({ operator: "+" })) : r.has("+") || t.push(s)), t;
  }, []);
}
u(bu, "simplifyOperatorTerms");
function Id(i) {
  const e = foundry.dice.terms;
  if (i.some((s) => s.operator === "*" || s.operator === "/")) return i;
  const t = bu(i).reduce((s, n, l) => {
    if (l === 0)
      return s.push(n), s;
    const r = i[l - 1];
    if (n instanceof e.OperatorTerm) return s;
    if (!(n instanceof e.DiceTerm) || r.operator === "-")
      return s.push(r, n), s;
    if (n.flavor) {
      const a = s.findIndex(
        ({ faces: c, flavor: f }) => c === n.faces && f === n.flavor
      );
      if (a !== -1) {
        const c = s[a].number + n.number, f = [...s[a].results, ...n.results], d = new e.Die({
          faces: n.faces,
          number: c,
          results: f,
          options: {
            flavor: n.flavor
          }
        });
        s.splice(a, 1, d);
      } else
        s.push(r, n);
      return s;
    }
    const o = s.findIndex(
      ({ faces: a, flavor: c }) => a === n.faces && !c
    );
    if (o !== -1) {
      const a = s[o].number + n.number, c = [...s[o].results, ...n.results], f = new e.Die({
        faces: n.faces,
        number: a,
        results: c
      });
      s.splice(o, 1, f);
    } else
      s.push(r, n);
    return s;
  }, []);
  return t.forEach((s) => {
    s._evaluated = !0;
  }), t;
}
u(Id, "simplifyDiceTerms");
const NH = {
  doubleAllDamage: OH,
  doubleDiceDamage: DH,
  doubleDiceQuantity: IH,
  doubleDiceQuantityAndMods: PH,
  maxDamage: FH,
  maxDamagePlusRoll: RH
};
async function jH(i, e) {
  const t = game.settings.get("a5e", "critCalculationMode"), s = await NH[t](i);
  return e && s.push(...await MH(e)), Roll.fromTerms(Id(s));
}
u(jH, "constructCritDamageRoll");
function LH({ actor: i, minRoll: e, rollMode: t }) {
  var n, l;
  let s = "1d20";
  return [CONFIG.A5E.ROLL_MODE.ADVANTAGE, CONFIG.A5E.ROLL_MODE.DISADVANTAGE].includes(t) && (s = "2d20"), (l = (n = i == null ? void 0 : i.flags) == null ? void 0 : n.a5e) != null && l.halflingLuck && (s += "r1"), e > 1 && (s += `min${e}`), t === CONFIG.A5E.ROLL_MODE.ADVANTAGE ? s += "kh" : t === CONFIG.A5E.ROLL_MODE.DISADVANTAGE && (s += "kl"), s;
}
u(LH, "constructD20Term");
function F5({ actor: i, item: e, minRoll: t, modifiers: s, rollMode: n }) {
  const l = i.getRollData(e), o = [
    LH({ actor: i, minRoll: t, rollMode: n }),
    ...(s ?? []).map(({ label: f, value: d }) => {
      if (!d || d === 0) return null;
      let p;
      try {
        p = new Roll(d.toString(), l);
      } catch {
        return null;
      }
      return p.terms.forEach((m) => {
        var g;
        m.constructor.name !== "OperatorTerm" && ((g = m.options).flavor ?? (g.flavor = f));
      }), p.formula;
    })
  ].filter((f) => f && f !== "0").join(" + "), { terms: a } = new Roll(o, l), c = bu(a);
  return { rollFormula: Roll.getFormula(c) };
}
u(F5, "constructD20RollFormula");
function Gc({ actor: i, formula: e, item: t, modifiers: s }) {
  const n = i.getRollData(t), l = [
    e,
    ...(s ?? []).map(({ label: a, value: c }) => {
      if (!c || c === 0) return null;
      let f;
      try {
        f = new Roll(c.toString(), n);
      } catch {
        return null;
      }
      return f.terms.forEach((d) => {
        var p;
        ["OperatorTerm", "StringTerm"].includes(d.constructor.name) || ((p = d.options).flavor ?? (p.flavor = a));
      }), f.formula;
    })
  ], { terms: r } = new Roll(l.filter((a) => a && a !== "0").join(" + "), n), o = bu(r);
  return { rollFormula: Roll.getFormula(o) };
}
u(Gc, "constructRollFormula");
function BH(i, e) {
  let t;
  const s = i.system;
  return e.system.spellBook && (t = i.spellBooks.get(e.system.spellBook)), t ? t.stats.dc ?? 8 : s.attributes.spellDC ?? 8;
}
u(BH, "getSpellBookDC");
function R5(i, e, t) {
  if (!i) return null;
  const s = i.getRollData(e), n = [];
  return (t == null ? void 0 : t.type) === "spellcasting" ? n.push(BH(i, e)) : (t == null ? void 0 : t.type) === "maneuver" ? n.push(i.system.attributes.maneuverDC) : Object.keys(CONFIG.A5E.abilities).includes(t == null ? void 0 : t.type) && n.push(8, i.system.attributes.prof, i.system.abilities[t == null ? void 0 : t.type].check.mod), t.bonus && n.push(t == null ? void 0 : t.bonus), mt(n.join(" + "), s);
}
u(R5, "computeSaveDC");
function FO(i, e) {
  let t;
  const s = i.system;
  return e.system.spellBook && (t = i.spellBooks.get(e.system.spellBook)), !t || t.stats.ability === "default" ? s.attributes.spellcasting ?? "int" : t.stats.ability || "int";
}
u(FO, "getSpellBookAbility");
function qH(i, e, t) {
  var o, a;
  const s = i.system, n = e.system, l = s.abilities.dex.mod, r = s.abilities.str.mod;
  if (Object.values(t).length && (t.attackType ?? (t.attackType = "meleeWeaponAttack")), t.ability === "spellcasting")
    return FO(i, e);
  if ((t == null ? void 0 : t.ability) === "default") {
    if (["meleeSpellAttack", "rangedSpellAttack"].includes(t.attackType))
      return FO(i, e);
    if (t.attackType === "meleeWeaponAttack")
      return (o = n == null ? void 0 : n.weaponProperties) != null && o.includes("finesse") && l > r ? "dex" : "str";
    if (t.attackType === "rangedWeaponAttack")
      return (a = n == null ? void 0 : n.weaponProperties) != null && a.includes("thrown") ? l > r ? "dex" : "str" : "dex";
  }
  return t.ability;
}
u(qH, "getAttackAbility");
function _u(i, e = !0) {
  let t;
  if (i === 1) t = "d4";
  else if (i === 2) t = "d6";
  else if (i === 3) t = "d8";
  else if (i === 4) t = "d10";
  else if (i === 5) t = "d12";
  else if (i >= 6) t = "d20";
  else return null;
  return `${e ? 1 : ""}${t}`;
}
u(_u, "getExpertiseDieSize");
var pt, sb, JL, ZL, QL, nb, ib, zc, xL, e9, t9, s9, n9, Hc, i9, lb, l9, r9, o9, Uc;
const l$ = class l$ {
  constructor(e, t) {
    x(this, pt);
    this.actor = e, this.rollData = t;
  }
  getModifiers() {
    switch (this.rollData.type) {
      case "abilityCheck":
        return X(this, pt, sb).call(this).filter(Boolean);
      case "attack":
        return X(this, pt, JL).call(this).filter(Boolean);
      case "initiative":
        return X(this, pt, ZL).call(this).filter(Boolean);
      case "savingThrow":
        return X(this, pt, QL).call(this).filter(Boolean);
      case "skillCheck":
        return X(this, pt, nb).call(this).filter(Boolean);
      default:
        return [];
    }
  }
};
pt = new WeakSet(), sb = /* @__PURE__ */ u(function() {
  return [
    X(this, pt, zc).call(this),
    X(this, pt, xL).call(this),
    X(this, pt, ib).call(this),
    X(this, pt, Hc).call(this),
    X(this, pt, Uc).call(this)
  ];
}, "#getAbilityCheckModifiers"), JL = /* @__PURE__ */ u(function() {
  return [
    X(this, pt, l9).call(this),
    X(this, pt, zc).call(this),
    X(this, pt, s9).call(this),
    X(this, pt, i9).call(this),
    X(this, pt, Hc).call(this),
    X(this, pt, Uc).call(this)
  ];
}, "#getAttackRollModifiers"), ZL = /* @__PURE__ */ u(function() {
  return game.settings.storage.get("world").getItem("a5e.simpleInitiative") ?? !1 ? [X(this, pt, lb).call(this), ...X(this, pt, sb).call(this)] : [X(this, pt, lb).call(this), ...X(this, pt, nb).call(this)];
}, "#getInitiativeRollModifiers"), QL = /* @__PURE__ */ u(function() {
  return [
    X(this, pt, t9).call(this),
    X(this, pt, zc).call(this),
    X(this, pt, e9).call(this),
    X(this, pt, n9).call(this),
    X(this, pt, Hc).call(this),
    X(this, pt, Uc).call(this)
  ];
}, "#getSavingThrowModifiers"), nb = /* @__PURE__ */ u(function() {
  return [
    X(this, pt, r9).call(this),
    X(this, pt, zc).call(this),
    X(this, pt, o9).call(this),
    X(this, pt, ib).call(this),
    X(this, pt, Hc).call(this),
    X(this, pt, Uc).call(this)
  ];
}, "#getSkillCheckModifiers"), ib = /* @__PURE__ */ u(function() {
  const { ability: e, selectedAbilityBonuses: t } = this.rollData;
  if (!e) return null;
  let s;
  return t ? s = this.actor.BonusesManager.getSelectedBonusesFormula(
    "abilities",
    t
  ) : s = this.actor.BonusesManager.getAbilityBonusesFormula(e, "check"), {
    label: K("A5E.AbilityCheckBonus", {
      ability: CONFIG.A5E.abilities[e]
    }),
    value: s || null
  };
}, "#getAbilityCheckBonus"), zc = /* @__PURE__ */ u(function() {
  var t;
  const { ability: e } = this.rollData;
  return e ? {
    label: K("A5E.AbilityCheckMod", {
      ability: CONFIG.A5E.abilities[e] ?? e
    }),
    value: ((t = this.actor.system.abilities[e]) == null ? void 0 : t.mod) ?? null
  } : null;
}, "#getAbilityModifier"), xL = /* @__PURE__ */ u(function() {
  var s;
  const { ability: e } = this.rollData;
  if (!e) return null;
  let t = !1;
  return (game.settings.storage.get("world").getItem("a5e.5eStyleJackOfAllTrades") ?? !1) && (t = ((s = this.actor.flags.a5e) == null ? void 0 : s.jackOfAllTrades) ?? !1), t ? {
    label: K("A5E.ProficiencyBonusJack"),
    value: Math.floor(this.actor.system.attributes.prof / 2)
  } : null;
}, "#getAbilityCheckProficiencyBonus"), e9 = /* @__PURE__ */ u(function() {
  const { ability: e, selectedAbilityBonuses: t } = this.rollData;
  if (!e) return null;
  let s;
  return t ? s = this.actor.BonusesManager.getSelectedBonusesFormula(
    "abilities",
    t
  ) : s = this.actor.BonusesManager.getAbilityBonusesFormula(e, "save"), {
    label: K("A5E.AbilitySaveBonus", {
      ability: CONFIG.A5E.abilities[e]
    }),
    value: s || null
  };
}, "#getAbilitySaveBonus"), t9 = /* @__PURE__ */ u(function() {
  var n, l;
  const { ability: e } = this.rollData;
  if (!e) return null;
  const t = (l = (n = this.actor.system.abilities[e]) == null ? void 0 : n.save) == null ? void 0 : l.proficient, s = this.actor.system.attributes.prof;
  return {
    label: K("A5E.ProficiencyBonus"),
    value: t ? s : 0
  };
}, "#getAbilitySaveModifier"), s9 = /* @__PURE__ */ u(function() {
  return {
    label: K("A5E.AttackBonus"),
    value: this.rollData.attackBonus ?? 0
  };
}, "#getAttackBonus"), n9 = /* @__PURE__ */ u(function() {
  return this.rollData.saveType !== "concentration" ? null : {
    label: K("A5E.ConcentrationBonus"),
    value: this.actor.system.abilities.con.save.concentrationBonus
  };
}, "#getConcentrationBonus"), Hc = /* @__PURE__ */ u(function() {
  var e;
  return {
    label: K("A5E.ExpertiseDie"),
    value: _u(((e = this.rollData) == null ? void 0 : e.expertiseDie) ?? 0)
  };
}, "#getExpertiseDice"), i9 = /* @__PURE__ */ u(function() {
  const { BonusesManager: e } = this.actor, { attackType: t, item: s, selectedAttackBonuses: n } = this.rollData;
  let l;
  switch (n ? l = e.getSelectedBonusesFormula("attacks", n) : l = e.getAttackBonusFormula(s, t), t) {
    case "meleeSpellAttack":
      return { label: K("A5E.BonusMeleeSpellAttack"), value: l };
    case "meleeWeaponAttack":
      return { label: K("A5E.BonusMeleeWeaponAttack"), value: l };
    case "rangedSpellAttack":
      return { label: K("A5E.BonusRangedSpellAttack"), value: l };
    case "rangedWeaponAttack":
      return { label: K("A5E.BonusRangedWeaponAttack"), value: l };
    default:
      return null;
  }
}, "#getGlobalAttackBonus"), lb = /* @__PURE__ */ u(function() {
  const { ability: e, selectedInitiativeBonuses: t, skill: s } = this.rollData;
  let n;
  return t ? n = this.actor.BonusesManager.getSelectedBonusesFormula(
    "initiative",
    t
  ) : n = this.actor.BonusesManager.getInitiativeBonusFormula({
    abilityKey: e,
    skillKey: s
  }), {
    label: K("A5E.InitiativeBonus"),
    value: n || null
  };
}, "#getInitiativeBonus"), l9 = /* @__PURE__ */ u(function() {
  return this.rollData.proficient ? {
    label: K("A5E.ProficiencyBonus"),
    value: this.actor.system.attributes.prof
  } : null;
}, "#getProficiencyBonus"), r9 = /* @__PURE__ */ u(function() {
  var l;
  const { skill: e } = this.rollData;
  if (!e) return null;
  let t = "A5E.SkillCheckMod";
  const s = (l = this.actor.flags.a5e) == null ? void 0 : l.jackOfAllTrades, n = this.actor.system.skills[e];
  return (n == null ? void 0 : n.proficient) === 2 ? t = "A5E.ProficiencyBonusExpertise" : n != null && n.proficient ? t = "A5E.ProficiencyBonus" : s && (t = "A5E.ProficiencyBonusJack"), {
    label: t ? K(t, { skill: CONFIG.A5E.skills[e] }) : "",
    value: (n == null ? void 0 : n.mod) ?? null
  };
}, "#getSkillCheckModifier"), o9 = /* @__PURE__ */ u(function() {
  const { ability: e, selectedSkillBonuses: t, skill: s } = this.rollData;
  if (!s) return null;
  let n;
  return t ? n = this.actor.BonusesManager.getSelectedBonusesFormula("skills", t) : n = this.actor.BonusesManager.getSkillBonusesFormula(s, e), {
    label: K("A5E.SkillCheckBonus", { skill: CONFIG.A5E.skills[s] }),
    value: n || null
  };
}, "#getSkillCheckBonus"), Uc = /* @__PURE__ */ u(function() {
  return { value: this.rollData.situationalMods };
}, "#getSituationalModifiers"), u(l$, "ModifierManager");
let yu = l$;
function ll(i, e = {}) {
  const t = new yu(i, e);
  return F5({
    actor: i,
    rollMode: e.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL,
    minRoll: e.minRoll ?? 1,
    item: e.item ?? null,
    modifiers: t.getModifiers()
  }).rollFormula;
}
u(ll, "getRollFormula");
function GH(i, e) {
  if (!i.length) return [];
  if (e === "resource") return i;
  const [t, s] = i[0];
  return [t, s];
}
u(GH, "_prepareConsumers");
function zH(i, e) {
  const { consumers: t } = i.actions.get(e), s = Object.entries(t ?? {}).reduce((n, [l, r]) => {
    var o;
    return n[o = r.type] ?? (n[o] = []), n[r.type].push([l, r]), n;
  }, {});
  return Object.entries(s).reduce((n, [l, r]) => (n[l] = GH(r, l) ?? [], n), {});
}
u(zH, "prepareConsumers");
function HH(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (s.ability ?? (s.ability = "str"), !s.label) {
      const l = game.i18n.format("A5E.AbilityCheckSpecific", {
        ability: game.i18n.localize(CONFIG.A5E.abilities[s.ability])
      });
      e[n = s.ability] ?? (e[n] = 0), e[s.ability] += 1, s.defaultLabel = `${l} #${e[s.ability]}`;
    }
    return [t, s];
  }) : [];
}
u(HH, "prepareAbilityCheckPrompts");
function UH(i) {
  let e = 0;
  return i.length ? i.map(([t, s]) => {
    if (!s.label) {
      const n = game.i18n.localize("A5E.Other");
      e += 1, s.defaultLabel = `${n} #${e}`;
    }
    return [t, s];
  }) : [];
}
u(UH, "prepareGenericRollPrompts");
function VH(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (s.ability ?? (s.ability = "str"), !s.label) {
      const l = game.i18n.format("A5E.SavingThrowSpecific", {
        ability: game.i18n.localize(CONFIG.A5E.abilities[s.ability])
      });
      e[n = s.ability] ?? (e[n] = 0), e[s.ability] += 1, s.defaultLabel = `${l} #${e[s.ability]}`;
    }
    return [t, s];
  }) : [];
}
u(VH, "prepareSavingThrowPrompts");
function WH(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (s.skill ?? (s.skill = "acr"), !s.label) {
      const l = game.i18n.format("A5E.SkillCheck", {
        skill: game.i18n.localize(CONFIG.A5E.skills[s.skill])
      });
      e[n = s.skill] ?? (e[n] = 0), e[s.skill] += 1, s.defaultLabel = `${l} #${e[s.skill]}`;
    }
    return [t, s];
  }) : [];
}
u(WH, "prepareSkillCheckPrompts");
const RO = {
  abilityCheck: HH,
  savingThrow: VH,
  skillCheck: WH,
  generic: UH
};
function KH(i, e) {
  const { prompts: t } = i.actions.get(e), s = Object.entries(t ?? {}).reduce((n, [l, r]) => {
    var o;
    return n[o = r.type] ?? (n[o] = []), n[r.type].push([l, r]), n;
  }, {});
  return Object.entries(s).reduce((n, [l, r]) => (typeof RO[l] == "function" && (n[l] = RO[l](r, i) ?? []), n), {});
}
u(KH, "preparePrompts$1");
function YH(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (s.ability ?? (s.ability = "str"), !s.label) {
      const l = game.i18n.format("A5E.AbilityCheckSpecific", {
        ability: game.i18n.localize(CONFIG.A5E.abilities[s.ability])
      });
      e[n = s.ability] ?? (e[n] = 0), e[s.ability] += 1, s.defaultLabel = `${l} #${e[s.ability]}`;
    }
    return [t, s];
  }) : [];
}
u(YH, "prepareAbilityChecks");
function XH(i) {
  if (!i.length) return [];
  const [e, t] = i[0];
  return [[e, t]];
}
u(XH, "prepareAttackRolls");
function JH(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (!s.label) {
      const l = game.i18n.format("A5E.DamageSpecific", {
        damageType: game.i18n.localize(CONFIG.A5E.damageTypes[s.damageType] ?? "")
      });
      e[n = s.damageType] ?? (e[n] = 0), e[s.damageType] += 1, s.defaultLabel = `${l} #${e[s.damageType]}`;
    }
    return [t, s];
  }) : [];
}
u(JH, "prepareDamageRolls");
function ZH(i) {
  let e = 0;
  return i.length ? i.map(([t, s]) => {
    if (!s.label) {
      const n = game.i18n.localize("A5E.Other");
      e += 1, s.defaultLabel = `${n} #${e}`;
    }
    return [t, s];
  }) : [];
}
u(ZH, "prepareGenericRolls");
function QH(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (!s.label) {
      s.healingType ?? (s.healingType = "healing");
      const l = game.i18n.localize(CONFIG.A5E.healingTypes[s.healingType] ?? "");
      e[n = s.healingType] ?? (e[n] = 0), e[s.healingType] += 1, s.defaultLabel = `${l} #${e[s.healingType]}`;
    }
    return [t, s];
  }) : [];
}
u(QH, "prepareHealingRolls");
function xH(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (s.ability ?? (s.ability = "str"), !s.label) {
      const l = game.i18n.format("A5E.SavingThrowSpecific", {
        ability: game.i18n.localize(CONFIG.A5E.abilities[s.ability])
      });
      e[n = s.ability] ?? (e[n] = 0), e[s.ability] += 1, s.defaultLabel = `${l} #${e[s.ability]}`;
    }
    return [t, s];
  }) : [];
}
u(xH, "prepareSavingThrows");
function eU(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (s.skill ?? (s.skill = "acr"), !s.label) {
      const l = game.i18n.format("A5E.SkillCheck", {
        skill: game.i18n.localize(CONFIG.A5E.skills[s.skill])
      });
      e[n = s.skill] ?? (e[n] = 0), e[s.skill] += 1, s.defaultLabel = `${l} #${e[s.skill]}`;
    }
    return [t, s];
  }) : [];
}
u(eU, "prepareSkillChecks");
function tU(i) {
  const e = {}, t = Object.values(CONFIG.A5E.tools).reduce((s, n) => ({ ...s, ...n }), {});
  return i.length ? i.map(([s, n]) => {
    var l;
    if (n.tool ?? (n.tool = "airVehicles"), !n.label) {
      const r = game.i18n.format("A5E.ToolCheckSpecific", {
        tool: game.i18n.localize(t[n.tool])
      });
      e[l = n.tool] ?? (e[l] = 0), e[n.tool] += 1, n.defaultLabel = `${r} #${e[n.tool]}`;
    }
    return [s, n];
  }) : [];
}
u(tU, "prepareToolChecks");
const NO = {
  abilityCheck: YH,
  attack: XH,
  damage: JH,
  generic: ZH,
  healing: QH,
  savingThrow: xH,
  skillCheck: eU,
  toolCheck: tU
};
function sU(i, e) {
  const { rolls: t } = i.actions.get(e), s = Object.entries(t ?? {}).reduce(
    (n, [l, r]) => {
      var o;
      return n[o = r.type] ?? (n[o] = []), n[r.type].push([l, r]), n;
    },
    {}
  );
  return Object.entries(s).reduce(
    (n, [l, r]) => (typeof NO[l] == "function" && (n[l] = NO[l](r) ?? []), n),
    {}
  );
}
u(sU, "prepareRolls$1");
function nU(i, e) {
  return [...i.actions.get(e).effects.map((n) => i.effects.get(n))].filter((n) => !!n);
}
u(nU, "prepareEffectPrompts");
var Us, Xi, Pa, Ma, Ji, wf, dt, a9, c9, u9, f9, d9, p9, rb, m9, h9, Pd, g9, b9, _9, Md, y9, v9, k9, w9, $9, A9, Mo, $f, ob;
const qo = class qo {
  constructor({
    actor: e,
    item: t,
    consumers: s,
    damageBonuses: n,
    healingBonuses: l,
    rolls: r
  }) {
    x(this, dt);
    x(this, Us);
    x(this, Xi);
    x(this, Pa);
    x(this, Ma);
    x(this, Ji);
    x(this, wf);
    Ae(this, Us, e), Ae(this, Xi, s), Ae(this, Pa, n), Ae(this, Ma, l), Ae(this, Ji, t), Ae(this, wf, r);
  }
  /** ****************************************************
   *  Preparation Methods
   **************************************************** */
  async prepareRolls() {
    const { attack: e, damage: t, healing: s, other: n } = P(this, wf).reduce(
      (c, f) => (f && f.type === "attack" ? c.attack = f : f && f.type === "damage" ? c.damage.push(f) : f && f.type === "healing" ? c.healing.push(f) : c.other.push(f), c),
      {
        attack: null,
        damage: [],
        healing: [],
        other: []
      }
    ), l = await X(this, dt, u9).call(this, e ?? {}), r = await Promise.all(
      t.map(async (c, f) => X(this, dt, rb).call(this, c, l, f))
    ), o = (await Promise.all(s.map(async (c) => X(this, dt, Pd).call(this, c)))).filter(Boolean);
    if (r.length) {
      const c = await X(this, dt, f9).call(this, l);
      r.push(...c);
    }
    if (o.some(({ healingType: c }) => c === "healing" || !c)) {
      const c = (await X(this, dt, d9).call(this)).filter(
        Boolean
      );
      o.push(...c);
    }
    if (o.some(({ healingType: c }) => c === "temporaryHealing")) {
      const c = (await X(this, dt, p9).call(this)).filter(
        Boolean
      );
      o.push(...c);
    }
    const a = await Promise.all(n.map(async (c) => X(this, dt, a9).call(this, c)));
    return [l, ...r, ...o, ...a].filter(Boolean);
  }
  /** ****************************************************
   *  Static Methods
   **************************************************** */
  static prepareAttackRollData(e, t, s, n = {}) {
    const { attackType: l } = s, r = e.BonusesManager.prepareAttackBonuses(t, l), o = qH(e, t, s), a = e.RollOverrideManager.getExpertiseDice(
      `attackTypes.${l}`,
      n.expertiseDie ?? 0
    ), c = e.RollOverrideManager.getExpertiseDiceSource(
      `attackTypes.${l}`,
      n.expertiseDie ?? 0
    ), f = e.RollOverrideManager.getRollOverride(
      `attackTypes.${l}`,
      n.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL
    ), d = e.RollOverrideManager.getRollOverridesSource(
      `attackTypes.${l}`,
      n.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL
    ), p = e.BonusesManager.getDefaultSelections("attacks", {
      item: t,
      attackType: l
    }), m = ll(e, {
      ability: o,
      attackBonus: s == null ? void 0 : s.bonus,
      attackType: s == null ? void 0 : s.attackType,
      expertiseDie: a,
      item: t,
      proficient: (s == null ? void 0 : s.proficient) ?? !0,
      rollMode: f,
      situationalMods: n.situationalMods,
      selectedAttackBonuses: p,
      type: "attack"
    });
    return {
      attackBonuses: r,
      attackAbility: o,
      expertiseDie: a,
      expertiseDieSource: c,
      formula: m,
      rollMode: f,
      rollModeSource: d,
      selectedAttackBonuses: p
    };
  }
  static prepareOtherRollData(e) {
    var n;
    const t = X(n = qo, $f, ob).call(n, e), s = Object.entries(e).reduce(
      (l, [r, o]) => (r === "attack" || (l[r] = o), l),
      {}
    );
    return {
      invalidSelections: t,
      otherRolls: s
    };
  }
  static getSelectedRolls(e, t, s) {
    const n = e.actions.get(t), l = Object.entries(n.rolls ?? {});
    return Object.values(n.rolls ?? {}), l.reduce(
      (r, [o, a]) => (s.includes(o) && a.type !== "attack" && r.push(a), r),
      []
    );
  }
  static preparePromptsData(e) {
    var s;
    return {
      invalidSelections: X(s = qo, $f, ob).call(s, e)
    };
  }
  static getSelectedPrompts(e, t, s, n) {
    const l = t.actions.get(s), r = Object.entries(l.prompts ?? {});
    return Object.values(l.prompts ?? {}), r.reduce(
      (o, [a, c]) => (c = foundry.utils.duplicate(c), n.includes(a) && (c.type === "savingThrow" && (c.dc = R5(e, t, c.saveDC)), o.push(c)), o),
      []
    );
  }
  static getSelectedBonuses(e, t, s) {
    return Object.entries(e.system.bonuses[t]).reduce((l, [r, o]) => (s.includes(r) && l.push(o), l), []);
  }
  static getDefaultSelectedEffects(e) {
    return e.reduce((t, s) => (s.system.default && t.push(s.id), t), []);
  }
  /** ******************************************* */
  static prepareConsumers(e, t) {
    return zH(e, t);
  }
  static prepareEffects(e, t) {
    return nU(e, t);
  }
  static preparePrompts(e, t) {
    return KH(e, t);
  }
  static prepareRolls(e, t) {
    return sU(e, t);
  }
};
Us = new WeakMap(), Xi = new WeakMap(), Pa = new WeakMap(), Ma = new WeakMap(), Ji = new WeakMap(), wf = new WeakMap(), dt = new WeakSet(), a9 = /* @__PURE__ */ u(function(e) {
  switch (e == null ? void 0 : e.type) {
    case "abilityCheck":
      return X(this, dt, c9).call(this, e);
    case "generic":
      return X(this, dt, h9).call(this, e);
    case "savingThrow":
      return X(this, dt, g9).call(this, e);
    case "skillCheck":
      return X(this, dt, b9).call(this, e);
    case "toolCheck":
      return X(this, dt, _9).call(this, e);
    default:
      return null;
  }
}, "#prepareItemRoll"), c9 = /* @__PURE__ */ u(async function(e) {
  const t = P(this, Us).getDefaultAbilityCheckData(e.ability, {
    situationalMods: e.bonus
  }), s = e.rollFormula ?? t.rollFormula;
  if (!s) return null;
  const n = K(CONFIG.A5E.abilities[(e == null ? void 0 : e.ability) ?? ""]), l = await new Roll(s).evaluate(), r = K("A5E.AbilityCheckSpecific", { ability: n });
  return {
    expertiseDice: e.expertiseDie ?? t.expertiseDie,
    label: r,
    userLabel: e.label,
    roll: l,
    rollMode: e.rollMode ?? t.rollMode,
    type: "abilityCheck"
  };
}, "#prepareAbilityCheckRoll"), u9 = /* @__PURE__ */ u(async function(e) {
  const { rollFormula: t } = Gc({
    actor: P(this, Us),
    formula: e.formula,
    item: P(this, Ji)
  });
  if (!t) return null;
  const s = e.critThreshold ?? 20, n = await new Roll(t).evaluate(), l = K(CONFIG.A5E.attackTypes[(e == null ? void 0 : e.attackType) ?? "meleeWeaponAttack"]), r = (n.dice[0].total ?? 0) >= s;
  return {
    attackType: e.attackType,
    critThreshold: s,
    expertiseDice: e.expertiseDie,
    isCrit: r,
    label: l,
    roll: n,
    rollMode: e.rollMode,
    type: "attack"
  };
}, "#prepareAttackRoll"), f9 = /* @__PURE__ */ u(async function(e) {
  const t = Object.values(P(this, Pa)).filter(
    ({ damageType: s }) => s && s !== "null"
  );
  return Promise.all(
    t.map(
      ({ label: s, formula: n, damageType: l, context: r }) => X(this, dt, rb).call(this, {
        label: s,
        formula: n,
        canCrit: !0,
        critBonus: "",
        damageType: l,
        context: r
      }, e)
    )
  );
}, "#prepareBonusDamageRolls"), d9 = /* @__PURE__ */ u(async function() {
  const e = Object.values(P(this, Ma)).filter(
    ({ healingType: t }) => t === "healing" || !t
  );
  return Promise.all(
    e.map(
      ({ label: t, formula: s, healingType: n }) => X(this, dt, Pd).call(this, {
        label: t || "Bonus Healing",
        formula: s,
        healingType: n || "healing"
      })
    )
  );
}, "#prepareBonusHealingRolls"), p9 = /* @__PURE__ */ u(async function() {
  const e = Object.values(P(this, Ma)).filter(
    ({ healingType: t }) => t === "temporaryHealing"
  );
  return Promise.all(
    e.map(
      ({ label: t, formula: s, healingType: n }) => X(this, dt, Pd).call(this, {
        label: t || "Bonus Temporary Healing",
        formula: s,
        healingType: n
      })
    )
  );
}, "#prepareBonusTemporaryHealingRolls"), rb = /* @__PURE__ */ u(async function(e, t, s) {
  const { isCrit: n } = t ?? {}, { canCrit: l, critBonus: r, damageType: o } = e ?? {}, a = [], c = [], { context: f } = e;
  let d = "";
  s === 0 && (X(this, dt, m9).call(this).forEach((k) => {
    var S;
    (S = k.context) != null && S.isCritBonus ? a.push(k.formula) : c.push({ value: k.formula, label: k.label });
  }), a.length && (d = a.join(" + ")));
  const { rollFormula: p } = Gc({
    actor: P(this, Us),
    formula: X(this, dt, Md).call(this, e),
    item: P(this, Ji),
    modifiers: c
  });
  if (!p) return null;
  const m = await new Roll(p).evaluate();
  let g = Roll.fromTerms(Id(m.terms)), h = g, _ = g;
  if (l ?? !0)
    if (f != null && f.isCritBonus)
      _ = h, g = await new Roll("0").evaluate(), h = g;
    else {
      let v = r || "";
      v += d ? ` + ${d}` : "", _ = await jH(h, v);
    }
  n && (h = _);
  const y = o ? K("A5E.DamageSpecific", { damageType: K(CONFIG.A5E.damageTypes[o]) }) : K("A5E.Damage");
  return {
    baseRoll: g,
    canCrit: l ?? !0,
    critRoll: _,
    damageType: o,
    label: y,
    userLabel: e.label,
    roll: h,
    type: "damage"
  };
}, "#prepareDamageRoll"), /**
 * Prepares the damage bonuses without any damage type. These are folded into the first
 * damage roll for the action.
 */
m9 = /* @__PURE__ */ u(function() {
  return Object.values(P(this, Pa)).filter(
    ({ damageType: t }) => !t || t === "null"
  ).map(({ formula: t, context: s, label: n }) => ({ formula: t, context: s, label: n }));
}, "#prepareGenericBonusDamage"), h9 = /* @__PURE__ */ u(async function(e) {
  const { rollFormula: t } = Gc({
    actor: P(this, Us),
    formula: X(this, dt, Md).call(this, e),
    item: P(this, Ji)
  });
  if (!t) return null;
  const s = await new Roll(t).evaluate(), n = Roll.fromTerms(Id(s.terms));
  return {
    label: e.label || K("A5E.GenericRoll"),
    roll: n,
    type: "generic"
  };
}, "#prepareGenericRoll"), Pd = /* @__PURE__ */ u(async function(e) {
  const { rollFormula: t } = Gc({
    actor: P(this, Us),
    formula: X(this, dt, Md).call(this, e),
    item: P(this, Ji)
  });
  if (!t) return null;
  const s = await new Roll(t).evaluate(), n = Roll.fromTerms(Id(s.terms)), l = CONFIG.A5E.healingTypes[e.healingType ?? "healing"];
  return {
    label: K(l),
    userLabel: e.label,
    healingType: e.healingType,
    roll: n,
    type: "healing"
  };
}, "#prepareHealingRoll"), g9 = /* @__PURE__ */ u(async function(e) {
  const t = P(this, Us).getDefaultSavingThrowData(e.ability, {
    situationalMods: e.bonus
  }), s = e.rollFormula ?? t.rollFormula;
  if (!s) return null;
  const n = K(CONFIG.A5E.abilities[(e == null ? void 0 : e.ability) ?? ""]), l = await new Roll(s).evaluate();
  let r;
  return e.saveType === "concentration" ? r = K("A5E.ConcentrationCheck") : e.saveType === "death" ? r = K("A5E.DeathSavingThrow") : r = K("A5E.SavingThrowSpecific", { ability: n }), {
    expertiseDice: e.expertiseDie ?? t.expertiseDie,
    label: r,
    userLabel: e.label,
    roll: l,
    rollMode: e.rollMode ?? t.rollMode,
    saveType: e.saveType,
    type: "savingThrow"
  };
}, "#prepareSavingThrowRoll"), b9 = /* @__PURE__ */ u(async function(e) {
  const t = K(CONFIG.A5E.skills[e == null ? void 0 : e.skill]), s = P(this, Us).getDefaultSkillCheckData(e.skill, {
    abilityKey: e.ability,
    situationalMods: e.bonus
  }), n = e.ability ?? s.abilityKey, l = e.rollFormula ?? s.rollFormula;
  if (!l) return null;
  const r = await new Roll(l).evaluate(), o = n && n !== "none" ? K("A5E.SkillCheckAbility", {
    skill: t,
    ability: CONFIG.A5E.abilityAbbreviations[n]
  }) : K("A5E.SkillCheck", { skill: t });
  return {
    expertiseDice: e.expertiseDie ?? s.expertiseDie,
    label: o,
    userLabel: e.label,
    roll: r,
    rollMode: e.rollMode ?? s.rollMode,
    skillKey: e == null ? void 0 : e.skill,
    type: "skillCheck"
  };
}, "#prepareSkillCheckRoll"), _9 = /* @__PURE__ */ u(async function(e) {
  var c, f, d;
  const t = e.ability === "none" ? null : e.ability, s = (f = (c = P(this, Us).system.proficiencies) == null ? void 0 : c.tools) == null ? void 0 : f.includes(e.tool), n = [], l = Object.values(CONFIG.A5E.tools).reduce((p, m) => ({ ...p, ...m }), {}), r = K("A5E.ToolCheckSpecific", { tool: K(l[e == null ? void 0 : e.tool] ?? "") });
  t && n.push({
    label: K("A5E.AbilityCheckMod", {
      ability: K(CONFIG.A5E.abilities[t])
    }),
    value: (d = P(this, Us).system.abilities[t]) == null ? void 0 : d.check.mod
  }), s && n.push({
    label: K("A5E.Proficiency"),
    // @ts-expect-error
    value: P(this, Us).system.attributes.prof
  }), n.push({
    label: K("A5E.AbilityCheckBonusGlobal"),
    value: P(this, Us).BonusesManager.getGlobalAbilityBonusesFormula("check")
  }), n.push({
    value: e.bonus
  });
  const { rollFormula: o } = F5({
    actor: P(this, Us),
    item: P(this, Ji),
    modifiers: n
  });
  if (!o) return null;
  const a = await new Roll(o).evaluate();
  return {
    label: r,
    userLabel: e.label,
    roll: a,
    type: "toolCheck"
  };
}, "#prepareToolCheckRoll"), /** ****************************************************
 *  Scaling Adjustment Methods
 **************************************************** */
Md = /* @__PURE__ */ u(function(e) {
  var s;
  const t = (s = e.scaling) == null ? void 0 : s.mode;
  return t ? t === "cantrip" ? X(this, dt, y9).call(this, e) : t === "spellLevel" ? X(this, dt, v9).call(this, e) : t === "spellPoints" ? X(this, dt, k9).call(this, e) : t === "actionUses" ? X(this, dt, $9).call(this, e) : t === "itemUses" ? X(this, dt, A9).call(this, e) : t === "artifactCharges" ? X(this, dt, w9).call(this, e) : e.formula ?? 0 : (e == null ? void 0 : e.formula) ?? 0;
}, "#applyScaling"), y9 = /* @__PURE__ */ u(function(e) {
  var o, a, c;
  const t = P(this, Us).system, s = (
    // @ts-expect-error
    ((a = (o = P(this, Us)) == null ? void 0 : o.levels) == null ? void 0 : a.character) ?? // @ts-expect-error
    t.details.level ?? // @ts-expect-error
    t.attributes.casterLevel
  ), n = e.formula;
  if (s < 5) return n;
  const l = new Roll(((c = e.scaling) == null ? void 0 : c.formula) ?? 0);
  let r = 0;
  return s >= 17 ? r = 3 : s >= 11 ? r = 2 : s >= 5 && (r = 1), [n, l.alter(r, 0, { multiplyNumeric: !0 }).formula].join(
    "+"
  );
}, "#applyCantripScaling"), v9 = /* @__PURE__ */ u(function(e) {
  var l, r;
  const t = ((l = P(this, Xi).spell) == null ? void 0 : l.baseLevel) ?? P(this, Ji).system.level ?? 1, n = (((r = P(this, Xi).spell) == null ? void 0 : r.level) ?? t) - t;
  return X(this, dt, Mo).call(this, e, n);
}, "#applySpellLevelScaling"), k9 = /* @__PURE__ */ u(function(e) {
  const t = P(this, Xi).spell;
  if (foundry.utils.isEmpty(t)) return e.formula;
  const s = (t == null ? void 0 : t.basePoints) || 1;
  if (s >= t.points) return e.formula;
  const n = Math.max(0, t.points - s);
  return X(this, dt, Mo).call(this, e, n);
}, "#applySpellPointScaling"), w9 = /* @__PURE__ */ u(function(e) {
  const t = P(this, Xi).spell;
  if (foundry.utils.isEmpty(t)) return e.formula;
  const s = (t == null ? void 0 : t.baseCharges) || 1;
  if (s >= t.charges) return e.formula;
  const n = Math.max(0, t.charges - s);
  return X(this, dt, Mo).call(this, e, n);
}, "#applyArtifactChargesScaling"), $9 = /* @__PURE__ */ u(function(e) {
  const t = P(this, Xi).actionUses;
  if (foundry.utils.isEmpty(t)) return e.formula;
  const s = t.baseUses;
  if (s >= t.quantity) return e.formula;
  const n = t.quantity - s;
  return X(this, dt, Mo).call(this, e, n);
}, "#applyActionUsesScaling"), A9 = /* @__PURE__ */ u(function(e) {
  const t = P(this, Xi).itemUses;
  if (foundry.utils.isEmpty(t)) return e.formula;
  const s = t.baseUses;
  if (s >= t.quantity) return e.formula;
  const n = t.quantity - s;
  return X(this, dt, Mo).call(this, e, n);
}, "#applyItemUsesScaling"), Mo = /* @__PURE__ */ u(function(e, t) {
  var o, a;
  const s = e.formula;
  if (!t) return s;
  const n = new Roll(((o = e.scaling) == null ? void 0 : o.formula) ?? 0), l = ((a = e.scaling) == null ? void 0 : a.step) || 1, r = Math.floor(t / l);
  return r === 0 ? s : [s, n.alter(r, 0, { multiplyNumeric: !0 }).formula].join(
    "+"
  );
}, "#applyResourceBasedScaling"), $f = new WeakSet(), ob = /* @__PURE__ */ u(function(e) {
  return Object.values(e).flat().reduce((t, [s, n]) => (["generic", "healing", "damage"].includes(n.type) && !n.formula && t.push(s), t), []);
}, "#getInvalidSelections"), x(qo, $f), u(qo, "RollPreparationManager");
let ns = qo;
function te(i, e, t) {
  i.update({ [e]: t });
}
u(te, "updateDocumentDataFromField");
function iU(i) {
  let e, t, s, n, l = K(
    /*label*/
    i[1]
  ) + "", r, o, a;
  return {
    c() {
      e = E("div"), t = E("input"), s = F(), n = E("label"), r = Q(l), b(t, "class", "checkbox svelte-uw08p1"), b(t, "type", "checkbox"), t.disabled = /*disabled*/
      i[2], b(
        t,
        "id",
        /*id*/
        i[3]
      ), t.checked = /*checked*/
      i[0], b(n, "class", "label svelte-uw08p1"), b(
        n,
        "for",
        /*id*/
        i[3]
      ), b(e, "class", "checkbox-wrapper svelte-uw08p1");
    },
    m(c, f) {
      T(c, e, f), A(e, t), A(e, s), A(e, n), A(n, r), o || (a = W(
        t,
        "change",
        /*change_handler*/
        i[5]
      ), o = !0);
    },
    p(c, [f]) {
      f & /*disabled*/
      4 && (t.disabled = /*disabled*/
      c[2]), f & /*checked*/
      1 && (t.checked = /*checked*/
      c[0]), f & /*label*/
      2 && l !== (l = K(
        /*label*/
        c[1]
      ) + "") && be(r, l);
    },
    i: se,
    o: se,
    d(c) {
      c && C(e), o = !1, a();
    }
  };
}
u(iU, "create_fragment$4v");
function lU(i, e, t) {
  let { checked: s } = e, { label: n } = e, { disabled: l = !1 } = e;
  const r = foundry.utils.randomID(), o = ft(), a = /* @__PURE__ */ u(({ target: c }) => o("updateSelection", c.checked), "change_handler");
  return i.$$set = (c) => {
    "checked" in c && t(0, s = c.checked), "label" in c && t(1, n = c.label), "disabled" in c && t(2, l = c.disabled);
  }, [s, n, l, r, o, a];
}
u(lU, "instance$4m");
const r$ = class r$ extends re {
  constructor(e) {
    super(), oe(this, e, lU, iU, le, { checked: 0, label: 1, disabled: 2 });
  }
};
u(r$, "Checkbox");
let Te = r$;
function rU(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*abilityBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*abilityBonus*/
      1 && t !== (t = /*abilityBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(rU, "create_default_slot_4$u");
function oU(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [rU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, abilityBonus*/
      4194305 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(oU, "create_default_slot_3$P");
function aU(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.contexts.requiresProficiency",
      checked: (
        /*requiresProficiency*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[18]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*requiresProficiency*/
      2 && (l.checked = /*requiresProficiency*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(aU, "create_default_slot_2$18");
function cU(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Select Ability Bonus Automatically in Roll Prompt",
      checked: (
        /*abilityBonus*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[19]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*abilityBonus*/
      1 && (l.checked = /*abilityBonus*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(cU, "create_default_slot_1$1w");
function uU(i) {
  let e, t, s, n, l, r, o, a;
  return e = new tt({
    props: {
      heading: "A5E.contexts.abilities",
      options: Object.entries(
        /*abilities*/
        i[7]
      ),
      selected: (
        /*abilitiesContext*/
        i[3]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  ), s = new tt({
    props: {
      heading: "A5E.contexts.bonusTypes",
      options: Object.entries(
        /*abilityBonusContexts*/
        i[8]
      ),
      selected: (
        /*abilityTypeContext*/
        i[2]
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), l = new ie({
    props: {
      $$slots: { default: [aU] },
      $$scope: { ctx: i }
    }
  }), o = new ie({
    props: {
      $$slots: { default: [cU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment);
    },
    m(c, f) {
      R(e, c, f), T(c, t, f), R(s, c, f), T(c, n, f), R(l, c, f), T(c, r, f), R(o, c, f), a = !0;
    },
    p(c, f) {
      const d = {};
      f & /*abilitiesContext*/
      8 && (d.selected = /*abilitiesContext*/
      c[3]), e.$set(d);
      const p = {};
      f & /*abilityTypeContext*/
      4 && (p.selected = /*abilityTypeContext*/
      c[2]), s.$set(p);
      const m = {};
      f & /*$$scope, requiresProficiency*/
      4194306 && (m.$$scope = { dirty: f, ctx: c }), l.$set(m);
      const g = {};
      f & /*$$scope, abilityBonus*/
      4194305 && (g.$$scope = { dirty: f, ctx: c }), o.$set(g);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(s.$$.fragment, c), w(l.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      O(e.$$.fragment, c), O(s.$$.fragment, c), O(l.$$.fragment, c), O(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (C(t), C(n), C(r)), N(e, c), N(s, c), N(l, c), N(o, c);
    }
  };
}
u(uU, "create_default_slot$2w");
function fU(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v;
  return d = new De({
    props: {
      $$slots: { default: [oU] },
      $$scope: { ctx: i }
    }
  }), g = new De({
    props: {
      heading: "Contexts",
      hint: "The context determines when the ability bonus applies",
      $$slots: { default: [uU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), h = E("div"), j(g.$$.fragment), b(s, "class", "bonus-image svelte-1lr65k0"), ze(s.src, n = /*abilityBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*abilityBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*abilityBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1lr65k0"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1lr65k0"), b(t, "class", "sheet-header svelte-1lr65k0"), G(p, "display", "contents"), G(p, "--a5e-section-margin", "0.25rem 0"), G(h, "display", "contents"), G(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1lr65k0");
    },
    m(k, S) {
      T(k, e, S), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), A(e, h), R(g, h, null), _ = !0, y || (v = [
        W(
          s,
          "click",
          /*click_handler*/
          i[13]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[14]
        )
      ], y = !0);
    },
    p(k, [S]) {
      (!_ || S & /*abilityBonus*/
      1 && !ze(s.src, n = /*abilityBonus*/
      k[0].img)) && b(s, "src", n), (!_ || S & /*abilityBonus*/
      1 && l !== (l = /*abilityBonus*/
      k[0].label)) && b(s, "alt", l), (!_ || S & /*abilityBonus*/
      1 && c !== (c = /*abilityBonus*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const D = {};
      S & /*$$scope, abilityBonus*/
      4194305 && (D.$$scope = { dirty: S, ctx: k }), d.$set(D);
      const I = {};
      S & /*$$scope, abilityBonus, requiresProficiency, abilityTypeContext, abilitiesContext*/
      4194319 && (I.$$scope = { dirty: S, ctx: k }), g.$set(I);
    },
    i(k) {
      _ || (w(d.$$.fragment, k), w(g.$$.fragment, k), _ = !0);
    },
    o(k) {
      O(d.$$.fragment, k), O(g.$$.fragment, k), _ = !1;
    },
    d(k) {
      k && C(e), N(d), N(g), y = !1, Me(v);
    }
  };
}
u(fU, "create_fragment$4u");
function dU(i, e, t) {
  let s, n, l, r, o, { document: a, bonusID: c } = de("#external").application, { document: f = a, bonusID: d = c } = e, { jsonValue: p = null } = e;
  const m = f;
  pe(i, m, (q) => t(12, o = q));
  const g = ft();
  function h() {
    const q = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: q,
      callback: /* @__PURE__ */ u((H) => {
        _("img", H);
      }, "callback")
    }).browse();
  }
  u(h, "updateImage");
  function _(q, U) {
    if (p === null) {
      q = `system.bonuses.abilities.${d}.${q}`, te(o, q, U);
      return;
    }
    const H = foundry.utils.expandObject({ ...s, [q]: U });
    g("change", JSON.stringify(H));
  }
  u(_, "onUpdateValue");
  function y() {
    if (p === null) return o.system.bonuses.abilities[d];
    try {
      const q = JSON.parse(p || '""') ?? {};
      if (typeof q != "object") throw new Error();
      return q.label = q.label ?? "", q.formula = q.formula ?? "", q.context = q.context ?? {
        abilities: [],
        types: [],
        requiresProficiency: !1
      }, q.default = q.default ?? !0, q.img = q.img || "icons/svg/upgrade.svg", q;
    } catch {
      return {
        label: "",
        formula: "",
        damageType: "",
        context: {
          abilities: [],
          types: [],
          requiresProficiency: !1
        },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  u(y, "getAbilityBonus");
  const { abilities: v, abilityBonusContexts: k } = CONFIG.A5E, S = /* @__PURE__ */ u(() => h(), "click_handler"), D = /* @__PURE__ */ u(({ target: q }) => _("label", q.value), "change_handler"), I = /* @__PURE__ */ u(({ target: q }) => _("formula", q.value), "change_handler_1"), M = /* @__PURE__ */ u(({ detail: q }) => {
    _("context.abilities", q);
  }, "updateSelection_handler"), L = /* @__PURE__ */ u(({ detail: q }) => {
    _("context.types", q);
  }, "updateSelection_handler_1"), B = /* @__PURE__ */ u(({ detail: q }) => {
    _("context.requiresProficiency", q);
  }, "updateSelection_handler_2"), z = /* @__PURE__ */ u(({ detail: q }) => {
    _("default", q);
  }, "updateSelection_handler_3");
  return i.$$set = (q) => {
    "document" in q && t(9, f = q.document), "bonusID" in q && t(10, d = q.bonusID), "jsonValue" in q && t(11, p = q.jsonValue);
  }, i.$$.update = () => {
    var q, U, H;
    i.$$.dirty & /*$actor, jsonValue*/
    6144 && t(0, s = y() ?? {}), i.$$.dirty & /*abilityBonus*/
    1 && t(3, n = ((q = s.context) == null ? void 0 : q.abilities) ?? []), i.$$.dirty & /*abilityBonus*/
    1 && t(2, l = ((U = s.context) == null ? void 0 : U.types) ?? []), i.$$.dirty & /*abilityBonus*/
    1 && t(1, r = ((H = s.context) == null ? void 0 : H.requiresProficiency) ?? !1);
  }, [
    s,
    r,
    l,
    n,
    m,
    h,
    _,
    v,
    k,
    f,
    d,
    p,
    o,
    S,
    D,
    I,
    M,
    L,
    B,
    z
  ];
}
u(dU, "instance$4l");
const o$ = class o$ extends re {
  constructor(e) {
    super(), oe(this, e, dU, fU, le, { document: 9, bonusID: 10, jsonValue: 11 });
  }
};
u(o$, "AbilityBonusConfigDialog");
let up = o$;
function E9(i = "character") {
  const e = [
    [0, game.i18n.localize("A5E.None")],
    [1, "d4"],
    [2, "d6"],
    [3, "d8"],
    [4, "d10"],
    [5, "d12"]
  ];
  return i !== "character" && e.push([6, "d20"]), e;
}
u(E9, "prepareExpertiseDiceOptions");
function pU(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "A5E.ExpertiseDie",
      buttons: (
        /*buttons*/
        i[1]
      ),
      options: (
        /*options*/
        i[2]
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      allowDeselect: !1,
      optionStyles: "min-width: 1.75rem; text-align: center;"
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*buttons*/
      2 && (l.buttons = /*buttons*/
      s[1]), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(pU, "create_if_block$2p");
function mU(i) {
  let e, t, s = !/*hideExpertiseDice*/
  i[3] && pU(i);
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, [l]) {
      /*hideExpertiseDice*/
      n[3] || s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(mU, "create_fragment$4t");
function hU(i, e, t) {
  let s, { type: n = "character" } = e, { selected: l } = e, { source: r = "" } = e;
  const o = E9(n), a = game.settings.get("a5e", "hideExpertiseDice");
  function c(f) {
    bt.call(this, i, f);
  }
  return u(c, "updateSelection_handler"), i.$$set = (f) => {
    "type" in f && t(4, n = f.type), "selected" in f && t(0, l = f.selected), "source" in f && t(5, r = f.source);
  }, i.$$.update = () => {
    i.$$.dirty & /*source*/
    32 && t(1, s = r.length ? [
      {
        classes: "fas fa-question-circle",
        tooltip: r
      }
    ] : []);
  }, [
    l,
    s,
    o,
    a,
    n,
    r,
    c
  ];
}
u(hU, "instance$4k");
const a$ = class a$ extends re {
  constructor(e) {
    super(), oe(this, e, hU, mU, le, { type: 4, selected: 0, source: 5 });
  }
};
u(a$, "ExpertiseDiePicker");
let hi = a$;
function gU(i) {
  let e, t;
  return e = new De({
    props: {
      heading: "Ability Check Configuration",
      $$slots: { default: [bU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $actor, abilityKey*/
      2051 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(gU, "create_if_block_2$10");
function bU(i) {
  var s, n;
  let e, t;
  return e = new hi({
    props: {
      selected: (
        /*$actor*/
        (n = (s = i[1]._source.system.abilities[
          /*abilityKey*/
          i[0]
        ]) == null ? void 0 : s.check) == null ? void 0 : n.expertiseDice
      ),
      type: (
        /*$actor*/
        i[1].type
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), t = !0;
    },
    p(l, r) {
      var a, c;
      const o = {};
      r & /*$actor, abilityKey*/
      3 && (o.selected = /*$actor*/
      (c = (a = l[1]._source.system.abilities[
        /*abilityKey*/
        l[0]
      ]) == null ? void 0 : a.check) == null ? void 0 : c.expertiseDice), r & /*$actor*/
      2 && (o.type = /*$actor*/
      l[1].type), e.$set(o);
    },
    i(l) {
      t || (w(e.$$.fragment, l), t = !0);
    },
    o(l) {
      O(e.$$.fragment, l), t = !1;
    },
    d(l) {
      N(e, l);
    }
  };
}
u(bU, "create_default_slot_3$O");
function _U(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.ProficiencyProficient",
      checked: (
        /*ability*/
        i[2].save.proficient
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*ability*/
      4 && (l.checked = /*ability*/
      s[2].save.proficient), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(_U, "create_default_slot_2$17");
function yU(i) {
  var s, n;
  let e, t;
  return e = new hi({
    props: {
      selected: (
        /*$actor*/
        (n = (s = i[1]._source.system.abilities[
          /*abilityKey*/
          i[0]
        ]) == null ? void 0 : s.save) == null ? void 0 : n.expertiseDice
      ),
      type: (
        /*$actor*/
        i[1].type
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[9]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), t = !0;
    },
    p(l, r) {
      var a, c;
      const o = {};
      r & /*$actor, abilityKey*/
      3 && (o.selected = /*$actor*/
      (c = (a = l[1]._source.system.abilities[
        /*abilityKey*/
        l[0]
      ]) == null ? void 0 : a.save) == null ? void 0 : c.expertiseDice), r & /*$actor*/
      2 && (o.type = /*$actor*/
      l[1].type), e.$set(o);
    },
    i(l) {
      t || (w(e.$$.fragment, l), t = !0);
    },
    o(l) {
      O(e.$$.fragment, l), t = !1;
    },
    d(l) {
      N(e, l);
    }
  };
}
u(yU, "create_if_block_1$1x");
function jO(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.ConcentrationCheckBonus",
      hint: "This field accepts any values valid in roll formulae.",
      $$slots: { default: [vU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, ability, $actor*/
      2054 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(jO, "create_if_block$2o");
function vU(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), e.value = t = /*ability*/
      ((l = i[2].save) == null ? void 0 : l.concentrationBonus) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*ability*/
      4 && t !== (t = /*ability*/
      ((o = l[2].save) == null ? void 0 : o.concentrationBonus) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(vU, "create_default_slot_1$1v");
function kU(i) {
  let e, t, s, n, l;
  e = new ie({
    props: {
      hint: "Determines whether to add this actor's proficiency bonus to its saving throws",
      $$slots: { default: [_U] },
      $$scope: { ctx: i }
    }
  });
  let r = !/*hideExpertiseDice*/
  i[4] && yU(i), o = (
    /*abilityKey*/
    i[0] === "con" && jO(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), r && r.c(), s = F(), o && o.c(), n = $e();
    },
    m(a, c) {
      R(e, a, c), T(a, t, c), r && r.m(a, c), T(a, s, c), o && o.m(a, c), T(a, n, c), l = !0;
    },
    p(a, c) {
      const f = {};
      c & /*$$scope, ability, $actor, abilityKey*/
      2055 && (f.$$scope = { dirty: c, ctx: a }), e.$set(f), /*hideExpertiseDice*/
      a[4] || r.p(a, c), /*abilityKey*/
      a[0] === "con" ? o ? (o.p(a, c), c & /*abilityKey*/
      1 && w(o, 1)) : (o = jO(a), o.c(), w(o, 1), o.m(n.parentNode, n)) : o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce());
    },
    i(a) {
      l || (w(e.$$.fragment, a), w(r), w(o), l = !0);
    },
    o(a) {
      O(e.$$.fragment, a), O(r), O(o), l = !1;
    },
    d(a) {
      a && (C(t), C(s), C(n)), N(e, a), r && r.d(a), o && o.d(a);
    }
  };
}
u(kU, "create_default_slot$2v");
function wU(i) {
  let e, t, s, n, l, r = !/*hideExpertiseDice*/
  i[4] && gU(i);
  return s = new De({
    props: {
      heading: "Saving Throw Configuration",
      $$slots: { default: [kU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("article"), r && r.c(), t = F(), n = E("div"), j(s.$$.fragment), G(n, "display", "contents"), G(n, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-q1ziz4");
    },
    m(o, a) {
      T(o, e, a), r && r.m(e, null), A(e, t), A(e, n), R(s, n, null), l = !0;
    },
    p(o, [a]) {
      /*hideExpertiseDice*/
      o[4] || r.p(o, a);
      const c = {};
      a & /*$$scope, ability, $actor, abilityKey*/
      2055 && (c.$$scope = { dirty: a, ctx: o }), s.$set(c);
    },
    i(o) {
      l || (w(r), w(s.$$.fragment, o), l = !0);
    },
    o(o) {
      O(r), O(s.$$.fragment, o), l = !1;
    },
    d(o) {
      o && C(e), r && r.d(), N(s);
    }
  };
}
u(wU, "create_fragment$4s");
function $U(i, e, t) {
  let s, n, { document: l, appId: r, abilityKey: o } = de("#external").application, { document: a = l, appId: c = r, abilityKey: f = o } = e;
  const d = a;
  pe(i, d, (y) => t(1, n = y));
  const p = game.settings.get("a5e", "hideExpertiseDice"), m = /* @__PURE__ */ u(({ detail: y }) => te(n, `system.abilities.${f}.check.expertiseDice`, y), "updateSelection_handler"), g = /* @__PURE__ */ u(({ detail: y }) => {
    te(n, `system.abilities.${f}.save.proficient`, y);
  }, "updateSelection_handler_1"), h = /* @__PURE__ */ u(({ detail: y }) => te(n, `system.abilities.${f}.save.expertiseDice`, y), "updateSelection_handler_2"), _ = /* @__PURE__ */ u(({ target: y }) => te(n, "system.abilities.con.save.concentrationBonus", y.value), "change_handler");
  return i.$$set = (y) => {
    "document" in y && t(5, a = y.document), "appId" in y && t(6, c = y.appId), "abilityKey" in y && t(0, f = y.abilityKey);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, abilityKey*/
    3 && t(2, s = n.system.abilities[f]);
  }, [
    f,
    n,
    s,
    d,
    p,
    a,
    c,
    m,
    g,
    h,
    _
  ];
}
u($U, "instance$4j");
const c$ = class c$ extends re {
  constructor(e) {
    super(), oe(this, e, $U, wU, le, { document: 5, appId: 6, abilityKey: 0 });
  }
};
u(c$, "ActorAbilityConfigDialog");
let ab = c$;
function AU(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "Visibility Mode",
      options: Object.entries(
        /*rollModes*/
        i[1]
      ).map(
        /*func*/
        i[3]
      ),
      selected: (
        /*visibilityMode*/
        i[0]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*visibilityMode*/
      1 && (l.selected = /*visibilityMode*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(AU, "create_fragment$4r");
function EU(i, e, t) {
  const s = CONST.DICE_ROLL_MODES, { DICE_ROLL_MODES: n } = CONFIG.A5E;
  let { visibilityMode: l } = e;
  const r = /* @__PURE__ */ u(([a, c]) => [c, n[c]], "func"), o = /* @__PURE__ */ u(({ detail: a }) => t(0, l = a), "updateSelection_handler");
  return i.$$set = (a) => {
    "visibilityMode" in a && t(0, l = a.visibilityMode);
  }, [l, s, n, r, o];
}
u(EU, "instance$4i");
const u$ = class u$ extends re {
  constructor(e) {
    super(), oe(this, e, EU, AU, le, { visibilityMode: 0 });
  }
};
u(u$, "OutputVisibilitySection");
let cc = u$;
function SU(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "A5E.RollModeHeading",
      buttons: (
        /*buttons*/
        i[1]
      ),
      options: (
        /*options*/
        i[2]
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*buttons*/
      2 && (l.buttons = /*buttons*/
      s[1]), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(SU, "create_fragment$4q");
function CU(i, e, t) {
  let s, { selected: n } = e, { source: l } = e;
  const o = Object.entries(CONFIG.A5E.rollModes ?? {}).map(([c, f]) => [CONFIG.A5E.ROLL_MODE[c.toUpperCase()], K(f)]);
  function a(c) {
    bt.call(this, i, c);
  }
  return u(a, "updateSelection_handler"), i.$$set = (c) => {
    "selected" in c && t(0, n = c.selected), "source" in c && t(3, l = c.source);
  }, i.$$.update = () => {
    i.$$.dirty & /*source*/
    8 && t(1, s = l.length ? [
      {
        classes: "fas fa-question-circle",
        tooltip: l
      }
    ] : []);
  }, [n, s, o, l, a];
}
u(CU, "instance$4h");
const f$ = class f$ extends re {
  constructor(e) {
    super(), oe(this, e, CU, SU, le, { selected: 0, source: 3 });
  }
};
u(f$, "RollModePicker");
let vr = f$;
function TU(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Ability Bonuses",
      options: (
        /*abilityBonuses*/
        i[10].map(IU)
      ),
      selected: (
        /*selectedAbilityBonuses*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[21]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*selectedAbilityBonuses*/
      8 && (l.selected = /*selectedAbilityBonuses*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(TU, "create_if_block$2n");
function OU(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "id", t = /*$actor*/
      i[4].id + "-" + /*appId*/
      i[9] + "-situational-mod");
    },
    m(l, r) {
      T(l, e, r), He(
        e,
        /*situationalMods*/
        i[2]
      ), s || (n = W(
        e,
        "input",
        /*input_input_handler*/
        i[22]
      ), s = !0);
    },
    p(l, r) {
      r & /*$actor*/
      16 && t !== (t = /*$actor*/
      l[4].id + "-" + /*appId*/
      l[9] + "-situational-mod") && b(e, "id", t), r & /*situationalMods*/
      4 && e.value !== /*situationalMods*/
      l[2] && He(
        e,
        /*situationalMods*/
        l[2]
      );
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(OU, "create_default_slot$2u");
function DU(i) {
  let e, t, s, n, l, r, o, a, c = Object.values(
    /*abilityBonuses*/
    i[10]
  ).flat().length, f, d, p, m, g, h, _, y, v, k, S;
  function D(L) {
    i[18](L);
  }
  u(D, "outputvisibilitysection_visibilityMode_binding");
  let I = {};
  /*visibilityMode*/
  i[5] !== void 0 && (I.visibilityMode = /*visibilityMode*/
  i[5]), t = new cc({ props: I }), rt.push(() => Ot(t, "visibilityMode", D)), l = new vr({
    props: {
      selected: (
        /*rollMode*/
        i[1]
      ),
      source: (
        /*rollModeString*/
        i[13]
      )
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[19]
  ), o = new hi({
    props: {
      source: (
        /*expertiseDieSource*/
        i[12]
      ),
      selected: (
        /*expertiseDie*/
        i[0]
      ),
      type: (
        /*$actor*/
        i[4].type
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[20]
  );
  let M = c && TU(i);
  return d = new ie({
    props: {
      heading: "A5E.SituationalMods",
      $$slots: { default: [OU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), j(t.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), M && M.c(), f = F(), j(d.$$.fragment), p = F(), m = E("section"), g = Q(
        /*rollFormula*/
        i[6]
      ), h = F(), _ = E("section"), y = E("button"), y.textContent = `${/*buttonText*/
      i[11]}`, b(m, "class", "roll-formula-preview svelte-8gi69h"), b(e, "class", "svelte-8gi69h");
    },
    m(L, B) {
      T(L, e, B), R(t, e, null), A(e, n), R(l, e, null), A(e, r), R(o, e, null), A(e, a), M && M.m(e, null), A(e, f), R(d, e, null), A(e, p), A(e, m), A(m, g), A(e, h), A(e, _), A(_, y), v = !0, k || (S = W(y, "click", st(
        /*onSubmit*/
        i[7]
      )), k = !0);
    },
    p(L, [B]) {
      const z = {};
      !s && B & /*visibilityMode*/
      32 && (s = !0, z.visibilityMode = /*visibilityMode*/
      L[5], It(() => s = !1)), t.$set(z);
      const q = {};
      B & /*rollMode*/
      2 && (q.selected = /*rollMode*/
      L[1]), l.$set(q);
      const U = {};
      B & /*expertiseDie*/
      1 && (U.selected = /*expertiseDie*/
      L[0]), B & /*$actor*/
      16 && (U.type = /*$actor*/
      L[4].type), o.$set(U), c && M.p(L, B);
      const H = {};
      B & /*$$scope, $actor, situationalMods*/
      134217748 && (H.$$scope = { dirty: B, ctx: L }), d.$set(H), (!v || B & /*rollFormula*/
      64) && be(
        g,
        /*rollFormula*/
        L[6]
      );
    },
    i(L) {
      v || (w(t.$$.fragment, L), w(l.$$.fragment, L), w(o.$$.fragment, L), w(M), w(d.$$.fragment, L), v = !0);
    },
    o(L) {
      O(t.$$.fragment, L), O(l.$$.fragment, L), O(o.$$.fragment, L), O(M), O(d.$$.fragment, L), v = !1;
    },
    d(L) {
      L && C(e), N(t), N(l), N(o), M && M.d(), N(d), k = !1, S();
    }
  };
}
u(DU, "create_fragment$4p");
const IU = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel], "func$e");
function PU(i, e, t) {
  var ke;
  let s, n, { document: l, abilityKey: r, dialog: o, options: a } = de("#external").application, { document: c = l, abilityKey: f = r, dialog: d = o, options: p = a } = e;
  function m() {
    return v ? 0 : n.RollOverrideManager.getExpertiseDice(`system.abilities.${f}.check`, n.system.abilities[f].check.expertiseDice || p.expertiseDice || 0);
  }
  u(m, "getInitialExpertiseDieSelection");
  function g() {
    d.submit({
      expertiseDie: D,
      rollFormula: q,
      rollMode: L,
      visibilityMode: z
    });
  }
  u(g, "onSubmit");
  const h = new Zt(c);
  pe(i, h, (ee) => t(4, n = ee));
  const _ = d.id, y = n.BonusesManager.prepareAbilityBonuses(f, "check"), v = game.settings.get("a5e", "hideExpertiseDice"), k = K(CONFIG.A5E.abilities[f]), S = K("A5E.RollPromptAbilityCheck", { ability: k });
  let D = m(), I = p.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL, M = n.RollOverrideManager.getExpertiseDiceSource(`system.abilities.${f}.check`, p.expertiseDie ?? 0), L = n.RollOverrideManager.getRollOverride(`system.abilities.${f}.check`, I), B = (ke = n.RollOverrideManager) == null ? void 0 : ke.getRollOverridesSource(`system.abilities.${f}.check`, I), z = p.visibilityMode ?? game.settings.get("core", "rollMode"), q, U = p.situationalMods ?? "";
  function H(ee) {
    z = ee, t(5, z);
  }
  u(H, "outputvisibilitysection_visibilityMode_binding");
  const V = /* @__PURE__ */ u(({ detail: ee }) => t(1, L = ee), "updateSelection_handler"), Y = /* @__PURE__ */ u(({ detail: ee }) => t(0, D = ee), "updateSelection_handler_1"), J = /* @__PURE__ */ u(({ detail: ee }) => t(3, s = ee), "updateSelection_handler_2");
  function fe() {
    U = this.value, t(2, U);
  }
  return u(fe, "input_input_handler"), i.$$set = (ee) => {
    "document" in ee && t(14, c = ee.document), "abilityKey" in ee && t(15, f = ee.abilityKey), "dialog" in ee && t(16, d = ee.dialog), "options" in ee && t(17, p = ee.options);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, abilityKey*/
    32784 && t(3, s = n.BonusesManager.getDefaultSelections("abilities", { abilityKey: f, abilityType: "check" })), i.$$.dirty & /*$actor, abilityKey, expertiseDie, rollMode, situationalMods, selectedAbilityBonuses*/
    32799 && t(6, q = ll(n, {
      ability: f,
      expertiseDie: D,
      rollMode: L,
      situationalMods: U,
      selectedAbilityBonuses: s,
      type: "abilityCheck"
    }));
  }, [
    D,
    L,
    U,
    s,
    n,
    z,
    q,
    g,
    h,
    _,
    y,
    S,
    M,
    B,
    c,
    f,
    d,
    p,
    H,
    V,
    Y,
    J,
    fe
  ];
}
u(PU, "instance$4g");
const d$ = class d$ extends re {
  constructor(e) {
    super(), oe(this, e, PU, DU, le, {
      document: 14,
      abilityKey: 15,
      dialog: 16,
      options: 17
    });
  }
};
u(d$, "AbilityCheckRollDialog");
let cb = d$;
function N5(i) {
  const e = i.type, t = ["d6", "d8", "d10", "d12"];
  return e === "npc" && (t.unshift("d4"), t.push("d20")), t.map((s) => ({
    die: s,
    dieSize: s,
    current: i.system.attributes.hitDice[s].current,
    total: i.system.attributes.hitDice[s].total
  }));
}
u(N5, "prepareHitDice");
function LO(i, e, t) {
  const s = i.slice();
  return s[13] = e[t].dieSize, s[14] = e[t].current, s[15] = e[t].total, s;
}
u(LO, "get_each_context$1H");
function BO(i, e, t) {
  const s = i.slice();
  return s[18] = e[t].label, s[19] = e[t].updateAttribute, s;
}
u(BO, "get_each_context_1$o");
function qO(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: (
        /*label*/
        i[18]
      ),
      $$slots: { default: [MU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-direction", "row"), G(t, "--a5e-field-wrapper-background", "rgba(0, 0, 0, 0.05)"), G(t, "--a5e-field-wrapper-padding", "0.5rem"), G(t, "--a5e-field-wrapper-item-alignment", "center"), G(t, "--a5e-field-wrapper-label-width", "8rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, hp, $actor*/
      4194321 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(qO, "create_if_block$2m");
function MU(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "a5e-input"), b(t, "type", "number"), b(t, "data-dtype", "Number"), b(t, "name", "system.attributes.hp." + /*updateAttribute*/
      i[19]), t.value = s = /*hp*/
      i[4][
        /*updateAttribute*/
        i[19]
      ], b(e, "class", "u-w-20");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = W(
        t,
        "change",
        /*change_handler*/
        i[10]
      ), n = !0);
    },
    p(r, o) {
      o & /*hp*/
      16 && s !== (s = /*hp*/
      r[4][
        /*updateAttribute*/
        r[19]
      ]) && t.value !== s && (t.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(MU, "create_default_slot$2t");
function GO(i) {
  let e, t, s = (!/*disableMaxHp*/
  i[1] || /*updateAttribute*/
  i[19] !== "baseMax") && qO(i);
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      !/*disableMaxHp*/
      n[1] || /*updateAttribute*/
      n[19] !== "baseMax" ? s ? (s.p(n, l), l & /*disableMaxHp*/
      2 && w(s, 1)) : (s = qO(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(GO, "create_each_block_1$o");
function zO(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("span"), s.textContent = `${/*dieSize*/
      i[13]}`, n = F(), l = E("div"), r = E("input"), a = Q(`
                        /
                        `), c = E("input"), f = F(), b(s, "class", "a5e-hit-die__label"), b(t, "class", "a5e-hit-die"), b(r, "class", "a5e-hit-die__quantity"), b(r, "type", "number"), b(r, "data-dtype", "Number"), b(r, "min", "0"), b(r, "name", "system.attributes.hitDice." + /*dieSize*/
      i[13] + ".current"), r.disabled = /*disableHitDice*/
      i[3], b(r, "data-tooltip", o = /*disableHitDice*/
      i[3] ? "Update Hit Dice in class document.   " : ""), r.value = /*current*/
      i[14], b(c, "class", "a5e-hit-die__quantity"), b(c, "data-dtype", "Number"), b(c, "type", "number"), b(c, "min", "0"), b(c, "name", "system.attributes.hitDice." + /*dieSize*/
      i[13] + ".total"), c.disabled = /*disableHitDice*/
      i[3], c.value = /*total*/
      i[15], b(l, "class", "a5e-hit-die__input-container"), b(e, "class", "a5e-hit-die-wrapper");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, s), A(e, n), A(e, l), A(l, r), A(l, a), A(l, c), A(e, f), d || (p = [
        W(
          r,
          "change",
          /*change_handler_1*/
          i[11]
        ),
        W(
          c,
          "change",
          /*change_handler_2*/
          i[12]
        )
      ], d = !0);
    },
    p(m, g) {
      g & /*disableHitDice*/
      8 && (r.disabled = /*disableHitDice*/
      m[3]), g & /*disableHitDice*/
      8 && o !== (o = /*disableHitDice*/
      m[3] ? "Update Hit Dice in class document.   " : "") && b(r, "data-tooltip", o), g & /*disableHitDice*/
      8 && (c.disabled = /*disableHitDice*/
      m[3]);
    },
    d(m) {
      m && C(e), d = !1, Me(p);
    }
  };
}
u(zO, "create_each_block$1H");
function FU(i) {
  let e, t, s, n, l, r, o, a, c = ue(
    /*hpFields*/
    i[5]
  ), f = [];
  for (let g = 0; g < c.length; g += 1)
    f[g] = GO(BO(i, c, g));
  const d = /* @__PURE__ */ u((g) => O(f[g], 1, 1, () => {
    f[g] = null;
  }), "out");
  let p = ue(
    /*hitDice*/
    i[7]
  ), m = [];
  for (let g = 0; g < p.length; g += 1)
    m[g] = zO(LO(i, p, g));
  return {
    c() {
      e = E("article"), t = E("div");
      for (let g = 0; g < f.length; g += 1)
        f[g].c();
      s = F(), n = E("hr"), l = F(), r = E("section");
      for (let g = 0; g < m.length; g += 1)
        m[g].c();
      b(n, "class", "a5e-rule a5e-rule--from u-my-sm"), b(r, "class", o = `u-mt-0 ${/*hitDieClasses*/
      i[2]}`), b(t, "class", "u-flex u-flex-col u-gap-md"), b(e, "class", "svelte-1buetme");
    },
    m(g, h) {
      T(g, e, h), A(e, t);
      for (let _ = 0; _ < f.length; _ += 1)
        f[_] && f[_].m(t, null);
      A(t, s), A(t, n), A(t, l), A(t, r);
      for (let _ = 0; _ < m.length; _ += 1)
        m[_] && m[_].m(r, null);
      a = !0;
    },
    p(g, [h]) {
      if (h & /*hpFields, hp, $actor, Number, disableMaxHp*/
      51) {
        c = ue(
          /*hpFields*/
          g[5]
        );
        let _;
        for (_ = 0; _ < c.length; _ += 1) {
          const y = BO(g, c, _);
          f[_] ? (f[_].p(y, h), w(f[_], 1)) : (f[_] = GO(y), f[_].c(), w(f[_], 1), f[_].m(t, s));
        }
        for (ae(), _ = c.length; _ < f.length; _ += 1)
          d(_);
        ce();
      }
      if (h & /*hitDice, disableHitDice, $actor, Number*/
      137) {
        p = ue(
          /*hitDice*/
          g[7]
        );
        let _;
        for (_ = 0; _ < p.length; _ += 1) {
          const y = LO(g, p, _);
          m[_] ? m[_].p(y, h) : (m[_] = zO(y), m[_].c(), m[_].m(r, null));
        }
        for (; _ < m.length; _ += 1)
          m[_].d(1);
        m.length = p.length;
      }
      (!a || h & /*hitDieClasses*/
      4 && o !== (o = `u-mt-0 ${/*hitDieClasses*/
      g[2]}`)) && b(r, "class", o);
    },
    i(g) {
      if (!a) {
        for (let h = 0; h < c.length; h += 1)
          w(f[h]);
        a = !0;
      }
    },
    o(g) {
      f = f.filter(Boolean);
      for (let h = 0; h < f.length; h += 1)
        O(f[h]);
      a = !1;
    },
    d(g) {
      g && C(e), Le(f, g), Le(m, g);
    }
  };
}
u(FU, "create_fragment$4o");
function RU(i, e, t) {
  let s, n, l, r, o, { document: a, appId: c } = de("#external").application, { document: f = a, appId: d = c } = e;
  const p = [
    {
      label: "A5E.HitPointsCurrent",
      updateAttribute: "value"
    },
    {
      label: "A5E.HitPointsBaseMaximum",
      updateAttribute: "baseMax"
    },
    {
      label: "A5E.HitPointsTemporary",
      updateAttribute: "temp"
    },
    {
      label: "A5E.HitPointsMaxModifier",
      updateAttribute: "bonus"
    }
  ], m = f;
  pe(i, m, (v) => t(0, o = v));
  const g = N5(o), h = /* @__PURE__ */ u(({ target: v }) => te(o, v.name, Number(v.value)), "change_handler"), _ = /* @__PURE__ */ u(({ target: v }) => te(o, v.name, Number(v.value)), "change_handler_1"), y = /* @__PURE__ */ u(({ target: v }) => te(o, v.name, Number(v.value)), "change_handler_2");
  return i.$$set = (v) => {
    "document" in v && t(8, f = v.document), "appId" in v && t(9, d = v.appId);
  }, i.$$.update = () => {
    var v;
    i.$$.dirty & /*$actor*/
    1 && t(4, s = o.system.attributes.hp), i.$$.dirty & /*$actor*/
    1 && t(3, n = Object.keys(o.classes ?? {}).length ?? !1), i.$$.dirty & /*$actor*/
    1 && t(2, l = o.type === "character" ? "u-flex u-gap-md" : "u-grid u-grid-3 u-gap-lg"), i.$$.dirty & /*$actor*/
    1 && t(1, r = Object.keys(o.classes ?? {}).length ?? !((v = o.classAutomationFlags) != null && v.hitPoints) ?? !1);
  }, [
    o,
    r,
    l,
    n,
    s,
    p,
    m,
    g,
    f,
    d,
    h,
    _,
    y
  ];
}
u(RU, "instance$4f");
const p$ = class p$ extends re {
  constructor(e) {
    super(), oe(this, e, RU, FU, le, { document: 8, appId: 9 });
  }
};
u(p$, "ActorHpConfigDialog");
let ub = p$;
function fl(i = !1, e = !1) {
  const t = Object.entries(CONFIG.A5E.abilityAbbreviations).map(([s, n]) => [
    s,
    game.i18n.localize(n)
  ]);
  return i && t.unshift([null, game.i18n.localize("A5E.None")]), e && t.unshift(["none", game.i18n.localize("A5E.None")]), t;
}
u(fl, "prepareAbilityOptions");
function NU(i) {
  let e, t, s, n;
  return e = new Ke({
    props: {
      heading: "A5E.AbilityScore",
      optionStyles: "min-width:2rem; text-align: center;",
      options: (
        /*abilityOptions*/
        i[3]
      ),
      selected: (
        /*$actor*/
        i[0].system.attributes.initiative.ability
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  ), s = new hi({
    props: {
      selected: (
        /*initiative*/
        i[1].expertiseDice
      ),
      type: (
        /*$actor*/
        i[0].type
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$actor*/
      1 && (o.selected = /*$actor*/
      l[0].system.attributes.initiative.ability), e.$set(o);
      const a = {};
      r & /*initiative*/
      2 && (a.selected = /*initiative*/
      l[1].expertiseDice), r & /*$actor*/
      1 && (a.type = /*$actor*/
      l[0].type), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(NU, "create_default_slot$2s");
function jU(i) {
  let e, t, s;
  return e = new De({
    props: {
      $$slots: { default: [NU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-padding", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, initiative, $actor*/
      259 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(jU, "create_fragment$4n");
function LU(i, e, t) {
  let s, n, { document: l, appId: r } = de("#external").application, { document: o = l, appId: a = r } = e;
  const c = o;
  pe(i, c, (m) => t(0, n = m));
  const f = fl(), d = /* @__PURE__ */ u((m) => te(n, "system.attributes.initiative.ability", m.detail), "updateSelection_handler"), p = /* @__PURE__ */ u((m) => te(n, "system.attributes.initiative.expertiseDice", m.detail), "updateSelection_handler_1");
  return i.$$set = (m) => {
    "document" in m && t(4, o = m.document), "appId" in m && t(5, a = m.appId);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(1, s = n._source.system.attributes.initiative);
  }, [
    n,
    s,
    c,
    f,
    o,
    a,
    d,
    p
  ];
}
u(LU, "instance$4e");
const m$ = class m$ extends re {
  constructor(e) {
    super(), oe(this, e, LU, jU, le, { document: 4, appId: 5 });
  }
};
u(m$, "ActorInitConfigDialog");
let fb = m$;
function S9(i) {
  var r;
  const e = i.system.attributes.ac.changes ?? {};
  if (!(e != null && e.override) && !((r = e == null ? void 0 : e.bonuses) != null && r.length)) return "";
  const t = i.effects.reduce((o, a) => {
    if (a.isSuppressed) return o;
    const c = a.changes.reduce((f, d) => {
      if (d.key !== "system.attributes.ac.changes.bonuses.value") return f;
      let p = 0;
      try {
        p = mt(d.value, i.getRollData());
      } catch (m) {
        console.error(m);
      }
      return f.push({
        name: a.name,
        mode: d.mode,
        value: p
      }), f;
    }, []);
    return o.concat(c);
  }, []);
  let s;
  t.find(({ mode: o }) => o === CONFIG.A5E.ACTIVE_EFFECT_MODES.OVERRIDE) ? s = t : s = (e.bonuses.components ?? []).concat(
    e.bonuses.value ? t : []
  );
  const n = s.map(({ name: o, value: a }) => `${a >= 0 ? "+" : "-"} ${Math.abs(a)}[${o}]`);
  if (e.override.formula) {
    const o = new Roll(e.override.formula, i.getRollData()).evaluateSync().terms, a = bu(o ?? []).reduce((c, f) => {
      var d;
      return f instanceof foundry.dice.terms.OperatorTerm ? `${c} ${f.operator} ` : (c += `${f.total}`, (d = f.options) != null && d.flavor && (c += `[${f.options.flavor.replaceAll("[", "(").replaceAll("]", ")")}]`), c);
    }, "");
    n.unshift(a);
  } else
    n.unshift(
      `${e.override.value}[${e.override.name.replaceAll("[", "(").replaceAll("]", ")")}]`
    );
  const l = bu(
    new Roll(n.join(" "), i.getRollData()).evaluateSync().terms ?? []
  );
  return Roll.getFormula(l);
}
u(S9, "getACComponents");
function BU(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "name", "system.attributes.ac.baseFormula"), e.value = t = /*$actor*/
      i[0].system.attributes.ac.baseFormula;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[5]
      ), s = !0);
    },
    p(l, r) {
      r & /*$actor*/
      1 && t !== (t = /*$actor*/
      l[0].system.attributes.ac.baseFormula) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(BU, "create_default_slot_2$16");
function qU(i) {
  let e, t;
  return {
    c() {
      e = E("div"), t = Q(
        /*acFormula*/
        i[1]
      ), b(e, "class", "u-w-full ac-formula-preview svelte-1y1nzns");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n & /*acFormula*/
      2 && be(
        t,
        /*acFormula*/
        s[1]
      );
    },
    d(s) {
      s && C(e);
    }
  };
}
u(qU, "create_default_slot_1$1u");
function GU(i) {
  let e, t, s, n;
  return e = new ie({
    props: {
      heading: "A5E.armorClass.baseFormula",
      hint: "For NPCs this value states their Natural Armor.",
      $$slots: { default: [BU] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      heading: "A5E.armorClass.formula",
      $$slots: { default: [qU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, $actor*/
      65 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, acFormula*/
      66 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(GU, "create_default_slot$2r");
function zU(i) {
  let e, t, s;
  return e = new De({
    props: {
      $$slots: { default: [GU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-padding", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, acFormula, $actor*/
      67 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(zU, "create_fragment$4m");
function HU(i, e, t) {
  let s, n, { document: l, appId: r } = de("#external").application, { document: o = l, appId: a = r } = e;
  const c = o;
  pe(i, c, (d) => t(0, n = d));
  const f = /* @__PURE__ */ u(({ target: d }) => te(n, d.name, d.value), "change_handler");
  return i.$$set = (d) => {
    "document" in d && t(3, o = d.document), "appId" in d && t(4, a = d.appId);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(1, s = S9(n));
  }, [n, s, c, o, a, f];
}
u(HU, "instance$4d");
const h$ = class h$ extends re {
  constructor(e) {
    super(), oe(this, e, HU, zU, le, { document: 3, appId: 4 });
  }
};
u(h$, "ArmorClassConfigDialog");
let db = h$;
function UU(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*attackBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*attackBonus*/
      1 && t !== (t = /*attackBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(UU, "create_default_slot_3$N");
function VU(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [UU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-grow", "1");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, attackBonus*/
      4194305 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(VU, "create_default_slot_2$15");
function WU(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Select Attack Bonus Automatically in Roll Prompt",
      checked: (
        /*attackBonus*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[19]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*attackBonus*/
      1 && (l.checked = /*attackBonus*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(WU, "create_default_slot_1$1t");
function KU(i) {
  let e, t, s, n, l, r, o, a;
  return e = new tt({
    props: {
      heading: "A5E.contexts.attackType",
      options: Object.entries(
        /*attackTypes*/
        i[7]
      ),
      selected: (
        /*attackTypesContext*/
        i[3]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  ), s = new tt({
    props: {
      heading: "A5E.contexts.spellLevel",
      options: Object.entries(
        /*spellLevels*/
        i[8]
      ),
      selected: (
        /*spellLevelsContext*/
        i[2]
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), l = new Te({
    props: {
      label: "A5E.contexts.requiresProficiency",
      checked: (
        /*requiresProficiency*/
        i[1]
      )
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[18]
  ), o = new ie({
    props: {
      $$slots: { default: [WU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment);
    },
    m(c, f) {
      R(e, c, f), T(c, t, f), R(s, c, f), T(c, n, f), R(l, c, f), T(c, r, f), R(o, c, f), a = !0;
    },
    p(c, f) {
      const d = {};
      f & /*attackTypesContext*/
      8 && (d.selected = /*attackTypesContext*/
      c[3]), e.$set(d);
      const p = {};
      f & /*spellLevelsContext*/
      4 && (p.selected = /*spellLevelsContext*/
      c[2]), s.$set(p);
      const m = {};
      f & /*requiresProficiency*/
      2 && (m.checked = /*requiresProficiency*/
      c[1]), l.$set(m);
      const g = {};
      f & /*$$scope, attackBonus*/
      4194305 && (g.$$scope = { dirty: f, ctx: c }), o.$set(g);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(s.$$.fragment, c), w(l.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      O(e.$$.fragment, c), O(s.$$.fragment, c), O(l.$$.fragment, c), O(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (C(t), C(n), C(r)), N(e, c), N(s, c), N(l, c), N(o, c);
    }
  };
}
u(KU, "create_default_slot$2q");
function YU(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v;
  return d = new De({
    props: {
      $$slots: { default: [VU] },
      $$scope: { ctx: i }
    }
  }), g = new De({
    props: {
      heading: "Contexts",
      hint: "The context determines when the attack bonus applies",
      $$slots: { default: [KU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), h = E("div"), j(g.$$.fragment), b(s, "class", "bonus-image svelte-1lr65k0"), ze(s.src, n = /*attackBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*attackBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*attackBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1lr65k0"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1lr65k0"), b(t, "class", "sheet-header svelte-1lr65k0"), G(p, "display", "contents"), G(p, "--a5e-section-body-direction", "row"), G(p, "--a5e-section-margin", "0.25rem 0"), G(h, "display", "contents"), G(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1lr65k0");
    },
    m(k, S) {
      T(k, e, S), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), A(e, h), R(g, h, null), _ = !0, y || (v = [
        W(
          s,
          "click",
          /*click_handler*/
          i[13]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[14]
        )
      ], y = !0);
    },
    p(k, [S]) {
      (!_ || S & /*attackBonus*/
      1 && !ze(s.src, n = /*attackBonus*/
      k[0].img)) && b(s, "src", n), (!_ || S & /*attackBonus*/
      1 && l !== (l = /*attackBonus*/
      k[0].label)) && b(s, "alt", l), (!_ || S & /*attackBonus*/
      1 && c !== (c = /*attackBonus*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const D = {};
      S & /*$$scope, attackBonus*/
      4194305 && (D.$$scope = { dirty: S, ctx: k }), d.$set(D);
      const I = {};
      S & /*$$scope, attackBonus, requiresProficiency, spellLevelsContext, attackTypesContext*/
      4194319 && (I.$$scope = { dirty: S, ctx: k }), g.$set(I);
    },
    i(k) {
      _ || (w(d.$$.fragment, k), w(g.$$.fragment, k), _ = !0);
    },
    o(k) {
      O(d.$$.fragment, k), O(g.$$.fragment, k), _ = !1;
    },
    d(k) {
      k && C(e), N(d), N(g), y = !1, Me(v);
    }
  };
}
u(YU, "create_fragment$4l");
function XU(i, e, t) {
  let s, n, l, r, o, { document: a, bonusID: c } = de("#external").application, { document: f = a, bonusID: d = c } = e, { jsonValue: p = null } = e;
  const m = f;
  pe(i, m, (q) => t(12, o = q));
  const g = ft();
  function h() {
    const q = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: q,
      callback: /* @__PURE__ */ u((H) => {
        _("img", H);
      }, "callback")
    }).browse();
  }
  u(h, "updateImage");
  function _(q, U) {
    if (p === null) {
      q = `system.bonuses.attacks.${d}.${q}`, te(o, q, U);
      return;
    }
    const H = foundry.utils.expandObject({ ...s, [q]: U });
    g("change", JSON.stringify(H));
  }
  u(_, "onUpdateValue");
  function y() {
    if (p === null) return o.system.bonuses.attacks[d];
    try {
      const q = JSON.parse(p || '""') ?? {};
      if (typeof q != "object") throw new Error();
      return q.label = q.label ?? "", q.formula = q.formula ?? "", q.context = q.context ?? {
        attackTypes: [],
        spellLevels: [],
        requiresProficiency: !1
      }, q.default = q.default ?? !0, q.img = q.img || "icons/svg/upgrade.svg", q;
    } catch {
      return {
        label: "",
        formula: "",
        context: {
          attackTypes: [],
          spellLevels: [],
          requiresProficiency: !1
        },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  u(y, "getAttackBonus");
  const { attackTypes: v, spellLevels: k } = CONFIG.A5E, S = /* @__PURE__ */ u(() => h(), "click_handler"), D = /* @__PURE__ */ u(({ target: q }) => _("label", q.value), "change_handler"), I = /* @__PURE__ */ u(({ target: q }) => _("formula", q.value), "change_handler_1"), M = /* @__PURE__ */ u(({ detail: q }) => {
    _("context.attackTypes", q);
  }, "updateSelection_handler"), L = /* @__PURE__ */ u(({ detail: q }) => {
    _("context.spellLevels", q);
  }, "updateSelection_handler_1"), B = /* @__PURE__ */ u(({ detail: q }) => {
    _("context.requiresProficiency", q);
  }, "updateSelection_handler_2"), z = /* @__PURE__ */ u(({ detail: q }) => {
    _("default", q);
  }, "updateSelection_handler_3");
  return i.$$set = (q) => {
    "document" in q && t(9, f = q.document), "bonusID" in q && t(10, d = q.bonusID), "jsonValue" in q && t(11, p = q.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    6144 && t(0, s = y() ?? {}), i.$$.dirty & /*attackBonus*/
    1 && t(3, n = s.context.attackTypes ?? []), i.$$.dirty & /*attackBonus*/
    1 && t(2, l = s.context.spellLevels ?? []), i.$$.dirty & /*attackBonus*/
    1 && t(1, r = s.context.requiresProficiency ?? !1);
  }, [
    s,
    r,
    l,
    n,
    m,
    h,
    _,
    v,
    k,
    f,
    d,
    p,
    o,
    S,
    D,
    I,
    M,
    L,
    B,
    z
  ];
}
u(XU, "instance$4c");
const g$ = class g$ extends re {
  constructor(e) {
    super(), oe(this, e, XU, YU, le, { document: 9, bonusID: 10, jsonValue: 11 });
  }
};
u(g$, "AttackBonusConfigDialog");
let fp = g$;
function HO(i, e, t) {
  const s = i.slice();
  return s[26] = e[t][0], s[27] = e[t][1], s;
}
u(HO, "get_each_context$1G");
function JU(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*damageBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[17]
      ), s = !0);
    },
    p(l, r) {
      r & /*damageBonus*/
      1 && t !== (t = /*damageBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(JU, "create_default_slot_4$t");
function UO(i, e) {
  let t, s = K(
    /*name*/
    e[27]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = Q(s), l = F(), t.__value = /*key*/
      e[26], He(t, t.__value), t.selected = r = /*damageBonus*/
      e[0].damageType === /*key*/
      e[26], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*damageBonus*/
      1 && r !== (r = /*damageBonus*/
      e[0].damageType === /*key*/
      e[26]) && (t.selected = r);
    },
    d(o) {
      o && C(t);
    }
  };
}
u(UO, "create_each_block$1G");
function ZU(i) {
  let e, t, s = K("A5E.None") + "", n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, f, d = ue(Object.entries(
    /*damageTypes*/
    i[9]
  ));
  const p = /* @__PURE__ */ u((m) => (
    /*key*/
    m[26]
  ), "get_key");
  for (let m = 0; m < d.length; m += 1) {
    let g = HO(i, d, m), h = p(g);
    a.set(h, o[m] = UO(h, g));
  }
  return {
    c() {
      e = E("select"), t = E("option"), n = Q(s), l = F();
      for (let m = 0; m < o.length; m += 1)
        o[m].c();
      t.__value = null, He(t, t.__value), t.selected = r = /*damageBonus*/
      i[0].damageType === "null" || /*damageBonus*/
      i[0].damageType === null, b(e, "class", "u-w-fit damage-type-select");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, n), A(t, l);
      for (let h = 0; h < o.length; h += 1)
        o[h] && o[h].m(e, null);
      c || (f = W(
        e,
        "change",
        /*change_handler_2*/
        i[18]
      ), c = !0);
    },
    p(m, g) {
      g & /*damageBonus*/
      1 && r !== (r = /*damageBonus*/
      m[0].damageType === "null" || /*damageBonus*/
      m[0].damageType === null) && (t.selected = r), g & /*Object, damageTypes, damageBonus*/
      513 && (d = ue(Object.entries(
        /*damageTypes*/
        m[9]
      )), o = Lt(o, g, p, 1, m, d, a, e, an, UO, null, HO));
    },
    d(m) {
      m && C(e);
      for (let g = 0; g < o.length; g += 1)
        o[g].d();
      c = !1, f();
    }
  };
}
u(ZU, "create_default_slot_3$M");
function QU(i) {
  let e, t, s, n, l, r;
  return e = new ie({
    props: {
      heading: "A5E.DamageFormula",
      $$slots: { default: [JU] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.DamageType",
      $$slots: { default: [ZU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-grow", "1"), G(l, "display", "contents"), G(l, "--background", "none"), G(l, "--direction", "column"), G(l, "--padding", "0");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), T(o, l, a), R(n, l, null), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, damageBonus*/
      1073741825 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const f = {};
      a & /*$$scope, damageBonus*/
      1073741825 && (f.$$scope = { dirty: a, ctx: o }), n.$set(f);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && C(s), o && e && C(t), N(e, o), o && n && C(l), N(n, o);
    }
  };
}
u(QU, "create_default_slot_2$14");
function xU(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Select Damage Bonus Automatically in Roll Prompt",
      checked: (
        /*damageBonus*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[23]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*damageBonus*/
      1 && (l.checked = /*damageBonus*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(xU, "create_default_slot_1$1s");
function eV(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return e = new tt({
    props: {
      heading: "A5E.contexts.attackType",
      options: Object.entries(
        /*damageBonusContexts*/
        i[8]
      ),
      selected: (
        /*attackTypesContext*/
        i[4]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[19]
  ), s = new tt({
    props: {
      heading: "A5E.contexts.damageType",
      options: Object.entries(
        /*damageTypes*/
        i[9]
      ),
      selected: (
        /*damageTypesContext*/
        i[3]
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[20]
  ), l = new tt({
    props: {
      heading: "A5E.contexts.spellLevel",
      options: Object.entries(
        /*spellLevels*/
        i[10]
      ),
      selected: (
        /*spellLevelsContext*/
        i[1]
      ),
      showToggleAllButton: !0
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[21]
  ), o = new Te({
    props: {
      label: "This bonus only applies to critical hits.",
      checked: (
        /*isCritBonus*/
        i[2]
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[22]
  ), c = new ie({
    props: {
      $$slots: { default: [xU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment);
    },
    m(d, p) {
      R(e, d, p), T(d, t, p), R(s, d, p), T(d, n, p), R(l, d, p), T(d, r, p), R(o, d, p), T(d, a, p), R(c, d, p), f = !0;
    },
    p(d, p) {
      const m = {};
      p & /*attackTypesContext*/
      16 && (m.selected = /*attackTypesContext*/
      d[4]), e.$set(m);
      const g = {};
      p & /*damageTypesContext*/
      8 && (g.selected = /*damageTypesContext*/
      d[3]), s.$set(g);
      const h = {};
      p & /*spellLevelsContext*/
      2 && (h.selected = /*spellLevelsContext*/
      d[1]), l.$set(h);
      const _ = {};
      p & /*isCritBonus*/
      4 && (_.checked = /*isCritBonus*/
      d[2]), o.$set(_);
      const y = {};
      p & /*$$scope, damageBonus*/
      1073741825 && (y.$$scope = { dirty: p, ctx: d }), c.$set(y);
    },
    i(d) {
      f || (w(e.$$.fragment, d), w(s.$$.fragment, d), w(l.$$.fragment, d), w(o.$$.fragment, d), w(c.$$.fragment, d), f = !0);
    },
    o(d) {
      O(e.$$.fragment, d), O(s.$$.fragment, d), O(l.$$.fragment, d), O(o.$$.fragment, d), O(c.$$.fragment, d), f = !1;
    },
    d(d) {
      d && (C(t), C(n), C(r), C(a)), N(e, d), N(s, d), N(l, d), N(o, d), N(c, d);
    }
  };
}
u(eV, "create_default_slot$2p");
function tV(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v;
  return d = new De({
    props: {
      $$slots: { default: [QU] },
      $$scope: { ctx: i }
    }
  }), g = new De({
    props: {
      heading: "Contexts",
      hint: "The context determines when the damage bonus applies",
      $$slots: { default: [eV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), h = E("div"), j(g.$$.fragment), b(s, "class", "bonus-image svelte-1lr65k0"), ze(s.src, n = /*damageBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*damageBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*damageBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1lr65k0"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1lr65k0"), b(t, "class", "sheet-header svelte-1lr65k0"), G(p, "display", "contents"), G(p, "--a5e-section-body-direction", "row"), G(p, "--a5e-section-margin", "0.25rem 0"), G(h, "display", "contents"), G(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1lr65k0");
    },
    m(k, S) {
      T(k, e, S), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), A(e, h), R(g, h, null), _ = !0, y || (v = [
        W(
          s,
          "click",
          /*click_handler*/
          i[15]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[16]
        )
      ], y = !0);
    },
    p(k, [S]) {
      (!_ || S & /*damageBonus*/
      1 && !ze(s.src, n = /*damageBonus*/
      k[0].img)) && b(s, "src", n), (!_ || S & /*damageBonus*/
      1 && l !== (l = /*damageBonus*/
      k[0].label)) && b(s, "alt", l), (!_ || S & /*damageBonus*/
      1 && c !== (c = /*damageBonus*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const D = {};
      S & /*$$scope, damageBonus*/
      1073741825 && (D.$$scope = { dirty: S, ctx: k }), d.$set(D);
      const I = {};
      S & /*$$scope, damageBonus, isCritBonus, spellLevelsContext, damageTypesContext, attackTypesContext*/
      1073741855 && (I.$$scope = { dirty: S, ctx: k }), g.$set(I);
    },
    i(k) {
      _ || (w(d.$$.fragment, k), w(g.$$.fragment, k), _ = !0);
    },
    o(k) {
      O(d.$$.fragment, k), O(g.$$.fragment, k), _ = !1;
    },
    d(k) {
      k && C(e), N(d), N(g), y = !1, Me(v);
    }
  };
}
u(tV, "create_fragment$4k");
function sV(i, e, t) {
  let s, n, l, r, o, a, { document: c, bonusID: f } = de("#external").application, { document: d = c, bonusID: p = f } = e, { jsonValue: m = null } = e;
  const g = d;
  pe(i, g, (Y) => t(14, a = Y));
  const h = ft();
  function _() {
    const Y = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: Y,
      callback: /* @__PURE__ */ u((fe) => {
        y("img", fe);
      }, "callback")
    }).browse();
  }
  u(_, "updateImage");
  function y(Y, J) {
    if (m === null) {
      Y = `system.bonuses.damage.${p}.${Y}`, te(a, Y, J);
      return;
    }
    const fe = foundry.utils.expandObject({ ...s, [Y]: J });
    h("change", JSON.stringify(fe));
  }
  u(y, "onUpdateValue");
  function v() {
    if (m === null) return a.system.bonuses.damage[p];
    try {
      const Y = JSON.parse(m || '""') ?? {};
      if (typeof Y != "object") throw new Error();
      return Y.label = Y.label ?? "", Y.formula = Y.formula ?? "", Y.damageType = Y.damageType ?? "", Y.context = Y.context ?? {
        attackTypes: [],
        damageTypes: [],
        spellLevels: [],
        isCritBonus: !1
      }, Y.default = Y.default ?? !0, Y.img = Y.img || "icons/svg/upgrade.svg", Y;
    } catch {
      return {
        label: "",
        formula: "",
        damageType: "",
        context: {
          attackTypes: [],
          damageTypes: [],
          spellLevels: [],
          isCritBonus: !1
        },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  u(v, "getDamageBonus");
  const { damageBonusContexts: k, damageTypes: S, spellLevels: D } = CONFIG.A5E, I = /* @__PURE__ */ u(() => _(), "click_handler"), M = /* @__PURE__ */ u(({ target: Y }) => y("label", Y.value), "change_handler"), L = /* @__PURE__ */ u(({ target: Y }) => y("formula", Y.value), "change_handler_1"), B = /* @__PURE__ */ u(({ target: Y }) => y("damageType", Y.value), "change_handler_2"), z = /* @__PURE__ */ u(({ detail: Y }) => {
    y("context.attackTypes", Y);
  }, "updateSelection_handler"), q = /* @__PURE__ */ u(({ detail: Y }) => {
    y("context.damageTypes", Y);
  }, "updateSelection_handler_1"), U = /* @__PURE__ */ u(({ detail: Y }) => {
    y("context.spellLevels", Y);
  }, "updateSelection_handler_2"), H = /* @__PURE__ */ u(({ detail: Y }) => {
    y("context.isCritBonus", Y);
  }, "updateSelection_handler_3"), V = /* @__PURE__ */ u(({ detail: Y }) => {
    y("default", Y);
  }, "updateSelection_handler_4");
  return i.$$set = (Y) => {
    "document" in Y && t(11, d = Y.document), "bonusID" in Y && t(12, p = Y.bonusID), "jsonValue" in Y && t(13, m = Y.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    24576 && t(0, s = v() ?? {}), i.$$.dirty & /*damageBonus*/
    1 && t(4, n = s.context.attackTypes ?? []), i.$$.dirty & /*damageBonus*/
    1 && t(3, l = s.context.damageTypes ?? []), i.$$.dirty & /*damageBonus*/
    1 && t(2, r = s.context.isCritBonus ?? !1), i.$$.dirty & /*damageBonus*/
    1 && t(1, o = s.context.spellLevels ?? []);
  }, [
    s,
    o,
    r,
    l,
    n,
    g,
    _,
    y,
    k,
    S,
    D,
    d,
    p,
    m,
    a,
    I,
    M,
    L,
    B,
    z,
    q,
    U,
    H,
    V
  ];
}
u(sV, "instance$4b");
const b$ = class b$ extends re {
  constructor(e) {
    super(), oe(this, e, sV, tV, le, { document: 11, bonusID: 12, jsonValue: 13 });
  }
};
u(b$, "DamageBonusConfigDialog");
let dp = b$;
function VO(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.HintSeparateBySemiColon",
      $$slots: { default: [nV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, selectedCustomOptions*/
      8404992 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(VO, "create_if_block$2l");
function nV(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), e.value = t = /*selectedCustomOptions*/
      i[14].join("; ");
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[20]
      ), s = !0);
    },
    p(l, r) {
      r & /*selectedCustomOptions*/
      16384 && t !== (t = /*selectedCustomOptions*/
      l[14].join("; ")) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(nV, "create_default_slot$2o");
function iV(i) {
  let e, t, s, n;
  e = new tt({
    props: {
      heading: (
        /*heading*/
        i[2]
      ),
      hint: (
        /*hint*/
        i[3]
      ),
      listClasses: (
        /*listClasses*/
        i[4]
      ),
      options: (
        /*options*/
        i[5]
      ),
      optionStyles: (
        /*optionStyles*/
        i[6]
      ),
      orange: (
        /*orange*/
        i[7]
      ),
      red: (
        /*red*/
        i[8]
      ),
      selected: (
        /*selectedCoreOptions*/
        i[15]
      ),
      disabled: (
        /*disabled*/
        i[0]
      ),
      disabledOptions: (
        /*disabledOptions*/
        i[1]
      ),
      showToggleAllButton: (
        /*showToggleAllButton*/
        i[10]
      ),
      showWarning: (
        /*showWarning*/
        i[11]
      ),
      tooltipData: (
        /*tooltipData*/
        i[12]
      ),
      warning: (
        /*warning*/
        i[13]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[19]
  );
  let l = (
    /*showCustomInput*/
    i[9] && VO(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), l && l.c(), s = $e();
    },
    m(r, o) {
      R(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, [o]) {
      const a = {};
      o & /*heading*/
      4 && (a.heading = /*heading*/
      r[2]), o & /*hint*/
      8 && (a.hint = /*hint*/
      r[3]), o & /*listClasses*/
      16 && (a.listClasses = /*listClasses*/
      r[4]), o & /*options*/
      32 && (a.options = /*options*/
      r[5]), o & /*optionStyles*/
      64 && (a.optionStyles = /*optionStyles*/
      r[6]), o & /*orange*/
      128 && (a.orange = /*orange*/
      r[7]), o & /*red*/
      256 && (a.red = /*red*/
      r[8]), o & /*selectedCoreOptions*/
      32768 && (a.selected = /*selectedCoreOptions*/
      r[15]), o & /*disabled*/
      1 && (a.disabled = /*disabled*/
      r[0]), o & /*disabledOptions*/
      2 && (a.disabledOptions = /*disabledOptions*/
      r[1]), o & /*showToggleAllButton*/
      1024 && (a.showToggleAllButton = /*showToggleAllButton*/
      r[10]), o & /*showWarning*/
      2048 && (a.showWarning = /*showWarning*/
      r[11]), o & /*tooltipData*/
      4096 && (a.tooltipData = /*tooltipData*/
      r[12]), o & /*warning*/
      8192 && (a.warning = /*warning*/
      r[13]), e.$set(a), /*showCustomInput*/
      r[9] ? l ? (l.p(r, o), o & /*showCustomInput*/
      512 && w(l, 1)) : (l = VO(r), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ae(), O(l, 1, 1, () => {
        l = null;
      }), ce());
    },
    i(r) {
      n || (w(e.$$.fragment, r), w(l), n = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(l), n = !1;
    },
    d(r) {
      r && (C(t), C(s)), N(e, r), l && l.d(r);
    }
  };
}
u(iV, "create_fragment$4j");
function lV(i) {
  return i.split(";").map((e) => e.trim()).filter(Boolean);
}
u(lV, "splitCustomSelections");
function rV(i, e, t) {
  let s, n, { disabled: l = !1 } = e, { disabledOptions: r = [] } = e, { heading: o = "" } = e, { hint: a = "" } = e, { listClasses: c = "" } = e, { options: f = [] } = e, { optionStyles: d = "" } = e, { orange: p = [] } = e, { red: m = [] } = e, { selected: g = [] } = e, { showCustomInput: h = !0 } = e, { showToggleAllButton: _ = !0 } = e, { showWarning: y = !1 } = e, { tooltipData: v = {} } = e, { warning: k = "" } = e;
  function S(z) {
    t(18, g = [...z, ...n]), M("updateSelection", [...z, ...n]);
  }
  u(S, "updateCoreSelections");
  function D(z) {
    t(18, g = [...s, ...lV(z)]), M("updateSelection", g);
  }
  u(D, "updateCustomSelections");
  const I = f.map(([z]) => z), M = ft(), L = /* @__PURE__ */ u((z) => S(z.detail), "updateSelection_handler"), B = /* @__PURE__ */ u(({ target: z }) => {
    D(z.value);
  }, "change_handler");
  return i.$$set = (z) => {
    "disabled" in z && t(0, l = z.disabled), "disabledOptions" in z && t(1, r = z.disabledOptions), "heading" in z && t(2, o = z.heading), "hint" in z && t(3, a = z.hint), "listClasses" in z && t(4, c = z.listClasses), "options" in z && t(5, f = z.options), "optionStyles" in z && t(6, d = z.optionStyles), "orange" in z && t(7, p = z.orange), "red" in z && t(8, m = z.red), "selected" in z && t(18, g = z.selected), "showCustomInput" in z && t(9, h = z.showCustomInput), "showToggleAllButton" in z && t(10, _ = z.showToggleAllButton), "showWarning" in z && t(11, y = z.showWarning), "tooltipData" in z && t(12, v = z.tooltipData), "warning" in z && t(13, k = z.warning);
  }, i.$$.update = () => {
    i.$$.dirty & /*selected*/
    262144 && t(15, s = g.filter((z) => I.includes(z))), i.$$.dirty & /*selected*/
    262144 && t(14, n = g.filter((z) => !I.includes(z)));
  }, [
    l,
    r,
    o,
    a,
    c,
    f,
    d,
    p,
    m,
    h,
    _,
    y,
    v,
    k,
    n,
    s,
    S,
    D,
    g,
    L,
    B
  ];
}
u(rV, "instance$4a");
const _$ = class _$ extends re {
  constructor(e) {
    super(), oe(this, e, rV, iV, le, {
      disabled: 0,
      disabledOptions: 1,
      heading: 2,
      hint: 3,
      listClasses: 4,
      options: 5,
      optionStyles: 6,
      orange: 7,
      red: 8,
      selected: 18,
      showCustomInput: 9,
      showToggleAllButton: 10,
      showWarning: 11,
      tooltipData: 12,
      warning: 13
    });
  }
};
u(_$, "CustomTagGroup");
let Pi = _$;
const { Boolean: oV } = x7;
function WO(i, e, t) {
  const s = i.slice();
  return s[13] = e[t], s;
}
u(WO, "get_each_context$1F");
function aV(i) {
  let e, t;
  function s(...n) {
    return (
      /*updateSelection_handler*/
      i[10](
        /*key*/
        i[13],
        ...n
      )
    );
  }
  return u(s, "updateSelection_handler"), e = new tt({
    props: {
      heading: (
        /*headings*/
        i[3][
          /*key*/
          i[13]
        ] ?? /*key*/
        i[13]
      ),
      options: Object.entries(
        /*configObject*/
        i[0][
          /*key*/
          i[13]
        ]
      ),
      selected: (
        /*proficiencies*/
        i[6][
          /*key*/
          i[13]
        ]
      ),
      disabled: !!/*max*/
      i[5] && /*existingProperties*/
      i[2].length >= /*max*/
      i[5],
      disabledOptions: (
        /*disabledProperties*/
        i[1]
      ),
      showToggleAllButton: !0
    }
  }), e.$on("updateSelection", s), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      i = n;
      const r = {};
      l & /*headings*/
      8 && (r.heading = /*headings*/
      i[3][
        /*key*/
        i[13]
      ] ?? /*key*/
      i[13]), l & /*configObject*/
      1 && (r.options = Object.entries(
        /*configObject*/
        i[0][
          /*key*/
          i[13]
        ]
      )), l & /*proficiencies*/
      64 && (r.selected = /*proficiencies*/
      i[6][
        /*key*/
        i[13]
      ]), l & /*max, existingProperties*/
      36 && (r.disabled = !!/*max*/
      i[5] && /*existingProperties*/
      i[2].length >= /*max*/
      i[5]), l & /*disabledProperties*/
      2 && (r.disabledOptions = /*disabledProperties*/
      i[1]), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(aV, "create_if_block$2k");
function KO(i) {
  let e, t, s = (
    /*key*/
    i[13] !== "other" && aV(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*key*/
      n[13] !== "other" && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(KO, "create_each_block$1F");
function cV(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), e.value = t = /*otherProficiencies*/
      i[7] || "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[11]
      ), s = !0);
    },
    p(l, r) {
      r & /*otherProficiencies*/
      128 && t !== (t = /*otherProficiencies*/
      l[7] || "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(cV, "create_default_slot_1$1r");
function uV(i) {
  let e, t, s, n = ue(
    /*configKeys*/
    i[9]
  ), l = [];
  for (let o = 0; o < n.length; o += 1)
    l[o] = KO(WO(i, n, o));
  const r = /* @__PURE__ */ u((o) => O(l[o], 1, 1, () => {
    l[o] = null;
  }), "out");
  return t = new ie({
    props: {
      $$slots: { default: [cV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      for (let o = 0; o < l.length; o += 1)
        l[o].c();
      e = F(), j(t.$$.fragment);
    },
    m(o, a) {
      for (let c = 0; c < l.length; c += 1)
        l[c] && l[c].m(o, a);
      T(o, e, a), R(t, o, a), s = !0;
    },
    p(o, a) {
      if (a & /*headings, configKeys, Object, configObject, proficiencies, max, existingProperties, disabledProperties, updateFunction*/
      879) {
        n = ue(
          /*configKeys*/
          o[9]
        );
        let f;
        for (f = 0; f < n.length; f += 1) {
          const d = WO(o, n, f);
          l[f] ? (l[f].p(d, a), w(l[f], 1)) : (l[f] = KO(d), l[f].c(), w(l[f], 1), l[f].m(e.parentNode, e));
        }
        for (ae(), f = n.length; f < l.length; f += 1)
          r(f);
        ce();
      }
      const c = {};
      a & /*$$scope, otherProficiencies*/
      65664 && (c.$$scope = { dirty: a, ctx: o }), t.$set(c);
    },
    i(o) {
      if (!s) {
        for (let a = 0; a < n.length; a += 1)
          w(l[a]);
        w(t.$$.fragment, o), s = !0;
      }
    },
    o(o) {
      l = l.filter(oV);
      for (let a = 0; a < l.length; a += 1)
        O(l[a]);
      O(t.$$.fragment, o), s = !1;
    },
    d(o) {
      o && C(e), Le(l, o), N(t, o);
    }
  };
}
u(uV, "create_default_slot$2n");
function fV(i) {
  let e, t, s;
  return e = new ie({
    props: {
      hint: (
        /*hint*/
        i[4]
      ),
      $$slots: { default: [uV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*hint*/
      16 && (r.hint = /*hint*/
      n[4]), l & /*$$scope, otherProficiencies, headings, configObject, proficiencies, max, existingProperties, disabledProperties*/
      65775 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(fV, "create_fragment$4i");
function dV(i, e, t) {
  let s, n, { configObject: l = {} } = e, { disabledProperties: r = [] } = e, { existingProperties: o = [] } = e, { headings: a = {} } = e, { hint: c = "" } = e, { max: f = 0 } = e;
  function d() {
    const _ = [
      ...Object.entries(s).reduce(
        (y, [v, k]) => (v === "other" || y.push(...k), y),
        []
      ),
      ...n.split(";").map((y) => y.trim()).filter(Boolean)
    ];
    m("updateSelection", _);
  }
  u(d, "updateFunction");
  const p = [...Object.keys(l), "other"], m = ft(), g = /* @__PURE__ */ u((_, { detail: y }) => {
    t(6, s[_] = y, s), d();
  }, "updateSelection_handler"), h = /* @__PURE__ */ u(({ target: _ }) => {
    t(7, n = _.value), d();
  }, "change_handler");
  return i.$$set = (_) => {
    "configObject" in _ && t(0, l = _.configObject), "disabledProperties" in _ && t(1, r = _.disabledProperties), "existingProperties" in _ && t(2, o = _.existingProperties), "headings" in _ && t(3, a = _.headings), "hint" in _ && t(4, c = _.hint), "max" in _ && t(5, f = _.max);
  }, i.$$.update = () => {
    i.$$.dirty & /*existingProperties, configObject*/
    5 && t(6, s = o.reduce(
      (_, y) => {
        let v = !1;
        return p.forEach((k) => {
          var S, D;
          (D = (S = Object.keys((l == null ? void 0 : l[k]) ?? [])).includes) != null && D.call(S, y) && (_[k].push(y), v = !0);
        }), v || _.other.push(y), _;
      },
      Object.fromEntries(p.map((_) => [_, []]))
    )), i.$$.dirty & /*proficiencies*/
    64 && t(7, n = s.other.join("; "));
  }, [
    l,
    r,
    o,
    a,
    c,
    f,
    s,
    n,
    d,
    p,
    g,
    h
  ];
}
u(dV, "instance$49");
const y$ = class y$ extends re {
  constructor(e) {
    super(), oe(this, e, dV, fV, le, {
      configObject: 0,
      disabledProperties: 1,
      existingProperties: 2,
      headings: 3,
      hint: 4,
      max: 5
    });
  }
};
u(y$, "ComplexDetailEmbed");
let uc = y$;
function pV(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [bV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, heading, options, selected, tooltipData, $actor, propertyKey*/
      2097397 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(pV, "create_else_block$J");
function mV(i) {
  let e, t;
  return e = new uc({
    props: {
      existingProperties: (
        /*$actor*/
        i[4].system.proficiencies.tools
      ),
      headings: (
        /*toolCategories*/
        i[11]
      ),
      configObject: (
        /*configObject*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      16 && (l.existingProperties = /*$actor*/
      s[4].system.proficiencies.tools), n & /*configObject*/
      2 && (l.configObject = /*configObject*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(mV, "create_if_block_4$w");
function hV(i) {
  let e, t;
  return e = new uc({
    props: {
      existingProperties: (
        /*$actor*/
        i[4].system.proficiencies.weapons
      ),
      headings: (
        /*weaponCategories*/
        i[10]
      ),
      configObject: (
        /*configObject*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[15]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      16 && (l.existingProperties = /*$actor*/
      s[4].system.proficiencies.weapons), n & /*configObject*/
      2 && (l.configObject = /*configObject*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(hV, "create_if_block_3$E");
function gV(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [_V] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, heading, options, selected, $actor, propertyKey*/
      2097333 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(gV, "create_if_block_2$$");
function bV(i) {
  let e, t;
  return e = new Pi({
    props: {
      heading: (
        /*heading*/
        i[2]
      ),
      options: (
        /*options*/
        i[5]
      ),
      selected: (
        /*selected*/
        i[7]
      ),
      tooltipData: (
        /*tooltipData*/
        i[6]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*heading*/
      4 && (l.heading = /*heading*/
      s[2]), n & /*options*/
      32 && (l.options = /*options*/
      s[5]), n & /*selected*/
      128 && (l.selected = /*selected*/
      s[7]), n & /*tooltipData*/
      64 && (l.tooltipData = /*tooltipData*/
      s[6]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(bV, "create_default_slot_3$L");
function _V(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: (
        /*heading*/
        i[2]
      ),
      options: (
        /*options*/
        i[5]
      ),
      selected: (
        /*selected*/
        i[7]
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*heading*/
      4 && (l.heading = /*heading*/
      s[2]), n & /*options*/
      32 && (l.options = /*options*/
      s[5]), n & /*selected*/
      128 && (l.selected = /*selected*/
      s[7]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(_V, "create_default_slot_2$13");
function YO(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [yV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $actor*/
      2097168 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(YO, "create_if_block$2j");
function XO(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Squad",
      checked: (
        /*$actor*/
        i[4].system.details.isSquad
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[18]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      16 && (l.checked = /*$actor*/
      s[4].system.details.isSquad), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(XO, "create_if_block_1$1w");
function yV(i) {
  let e, t, s, n = (
    /*$actor*/
    i[4].type === "npc" && XO(i)
  );
  return t = new Te({
    props: {
      label: "A5E.CreatureSwarm",
      checked: (
        /*$actor*/
        i[4].system.details.isSwarm
      )
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[19]
  ), {
    c() {
      n && n.c(), e = F(), j(t.$$.fragment);
    },
    m(l, r) {
      n && n.m(l, r), T(l, e, r), R(t, l, r), s = !0;
    },
    p(l, r) {
      /*$actor*/
      l[4].type === "npc" ? n ? (n.p(l, r), r & /*$actor*/
      16 && w(n, 1)) : (n = XO(l), n.c(), w(n, 1), n.m(e.parentNode, e)) : n && (ae(), O(n, 1, 1, () => {
        n = null;
      }), ce());
      const o = {};
      r & /*$actor*/
      16 && (o.checked = /*$actor*/
      l[4].system.details.isSwarm), t.$set(o);
    },
    i(l) {
      s || (w(n), w(t.$$.fragment, l), s = !0);
    },
    o(l) {
      O(n), O(t.$$.fragment, l), s = !1;
    },
    d(l) {
      l && C(e), n && n.d(l), N(t, l);
    }
  };
}
u(yV, "create_default_slot_1$1q");
function vV(i) {
  let e, t, s, n, l;
  const r = [gV, hV, mV, pV], o = [];
  function a(f, d) {
    return (
      /*isRadioGroup*/
      f[9] ? 0 : (
        /*type*/
        f[3] === "weapons" ? 1 : (
          /*type*/
          f[3] === "tools" ? 2 : 3
        )
      )
    );
  }
  u(a, "select_block_type"), e = a(i), t = o[e] = r[e](i);
  let c = (
    /*type*/
    i[3] === "creatureTypes" && YO(i)
  );
  return {
    c() {
      t.c(), s = F(), c && c.c(), n = $e();
    },
    m(f, d) {
      o[e].m(f, d), T(f, s, d), c && c.m(f, d), T(f, n, d), l = !0;
    },
    p(f, d) {
      let p = e;
      e = a(f), e === p ? o[e].p(f, d) : (ae(), O(o[p], 1, 1, () => {
        o[p] = null;
      }), ce(), t = o[e], t ? t.p(f, d) : (t = o[e] = r[e](f), t.c()), w(t, 1), t.m(s.parentNode, s)), /*type*/
      f[3] === "creatureTypes" ? c ? (c.p(f, d), d & /*type*/
      8 && w(c, 1)) : (c = YO(f), c.c(), w(c, 1), c.m(n.parentNode, n)) : c && (ae(), O(c, 1, 1, () => {
        c = null;
      }), ce());
    },
    i(f) {
      l || (w(t), w(c), l = !0);
    },
    o(f) {
      O(t), O(c), l = !1;
    },
    d(f) {
      f && (C(s), C(n)), o[e].d(f), c && c.d(f);
    }
  };
}
u(vV, "create_default_slot$2m");
function kV(i) {
  let e, t, s;
  return e = new De({
    props: {
      $$slots: { default: [vV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-padding", "0.75rem"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, $actor, type, heading, options, selected, propertyKey, configObject, tooltipData*/
      2097407 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(kV, "create_fragment$4h");
function wV(i, e, t) {
  let s, n, l, { document: r, appId: o, propertyKey: a, configObject: c, heading: f, type: d } = de("#external").application, { document: p = r, appId: m = o, propertyKey: g = a, configObject: h = c, heading: _ = f, type: y = d } = e;
  function v() {
    const V = l.grants.getGrantedTraits(y), Y = {};
    for (const J of Object.values(V))
      J.traits.forEach((fe) => {
        var ee;
        const ke = (ee = fromUuidSync(J.itemId)) == null ? void 0 : ee.name;
        Y[fe] = `Granted by ${ke}`;
      });
    return Y;
  }
  u(v, "getTooltipData");
  const k = p;
  pe(i, k, (V) => t(4, l = V));
  let S = Object.entries(h);
  const D = ["size"].includes(y), { weaponCategories: I, toolCategories: M } = CONFIG.A5E, L = /* @__PURE__ */ u((V) => te(l, g, V.detail), "updateSelection_handler"), B = /* @__PURE__ */ u((V) => te(l, g, V.detail), "updateSelection_handler_1"), z = /* @__PURE__ */ u((V) => te(l, g, V.detail), "updateSelection_handler_2"), q = /* @__PURE__ */ u((V) => te(l, g, V.detail), "updateSelection_handler_3"), U = /* @__PURE__ */ u(({ detail: V }) => {
    te(l, "system.details.isSquad", V);
  }, "updateSelection_handler_4"), H = /* @__PURE__ */ u(({ detail: V }) => {
    te(l, "system.details.isSwarm", V);
  }, "updateSelection_handler_5");
  return i.$$set = (V) => {
    "document" in V && t(12, p = V.document), "appId" in V && t(13, m = V.appId), "propertyKey" in V && t(0, g = V.propertyKey), "configObject" in V && t(1, h = V.configObject), "heading" in V && t(2, _ = V.heading), "type" in V && t(3, y = V.type);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, propertyKey*/
    17 && t(7, s = foundry.utils.getProperty(l, g)), i.$$.dirty & /*$actor*/
    16 && t(6, n = v()), i.$$.dirty & /*configObject*/
    2 && t(5, S = Object.entries(h));
  }, [
    g,
    h,
    _,
    y,
    l,
    S,
    n,
    s,
    k,
    D,
    I,
    M,
    p,
    m,
    L,
    B,
    z,
    q,
    U,
    H
  ];
}
u(wV, "instance$48");
const v$ = class v$ extends re {
  constructor(e) {
    super(), oe(this, e, wV, kV, le, {
      document: 12,
      appId: 13,
      propertyKey: 0,
      configObject: 1,
      heading: 2,
      type: 3
    });
  }
};
u(v$, "DetailsConfigDialog");
let fn = v$;
function $V(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*exertionBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*exertionBonus*/
      1 && t !== (t = /*exertionBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u($V, "create_default_slot_1$1p");
function AV(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [$V] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, exertionBonus*/
      8193 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(AV, "create_default_slot$2l");
function EV(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h;
  return d = new De({
    props: {
      $$slots: { default: [AV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), b(s, "class", "bonus-image svelte-1lr65k0"), ze(s.src, n = /*exertionBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*exertionBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*exertionBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1lr65k0"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1lr65k0"), b(t, "class", "sheet-header svelte-1lr65k0"), G(p, "display", "contents"), G(p, "--a5e-section-margin", "0.25rem 0"), b(e, "class", "svelte-1lr65k0");
    },
    m(_, y) {
      T(_, e, y), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), m = !0, g || (h = [
        W(
          s,
          "click",
          /*click_handler*/
          i[8]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[9]
        )
      ], g = !0);
    },
    p(_, [y]) {
      (!m || y & /*exertionBonus*/
      1 && !ze(s.src, n = /*exertionBonus*/
      _[0].img)) && b(s, "src", n), (!m || y & /*exertionBonus*/
      1 && l !== (l = /*exertionBonus*/
      _[0].label)) && b(s, "alt", l), (!m || y & /*exertionBonus*/
      1 && c !== (c = /*exertionBonus*/
      _[0].label ?? "") && a.value !== c) && (a.value = c);
      const v = {};
      y & /*$$scope, exertionBonus*/
      8193 && (v.$$scope = { dirty: y, ctx: _ }), d.$set(v);
    },
    i(_) {
      m || (w(d.$$.fragment, _), m = !0);
    },
    o(_) {
      O(d.$$.fragment, _), m = !1;
    },
    d(_) {
      _ && C(e), N(d), g = !1, Me(h);
    }
  };
}
u(EV, "create_fragment$4g");
function SV(i, e, t) {
  let s, n, { document: l, bonusID: r } = de("#external").application, { document: o = l, bonusID: a = r } = e, { jsonValue: c = null } = e;
  const f = o;
  pe(i, f, (v) => t(7, n = v));
  const d = ft();
  function p() {
    const v = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: v,
      callback: /* @__PURE__ */ u((S) => {
        m("img", S);
      }, "callback")
    }).browse();
  }
  u(p, "updateImage");
  function m(v, k) {
    if (c === null) {
      v = `system.bonuses.exertion.${a}.${v}`, te(n, v, k);
      return;
    }
    const S = foundry.utils.expandObject({ ...s, [v]: k });
    d("change", JSON.stringify(S));
  }
  u(m, "onUpdateValue");
  function g() {
    if (c === null) return n.system.bonuses.exertion[a];
    try {
      const v = JSON.parse(c || '""') ?? {};
      if (typeof v != "object") throw new Error();
      return v.label = v.label ?? "", v.formula = v.formula ?? "", v.img = v.img || "icons/svg/upgrade.svg", v;
    } catch {
      return {
        label: "",
        formula: "",
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  u(g, "getExertionBonus");
  const h = /* @__PURE__ */ u(() => p(), "click_handler"), _ = /* @__PURE__ */ u(({ target: v }) => m("label", v.value), "change_handler"), y = /* @__PURE__ */ u(({ target: v }) => m("formula", v.value), "change_handler_1");
  return i.$$set = (v) => {
    "document" in v && t(4, o = v.document), "bonusID" in v && t(5, a = v.bonusID), "jsonValue" in v && t(6, c = v.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    192 && t(0, s = g() ?? {});
  }, [
    s,
    f,
    p,
    m,
    o,
    a,
    c,
    n,
    h,
    _,
    y
  ];
}
u(SV, "instance$47");
const k$ = class k$ extends re {
  constructor(e) {
    super(), oe(this, e, SV, EV, le, { document: 4, bonusID: 5, jsonValue: 6 });
  }
};
u(k$, "ExertionBonusConfigDialog");
let pb = k$;
function CV(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*initiativeBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*initiativeBonus*/
      1 && t !== (t = /*initiativeBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(CV, "create_default_slot_3$K");
function TV(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [CV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, initiativeBonus*/
      1048577 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(TV, "create_default_slot_2$12");
function OV(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Select Ability Bonus Automatically in Roll Prompt",
      checked: (
        /*initiativeBonus*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*initiativeBonus*/
      1 && (l.checked = /*initiativeBonus*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(OV, "create_default_slot_1$1o");
function DV(i) {
  let e, t, s, n, l, r;
  return e = new tt({
    props: {
      heading: "A5E.contexts.abilities",
      options: Object.entries(
        /*abilities*/
        i[6]
      ),
      selected: (
        /*abilitiesContext*/
        i[2]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[15]
  ), s = new tt({
    props: {
      heading: "A5E.contexts.skills",
      options: Object.entries(
        /*skills*/
        i[7]
      ),
      selected: (
        /*skillsContext*/
        i[1]
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[16]
  ), l = new ie({
    props: {
      $$slots: { default: [OV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), R(s, o, a), T(o, n, a), R(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*abilitiesContext*/
      4 && (c.selected = /*abilitiesContext*/
      o[2]), e.$set(c);
      const f = {};
      a & /*skillsContext*/
      2 && (f.selected = /*skillsContext*/
      o[1]), s.$set(f);
      const d = {};
      a & /*$$scope, initiativeBonus*/
      1048577 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(s.$$.fragment, o), O(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (C(t), C(n)), N(e, o), N(s, o), N(l, o);
    }
  };
}
u(DV, "create_default_slot$2k");
function IV(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v;
  return d = new De({
    props: {
      $$slots: { default: [TV] },
      $$scope: { ctx: i }
    }
  }), g = new De({
    props: {
      heading: "Contexts",
      hint: "The context determines when the ability bonus applies",
      $$slots: { default: [DV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), h = E("div"), j(g.$$.fragment), b(s, "class", "bonus-image svelte-1lr65k0"), ze(s.src, n = /*initiativeBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*initiativeBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*initiativeBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1lr65k0"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1lr65k0"), b(t, "class", "sheet-header svelte-1lr65k0"), G(p, "display", "contents"), G(p, "--a5e-section-margin", "0.25rem 0"), G(h, "display", "contents"), G(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1lr65k0");
    },
    m(k, S) {
      T(k, e, S), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), A(e, h), R(g, h, null), _ = !0, y || (v = [
        W(
          s,
          "click",
          /*click_handler*/
          i[12]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[13]
        )
      ], y = !0);
    },
    p(k, [S]) {
      (!_ || S & /*initiativeBonus*/
      1 && !ze(s.src, n = /*initiativeBonus*/
      k[0].img)) && b(s, "src", n), (!_ || S & /*initiativeBonus*/
      1 && l !== (l = /*initiativeBonus*/
      k[0].label)) && b(s, "alt", l), (!_ || S & /*initiativeBonus*/
      1 && c !== (c = /*initiativeBonus*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const D = {};
      S & /*$$scope, initiativeBonus*/
      1048577 && (D.$$scope = { dirty: S, ctx: k }), d.$set(D);
      const I = {};
      S & /*$$scope, initiativeBonus, skillsContext, abilitiesContext*/
      1048583 && (I.$$scope = { dirty: S, ctx: k }), g.$set(I);
    },
    i(k) {
      _ || (w(d.$$.fragment, k), w(g.$$.fragment, k), _ = !0);
    },
    o(k) {
      O(d.$$.fragment, k), O(g.$$.fragment, k), _ = !1;
    },
    d(k) {
      k && C(e), N(d), N(g), y = !1, Me(v);
    }
  };
}
u(IV, "create_fragment$4f");
function PV(i, e, t) {
  let s, n, l, r, { document: o, bonusID: a } = de("#external").application, { document: c = o, bonusID: f = a } = e, { jsonValue: d = null } = e;
  const p = c;
  pe(i, p, (B) => t(11, r = B));
  const m = ft();
  function g() {
    const B = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: B,
      callback: /* @__PURE__ */ u((q) => {
        h("img", q);
      }, "callback")
    }).browse();
  }
  u(g, "updateImage");
  function h(B, z) {
    if (d === null) {
      B = `system.bonuses.initiative.${f}.${B}`, te(r, B, z);
      return;
    }
    const q = foundry.utils.expandObject({ ...s, [B]: z });
    m("change", JSON.stringify(q));
  }
  u(h, "onUpdateValue");
  function _() {
    if (d === null) return r.system.bonuses.initiative[f];
    try {
      const B = JSON.parse(d || '""') ?? {};
      if (typeof B != "object") throw new Error();
      return B.label = B.label ?? "", B.formula = B.formula ?? "", B.context = B.context ?? {
        abilities: Object.keys(CONFIG.A5E.abilities),
        skills: Object.keys(CONFIG.A5E.skills)
      }, B.default = B.default ?? !0, B.img = B.img || "icons/svg/upgrade.svg", B;
    } catch {
      return {
        label: "",
        formula: "",
        damageType: "",
        context: {
          abilities: Object.keys(CONFIG.A5E.abilities),
          skills: Object.keys(CONFIG.A5E.skills)
        },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  u(_, "getAbilityBonus");
  const { abilities: y, skills: v } = CONFIG.A5E, k = /* @__PURE__ */ u(() => g(), "click_handler"), S = /* @__PURE__ */ u(({ target: B }) => h("label", B.value), "change_handler"), D = /* @__PURE__ */ u(({ target: B }) => h("formula", B.value), "change_handler_1"), I = /* @__PURE__ */ u(({ detail: B }) => {
    h("context.abilities", B);
  }, "updateSelection_handler"), M = /* @__PURE__ */ u(({ detail: B }) => {
    h("context.skills", B);
  }, "updateSelection_handler_1"), L = /* @__PURE__ */ u(({ detail: B }) => {
    h("default", B);
  }, "updateSelection_handler_2");
  return i.$$set = (B) => {
    "document" in B && t(8, c = B.document), "bonusID" in B && t(9, f = B.bonusID), "jsonValue" in B && t(10, d = B.jsonValue);
  }, i.$$.update = () => {
    var B, z;
    i.$$.dirty & /*$actor, jsonValue*/
    3072 && t(0, s = _() ?? {}), i.$$.dirty & /*initiativeBonus*/
    1 && t(2, n = ((B = s.context) == null ? void 0 : B.abilities) ?? []), i.$$.dirty & /*initiativeBonus*/
    1 && t(1, l = ((z = s.context) == null ? void 0 : z.skills) ?? []);
  }, [
    s,
    l,
    n,
    p,
    g,
    h,
    y,
    v,
    c,
    f,
    d,
    r,
    k,
    S,
    D,
    I,
    M,
    L
  ];
}
u(PV, "instance$46");
const w$ = class w$ extends re {
  constructor(e) {
    super(), oe(this, e, PV, IV, le, { document: 8, bonusID: 9, jsonValue: 10 });
  }
};
u(w$, "InitiativeBonusConfigDialog");
let pp = w$;
function JO(i, e, t) {
  const s = i.slice();
  return s[22] = e[t][0], s[23] = e[t][1], s;
}
u(JO, "get_each_context$1E");
function MV(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*healingBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*healingBonus*/
      1 && t !== (t = /*healingBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(MV, "create_default_slot_4$s");
function ZO(i, e) {
  let t, s = K(
    /*name*/
    e[23]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = Q(s), l = F(), t.__value = /*key*/
      e[22], He(t, t.__value), t.selected = r = /*healingBonus*/
      e[0].healingType === /*key*/
      e[22], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*healingBonus*/
      1 && r !== (r = /*healingBonus*/
      e[0].healingType === /*key*/
      e[22]) && (t.selected = r);
    },
    d(o) {
      o && C(t);
    }
  };
}
u(ZO, "create_each_block$1E");
function FV(i) {
  let e, t, s = K("A5E.None") + "", n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, f, d = ue(Object.entries(
    /*healingTypes*/
    i[7]
  ));
  const p = /* @__PURE__ */ u((m) => (
    /*key*/
    m[22]
  ), "get_key");
  for (let m = 0; m < d.length; m += 1) {
    let g = JO(i, d, m), h = p(g);
    a.set(h, o[m] = ZO(h, g));
  }
  return {
    c() {
      e = E("select"), t = E("option"), n = Q(s), l = F();
      for (let m = 0; m < o.length; m += 1)
        o[m].c();
      t.__value = null, He(t, t.__value), t.selected = r = /*healingBonus*/
      i[0].healingType === "null" || /*healingBonus*/
      i[0].healingType === null, b(e, "class", "u-w-fit healing-type-select");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, n), A(t, l);
      for (let h = 0; h < o.length; h += 1)
        o[h] && o[h].m(e, null);
      c || (f = W(
        e,
        "change",
        /*change_handler_2*/
        i[16]
      ), c = !0);
    },
    p(m, g) {
      g & /*healingBonus*/
      1 && r !== (r = /*healingBonus*/
      m[0].healingType === "null" || /*healingBonus*/
      m[0].healingType === null) && (t.selected = r), g & /*Object, healingTypes, healingBonus*/
      129 && (d = ue(Object.entries(
        /*healingTypes*/
        m[7]
      )), o = Lt(o, g, p, 1, m, d, a, e, an, ZO, null, JO));
    },
    d(m) {
      m && C(e);
      for (let g = 0; g < o.length; g += 1)
        o[g].d();
      c = !1, f();
    }
  };
}
u(FV, "create_default_slot_3$J");
function RV(i) {
  let e, t, s, n, l;
  return e = new ie({
    props: {
      heading: "A5E.HealingFormula",
      $$slots: { default: [MV] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.HealingType",
      $$slots: { default: [FV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-grow", "1");
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), T(r, s, o), R(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$$scope, healingBonus*/
      67108865 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, healingBonus*/
      67108865 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(s), r && e && C(t), N(e, r), N(n, r);
    }
  };
}
u(RV, "create_default_slot_2$11");
function NV(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Select Healing Bonus Automatically in Roll Prompt",
      checked: (
        /*healingBonus*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[19]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*healingBonus*/
      1 && (l.checked = /*healingBonus*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(NV, "create_default_slot_1$1n");
function jV(i) {
  let e, t, s, n, l, r;
  return e = new tt({
    props: {
      heading: "A5E.contexts.healingType",
      options: Object.entries(
        /*healingBonusContexts*/
        i[6]
      ),
      selected: (
        /*healingTypesContext*/
        i[2]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[17]
  ), s = new tt({
    props: {
      heading: "A5E.contexts.spellLevel",
      options: Object.entries(
        /*spellLevels*/
        i[8]
      ),
      selected: (
        /*spellLevelsContext*/
        i[1]
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[18]
  ), l = new ie({
    props: {
      $$slots: { default: [NV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), R(s, o, a), T(o, n, a), R(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*healingTypesContext*/
      4 && (c.selected = /*healingTypesContext*/
      o[2]), e.$set(c);
      const f = {};
      a & /*spellLevelsContext*/
      2 && (f.selected = /*spellLevelsContext*/
      o[1]), s.$set(f);
      const d = {};
      a & /*$$scope, healingBonus*/
      67108865 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(s.$$.fragment, o), O(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (C(t), C(n)), N(e, o), N(s, o), N(l, o);
    }
  };
}
u(jV, "create_default_slot$2j");
function LV(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v;
  return d = new De({
    props: {
      $$slots: { default: [RV] },
      $$scope: { ctx: i }
    }
  }), g = new De({
    props: {
      heading: "Contexts",
      hint: "The context determines when the healing bonus applies",
      $$slots: { default: [jV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), h = E("div"), j(g.$$.fragment), b(s, "class", "bonus-image svelte-1lr65k0"), ze(s.src, n = /*healingBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*healingBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*healingBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1lr65k0"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1lr65k0"), b(t, "class", "sheet-header svelte-1lr65k0"), G(p, "display", "contents"), G(p, "--a5e-section-body-direction", "row"), G(p, "--a5e-section-margin", "0.25rem 0"), G(h, "display", "contents"), G(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1lr65k0");
    },
    m(k, S) {
      T(k, e, S), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), A(e, h), R(g, h, null), _ = !0, y || (v = [
        W(
          s,
          "click",
          /*click_handler*/
          i[13]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[14]
        )
      ], y = !0);
    },
    p(k, [S]) {
      (!_ || S & /*healingBonus*/
      1 && !ze(s.src, n = /*healingBonus*/
      k[0].img)) && b(s, "src", n), (!_ || S & /*healingBonus*/
      1 && l !== (l = /*healingBonus*/
      k[0].label)) && b(s, "alt", l), (!_ || S & /*healingBonus*/
      1 && c !== (c = /*healingBonus*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const D = {};
      S & /*$$scope, healingBonus*/
      67108865 && (D.$$scope = { dirty: S, ctx: k }), d.$set(D);
      const I = {};
      S & /*$$scope, healingBonus, spellLevelsContext, healingTypesContext*/
      67108871 && (I.$$scope = { dirty: S, ctx: k }), g.$set(I);
    },
    i(k) {
      _ || (w(d.$$.fragment, k), w(g.$$.fragment, k), _ = !0);
    },
    o(k) {
      O(d.$$.fragment, k), O(g.$$.fragment, k), _ = !1;
    },
    d(k) {
      k && C(e), N(d), N(g), y = !1, Me(v);
    }
  };
}
u(LV, "create_fragment$4e");
function BV(i, e, t) {
  let s, n, l, r, { document: o, bonusID: a } = de("#external").application, { document: c = o, bonusID: f = a } = e, { jsonValue: d = null } = e;
  const p = c;
  pe(i, p, (q) => t(12, r = q));
  const m = ft();
  function g() {
    const q = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: q,
      callback: /* @__PURE__ */ u((H) => {
        h("img", H);
      }, "callback")
    }).browse();
  }
  u(g, "updateImage");
  function h(q, U) {
    if (d === null) {
      q = `system.bonuses.healing.${f}.${q}`, te(r, q, U);
      return;
    }
    const H = foundry.utils.expandObject({ ...s, [q]: U });
    m("change", JSON.stringify(H));
  }
  u(h, "onUpdateValue");
  function _() {
    if (d === null) return r.system.bonuses.healing[f];
    try {
      const q = JSON.parse(d || '""') ?? {};
      if (typeof q != "object") throw new Error();
      return q.label = q.label ?? "", q.formula = q.formula ?? "", q.healingType = q.healingType ?? "", q.context = q.context ?? { healingTypes: [], spellLevels: [] }, q.default = q.default ?? !0, q.img = q.img || "icons/svg/upgrade.svg", q;
    } catch {
      return {
        label: "",
        formula: "",
        healingType: "",
        context: { healingTypes: [], spellLevels: [] },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  u(_, "getHealingBonus");
  const { healingBonusContexts: y, healingTypes: v, spellLevels: k } = CONFIG.A5E, S = /* @__PURE__ */ u(() => g(), "click_handler"), D = /* @__PURE__ */ u(({ target: q }) => h("label", q.value), "change_handler"), I = /* @__PURE__ */ u(({ target: q }) => h("formula", q.value), "change_handler_1"), M = /* @__PURE__ */ u(({ target: q }) => h("healingType", q.value), "change_handler_2"), L = /* @__PURE__ */ u(({ detail: q }) => h("context.healingTypes", q), "updateSelection_handler"), B = /* @__PURE__ */ u(({ detail: q }) => h("context.spellLevels", q), "updateSelection_handler_1"), z = /* @__PURE__ */ u(({ detail: q }) => {
    h("default", q);
  }, "updateSelection_handler_2");
  return i.$$set = (q) => {
    "document" in q && t(9, c = q.document), "bonusID" in q && t(10, f = q.bonusID), "jsonValue" in q && t(11, d = q.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    6144 && t(0, s = _() ?? {}), i.$$.dirty & /*healingBonus*/
    1 && t(2, n = s.context.healingTypes ?? []), i.$$.dirty & /*healingBonus*/
    1 && t(1, l = s.context.spellLevels ?? []);
  }, [
    s,
    l,
    n,
    p,
    g,
    h,
    y,
    v,
    k,
    c,
    f,
    d,
    r,
    S,
    D,
    I,
    M,
    L,
    B,
    z
  ];
}
u(BV, "instance$45");
const $$ = class $$ extends re {
  constructor(e) {
    super(), oe(this, e, BV, LV, le, { document: 9, bonusID: 10, jsonValue: 11 });
  }
};
u($$, "HealingBonusConfigDialog");
let mp = $$;
function qV(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*hitPointsBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*hitPointsBonus*/
      1 && t !== (t = /*hitPointsBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(qV, "create_default_slot_3$I");
function GV(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "Hit Points Formula",
      $$slots: { default: [qV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-grow", "1");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, hitPointsBonus*/
      16385 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(GV, "create_default_slot_2$10");
function zV(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "Apply Healing Bonus Every Level",
      checked: (
        /*hitPointsBonus*/
        ((s = i[0].context) == null ? void 0 : s.perLevel) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[11]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*hitPointsBonus*/
      1 && (r.checked = /*hitPointsBonus*/
      ((o = n[0].context) == null ? void 0 : o.perLevel) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(zV, "create_default_slot_1$1m");
function HV(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [zV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, hitPointsBonus*/
      16385 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(HV, "create_default_slot$2i");
function UV(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v;
  return d = new De({
    props: {
      $$slots: { default: [GV] },
      $$scope: { ctx: i }
    }
  }), g = new De({
    props: {
      heading: "Contexts",
      hint: "The context determines when the healing bonus applies",
      $$slots: { default: [HV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), h = E("div"), j(g.$$.fragment), b(s, "class", "bonus-image svelte-1lr65k0"), ze(s.src, n = /*hitPointsBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*hitPointsBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*hitPointsBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1lr65k0"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1lr65k0"), b(t, "class", "sheet-header svelte-1lr65k0"), G(p, "display", "contents"), G(p, "--a5e-section-margin", "0.25rem 0"), G(h, "display", "contents"), G(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1lr65k0");
    },
    m(k, S) {
      T(k, e, S), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), A(e, h), R(g, h, null), _ = !0, y || (v = [
        W(
          s,
          "click",
          /*click_handler*/
          i[8]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[9]
        )
      ], y = !0);
    },
    p(k, [S]) {
      (!_ || S & /*hitPointsBonus*/
      1 && !ze(s.src, n = /*hitPointsBonus*/
      k[0].img)) && b(s, "src", n), (!_ || S & /*hitPointsBonus*/
      1 && l !== (l = /*hitPointsBonus*/
      k[0].label)) && b(s, "alt", l), (!_ || S & /*hitPointsBonus*/
      1 && c !== (c = /*hitPointsBonus*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const D = {};
      S & /*$$scope, hitPointsBonus*/
      16385 && (D.$$scope = { dirty: S, ctx: k }), d.$set(D);
      const I = {};
      S & /*$$scope, hitPointsBonus*/
      16385 && (I.$$scope = { dirty: S, ctx: k }), g.$set(I);
    },
    i(k) {
      _ || (w(d.$$.fragment, k), w(g.$$.fragment, k), _ = !0);
    },
    o(k) {
      O(d.$$.fragment, k), O(g.$$.fragment, k), _ = !1;
    },
    d(k) {
      k && C(e), N(d), N(g), y = !1, Me(v);
    }
  };
}
u(UV, "create_fragment$4d");
function VV(i, e, t) {
  let s, n, { document: l, bonusID: r } = de("#external").application, { document: o = l, bonusID: a = r } = e, { jsonValue: c = null } = e;
  const f = o;
  pe(i, f, (k) => t(7, n = k));
  const d = ft();
  function p() {
    const k = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: k,
      callback: /* @__PURE__ */ u((D) => {
        m("img", D);
      }, "callback")
    }).browse();
  }
  u(p, "updateImage");
  function m(k, S) {
    if (c === null) {
      k = `system.bonuses.hitPoint.${a}.${k}`, te(n, k, S);
      return;
    }
    const D = foundry.utils.expandObject({ ...s, [k]: S });
    d("change", JSON.stringify(D));
  }
  u(m, "onUpdateValue");
  function g() {
    if (c === null) return n.system.bonuses.hitPoint[a];
    try {
      const k = JSON.parse(c || '""') ?? {};
      if (typeof k != "object") throw new Error();
      return k.label = k.label ?? "", k.formula = k.formula ?? "", k.context = k.context ?? { perLevel: !1 }, k.default = k.default ?? !0, k.img = k.img || "icons/svg/upgrade.svg", k;
    } catch {
      return {
        label: "",
        formula: "",
        context: { perLevel: !1 },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  u(g, "getHealingBonus");
  const h = /* @__PURE__ */ u(() => p(), "click_handler"), _ = /* @__PURE__ */ u(({ target: k }) => m("label", k.value), "change_handler"), y = /* @__PURE__ */ u(({ target: k }) => m("formula", k.value), "change_handler_1"), v = /* @__PURE__ */ u(({ detail: k }) => {
    m("context.perLevel", k);
  }, "updateSelection_handler");
  return i.$$set = (k) => {
    "document" in k && t(4, o = k.document), "bonusID" in k && t(5, a = k.bonusID), "jsonValue" in k && t(6, c = k.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    192 && t(0, s = g() ?? {});
  }, [
    s,
    f,
    p,
    m,
    o,
    a,
    c,
    n,
    h,
    _,
    y,
    v
  ];
}
u(VV, "instance$44");
const A$ = class A$ extends re {
  constructor(e) {
    super(), oe(this, e, VV, UV, le, { document: 4, bonusID: 5, jsonValue: 6 });
  }
};
u(A$, "HitPointsBonusConfigDialog");
let mb = A$;
function QO(i, e, t) {
  const s = i.slice();
  return s[20] = e[t][0], s[21] = e[t][1], s;
}
u(QO, "get_each_context$1D");
function WV(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*movementBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*movementBonus*/
      1 && t !== (t = /*movementBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(WV, "create_default_slot_4$r");
function xO(i, e) {
  let t, s = K(
    /*name*/
    e[21]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = Q(s), l = F(), t.__value = /*key*/
      e[20], He(t, t.__value), t.selected = r = /*movementBonus*/
      e[0].unit === /*key*/
      e[20], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*movementBonus*/
      1 && r !== (r = /*movementBonus*/
      e[0].unit === /*key*/
      e[20]) && (t.selected = r);
    },
    d(o) {
      o && C(t);
    }
  };
}
u(xO, "create_each_block$1D");
function KV(i) {
  let e, t, s = K("A5E.None") + "", n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, f, d = ue(Object.entries(
    /*distanceUnits*/
    i[7]
  ));
  const p = /* @__PURE__ */ u((m) => (
    /*key*/
    m[20]
  ), "get_key");
  for (let m = 0; m < d.length; m += 1) {
    let g = QO(i, d, m), h = p(g);
    a.set(h, o[m] = xO(h, g));
  }
  return {
    c() {
      e = E("select"), t = E("option"), n = Q(s), l = F();
      for (let m = 0; m < o.length; m += 1)
        o[m].c();
      t.__value = null, He(t, t.__value), t.selected = r = /*movementBonus*/
      i[0].unit === "null" || /*movementBonus*/
      i[0].unit === null, b(e, "class", "u-w-fit damage-type-select");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, n), A(t, l);
      for (let h = 0; h < o.length; h += 1)
        o[h] && o[h].m(e, null);
      c || (f = W(
        e,
        "change",
        /*change_handler_2*/
        i[15]
      ), c = !0);
    },
    p(m, g) {
      g & /*movementBonus*/
      1 && r !== (r = /*movementBonus*/
      m[0].unit === "null" || /*movementBonus*/
      m[0].unit === null) && (t.selected = r), g & /*Object, distanceUnits, movementBonus*/
      129 && (d = ue(Object.entries(
        /*distanceUnits*/
        m[7]
      )), o = Lt(o, g, p, 1, m, d, a, e, an, xO, null, QO));
    },
    d(m) {
      m && C(e);
      for (let g = 0; g < o.length; g += 1)
        o[g].d();
      c = !1, f();
    }
  };
}
u(KV, "create_default_slot_3$H");
function YV(i) {
  let e, t, s, n, l, r;
  return e = new ie({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [WV] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.Unit",
      $$slots: { default: [KV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-grow", "1"), G(l, "display", "contents"), G(l, "--background", "none"), G(l, "--direction", "column"), G(l, "--padding", "0");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), T(o, l, a), R(n, l, null), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, movementBonus*/
      16777217 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const f = {};
      a & /*$$scope, movementBonus*/
      16777217 && (f.$$scope = { dirty: a, ctx: o }), n.$set(f);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && C(s), o && e && C(t), N(e, o), o && n && C(l), N(n, o);
    }
  };
}
u(YV, "create_default_slot_2$$");
function XV(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Is Hover For Flying Speed",
      checked: (
        /*isHover*/
        i[1] ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*isHover*/
      2 && (l.checked = /*isHover*/
      s[1] ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(XV, "create_default_slot_1$1l");
function JV(i) {
  let e, t, s, n;
  return e = new tt({
    props: {
      heading: "A5E.contexts.movementTypes",
      options: Object.entries(
        /*movement*/
        i[6]
      ),
      selected: (
        /*movementTypes*/
        i[2]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  ), s = new ie({
    props: {
      $$slots: { default: [XV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*movementTypes*/
      4 && (o.selected = /*movementTypes*/
      l[2]), e.$set(o);
      const a = {};
      r & /*$$scope, isHover*/
      16777218 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(JV, "create_default_slot$2h");
function ZV(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v;
  return d = new De({
    props: {
      $$slots: { default: [YV] },
      $$scope: { ctx: i }
    }
  }), g = new De({
    props: {
      heading: "Contexts",
      hint: "The context determines when the ability bonus applies",
      $$slots: { default: [JV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), h = E("div"), j(g.$$.fragment), b(s, "class", "bonus-image svelte-1lr65k0"), ze(s.src, n = /*movementBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*movementBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*movementBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1lr65k0"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1lr65k0"), b(t, "class", "sheet-header svelte-1lr65k0"), G(p, "display", "contents"), G(p, "--a5e-section-body-direction", "row"), G(p, "--a5e-section-margin", "0.25rem 0"), G(h, "display", "contents"), G(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1lr65k0");
    },
    m(k, S) {
      T(k, e, S), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), A(e, h), R(g, h, null), _ = !0, y || (v = [
        W(
          s,
          "click",
          /*click_handler*/
          i[12]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[13]
        )
      ], y = !0);
    },
    p(k, [S]) {
      (!_ || S & /*movementBonus*/
      1 && !ze(s.src, n = /*movementBonus*/
      k[0].img)) && b(s, "src", n), (!_ || S & /*movementBonus*/
      1 && l !== (l = /*movementBonus*/
      k[0].label)) && b(s, "alt", l), (!_ || S & /*movementBonus*/
      1 && c !== (c = /*movementBonus*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const D = {};
      S & /*$$scope, movementBonus*/
      16777217 && (D.$$scope = { dirty: S, ctx: k }), d.$set(D);
      const I = {};
      S & /*$$scope, isHover, movementTypes*/
      16777222 && (I.$$scope = { dirty: S, ctx: k }), g.$set(I);
    },
    i(k) {
      _ || (w(d.$$.fragment, k), w(g.$$.fragment, k), _ = !0);
    },
    o(k) {
      O(d.$$.fragment, k), O(g.$$.fragment, k), _ = !1;
    },
    d(k) {
      k && C(e), N(d), N(g), y = !1, Me(v);
    }
  };
}
u(ZV, "create_fragment$4c");
function QV(i, e, t) {
  let s, n, l, r, { document: o, bonusID: a } = de("#external").application, { document: c = o, bonusID: f = a } = e, { jsonValue: d = null } = e;
  const p = c;
  pe(i, p, (B) => t(11, r = B));
  const m = ft();
  function g() {
    const B = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: B,
      callback: /* @__PURE__ */ u((q) => {
        h("img", q);
      }, "callback")
    }).browse();
  }
  u(g, "updateImage");
  function h(B, z) {
    if (d === null) {
      B = `system.bonuses.movement.${f}.${B}`, te(r, B, z);
      return;
    }
    const q = foundry.utils.expandObject({ ...s, [B]: z });
    m("change", JSON.stringify(q));
  }
  u(h, "onUpdateValue");
  function _() {
    if (d === null) return r.system.bonuses.movement[f];
    try {
      const B = JSON.parse(d || '""') ?? {};
      if (typeof B != "object") throw new Error();
      return B.label = B.label ?? "", B.unit = B.unit || "feet", B.formula = B.formula ?? "", B.context = B.context ?? { movementTypes: [], isHover: !1 }, B.img = B.img || "icons/svg/upgrade.svg", B;
    } catch {
      return {
        label: "",
        formula: "",
        unit: "feet",
        damageType: "",
        context: { movementTypes: [], isHover: !1 },
        // valueIfOriginalIsZero: "",
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  u(_, "getMovementBonus");
  const { movement: y, distanceUnits: v } = CONFIG.A5E, k = /* @__PURE__ */ u(() => g(), "click_handler"), S = /* @__PURE__ */ u(({ target: B }) => h("label", B.value), "change_handler"), D = /* @__PURE__ */ u(({ target: B }) => h("formula", B.value), "change_handler_1"), I = /* @__PURE__ */ u(({ target: B }) => h("unit", B.value), "change_handler_2"), M = /* @__PURE__ */ u(({ detail: B }) => {
    h("context.movementTypes", B);
  }, "updateSelection_handler"), L = /* @__PURE__ */ u(({ detail: B }) => {
    h("context.isHover", B);
  }, "updateSelection_handler_1");
  return i.$$set = (B) => {
    "document" in B && t(8, c = B.document), "bonusID" in B && t(9, f = B.bonusID), "jsonValue" in B && t(10, d = B.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    3072 && t(0, s = _() ?? {}), i.$$.dirty & /*movementBonus*/
    1 && t(2, n = s.context.movementTypes ?? []), i.$$.dirty & /*movementBonus*/
    1 && t(1, l = s.context.isHover ?? !1);
  }, [
    s,
    l,
    n,
    p,
    g,
    h,
    y,
    v,
    c,
    f,
    d,
    r,
    k,
    S,
    D,
    I,
    M,
    L
  ];
}
u(QV, "instance$43");
const E$ = class E$ extends re {
  constructor(e) {
    super(), oe(this, e, QV, ZV, le, { document: 8, bonusID: 9, jsonValue: 10 });
  }
};
u(E$, "MovementBonusConfigDialog");
let hb = E$;
function eD(i, e, t) {
  const s = i.slice();
  return s[9] = e[t][0], s[10] = e[t][1], s;
}
u(eD, "get_each_context$1C");
function tD(i, e, t) {
  const s = i.slice();
  return s[13] = e[t][0], s[14] = e[t][1], s;
}
u(tD, "get_each_context_1$n");
function sD(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: (
        /*headings*/
        i[3][
          /*mode*/
          i[9]
        ]
      ),
      $$slots: { default: [xV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-direction", "row"), G(t, "--a5e-field-wrapper-background", "rgba(0, 0, 0, 0.05)"), G(t, "--a5e-field-wrapper-padding", "0.5rem"), G(t, "--a5e-field-wrapper-item-alignment", "center"), G(t, "--a5e-field-wrapper-label-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$actor*/
      1 && (r.heading = /*headings*/
      n[3][
        /*mode*/
        n[9]
      ]), l & /*$$scope, $actor*/
      131073 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(sD, "create_if_block$2i");
function nD(i) {
  let e, t = K(
    /*name*/
    i[14]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = Q(t), n = F(), b(
        e,
        "key",
        /*key*/
        i[13]
      ), e.__value = /*key*/
      i[13], He(e, e.__value), e.selected = l = /*movementData*/
      i[10].unit === /*key*/
      i[13];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*$actor*/
      1 && l !== (l = /*movementData*/
      r[10].unit === /*key*/
      r[13]) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(nD, "create_each_block_1$n");
function iD(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.MovementHover",
      checked: (
        /*movementData*/
        (s = i[10]) == null ? void 0 : s.hover
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*$actor*/
      1 && (r.checked = /*movementData*/
      (o = n[10]) == null ? void 0 : o.hover), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(iD, "create_if_block_1$1v");
function xV(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m = ue(Object.entries(
    /*A5E*/
    i[2].distanceUnits
  )), g = [];
  for (let _ = 0; _ < m.length; _ += 1)
    g[_] = nD(tD(i, m, _));
  let h = (
    /*mode*/
    i[9] === "fly" && iD(i)
  );
  return {
    c() {
      e = E("div"), t = E("input"), l = F(), r = E("select");
      for (let _ = 0; _ < g.length; _ += 1)
        g[_].c();
      a = F(), h && h.c(), c = F(), b(t, "class", "a5e-input"), b(t, "type", "number"), b(t, "name", s = "system.attributes.movement." + /*mode*/
      i[9] + ".distance"), t.value = n = /*movementData*/
      i[10].distance || 0, b(t, "min", "0"), b(e, "class", "u-w-20"), b(r, "class", "u-w-30"), b(r, "name", o = `system.attributes.movement.${/*mode*/
      i[9]}.unit`);
    },
    m(_, y) {
      T(_, e, y), A(e, t), T(_, l, y), T(_, r, y);
      for (let v = 0; v < g.length; v += 1)
        g[v] && g[v].m(r, null);
      T(_, a, y), h && h.m(_, y), T(_, c, y), f = !0, d || (p = [
        W(
          t,
          "change",
          /*change_handler*/
          i[6]
        ),
        W(
          r,
          "change",
          /*change_handler_1*/
          i[7]
        )
      ], d = !0);
    },
    p(_, y) {
      if ((!f || y & /*$actor*/
      1 && s !== (s = "system.attributes.movement." + /*mode*/
      _[9] + ".distance")) && b(t, "name", s), (!f || y & /*$actor*/
      1 && n !== (n = /*movementData*/
      _[10].distance || 0) && t.value !== n) && (t.value = n), y & /*Object, A5E, $actor*/
      5) {
        m = ue(Object.entries(
          /*A5E*/
          _[2].distanceUnits
        ));
        let v;
        for (v = 0; v < m.length; v += 1) {
          const k = tD(_, m, v);
          g[v] ? g[v].p(k, y) : (g[v] = nD(k), g[v].c(), g[v].m(r, null));
        }
        for (; v < g.length; v += 1)
          g[v].d(1);
        g.length = m.length;
      }
      (!f || y & /*$actor*/
      1 && o !== (o = `system.attributes.movement.${/*mode*/
      _[9]}.unit`)) && b(r, "name", o), /*mode*/
      _[9] === "fly" ? h ? (h.p(_, y), y & /*$actor*/
      1 && w(h, 1)) : (h = iD(_), h.c(), w(h, 1), h.m(c.parentNode, c)) : h && (ae(), O(h, 1, 1, () => {
        h = null;
      }), ce());
    },
    i(_) {
      f || (w(h), f = !0);
    },
    o(_) {
      O(h), f = !1;
    },
    d(_) {
      _ && (C(e), C(l), C(r), C(a), C(c)), Le(g, _), h && h.d(_), d = !1, Me(p);
    }
  };
}
u(xV, "create_default_slot$2g");
function lD(i) {
  let e, t, s = (
    /*mode*/
    i[9] != "traits" && sD(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*mode*/
      n[9] != "traits" ? s ? (s.p(n, l), l & /*$actor*/
      1 && w(s, 1)) : (s = sD(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(lD, "create_each_block$1C");
function eW(i) {
  let e, t, s = ue(Object.entries(
    /*$actor*/
    i[0]._source.system.attributes.movement
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = lD(eD(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("article");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "svelte-1buetme");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, [o]) {
      if (o & /*headings, Object, $actor, A5E, Math, Number*/
      13) {
        s = ue(Object.entries(
          /*$actor*/
          r[0]._source.system.attributes.movement
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = eD(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = lD(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(eW, "create_fragment$4b");
function tW(i, e, t) {
  let s, { document: n, appId: l } = de("#external").application, { document: r = n, appId: o = l } = e;
  const a = r;
  pe(i, a, (g) => t(0, s = g));
  const { A5E: c } = CONFIG, f = {
    burrow: "A5E.MovementBurrowingSpeed",
    climb: "A5E.MovementClimbingSpeed",
    fly: "A5E.MovementFlyingSpeed",
    swim: "A5E.MovementSwimmingSpeed",
    walk: "A5E.MovementWalkingSpeed"
  }, d = /* @__PURE__ */ u(({ target: g }) => {
    te(s, g.name, Math.max(Number(g.value), 0));
  }, "change_handler"), p = /* @__PURE__ */ u(({ target: g }) => te(s, g.name, g.value), "change_handler_1"), m = /* @__PURE__ */ u(({ detail: g }) => {
    te(s, "system.attributes.movement.traits.hover", g);
  }, "updateSelection_handler");
  return i.$$set = (g) => {
    "document" in g && t(4, r = g.document), "appId" in g && t(5, o = g.appId);
  }, [
    s,
    a,
    c,
    f,
    r,
    o,
    d,
    p,
    m
  ];
}
u(tW, "instance$42");
const S$ = class S$ extends re {
  constructor(e) {
    super(), oe(this, e, tW, eW, le, { document: 4, appId: 5 });
  }
};
u(S$, "MovementConfigDialog");
let gb = S$;
function rD(i, e, t) {
  const s = i.slice();
  return s[19] = e[t], s;
}
u(rD, "get_each_context$1B");
function oD(i) {
  let e, t, s;
  return e = new De({
    props: {
      $$slots: { default: [lW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-padding", "0"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, consumeSupply, $actor, recoverStrifeAndFatigue, haven*/
      4194333 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(oD, "create_if_block_1$1u");
function sW(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.HavenPrompt",
      checked: (
        /*haven*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[15]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*haven*/
      4 && (l.checked = /*haven*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(sW, "create_default_slot_5$k");
function nW(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.SupplyFatigueStrifePrompt",
      checked: (
        /*recoverStrifeAndFatigue*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*recoverStrifeAndFatigue*/
      8 && (l.checked = /*recoverStrifeAndFatigue*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(nW, "create_default_slot_4$q");
function aD(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [iW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, consumeSupply*/
      4194320 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(aD, "create_if_block_2$_");
function iW(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.SupplyConsume",
      checked: (
        /*consumeSupply*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*consumeSupply*/
      16 && (l.checked = /*consumeSupply*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(iW, "create_default_slot_3$G");
function lW(i) {
  let e, t, s, n, l, r;
  e = new ie({
    props: {
      $$slots: { default: [sW] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      $$slots: { default: [nW] },
      $$scope: { ctx: i }
    }
  });
  let o = (
    /*$actor*/
    i[0].type === "character" && aD(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), o && o.c(), l = $e();
    },
    m(a, c) {
      R(e, a, c), T(a, t, c), R(s, a, c), T(a, n, c), o && o.m(a, c), T(a, l, c), r = !0;
    },
    p(a, c) {
      const f = {};
      c & /*$$scope, haven*/
      4194308 && (f.$$scope = { dirty: c, ctx: a }), e.$set(f);
      const d = {};
      c & /*$$scope, recoverStrifeAndFatigue*/
      4194312 && (d.$$scope = { dirty: c, ctx: a }), s.$set(d), /*$actor*/
      a[0].type === "character" ? o ? (o.p(a, c), c & /*$actor*/
      1 && w(o, 1)) : (o = aD(a), o.c(), w(o, 1), o.m(l.parentNode, l)) : o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce());
    },
    i(a) {
      r || (w(e.$$.fragment, a), w(s.$$.fragment, a), w(o), r = !0);
    },
    o(a) {
      O(e.$$.fragment, a), O(s.$$.fragment, a), O(o), r = !1;
    },
    d(a) {
      a && (C(t), C(n), C(l)), N(e, a), N(s, a), o && o.d(a);
    }
  };
}
u(lW, "create_default_slot_2$_");
function cD(i) {
  let e, t, s;
  return e = new De({
    props: {
      $$slots: { default: [oW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-padding", "0");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, hitDice*/
      4194336 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(cD, "create_if_block$2h");
function uD(i) {
  let e, t, s, n, l, r = (
    /*hitDice*/
    i[5][
      /*die*/
      i[19]
    ].current + ""
  ), o, a, c, f;
  function d() {
    return (
      /*click_handler*/
      i[18](
        /*die*/
        i[19]
      )
    );
  }
  return u(d, "click_handler"), {
    c() {
      e = E("div"), t = E("div"), s = E("span"), s.textContent = `${/*die*/
      i[19]}`, n = F(), l = E("span"), o = Q(r), a = F(), b(s, "class", "a5e-hit-die__label"), b(t, "class", "a5e-hit-die a5e-hit-die--rollable a5e-hit-die--" + /*die*/
      i[19] + " svelte-akbbr2"), Z(
        t,
        "disabled",
        /*hitDice*/
        i[5][
          /*die*/
          i[19]
        ].current === 0
      ), b(l, "class", "a5e-hit-die__quantity"), b(e, "class", "a5e-hit-die-wrapper");
    },
    m(p, m) {
      T(p, e, m), A(e, t), A(t, s), A(e, n), A(e, l), A(l, o), A(e, a), c || (f = W(t, "click", d), c = !0);
    },
    p(p, m) {
      i = p, m & /*hitDice*/
      32 && Z(
        t,
        "disabled",
        /*hitDice*/
        i[5][
          /*die*/
          i[19]
        ].current === 0
      ), m & /*hitDice*/
      32 && r !== (r = /*hitDice*/
      i[5][
        /*die*/
        i[19]
      ].current + "") && be(o, r);
    },
    d(p) {
      p && C(e), c = !1, f();
    }
  };
}
u(uD, "create_each_block$1B");
function rW(i) {
  let e, t = ue(["d6", "d8", "d10", "d12"]), s = [];
  for (let n = 0; n < 4; n += 1)
    s[n] = uD(rD(i, t, n));
  return {
    c() {
      e = E("div");
      for (let n = 0; n < 4; n += 1)
        s[n].c();
      b(e, "class", "u-flex u-gap-md u-text-md");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < 4; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*hitDice, rollHitDie*/
      544) {
        t = ue(["d6", "d8", "d10", "d12"]);
        let r;
        for (r = 0; r < 4; r += 1) {
          const o = rD(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = uD(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < 4; r += 1)
          s[r].d(1);
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(rW, "create_default_slot_1$1k");
function oW(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.HitDiceLabel",
      $$slots: { default: [rW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, hitDice*/
      4194336 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(oW, "create_default_slot$2f");
function aW(i) {
  let e, t, s, n, l, r, o, a, c = K("A5E.Rest") + "", f, d, p, m;
  t = new Ke({
    props: {
      heading: "A5E.RestType",
      options: Object.entries(
        /*restTypeOptions*/
        i[7]
      ),
      selected: (
        /*restType*/
        i[1]
      )
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  );
  let g = (
    /*restType*/
    i[1] === "long" && !/*simpleRests*/
    i[8] && oD(i)
  ), h = (
    /*restType*/
    i[1] === "short" && cD(i)
  );
  return {
    c() {
      e = E("form"), j(t.$$.fragment), s = F(), g && g.c(), n = F(), h && h.c(), l = F(), r = E("button"), o = E("i"), a = F(), f = Q(c), b(o, "class", "fas fa-campground"), b(r, "class", "a5e-button"), b(e, "class", "form svelte-akbbr2");
    },
    m(_, y) {
      T(_, e, y), R(t, e, null), A(e, s), g && g.m(e, null), A(e, n), h && h.m(e, null), A(e, l), A(e, r), A(r, o), A(r, a), A(r, f), d = !0, p || (m = W(r, "click", st(
        /*onSubmit*/
        i[10]
      )), p = !0);
    },
    p(_, [y]) {
      const v = {};
      y & /*restType*/
      2 && (v.selected = /*restType*/
      _[1]), t.$set(v), /*restType*/
      _[1] === "long" && !/*simpleRests*/
      _[8] ? g ? (g.p(_, y), y & /*restType*/
      2 && w(g, 1)) : (g = oD(_), g.c(), w(g, 1), g.m(e, n)) : g && (ae(), O(g, 1, 1, () => {
        g = null;
      }), ce()), /*restType*/
      _[1] === "short" ? h ? (h.p(_, y), y & /*restType*/
      2 && w(h, 1)) : (h = cD(_), h.c(), w(h, 1), h.m(e, l)) : h && (ae(), O(h, 1, 1, () => {
        h = null;
      }), ce());
    },
    i(_) {
      d || (w(t.$$.fragment, _), w(g), w(h), d = !0);
    },
    o(_) {
      O(t.$$.fragment, _), O(g), O(h), d = !1;
    },
    d(_) {
      _ && C(e), N(t), g && g.d(), h && h.d(), p = !1, m();
    }
  };
}
u(aW, "create_fragment$4a");
function cW(i, e, t) {
  let s, n, { application: l } = de("#external"), { application: r = l } = e, { document: o, appId: a } = de("#external").application, { document: c = o, appId: f = a } = e;
  const d = c;
  pe(i, d, (B) => t(0, n = B));
  const p = {
    short: "A5E.RestShort",
    long: "A5E.RestLong"
  };
  let m = "short", g = !0, h = !0, _ = game.settings.get("a5e", "simpleRests"), y = !1;
  async function v(B) {
    try {
      await n.rollHitDice(B);
    } catch (z) {
      console.log(z);
      return;
    }
  }
  u(v, "rollHitDie");
  function k() {
    const B = game.settings.get("a5e", "simpleRests");
    r.submit({
      consumeSupply: B ? !1 : y,
      haven: B ? !0 : g,
      restType: m,
      recoverStrifeAndFatigue: B ? !0 : h
    });
  }
  u(k, "onSubmit");
  const S = /* @__PURE__ */ u(({ detail: B }) => t(1, m = B), "updateSelection_handler"), D = /* @__PURE__ */ u(({ detail: B }) => {
    t(2, g = B);
  }, "updateSelection_handler_1"), I = /* @__PURE__ */ u(({ detail: B }) => {
    t(3, h = B);
  }, "updateSelection_handler_2"), M = /* @__PURE__ */ u(({ detail: B }) => {
    t(4, y = B);
  }, "updateSelection_handler_3"), L = /* @__PURE__ */ u((B) => v(B), "click_handler");
  return i.$$set = (B) => {
    "application" in B && t(11, r = B.application), "document" in B && t(12, c = B.document), "appId" in B && t(13, f = B.appId);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(5, s = n.system.attributes.hitDice);
  }, [
    n,
    m,
    g,
    h,
    y,
    s,
    d,
    p,
    _,
    v,
    k,
    r,
    c,
    f,
    S,
    D,
    I,
    M,
    L
  ];
}
u(cW, "instance$41");
const C$ = class C$ extends re {
  constructor(e) {
    super(), oe(this, e, cW, aW, le, { application: 11, document: 12, appId: 13 });
  }
};
u(C$, "RestDialog");
let bb = C$;
function fD(i) {
  let e, t;
  return e = new vr({
    props: {
      selected: (
        /*rollMode*/
        i[4]
      ),
      source: (
        /*rollModeString*/
        i[10]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[22]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*rollMode*/
      16 && (l.selected = /*rollMode*/
      s[4]), n[0] & /*rollModeString*/
      1024 && (l.source = /*rollModeString*/
      s[10]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(fD, "create_key_block$4");
function dD(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "A5E.ItemSavingThrowType",
      options: (
        /*saveTypes*/
        i[12]
      ),
      selected: (
        /*saveType*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[24]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*saveType*/
      2 && (l.selected = /*saveType*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(dD, "create_if_block_1$1t");
function uW(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Ability Bonuses",
      options: (
        /*abilityBonuses*/
        i[14].map(mW)
      ),
      selected: (
        /*selectedAbilityBonuses*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[25]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*selectedAbilityBonuses*/
      8 && (l.selected = /*selectedAbilityBonuses*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(uW, "create_if_block$2g");
function fW(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "id", t = /*$actor*/
      i[6].id + "-" + /*appId*/
      i[15] + "-situational-mods");
    },
    m(l, r) {
      T(l, e, r), He(
        e,
        /*situationalMods*/
        i[2]
      ), s || (n = W(
        e,
        "input",
        /*input_input_handler*/
        i[26]
      ), s = !0);
    },
    p(l, r) {
      r[0] & /*$actor*/
      64 && t !== (t = /*$actor*/
      l[6].id + "-" + /*appId*/
      l[15] + "-situational-mods") && b(e, "id", t), r[0] & /*situationalMods*/
      4 && e.value !== /*situationalMods*/
      l[2] && He(
        e,
        /*situationalMods*/
        l[2]
      );
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(fW, "create_default_slot$2e");
function dW(i) {
  let e, t, s, n, l = (
    /*saveType*/
    i[1]
  ), r, o, a, c, f = Object.values(
    /*abilityBonuses*/
    i[14]
  ).flat().length, d, p, m, g, h, _, y, v, k, S, D, I;
  function M(U) {
    i[21](U);
  }
  u(M, "outputvisibilitysection_visibilityMode_binding");
  let L = {};
  /*visibilityMode*/
  i[7] !== void 0 && (L.visibilityMode = /*visibilityMode*/
  i[7]), t = new cc({ props: L }), rt.push(() => Ot(t, "visibilityMode", M));
  let B = fD(i);
  o = new hi({
    props: {
      source: (
        /*expertiseDieSource*/
        i[11]
      ),
      selected: (
        /*expertiseDie*/
        i[5]
      ),
      type: (
        /*$actor*/
        i[6].type
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[23]
  );
  let z = (
    /*abilityKey*/
    i[0] === "con" && /*saveType*/
    i[1] !== "death" && dD(i)
  ), q = f && uW(i);
  return p = new ie({
    props: {
      heading: "A5E.SituationalMods",
      $$slots: { default: [fW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), j(t.$$.fragment), n = F(), B.c(), r = F(), j(o.$$.fragment), a = F(), z && z.c(), c = F(), q && q.c(), d = F(), j(p.$$.fragment), m = F(), g = E("section"), h = Q(
        /*rollFormula*/
        i[8]
      ), _ = F(), y = E("section"), v = E("button"), k = Q(
        /*buttonText*/
        i[9]
      ), b(g, "class", "roll-formula-preview svelte-8gi69h"), b(e, "class", "svelte-8gi69h");
    },
    m(U, H) {
      T(U, e, H), R(t, e, null), A(e, n), B.m(e, null), A(e, r), R(o, e, null), A(e, a), z && z.m(e, null), A(e, c), q && q.m(e, null), A(e, d), R(p, e, null), A(e, m), A(e, g), A(g, h), A(e, _), A(e, y), A(y, v), A(v, k), S = !0, D || (I = W(v, "click", st(
        /*onSubmit*/
        i[16]
      )), D = !0);
    },
    p(U, H) {
      const V = {};
      !s && H[0] & /*visibilityMode*/
      128 && (s = !0, V.visibilityMode = /*visibilityMode*/
      U[7], It(() => s = !1)), t.$set(V), H[0] & /*saveType*/
      2 && le(l, l = /*saveType*/
      U[1]) ? (ae(), O(B, 1, 1, se), ce(), B = fD(U), B.c(), w(B, 1), B.m(e, r)) : B.p(U, H);
      const Y = {};
      H[0] & /*expertiseDieSource*/
      2048 && (Y.source = /*expertiseDieSource*/
      U[11]), H[0] & /*expertiseDie*/
      32 && (Y.selected = /*expertiseDie*/
      U[5]), H[0] & /*$actor*/
      64 && (Y.type = /*$actor*/
      U[6].type), o.$set(Y), /*abilityKey*/
      U[0] === "con" && /*saveType*/
      U[1] !== "death" ? z ? (z.p(U, H), H[0] & /*abilityKey, saveType*/
      3 && w(z, 1)) : (z = dD(U), z.c(), w(z, 1), z.m(e, c)) : z && (ae(), O(z, 1, 1, () => {
        z = null;
      }), ce()), f && q.p(U, H);
      const J = {};
      H[0] & /*$actor, situationalMods*/
      68 | H[1] & /*$$scope*/
      2 && (J.$$scope = { dirty: H, ctx: U }), p.$set(J), (!S || H[0] & /*rollFormula*/
      256) && be(
        h,
        /*rollFormula*/
        U[8]
      ), (!S || H[0] & /*buttonText*/
      512) && be(
        k,
        /*buttonText*/
        U[9]
      );
    },
    i(U) {
      S || (w(t.$$.fragment, U), w(B), w(o.$$.fragment, U), w(z), w(q), w(p.$$.fragment, U), S = !0);
    },
    o(U) {
      O(t.$$.fragment, U), O(B), O(o.$$.fragment, U), O(z), O(q), O(p.$$.fragment, U), S = !1;
    },
    d(U) {
      U && C(e), N(t), B.d(U), N(o), z && z.d(), q && q.d(), N(p), D = !1, I();
    }
  };
}
u(dW, "create_fragment$49");
function pW(i, e) {
  return e ? i === "concentration" ? "concentration" : `system.abilities.${e}.save` : "deathSave";
}
u(pW, "getRollModeKey");
const mW = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel], "func$d");
function hW(i, e, t) {
  let s, n, l, r, o, a, c, f, { document: d, abilityKey: p, dialog: m, options: g } = de("#external").application, { document: h = d, abilityKey: _ = p, dialog: y = m, options: v = g } = e;
  function k() {
    var ye, me;
    return B ? 0 : f.RollOverrideManager.getExpertiseDice(n ?? "", ((me = (ye = f.system.abilities[_]) == null ? void 0 : ye.save) == null ? void 0 : me.expertiseDice) || v.expertiseDice || 0);
  }
  u(k, "getInitialExpertiseDieSelection");
  function S(ye, me) {
    return ye === "death" ? "Roll Death Saving Throw" : me === "con" && ye === "concentration" ? K("A5E.RollConcentrationCheck") : v.dc ? K("A5E.RollPromptSavingThrowWithDC", { ability: z, dc: v.dc }) : K("A5E.RollPromptSavingThrow", { ability: z });
  }
  u(S, "getSubmitButtonText");
  const D = [
    ["standard", "A5E.SavingThrowNormal"],
    ["concentration", "A5E.ConcentrationCheck"]
  ], I = new Zt(h);
  pe(i, I, (ye) => t(6, f = ye));
  const M = f.BonusesManager.prepareAbilityBonuses(_, "save"), L = y.id, B = game.settings.get("a5e", "hideExpertiseDice"), z = K(CONFIG.A5E.abilities[_]);
  function q() {
    y.submit({
      expertiseDie: l,
      rollFormula: Y,
      rollMode: o,
      saveType: H,
      visibilityMode: U
    });
  }
  u(q, "onSubmit");
  let U = v.visibilityMode ?? game.settings.get("core", "rollMode"), H = v.saveType ?? "standard", V = v.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL, Y, J = v.situationalMods ?? "";
  function fe(ye) {
    U = ye, t(7, U);
  }
  u(fe, "outputvisibilitysection_visibilityMode_binding");
  const ke = /* @__PURE__ */ u(({ detail: ye }) => t(4, o = ye), "updateSelection_handler"), ee = /* @__PURE__ */ u(({ detail: ye }) => t(5, l = ye), "updateSelection_handler_1"), ne = /* @__PURE__ */ u((ye) => t(1, H = ye.detail), "updateSelection_handler_2"), Ee = /* @__PURE__ */ u(({ detail: ye }) => t(3, s = ye), "updateSelection_handler_3");
  function Pe() {
    J = this.value, t(2, J);
  }
  return u(Pe, "input_input_handler"), i.$$set = (ye) => {
    "document" in ye && t(17, h = ye.document), "abilityKey" in ye && t(0, _ = ye.abilityKey), "dialog" in ye && t(18, y = ye.dialog), "options" in ye && t(19, v = ye.options);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*$actor, abilityKey*/
    65 && t(3, s = f.BonusesManager.getDefaultSelections("abilities", { abilityKey: _, abilityType: "save" })), i.$$.dirty[0] & /*saveType, abilityKey*/
    3 && t(20, n = pW(H, _)), i.$$.dirty[0] & /*$actor, rollModeKey, options*/
    1572928 && t(11, r = f.RollOverrideManager.getExpertiseDiceSource(n, v.expertiseDie ?? 0)), i.$$.dirty[0] & /*$actor, rollModeKey*/
    1048640 && t(4, o = f.RollOverrideManager.getRollOverride(n, V)), i.$$.dirty[0] & /*$actor, rollModeKey*/
    1048640 && t(10, a = f.RollOverrideManager.getRollOverridesSource(n, V)), i.$$.dirty[0] & /*saveType, abilityKey*/
    3 && t(9, c = S(H, _)), i.$$.dirty[0] & /*$actor, abilityKey, expertiseDie, rollMode, saveType, situationalMods, selectedAbilityBonuses*/
    127 && t(8, Y = ll(f, {
      ability: _,
      expertiseDie: l,
      rollMode: o,
      saveType: H,
      situationalMods: J,
      selectedAbilityBonuses: s,
      type: "savingThrow"
    }));
  }, t(5, l = k()), [
    _,
    H,
    J,
    s,
    o,
    l,
    f,
    U,
    Y,
    c,
    a,
    r,
    D,
    I,
    M,
    L,
    q,
    h,
    y,
    v,
    n,
    fe,
    ke,
    ee,
    ne,
    Ee,
    Pe
  ];
}
u(hW, "instance$40");
const T$ = class T$ extends re {
  constructor(e) {
    super(), oe(
      this,
      e,
      hW,
      dW,
      le,
      {
        document: 17,
        abilityKey: 0,
        dialog: 18,
        options: 19
      },
      null,
      [-1, -1]
    );
  }
};
u(T$, "SavingThrowRollDialog");
let _b = T$;
function pD(i, e, t) {
  const s = i.slice();
  return s[20] = e[t][0], s[21] = e[t][1], s;
}
u(pD, "get_each_context$1A");
function gW(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*sensesBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*sensesBonus*/
      1 && t !== (t = /*sensesBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(gW, "create_default_slot_4$p");
function mD(i, e) {
  let t, s = K(
    /*name*/
    e[21]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = Q(s), l = F(), t.__value = /*key*/
      e[20], He(t, t.__value), t.selected = r = /*sensesBonus*/
      e[0].unit === /*key*/
      e[20], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*sensesBonus*/
      1 && r !== (r = /*sensesBonus*/
      e[0].unit === /*key*/
      e[20]) && (t.selected = r);
    },
    d(o) {
      o && C(t);
    }
  };
}
u(mD, "create_each_block$1A");
function bW(i) {
  let e, t, s = K("A5E.None") + "", n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, f, d = ue(Object.entries(
    /*visionUnits*/
    i[7]
  ));
  const p = /* @__PURE__ */ u((m) => (
    /*key*/
    m[20]
  ), "get_key");
  for (let m = 0; m < d.length; m += 1) {
    let g = pD(i, d, m), h = p(g);
    a.set(h, o[m] = mD(h, g));
  }
  return {
    c() {
      e = E("select"), t = E("option"), n = Q(s), l = F();
      for (let m = 0; m < o.length; m += 1)
        o[m].c();
      t.__value = null, He(t, t.__value), t.selected = r = /*sensesBonus*/
      i[0].unit === "null" || /*sensesBonus*/
      i[0].unit === null, b(e, "class", "u-w-fit damage-type-select");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, n), A(t, l);
      for (let h = 0; h < o.length; h += 1)
        o[h] && o[h].m(e, null);
      c || (f = W(
        e,
        "change",
        /*change_handler_2*/
        i[15]
      ), c = !0);
    },
    p(m, g) {
      g & /*sensesBonus*/
      1 && r !== (r = /*sensesBonus*/
      m[0].unit === "null" || /*sensesBonus*/
      m[0].unit === null) && (t.selected = r), g & /*Object, visionUnits, sensesBonus*/
      129 && (d = ue(Object.entries(
        /*visionUnits*/
        m[7]
      )), o = Lt(o, g, p, 1, m, d, a, e, an, mD, null, pD));
    },
    d(m) {
      m && C(e);
      for (let g = 0; g < o.length; g += 1)
        o[g].d();
      c = !1, f();
    }
  };
}
u(bW, "create_default_slot_3$F");
function _W(i) {
  let e, t, s, n, l, r;
  return e = new ie({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [gW] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.Unit",
      $$slots: { default: [bW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-grow", "1"), G(l, "display", "contents"), G(l, "--background", "none"), G(l, "--direction", "column"), G(l, "--padding", "0");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), T(o, l, a), R(n, l, null), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, sensesBonus*/
      16777217 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const f = {};
      a & /*$$scope, sensesBonus*/
      16777217 && (f.$$scope = { dirty: a, ctx: o }), n.$set(f);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && C(s), o && e && C(t), N(e, o), o && n && C(l), N(n, o);
    }
  };
}
u(_W, "create_default_slot_2$Z");
function yW(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Is Blind Beyond Vision Range",
      checked: (
        /*otherwiseBlind*/
        i[1] ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*otherwiseBlind*/
      2 && (l.checked = /*otherwiseBlind*/
      s[1] ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(yW, "create_default_slot_1$1j");
function vW(i) {
  let e, t, s, n;
  return e = new tt({
    props: {
      heading: "A5E.contexts.senses",
      options: Object.entries(
        /*senses*/
        i[6]
      ),
      selected: (
        /*sensesTypes*/
        i[2]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  ), s = new ie({
    props: {
      $$slots: { default: [yW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*sensesTypes*/
      4 && (o.selected = /*sensesTypes*/
      l[2]), e.$set(o);
      const a = {};
      r & /*$$scope, otherwiseBlind*/
      16777218 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(vW, "create_default_slot$2d");
function kW(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v;
  return d = new De({
    props: {
      $$slots: { default: [_W] },
      $$scope: { ctx: i }
    }
  }), g = new De({
    props: {
      heading: "Contexts",
      hint: "The context determines when the ability bonus applies",
      $$slots: { default: [vW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), h = E("div"), j(g.$$.fragment), b(s, "class", "bonus-image svelte-1lr65k0"), ze(s.src, n = /*sensesBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*sensesBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*sensesBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1lr65k0"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1lr65k0"), b(t, "class", "sheet-header svelte-1lr65k0"), G(p, "display", "contents"), G(p, "--a5e-section-body-direction", "row"), G(p, "--a5e-section-margin", "0.25rem 0"), G(h, "display", "contents"), G(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1lr65k0");
    },
    m(k, S) {
      T(k, e, S), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), A(e, h), R(g, h, null), _ = !0, y || (v = [
        W(
          s,
          "click",
          /*click_handler*/
          i[12]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[13]
        )
      ], y = !0);
    },
    p(k, [S]) {
      (!_ || S & /*sensesBonus*/
      1 && !ze(s.src, n = /*sensesBonus*/
      k[0].img)) && b(s, "src", n), (!_ || S & /*sensesBonus*/
      1 && l !== (l = /*sensesBonus*/
      k[0].label)) && b(s, "alt", l), (!_ || S & /*sensesBonus*/
      1 && c !== (c = /*sensesBonus*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const D = {};
      S & /*$$scope, sensesBonus*/
      16777217 && (D.$$scope = { dirty: S, ctx: k }), d.$set(D);
      const I = {};
      S & /*$$scope, otherwiseBlind, sensesTypes*/
      16777222 && (I.$$scope = { dirty: S, ctx: k }), g.$set(I);
    },
    i(k) {
      _ || (w(d.$$.fragment, k), w(g.$$.fragment, k), _ = !0);
    },
    o(k) {
      O(d.$$.fragment, k), O(g.$$.fragment, k), _ = !1;
    },
    d(k) {
      k && C(e), N(d), N(g), y = !1, Me(v);
    }
  };
}
u(kW, "create_fragment$48");
function wW(i, e, t) {
  let s, n, l, r, { document: o, bonusID: a } = de("#external").application, { document: c = o, bonusID: f = a } = e, { jsonValue: d = null } = e;
  const p = c;
  pe(i, p, (B) => t(11, r = B));
  const m = ft();
  function g() {
    const B = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: B,
      callback: /* @__PURE__ */ u((q) => {
        h("img", q);
      }, "callback")
    }).browse();
  }
  u(g, "updateImage");
  function h(B, z) {
    if (d === null) {
      B = `system.bonuses.senses.${f}.${B}`, te(r, B, z);
      return;
    }
    const q = foundry.utils.expandObject({ ...s, [B]: z });
    m("change", JSON.stringify(q));
  }
  u(h, "onUpdateValue");
  function _() {
    if (d === null) return r.system.bonuses.senses[f];
    try {
      const B = JSON.parse(d || '""') ?? {};
      if (typeof B != "object") throw new Error();
      return B.label = B.label ?? "", B.unit = B.unit || "feet", B.formula = B.formula ?? "", B.context = B.context ?? { senses: [], otherwiseBlind: !1 }, B.img = B.img || "icons/svg/upgrade.svg", B;
    } catch {
      return {
        label: "",
        unit: "feet",
        formula: "",
        damageType: "",
        context: { senses: [], otherwiseBlind: !1 },
        // valueIfOriginalIsZero: "",
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  u(_, "getSensesBonus");
  const { senses: y, visionUnits: v } = CONFIG.A5E, k = /* @__PURE__ */ u(() => g(), "click_handler"), S = /* @__PURE__ */ u(({ target: B }) => h("label", B.value), "change_handler"), D = /* @__PURE__ */ u(({ target: B }) => h("formula", B.value), "change_handler_1"), I = /* @__PURE__ */ u(({ target: B }) => h("unit", B.value), "change_handler_2"), M = /* @__PURE__ */ u(({ detail: B }) => {
    h("context.senses", B);
  }, "updateSelection_handler"), L = /* @__PURE__ */ u(({ detail: B }) => {
    h("context.otherwiseBlind", B);
  }, "updateSelection_handler_1");
  return i.$$set = (B) => {
    "document" in B && t(8, c = B.document), "bonusID" in B && t(9, f = B.bonusID), "jsonValue" in B && t(10, d = B.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    3072 && t(0, s = _() ?? {}), i.$$.dirty & /*sensesBonus*/
    1 && t(2, n = s.context.senses ?? []), i.$$.dirty & /*sensesBonus*/
    1 && t(1, l = s.context.otherwiseBlind ?? !1);
  }, [
    s,
    l,
    n,
    p,
    g,
    h,
    y,
    v,
    c,
    f,
    d,
    r,
    k,
    S,
    D,
    I,
    M,
    L
  ];
}
u(wW, "instance$3$");
const O$ = class O$ extends re {
  constructor(e) {
    super(), oe(this, e, wW, kW, le, { document: 8, bonusID: 9, jsonValue: 10 });
  }
};
u(O$, "SensesBonusConfigDialog");
let yb = O$;
function hD(i, e, t) {
  const s = i.slice();
  return s[9] = e[t][0], s[10] = e[t][1], s;
}
u(hD, "get_each_context$1z");
function gD(i, e, t) {
  const s = i.slice();
  return s[13] = e[t][0], s[14] = e[t][1], s;
}
u(gD, "get_each_context_1$m");
function bD(i) {
  let e, t = K(
    /*name*/
    i[14]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = Q(t), n = F(), b(
        e,
        "key",
        /*key*/
        i[13]
      ), e.__value = /*key*/
      i[13], He(e, e.__value), e.selected = l = /*$actor*/
      i[0].system.attributes.senses[
        /*sense*/
        i[9]
      ].unit === /*key*/
      i[13];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*$actor*/
      1 && l !== (l = /*$actor*/
      r[0].system.attributes.senses[
        /*sense*/
        r[9]
      ].unit === /*key*/
      r[13]) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(bD, "create_each_block_1$m");
function _D(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "Blind Beyond this Range",
      checked: (
        /*$actor*/
        (s = i[0].system.attributes.senses.blindsight) == null ? void 0 : s.otherwiseBlind
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*$actor*/
      1 && (r.checked = /*$actor*/
      (o = n[0].system.attributes.senses.blindsight) == null ? void 0 : o.otherwiseBlind), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(_D, "create_if_block$2f");
function $W(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h = ue(Object.entries(
    /*A5E*/
    i[2].visionUnits
  )), _ = [];
  for (let v = 0; v < h.length; v += 1)
    _[v] = bD(gD(i, h, v));
  let y = (
    /*sense*/
    i[9] === "blindsight" && _D(i)
  );
  return {
    c() {
      e = E("div"), t = E("input"), o = F(), a = E("select");
      for (let v = 0; v < _.length; v += 1)
        _[v].c();
      f = F(), y && y.c(), d = F(), b(t, "class", "a5e-input"), t.disabled = s = /*senseData*/
      i[10].unit === "unlimited", b(t, "type", n = /*senseData*/
      i[10].unit === "unlimited" ? "text" : "number"), b(t, "name", l = "system.attributes.senses." + /*sense*/
      i[9] + ".distance"), b(t, "min", "0"), t.value = r = /*senseData*/
      i[10].unit === "unlimited" ? "—" : (
        /*senseData*/
        i[10].distance || 0
      ), b(e, "class", "u-w-20"), b(a, "name", c = "system.attributes.senses." + /*sense*/
      i[9] + ".unit");
    },
    m(v, k) {
      T(v, e, k), A(e, t), T(v, o, k), T(v, a, k);
      for (let S = 0; S < _.length; S += 1)
        _[S] && _[S].m(a, null);
      T(v, f, k), y && y.m(v, k), T(v, d, k), p = !0, m || (g = [
        W(
          t,
          "change",
          /*change_handler*/
          i[6]
        ),
        W(
          a,
          "change",
          /*change_handler_1*/
          i[7]
        )
      ], m = !0);
    },
    p(v, k) {
      if ((!p || k & /*$actor*/
      1 && s !== (s = /*senseData*/
      v[10].unit === "unlimited")) && (t.disabled = s), (!p || k & /*$actor*/
      1 && n !== (n = /*senseData*/
      v[10].unit === "unlimited" ? "text" : "number")) && b(t, "type", n), (!p || k & /*$actor*/
      1 && l !== (l = "system.attributes.senses." + /*sense*/
      v[9] + ".distance")) && b(t, "name", l), (!p || k & /*$actor*/
      1 && r !== (r = /*senseData*/
      v[10].unit === "unlimited" ? "—" : (
        /*senseData*/
        v[10].distance || 0
      )) && t.value !== r) && (t.value = r), k & /*Object, A5E, $actor*/
      5) {
        h = ue(Object.entries(
          /*A5E*/
          v[2].visionUnits
        ));
        let S;
        for (S = 0; S < h.length; S += 1) {
          const D = gD(v, h, S);
          _[S] ? _[S].p(D, k) : (_[S] = bD(D), _[S].c(), _[S].m(a, null));
        }
        for (; S < _.length; S += 1)
          _[S].d(1);
        _.length = h.length;
      }
      (!p || k & /*$actor*/
      1 && c !== (c = "system.attributes.senses." + /*sense*/
      v[9] + ".unit")) && b(a, "name", c), /*sense*/
      v[9] === "blindsight" ? y ? (y.p(v, k), k & /*$actor*/
      1 && w(y, 1)) : (y = _D(v), y.c(), w(y, 1), y.m(d.parentNode, d)) : y && (ae(), O(y, 1, 1, () => {
        y = null;
      }), ce());
    },
    i(v) {
      p || (w(y), p = !0);
    },
    o(v) {
      O(y), p = !1;
    },
    d(v) {
      v && (C(e), C(o), C(a), C(f), C(d)), Le(_, v), y && y.d(v), m = !1, Me(g);
    }
  };
}
u($W, "create_default_slot$2c");
function yD(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: (
        /*headings*/
        i[3][
          /*sense*/
          i[9]
        ]
      ),
      $$slots: { default: [$W] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-direction", "row"), G(t, "--a5e-field-wrapper-background", "rgba(0, 0, 0, 0.05)"), G(t, "--a5e-field-wrapper-padding", "0.5rem"), G(t, "--a5e-field-wrapper-item-alignment", "center"), G(t, "--a5e-field-wrapper-label-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$actor*/
      1 && (r.heading = /*headings*/
      n[3][
        /*sense*/
        n[9]
      ]), l & /*$$scope, $actor*/
      131073 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(yD, "create_each_block$1z");
function AW(i) {
  let e, t, s = ue(Object.entries(
    /*$actor*/
    i[0]._source.system.attributes.senses
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = yD(hD(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("article");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "svelte-1buetme");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, [o]) {
      if (o & /*headings, Object, $actor, A5E, Math, Number*/
      13) {
        s = ue(Object.entries(
          /*$actor*/
          r[0]._source.system.attributes.senses
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = hD(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = yD(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(AW, "create_fragment$47");
function EW(i, e, t) {
  let s, { document: n, appId: l } = de("#external").application, { document: r = n, appId: o = l } = e;
  const a = r;
  pe(i, a, (g) => t(0, s = g));
  const { A5E: c } = CONFIG, f = {
    blindsight: "A5E.SenseBlindsightRange",
    darkvision: "A5E.SenseDarkvisionRange",
    tremorsense: "A5E.SenseTremorsenseRange",
    truesight: "A5E.SenseTruesightRange"
  }, d = /* @__PURE__ */ u(({ target: g }) => {
    te(s, g.name, Math.max(Number(g.value), 0));
  }, "change_handler"), p = /* @__PURE__ */ u(({ target: g }) => te(s, g.name, g.value), "change_handler_1"), m = /* @__PURE__ */ u(({ detail: g }) => te(s, "system.attributes.senses.blindsight.otherwiseBlind", g), "updateSelection_handler");
  return i.$$set = (g) => {
    "document" in g && t(4, r = g.document), "appId" in g && t(5, o = g.appId);
  }, [
    s,
    a,
    c,
    f,
    r,
    o,
    d,
    p,
    m
  ];
}
u(EW, "instance$3_");
const D$ = class D$ extends re {
  constructor(e) {
    super(), oe(this, e, EW, AW, le, { document: 4, appId: 5 });
  }
};
u(D$, "SensesConfigDialog");
let vb = D$;
function SW(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*skillBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*skillBonus*/
      1 && t !== (t = /*skillBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(SW, "create_default_slot_3$E");
function CW(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [SW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, skillBonus*/
      2097153 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(CW, "create_default_slot_2$Y");
function TW(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Select Skill Bonus Automatically in Roll Prompt",
      checked: (
        /*skillBonus*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[18]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skillBonus*/
      1 && (l.checked = /*skillBonus*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(TW, "create_default_slot_1$1i");
function OW(i) {
  let e, t, s, n, l, r, o, a;
  return e = new tt({
    props: {
      heading: "A5E.contexts.skills",
      options: Object.entries(
        /*skills*/
        i[7]
      ),
      selected: (
        /*skillsContext*/
        i[2]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[15]
  ), s = new Te({
    props: {
      label: "A5E.contexts.requiresProficiency",
      checked: (
        /*requiresProficiency*/
        i[1]
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[16]
  ), l = new Te({
    props: {
      label: "A5E.contexts.passiveOnly",
      checked: (
        /*passiveOnly*/
        i[3]
      )
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[17]
  ), o = new ie({
    props: {
      $$slots: { default: [TW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment);
    },
    m(c, f) {
      R(e, c, f), T(c, t, f), R(s, c, f), T(c, n, f), R(l, c, f), T(c, r, f), R(o, c, f), a = !0;
    },
    p(c, f) {
      const d = {};
      f & /*skillsContext*/
      4 && (d.selected = /*skillsContext*/
      c[2]), e.$set(d);
      const p = {};
      f & /*requiresProficiency*/
      2 && (p.checked = /*requiresProficiency*/
      c[1]), s.$set(p);
      const m = {};
      f & /*passiveOnly*/
      8 && (m.checked = /*passiveOnly*/
      c[3]), l.$set(m);
      const g = {};
      f & /*$$scope, skillBonus*/
      2097153 && (g.$$scope = { dirty: f, ctx: c }), o.$set(g);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(s.$$.fragment, c), w(l.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      O(e.$$.fragment, c), O(s.$$.fragment, c), O(l.$$.fragment, c), O(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (C(t), C(n), C(r)), N(e, c), N(s, c), N(l, c), N(o, c);
    }
  };
}
u(OW, "create_default_slot$2b");
function DW(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v;
  return d = new De({
    props: {
      $$slots: { default: [CW] },
      $$scope: { ctx: i }
    }
  }), g = new De({
    props: {
      heading: "Contexts",
      hint: "The context determines when the ability bonus applies",
      $$slots: { default: [OW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), h = E("div"), j(g.$$.fragment), b(s, "class", "bonus-image svelte-1lr65k0"), ze(s.src, n = /*skillBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*skillBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*skillBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1lr65k0"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1lr65k0"), b(t, "class", "sheet-header svelte-1lr65k0"), G(p, "display", "contents"), G(p, "--a5e-section-margin", "0.25rem 0"), G(h, "display", "contents"), G(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1lr65k0");
    },
    m(k, S) {
      T(k, e, S), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), A(e, h), R(g, h, null), _ = !0, y || (v = [
        W(
          s,
          "click",
          /*click_handler*/
          i[12]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[13]
        )
      ], y = !0);
    },
    p(k, [S]) {
      (!_ || S & /*skillBonus*/
      1 && !ze(s.src, n = /*skillBonus*/
      k[0].img)) && b(s, "src", n), (!_ || S & /*skillBonus*/
      1 && l !== (l = /*skillBonus*/
      k[0].label)) && b(s, "alt", l), (!_ || S & /*skillBonus*/
      1 && c !== (c = /*skillBonus*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const D = {};
      S & /*$$scope, skillBonus*/
      2097153 && (D.$$scope = { dirty: S, ctx: k }), d.$set(D);
      const I = {};
      S & /*$$scope, skillBonus, passiveOnly, requiresProficiency, skillsContext*/
      2097167 && (I.$$scope = { dirty: S, ctx: k }), g.$set(I);
    },
    i(k) {
      _ || (w(d.$$.fragment, k), w(g.$$.fragment, k), _ = !0);
    },
    o(k) {
      O(d.$$.fragment, k), O(g.$$.fragment, k), _ = !1;
    },
    d(k) {
      k && C(e), N(d), N(g), y = !1, Me(v);
    }
  };
}
u(DW, "create_fragment$46");
function IW(i, e, t) {
  let s, n, l, r, o, { document: a, bonusID: c } = de("#external").application, { document: f = a, bonusID: d = c } = e, { jsonValue: p = null } = e;
  const m = f;
  pe(i, m, (z) => t(11, o = z));
  const g = ft();
  function h() {
    const z = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: z,
      callback: /* @__PURE__ */ u((U) => {
        _("img", U);
      }, "callback")
    }).browse();
  }
  u(h, "updateImage");
  function _(z, q) {
    if (p === null) {
      z = `system.bonuses.skills.${d}.${z}`, te(o, z, q);
      return;
    }
    const U = foundry.utils.expandObject({ ...s, [z]: q });
    g("change", JSON.stringify(U));
  }
  u(_, "onUpdateValue");
  function y() {
    if (p === null) return o.system.bonuses.skills[d];
    try {
      const z = JSON.parse(p || '""') ?? {};
      if (typeof z != "object") throw new Error();
      return z.label = z.label ?? "", z.formula = z.formula ?? "", z.context = z.context ?? {
        skills: [],
        requiresProficiency: !1,
        passiveOnly: !1
      }, z.default = z.default ?? !0, z.img = z.img || "icons/svg/upgrade.svg", z;
    } catch {
      return {
        label: "",
        formula: "",
        damageType: "",
        context: {
          skills: [],
          requiresProficiency: !1,
          passiveOnly: !1
        },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  u(y, "getSKillBonus");
  const { skills: v } = CONFIG.A5E, k = /* @__PURE__ */ u(() => h(), "click_handler"), S = /* @__PURE__ */ u(({ target: z }) => _("label", z.value), "change_handler"), D = /* @__PURE__ */ u(({ target: z }) => _("formula", z.value), "change_handler_1"), I = /* @__PURE__ */ u(({ detail: z }) => {
    _("context.skills", z);
  }, "updateSelection_handler"), M = /* @__PURE__ */ u(({ detail: z }) => {
    _("context.requiresProficiency", z);
  }, "updateSelection_handler_1"), L = /* @__PURE__ */ u(({ detail: z }) => {
    _("context.passiveOnly", z);
  }, "updateSelection_handler_2"), B = /* @__PURE__ */ u(({ detail: z }) => {
    _("default", z);
  }, "updateSelection_handler_3");
  return i.$$set = (z) => {
    "document" in z && t(8, f = z.document), "bonusID" in z && t(9, d = z.bonusID), "jsonValue" in z && t(10, p = z.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    3072 && t(0, s = y() ?? {}), i.$$.dirty & /*skillBonus*/
    1 && t(3, n = s.context.passiveOnly ?? !1), i.$$.dirty & /*skillBonus*/
    1 && t(2, l = s.context.skills ?? []), i.$$.dirty & /*skillBonus*/
    1 && t(1, r = s.context.requiresProficiency ?? !1);
  }, [
    s,
    r,
    l,
    n,
    m,
    h,
    _,
    v,
    f,
    d,
    p,
    o,
    k,
    S,
    D,
    I,
    M,
    L,
    B
  ];
}
u(IW, "instance$3Z");
const I$ = class I$ extends re {
  constructor(e) {
    super(), oe(this, e, IW, DW, le, { document: 8, bonusID: 9, jsonValue: 10 });
  }
};
u(I$, "SkillBonusConfigDialog");
let hp = I$;
function vD(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Ability Bonuses",
      options: (
        /*abilityBonuses*/
        i[12].map(wD)
      ),
      selected: (
        /*selectedAbilityBonuses*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[26]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*abilityBonuses*/
      4096 && (l.options = /*abilityBonuses*/
      s[12].map(wD)), n[0] & /*selectedAbilityBonuses*/
      8 && (l.selected = /*selectedAbilityBonuses*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(vD, "create_if_block_1$1s");
function kD(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Skill Bonuses",
      options: (
        /*skillBonuses*/
        i[11].map($D)
      ),
      selected: (
        /*selectedSkillBonuses*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[27]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*skillBonuses*/
      2048 && (l.options = /*skillBonuses*/
      s[11].map($D)), n[0] & /*selectedSkillBonuses*/
      4 && (l.selected = /*selectedSkillBonuses*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(kD, "create_if_block$2e");
function PW(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "id", t = /*$actor*/
      i[6].id + "-" + /*appId*/
      i[15] + "-situational-mods");
    },
    m(l, r) {
      T(l, e, r), He(
        e,
        /*situationalMods*/
        i[1]
      ), s || (n = W(
        e,
        "input",
        /*input_input_handler*/
        i[28]
      ), s = !0);
    },
    p(l, r) {
      r[0] & /*$actor*/
      64 && t !== (t = /*$actor*/
      l[6].id + "-" + /*appId*/
      l[15] + "-situational-mods") && b(e, "id", t), r[0] & /*situationalMods*/
      2 && e.value !== /*situationalMods*/
      l[1] && He(
        e,
        /*situationalMods*/
        l[1]
      );
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(PW, "create_default_slot$2a");
function MW(i) {
  let e, t, s, n, l, r, o, a, c, f, d = Object.values(
    /*abilityBonuses*/
    i[12]
  ).flat().length, p, m = Object.values(
    /*skillBonuses*/
    i[11]
  ).flat().length, g, h, _, y, v, k, S, D, I, M, L;
  function B(H) {
    i[22](H);
  }
  u(B, "outputvisibilitysection_visibilityMode_binding");
  let z = {};
  /*visibilityMode*/
  i[7] !== void 0 && (z.visibilityMode = /*visibilityMode*/
  i[7]), t = new cc({ props: z }), rt.push(() => Ot(t, "visibilityMode", B)), l = new vr({
    props: {
      selected: (
        /*rollMode*/
        i[4]
      ),
      source: (
        /*rollModeString*/
        i[9]
      )
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[23]
  ), o = new Ke({
    props: {
      heading: "A5E.AbilityScore",
      options: Object.entries(
        /*abilities*/
        i[16]
      ),
      selected: (
        /*abilityKey*/
        i[0]
      ),
      allowDeselect: !1
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[24]
  ), c = new hi({
    props: {
      source: (
        /*expertiseDieSource*/
        i[10]
      ),
      selected: (
        /*expertiseDie*/
        i[5]
      ),
      type: (
        /*$actor*/
        i[6].type
      )
    }
  }), c.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[25]
  );
  let q = d && vD(i), U = m && kD(i);
  return h = new ie({
    props: {
      heading: "A5E.SituationalMods",
      $$slots: { default: [PW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), j(t.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment), f = F(), q && q.c(), p = F(), U && U.c(), g = F(), j(h.$$.fragment), _ = F(), y = E("section"), v = Q(
        /*rollFormula*/
        i[8]
      ), k = F(), S = E("section"), D = E("button"), D.textContent = `${/*buttonText*/
      i[17]}`, b(y, "class", "roll-formula-preview svelte-8gi69h"), b(e, "class", "svelte-8gi69h");
    },
    m(H, V) {
      T(H, e, V), R(t, e, null), A(e, n), R(l, e, null), A(e, r), R(o, e, null), A(e, a), R(c, e, null), A(e, f), q && q.m(e, null), A(e, p), U && U.m(e, null), A(e, g), R(h, e, null), A(e, _), A(e, y), A(y, v), A(e, k), A(e, S), A(S, D), I = !0, M || (L = W(D, "click", st(
        /*onSubmit*/
        i[13]
      )), M = !0);
    },
    p(H, V) {
      const Y = {};
      !s && V[0] & /*visibilityMode*/
      128 && (s = !0, Y.visibilityMode = /*visibilityMode*/
      H[7], It(() => s = !1)), t.$set(Y);
      const J = {};
      V[0] & /*rollMode*/
      16 && (J.selected = /*rollMode*/
      H[4]), V[0] & /*rollModeString*/
      512 && (J.source = /*rollModeString*/
      H[9]), l.$set(J);
      const fe = {};
      V[0] & /*abilityKey*/
      1 && (fe.selected = /*abilityKey*/
      H[0]), o.$set(fe);
      const ke = {};
      V[0] & /*expertiseDieSource*/
      1024 && (ke.source = /*expertiseDieSource*/
      H[10]), V[0] & /*expertiseDie*/
      32 && (ke.selected = /*expertiseDie*/
      H[5]), V[0] & /*$actor*/
      64 && (ke.type = /*$actor*/
      H[6].type), c.$set(ke), V[0] & /*abilityBonuses*/
      4096 && (d = Object.values(
        /*abilityBonuses*/
        H[12]
      ).flat().length), d ? q ? (q.p(H, V), V[0] & /*abilityBonuses*/
      4096 && w(q, 1)) : (q = vD(H), q.c(), w(q, 1), q.m(e, p)) : q && (ae(), O(q, 1, 1, () => {
        q = null;
      }), ce()), V[0] & /*skillBonuses*/
      2048 && (m = Object.values(
        /*skillBonuses*/
        H[11]
      ).flat().length), m ? U ? (U.p(H, V), V[0] & /*skillBonuses*/
      2048 && w(U, 1)) : (U = kD(H), U.c(), w(U, 1), U.m(e, g)) : U && (ae(), O(U, 1, 1, () => {
        U = null;
      }), ce());
      const ee = {};
      V[0] & /*$actor, situationalMods*/
      66 | V[1] & /*$$scope*/
      8 && (ee.$$scope = { dirty: V, ctx: H }), h.$set(ee), (!I || V[0] & /*rollFormula*/
      256) && be(
        v,
        /*rollFormula*/
        H[8]
      );
    },
    i(H) {
      I || (w(t.$$.fragment, H), w(l.$$.fragment, H), w(o.$$.fragment, H), w(c.$$.fragment, H), w(q), w(U), w(h.$$.fragment, H), I = !0);
    },
    o(H) {
      O(t.$$.fragment, H), O(l.$$.fragment, H), O(o.$$.fragment, H), O(c.$$.fragment, H), O(q), O(U), O(h.$$.fragment, H), I = !1;
    },
    d(H) {
      H && C(e), N(t), N(l), N(o), N(c), q && q.d(), U && U.d(), N(h), M = !1, L();
    }
  };
}
u(MW, "create_fragment$45");
const wD = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel], "func$c"), $D = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel], "func_1$4");
function FW(i, e, t) {
  let s, n, l, r, o, a, c, f, d, { document: p, dialog: m, skillKey: g, options: h } = de("#external").application, { document: _ = p, dialog: y = m, skillKey: v = g, options: k = h } = e;
  function S() {
    return z ? 0 : d.RollOverrideManager.getExpertiseDice(`system.skills.${v}` ?? "", d.system.skills[v].expertiseDice || k.expertiseDice || 0, { ability: U });
  }
  u(S, "getInitialExpertiseDieSelection");
  function D() {
    y.submit({
      expertiseDie: o,
      rollFormula: Y,
      abilityKey: U,
      rollMode: c,
      visibilityMode: H
    });
  }
  u(D, "onSubmit");
  const I = new Zt(_);
  pe(i, I, (Ce) => t(6, d = Ce));
  const M = y.id, L = K(CONFIG.A5E.skills[v]), B = {
    none: "A5E.None",
    ...CONFIG.A5E.abilities
  }, z = game.settings.get("a5e", "hideExpertiseDice"), q = K("A5E.RollPromptAbilityCheck", { ability: L });
  let U = k.abilityKey ?? d.system.skills[v].ability, H = k.visibilityMode ?? game.settings.get("core", "rollMode"), { minRoll: V } = k.minRoll ?? d.system.skills[v], Y, J = k.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL, fe = k.situationalMods ?? "";
  function ke(Ce) {
    H = Ce, t(7, H);
  }
  u(ke, "outputvisibilitysection_visibilityMode_binding");
  const ee = /* @__PURE__ */ u(({ detail: Ce }) => t(4, c = Ce), "updateSelection_handler"), ne = /* @__PURE__ */ u(({ detail: Ce }) => t(0, U = Ce), "updateSelection_handler_1"), Ee = /* @__PURE__ */ u(({ detail: Ce }) => t(5, o = Ce), "updateSelection_handler_2"), Pe = /* @__PURE__ */ u(({ detail: Ce }) => t(3, l = Ce), "updateSelection_handler_3"), ye = /* @__PURE__ */ u(({ detail: Ce }) => t(2, r = Ce), "updateSelection_handler_4");
  function me() {
    fe = this.value, t(1, fe);
  }
  return u(me, "input_input_handler"), i.$$set = (Ce) => {
    "document" in Ce && t(18, _ = Ce.document), "dialog" in Ce && t(19, y = Ce.dialog), "skillKey" in Ce && t(20, v = Ce.skillKey), "options" in Ce && t(21, k = Ce.options);
  }, i.$$.update = () => {
    var Ce;
    i.$$.dirty[0] & /*$actor, abilityKey*/
    65 && t(12, s = d.BonusesManager.prepareAbilityBonuses(U, "check")), i.$$.dirty[0] & /*$actor, skillKey, abilityKey*/
    1048641 && t(11, n = d.BonusesManager.prepareSkillBonuses(v, U)), i.$$.dirty[0] & /*$actor, abilityKey*/
    65 && t(3, l = d.BonusesManager.getDefaultSelections("abilities", { abilityKey: U, abilityType: "check" })), i.$$.dirty[0] & /*$actor, skillKey, abilityKey*/
    1048641 && t(2, r = d.BonusesManager.getDefaultSelections("skills", { skillKey: v, abilityKey: U })), i.$$.dirty[0] & /*$actor, skillKey, options, abilityKey*/
    3145793 && t(10, a = d.RollOverrideManager.getExpertiseDiceSource(`system.skills.${v}`, k.expertiseDice ?? 0, { ability: U })), i.$$.dirty[0] & /*$actor, skillKey, abilityKey*/
    1048641 && t(4, c = d.RollOverrideManager.getRollOverride(`system.skills.${v}`, J, { ability: U })), i.$$.dirty[0] & /*$actor, skillKey, abilityKey*/
    1048641 && t(9, f = (Ce = d.RollOverrideManager) == null ? void 0 : Ce.getRollOverridesSource(`system.skills.${v}`, J, { ability: U })), i.$$.dirty[0] & /*$actor, abilityKey, expertiseDie, rollMode, situationalMods, skillKey, selectedAbilityBonuses, selectedSkillBonuses*/
    1048703 && t(8, Y = ll(d, {
      ability: U,
      expertiseDie: o,
      minRoll: V,
      rollMode: c,
      situationalMods: fe,
      skill: v,
      selectedAbilityBonuses: l,
      selectedSkillBonuses: r,
      type: "skillCheck"
    }));
  }, t(5, o = S()), [
    U,
    fe,
    r,
    l,
    c,
    o,
    d,
    H,
    Y,
    f,
    a,
    n,
    s,
    D,
    I,
    M,
    B,
    q,
    _,
    y,
    v,
    k,
    ke,
    ee,
    ne,
    Ee,
    Pe,
    ye,
    me
  ];
}
u(FW, "instance$3Y");
const P$ = class P$ extends re {
  constructor(e) {
    super(), oe(
      this,
      e,
      FW,
      MW,
      le,
      {
        document: 18,
        dialog: 19,
        skillKey: 20,
        options: 21
      },
      null,
      [-1, -1]
    );
  }
};
u(P$, "SkillCheckRollDialog");
let kb = P$;
function RW(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.ProficiencyProficient",
      checked: (
        /*skill*/
        i[2].proficient
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[11]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skill*/
      4 && (l.checked = /*skill*/
      s[2].proficient), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(RW, "create_else_block$I");
function NW(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "Proficiency Level",
      options: [[0, "None"], [1, "Proficient"], [2, "Expertise"]],
      selected: (
        /*skill*/
        i[2].proficient
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[10]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skill*/
      4 && (l.selected = /*skill*/
      s[2].proficient), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(NW, "create_if_block_1$1r");
function jW(i) {
  let e, t, s, n;
  const l = [NW, RW], r = [];
  function o(a, c) {
    return (
      /*dnd5eStyleExpertise*/
      a[6] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      t.p(a, c);
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(jW, "create_default_slot_2$X");
function LW(i) {
  let e, t;
  return e = new Pi({
    props: {
      heading: "A5E.SkillSpecialties",
      options: (
        /*specialtyOptions*/
        i[5]
      ),
      selected: (
        /*skill*/
        i[2].specialties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[12]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skill*/
      4 && (l.selected = /*skill*/
      s[2].specialties), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(LW, "create_if_block$2d");
function BW(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "a5e-input"), b(t, "type", "number"), t.value = s = /*skill*/
      i[2].minRoll, b(t, "min", "0"), b(e, "class", "u-w-20");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = W(
        t,
        "change",
        /*change_handler*/
        i[15]
      ), n = !0);
    },
    p(r, o) {
      o & /*skill*/
      4 && s !== (s = /*skill*/
      r[2].minRoll) && t.value !== s && (t.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(BW, "create_default_slot_1$1h");
function qW(i) {
  var p;
  let e, t, s, n, l, r, o, a, c, f;
  e = new ie({
    props: {
      $$slots: { default: [jW] },
      $$scope: { ctx: i }
    }
  });
  let d = !/*hideSkillSpecialties*/
  i[7] && LW(i);
  return n = new Ke({
    props: {
      heading: "A5E.AbilityScore",
      optionStyles: "min-width:2rem; text-align: center;",
      options: [
        .../*abilityOptions*/
        i[4],
        ["@attributes.spellcasting", "Spellcasting"]
      ],
      selected: (
        /*$actor*/
        i[1]._source.system.skills[
          /*skillKey*/
          i[0]
        ].ability
      ),
      allowDeselect: !1
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[13]
  ), r = new hi({
    props: {
      selected: (
        /*$actor*/
        (p = i[1]._source.system.skills[
          /*skillKey*/
          i[0]
        ]) == null ? void 0 : p.expertiseDice
      ),
      type: (
        /*$actor*/
        i[1].type
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[14]
  ), a = new ie({
    props: {
      heading: "A5E.MinimumD20Roll",
      $$slots: { default: [BW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), d && d.c(), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), o = F(), c = E("div"), j(a.$$.fragment), G(c, "display", "contents"), G(c, "--direction", "column");
    },
    m(m, g) {
      R(e, m, g), T(m, t, g), d && d.m(m, g), T(m, s, g), R(n, m, g), T(m, l, g), R(r, m, g), T(m, o, g), T(m, c, g), R(a, c, null), f = !0;
    },
    p(m, g) {
      var k;
      const h = {};
      g & /*$$scope, skill, $actor, skillKey*/
      65543 && (h.$$scope = { dirty: g, ctx: m }), e.$set(h), /*hideSkillSpecialties*/
      m[7] || d.p(m, g);
      const _ = {};
      g & /*$actor, skillKey*/
      3 && (_.selected = /*$actor*/
      m[1]._source.system.skills[
        /*skillKey*/
        m[0]
      ].ability), n.$set(_);
      const y = {};
      g & /*$actor, skillKey*/
      3 && (y.selected = /*$actor*/
      (k = m[1]._source.system.skills[
        /*skillKey*/
        m[0]
      ]) == null ? void 0 : k.expertiseDice), g & /*$actor*/
      2 && (y.type = /*$actor*/
      m[1].type), r.$set(y);
      const v = {};
      g & /*$$scope, skill, $actor, skillKey*/
      65543 && (v.$$scope = { dirty: g, ctx: m }), a.$set(v);
    },
    i(m) {
      f || (w(e.$$.fragment, m), w(d), w(n.$$.fragment, m), w(r.$$.fragment, m), w(a.$$.fragment, m), f = !0);
    },
    o(m) {
      O(e.$$.fragment, m), O(d), O(n.$$.fragment, m), O(r.$$.fragment, m), O(a.$$.fragment, m), f = !1;
    },
    d(m) {
      m && (C(t), C(s), C(l), C(o)), N(e, m), d && d.d(m), N(n, m), N(r, m), m && a && C(c), N(a, m);
    }
  };
}
u(qW, "create_default_slot$29");
function GW(i) {
  let e, t, s, n;
  return t = new De({
    props: {
      $$slots: { default: [qW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("article"), s = E("div"), j(t.$$.fragment), G(s, "display", "contents"), G(s, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-yarbko");
    },
    m(l, r) {
      T(l, e, r), A(e, s), R(t, s, null), n = !0;
    },
    p(l, [r]) {
      const o = {};
      r & /*$$scope, skill, $actor, skillKey*/
      65543 && (o.$$scope = { dirty: r, ctx: l }), t.$set(o);
    },
    i(l) {
      n || (w(t.$$.fragment, l), n = !0);
    },
    o(l) {
      O(t.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(e), N(t);
    }
  };
}
u(GW, "create_fragment$44");
function zW(i, e, t) {
  let s, n, { document: l, appId: r, skillKey: o } = de("#external").application, { document: a = l, appId: c = r, skillKey: f = o } = e;
  const d = a;
  pe(i, d, (I) => t(1, n = I));
  const p = fl(), m = Object.entries(CONFIG.A5E.skillSpecialties[f]);
  let g = game.settings.get("a5e", "5eStyleExpertise"), h = game.settings.get("a5e", "hideSkillSpecialties") ?? !1;
  const _ = /* @__PURE__ */ u(({ detail: I }) => {
    te(n, `system.skills.${f}.proficient`, I);
  }, "updateSelection_handler"), y = /* @__PURE__ */ u(({ detail: I }) => {
    te(n, `system.skills.${f}.proficient`, I);
  }, "updateSelection_handler_1"), v = /* @__PURE__ */ u((I) => te(n, `system.skills.${f}.specialties`, I.detail), "updateSelection_handler_2"), k = /* @__PURE__ */ u((I) => te(n, `system.skills.${f}.ability`, I.detail), "updateSelection_handler_3"), S = /* @__PURE__ */ u(({ detail: I }) => te(n, `system.skills.${f}.expertiseDice`, I), "updateSelection_handler_4"), D = /* @__PURE__ */ u(({ target: I }) => te(n, `system.skills.${f}.minRoll`, Number(I.value)), "change_handler");
  return i.$$set = (I) => {
    "document" in I && t(8, a = I.document), "appId" in I && t(9, c = I.appId), "skillKey" in I && t(0, f = I.skillKey);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, skillKey*/
    3 && t(2, s = n.system.skills[f]);
  }, [
    f,
    n,
    s,
    d,
    p,
    m,
    g,
    h,
    a,
    c,
    _,
    y,
    v,
    k,
    S,
    D
  ];
}
u(zW, "instance$3X");
const M$ = class M$ extends re {
  constructor(e) {
    super(), oe(this, e, zW, GW, le, { document: 8, appId: 9, skillKey: 0 });
  }
};
u(M$, "SkillConfigDialog");
let wb = M$;
const F$ = class F$ extends Sn {
  initialize() {
    this.filters.add((e) => {
      var s, n;
      return ((s = e == null ? void 0 : e.changes) == null ? void 0 : s.find(
        (l) => l.key === "flags.a5e.effects.statusConditions"
      )) ? !0 : ((n = e == null ? void 0 : e.statuses) == null ? void 0 : n.size) === 0;
    }), this.sort.set((e, t) => {
      var s, n, l, r;
      return (((n = (s = e == null ? void 0 : e.flags) == null ? void 0 : s.a5e) == null ? void 0 : n.sort) ?? 0) - (((r = (l = t == null ? void 0 : t.flags) == null ? void 0 : l.a5e) == null ? void 0 : r.sort) ?? 0);
    }), this._types = {
      ongoing: this.derived.create("passive"),
      inactive: this.derived.create("inactive")
    }, this._types.ongoing.filters.add((e) => !e.isSuppressed), this._types.inactive.filters.add((e) => e.isSuppressed);
  }
};
u(F$, "ActorActiveEffectMapReducer");
let $b = F$;
const R$ = class R$ extends Sn {
  initialize() {
    this.sort.set((e, t) => {
      var s, n, l, r;
      return (((n = (s = e == null ? void 0 : e.flags) == null ? void 0 : s.a5e) == null ? void 0 : n.sort) ?? 0) - (((r = (l = t == null ? void 0 : t.flags) == null ? void 0 : l.a5e) == null ? void 0 : r.sort) ?? 0);
    }), this._types = {
      onUse: this.derived.create("onUse"),
      passive: this.derived.create("passive")
    }, this._types.onUse.filters.add((e) => e.system.effectType === "onUse"), this._types.passive.filters.add((e) => e.system.effectType === "passive");
  }
};
u(R$, "ItemActiveEffectMapReducer");
let Ab = R$;
var Af;
const N$ = class N$ extends Zt {
  constructor(t, s) {
    super(t, s);
    x(this, Af);
    Ae(this, Af, this.embedded.create(ActiveEffect, Ab));
  }
  get activeEffects() {
    return P(this, Af);
  }
};
Af = new WeakMap(), u(N$, "ItemDocument");
let gp = N$;
var Ef, Eb;
const j$ = class j$ extends Un {
  constructor(t, s, n, l = {}, r = {}) {
    const o = r.isItemDocument ? new gp(t) : new Zt(t);
    delete r.isItemDocument;
    super(
      {
        title: s,
        content: {
          class: n,
          props: { document: o, ...l }
        },
        zIndex: null
      },
      {
        classes: ["a5e-sheet"],
        width: r.width ?? 420,
        height: r.height ?? "auto",
        resizable: r.resizable ?? !1
      }
    );
    x(this, Ef);
    this.data.content.props.dialog = this, this.promise = new Promise((a) => {
      this.resolve = a;
    });
  }
  /** @inheritdoc */
  close(t) {
    var s;
    return X(this, Ef, Eb).call(this, null), (s = this.document) == null || s.destroy(), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    var s;
    return X(this, Ef, Eb).call(this, t), (s = this.document) == null || s.destroy(), super.close();
  }
};
Ef = new WeakSet(), Eb = /* @__PURE__ */ u(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), u(j$, "GenericConfigDialog");
let gi = j$;
var Sf, Sb;
const L$ = class L$ extends Un {
  constructor(t, s, n, l = {}, r = {}, o = {}) {
    super(
      {
        title: s,
        content: {
          class: n,
          props: { document: t, ...l, options: r }
        },
        zIndex: null
      },
      {
        classes: ["a5e-sheet"],
        height: o.height ?? "auto",
        width: o.width ?? 420,
        resizable: o.resizable ?? !1
      }
    );
    x(this, Sf);
    this.data.content.props.dialog = this, this.promise = new Promise((a) => {
      this.resolve = a;
    });
  }
  /** @inheritdoc */
  close(t) {
    return X(this, Sf, Sb).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return X(this, Sf, Sb).call(this, t), super.close();
  }
};
Sf = new WeakSet(), Sb = /* @__PURE__ */ u(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), u(L$, "GenericRollDialog");
let Ko = L$;
async function AD(i, e, t, s) {
  var f, d;
  if (game.user.id !== t || (s = i.type === "npc" && s === "unconscious" ? "dead" : s, !((d = (f = e == null ? void 0 : e.system) == null ? void 0 : f.attributes) != null && d.hp))) return;
  const { value: n, max: l } = i.system.attributes.hp;
  if (!CONFIG.statusEffects.find((p) => p.id === s)) return;
  const o = s === "bloodied" ? n <= l / 2 && n > 0 : n <= 0, a = ["unconscious", "dead"].includes(s), c = i.statuses.has(s);
  o && !c ? (i.toggleStatusEffect(s, { active: !0, overlay: a }), Hooks.callAll(`a5e.${s}`, i, !0), s === "unconscious" && i.toggleStatusEffect("prone", { active: !0 })) : !o && c && (i.toggleStatusEffect(s, { active: !1, overlay: a }), Hooks.callAll(`a5e.${s}`, i, !1));
}
u(AD, "automateHpConditions");
async function HW(i, e, t) {
  var r;
  if (game.user.id !== t) return;
  const s = /* @__PURE__ */ new Set(["corruption", "fatigue", "exhaustion", "inebriated", "strife"]), n = new Set(Object.keys(((r = e == null ? void 0 : e.system) == null ? void 0 : r.attributes) ?? {})), l = s.intersection(n);
  l != null && l.size && l.forEach(async (o) => {
    const a = e.system.attributes[o], c = CONFIG.statusEffects.find((g) => g.id === o);
    if (!c) return;
    const f = o === "fatigue" && game.settings.get("a5e", "replaceFatigueAndStrife") ? "exhaustion" : o, d = Object.entries(CONFIG.A5E.multiLevelConditions[f] ?? {}).reduce(
      (g, [h, _]) => (h > a || g.push(..._), g),
      []
    ), p = i.effects.get(c._id);
    if (p && await p.delete(), a === 0) return;
    const m = await ActiveEffect.implementation.fromStatusEffect(c.id);
    m.updateSource({ changes: d }), await ActiveEffect.implementation.create(m, { parent: i, keepId: !0 });
  });
}
u(HW, "automateMultiLevelConditions");
async function fd(i, e, t, s) {
  var o, a;
  const n = await ((o = i.getActiveTokens()) == null ? void 0 : o[0]);
  if (!n) return;
  const l = e === "damage" ? "damageColors" : "healingColors", r = ((a = CONFIG.A5E[l]) == null ? void 0 : a[s]) ?? "#fff";
  canvas.interface.createScrollingText(n == null ? void 0 : n.center, t, { fill: r });
}
u(fd, "displayCascadingNumbers");
const Zm = class Zm {
  constructor() {
    // @ts-expect-error
    qe(this, "version", this.constructor.version);
    qe(this, "requiresFlush", !1);
  }
};
u(Zm, "MigrationBase"), qe(Zm, "version");
let Rl = Zm;
const Qm = class Qm extends Rl {
  async updateActor(e) {
    var r;
    const t = ((r = Object.keys(e.system.spellBooks ?? {})) == null ? void 0 : r[0]) || foundry.utils.randomID(), s = foundry.utils.getProperty(e, "flags.a5e.showSpellPoints") ?? !1, n = foundry.utils.getProperty(e, "flags.a5e.showSpellSlots") ?? !0, l = {
      _id: t,
      name: "New Spell Book",
      img: "icons/svg/book.svg",
      ability: "default",
      disableSpellConsumers: !1,
      showSpellPoints: s,
      showSpellSlots: n
    };
    e["system.spellBooks"] = { [t]: l }, e["flags.a5e.filters.-=exclusive"] = null, e["flags.a5e.filters.-=inclusive"] = null, e["flags.a5e.-=showSpellPoints"] = null, e["flags.a5e.-=showSpellSlots"] = null, foundry.utils.setProperty(e, "flags.a5e.sortMode", {});
    for (const o of e.items)
      o.type === "spell" && (o.system.spellBook = t);
  }
};
u(Qm, "Migration014MigrateSpellBooks"), qe(Qm, "version", 0.014);
let Cb = Qm;
const xm = class xm extends Rl {
  async updateItem(e) {
    if (e.type !== "object") return;
    const t = e.system.weaponProperties ?? [];
    t.includes("defensiveHeavy") ? foundry.utils.setProperty(e, "system.defensiveProperties", "heavy") : t.includes("defensiveMedium") ? foundry.utils.setProperty(e, "system.defensiveProperties", "medium") : t.includes("defensiveLight") && foundry.utils.setProperty(e, "system.defensiveProperties", "light");
    const s = [];
    t.includes("breakerStone") && s.push("stone"), t.includes("breakerWood") && s.push("wood"), e.system.breakerProperties = s;
  }
};
u(xm, "Migration015MigrateProperties"), qe(xm, "version", 0.015);
let Tb = xm;
const eh = class eh extends Rl {
  async updateEffect(e) {
    const t = e.changes ?? [];
    t.length && t.forEach((s, n) => {
      const { key: l, value: r } = s;
      if (l.startsWith("system.skills") && l.endsWith(".proficient")) {
        const o = foundry.utils.deepClone(s);
        o.value = r === "true" ? 1 : 0, t[n] = o;
      }
    });
  }
};
u(eh, "Migration016MigrateSkillProficiency"), qe(eh, "version", 0.016);
let Ob = eh;
const th = class th extends Rl {
  async updateActor(e) {
    var s;
    if (e.type !== "character") return;
    const t = e.system.spellResources ?? {};
    Object.entries(t.slots ?? {}).forEach(([n, l]) => {
      foundry.utils.setProperty(
        e,
        `system.spellResources.slots.${n}.override`,
        l.max ?? 0
      ), foundry.utils.setProperty(e, `system.spellResources.slots.${n}.max`, 0);
    }), foundry.utils.setProperty(
      e,
      "system.spellResources.points.override",
      ((s = t.points) == null ? void 0 : s.max) ?? 0
    ), foundry.utils.setProperty(e, "system.spellResources.points.max", 0);
  }
};
u(th, "Migration017MigrateSpellMax"), qe(th, "version", 0.017);
let Db = th;
const sh = class sh extends Rl {
  constructor() {
    super(...arguments);
    qe(this, "traitTypes", ["armorTypes", "maneuverTraditions", "tools", "weapons"]);
  }
  async updateActor(t) {
    const s = t.system.grants ?? {};
    Object.entries(s).forEach(([n, l]) => {
      if (!["proficiency", "trait"].includes(l.grantType) || (l.grantType === "proficiency" && l.proficiencyData.proficiencyType === "ability" && foundry.utils.setProperty(
        t,
        `system.grants.${n}.proficiencyData.proficiencyType`,
        "savingThrow"
      ), l.grantType !== "trait")) return;
      const { traits: r, traitType: o } = l.traitData;
      if (!this.traitTypes.includes(o)) return;
      let a;
      o === "armorTypes" ? a = "armor" : o === "maneuverTraditions" ? a = "tradition" : o === "tools" ? a = "tool" : o === "weapons" ? a = "weapon" : a = o;
      const c = {
        grantType: "proficiency",
        proficiencyData: {
          keys: r,
          total: r.length,
          proficiencyType: a
        }
      };
      foundry.utils.setProperty(t, `system.grants.${n}`, c);
    });
  }
  async updateItem(t) {
    const s = t.system.grants ?? {};
    Object.entries(s).forEach(([n, l]) => {
      if (!["proficiency", "trait"].includes(l.grantType) || (l.grantType === "proficiency" && l.proficiencyType === "ability" && foundry.utils.setProperty(t, `system.grants.${n}.proficiencyType`, "savingThrow"), l.grantType !== "trait")) return;
      const { traits: r } = l, { traitType: o } = r;
      if (!this.traitTypes.includes(o)) return;
      let a;
      o === "armorTypes" ? a = "armor" : o === "maneuverTraditions" ? a = "tradition" : o === "tools" ? a = "tool" : o === "weapons" ? a = "weapon" : a = o;
      const c = {
        grantType: "proficiency",
        keys: {
          base: r.base,
          options: r.options,
          total: r.total
        },
        proficiencyType: a
      };
      foundry.utils.setProperty(t, `system.grants.${n}`, c);
    });
  }
};
u(sh, "Migration018MigrateTraitProficiencyGrant"), qe(sh, "version", 0.018);
let Ib = sh;
const nh = class nh extends Rl {
  async updateItem(e) {
    const t = e.system.grants ?? {};
    Object.entries(t).forEach(([s, n]) => {
      var c;
      if (n.grantType !== "feature") return;
      const { base: l = [], options: r = [] } = n.features ?? {}, o = l.map((f) => ({
        uuid: f,
        limitedReselection: !0,
        selectionLimit: 1
      })), a = r.map((f) => ({
        uuid: f,
        limitedReselection: !0,
        selectionLimit: 1
      }));
      e.system.grants[s].features = {
        base: o,
        options: a,
        total: ((c = n.features) == null ? void 0 : c.total) ?? 0
      };
    });
  }
};
u(nh, "Migration019MigrateFeatureGrant"), qe(nh, "version", 0.019);
let Pb = nh;
var ko, C9, Fb;
const ih = class ih extends Rl {
  constructor() {
    super(...arguments);
    x(this, ko);
  }
  async updateActor(t) {
    X(this, ko, Fb).call(this, t);
  }
  async updateItem(t) {
    X(this, ko, Fb).call(this, t), foundry.utils.setProperty(t, "system.actions", X(this, ko, C9).call(this, t));
  }
  async updateEffect(t, s) {
    var n, l, r, o, a, c;
    foundry.utils.setProperty(
      t,
      "system.applyToSelf",
      ((l = (n = t.flags) == null ? void 0 : n.a5e) == null ? void 0 : l.applyToSelf) ?? ((r = t.system) == null ? void 0 : r.applyToSelf) ?? !1
    ), foundry.utils.setProperty(
      t,
      "system.effectType",
      ((a = (o = t == null ? void 0 : t.flags) == null ? void 0 : o.a5e) == null ? void 0 : a.transferType) ?? ((c = t == null ? void 0 : t.system) == null ? void 0 : c.transferType) ?? "passive"
    ), t["flags.a5e.-=actionId"] = null, t["flags.a5e.-=applyToSelf"] = null, t["flags.a5e.-=sort"] = null, t["flags.a5e.-=transferType"] = null;
  }
};
ko = new WeakSet(), C9 = /* @__PURE__ */ u(function(t) {
  return Object.entries(t.system.actions ?? {}).reduce((n, [l, r]) => {
    const o = foundry.utils.deepClone(r), a = Object.entries(r.prompts ?? {});
    return o.prompts = a.reduce((c, [f, d]) => {
      if (d.type !== "effect")
        return c[f] = d, c;
      const p = d.effectId || "";
      return p && (o.effects ?? (o.effects = []), o.effects.push(p), c[`-=${f}`] = null), c;
    }, {}), n[l] = o, n;
  }, {});
}, "#migrateActionData"), Fb = /* @__PURE__ */ u(function(t) {
  var l, r, o, a, c, f, d;
  if (!("game" in globalThis)) return;
  const s = ((l = t == null ? void 0 : t.system) == null ? void 0 : l.schemaVersion) ?? {};
  if (!s || typeof s != "object") return;
  const n = {
    version: s.version ?? null,
    lastMigration: {
      schema: ((o = (r = s.lastMigration) == null ? void 0 : r.version) == null ? void 0 : o.schema) ?? null,
      system: ((c = (a = s.lastMigration) == null ? void 0 : a.system) == null ? void 0 : c.schema) ?? null,
      foundry: ((d = (f = s.lastMigration) == null ? void 0 : f.version) == null ? void 0 : d.system) ?? null
    }
  };
  foundry.utils.setProperty(t, "system.migrationData", n);
}, "#migrateSchemaData"), u(ih, "Migration020MigrateToV1"), qe(ih, "version", 0.02);
let Mb = ih;
const UW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Migration014MigrateSpellBooks: Cb,
  Migration015MigrateProperties: Tb,
  Migration016MigrateSkillProficiency: Ob,
  Migration017MigrateSpellMax: Db,
  Migration018MigrateTraitProficiencyGrant: Ib,
  Migration019MigrateFeatureGrant: Pb,
  Migration020MigrateToV1: Mb
}, Symbol.toStringTag, { value: "Module" }));
var mr;
const bl = class bl {
  static get latestVersion() {
    return Math.max(...P(bl, mr).map((e) => e.version));
  }
  static constructAll() {
    return P(bl, mr).map((e) => new e());
  }
  static constructFromVersion(e) {
    const t = Number(e) || tn.RECOMMENDED_SAFE_VERSION;
    return P(bl, mr).reduce((s, n) => (n.version > t && s.push(new n()), s), []);
  }
  static constructFromLatestVersion(e) {
    const t = Number(e) - 1e-3 || tn.RECOMMENDED_SAFE_VERSION;
    return P(bl, mr).reduce((s, n) => (n.version > t && s.push(new n()), s), []);
  }
  static constructRange(e, t = Number.POSITIVE_INFINITY) {
    return P(bl, mr).reduce((s, n) => (n.version >= e && n.version <= t && s.push(new n()), s), []);
  }
};
mr = new WeakMap(), u(bl, "MigrationList"), x(bl, mr, Object.values(UW));
let kr = bl;
async function VW(i) {
  var n;
  if (!((n = game.user) != null && n.isGM)) return !1;
  const e = i.system.migrationData.version ?? tn.RECOMMENDED_SAFE_VERSION;
  await new tn(
    kr.constructFromVersion(e)
  ).runDocumentMigration(i) ? ui.notifications.info(`Migrated ${i.name} to the latest version.`) : ui.notifications.info(`No migration for ${i.name} not available.`);
}
u(VW, "handleDocumentMigration");
async function T9(i, e = null) {
  var l, r, o;
  const t = i.documentName, s = tn.LATEST_MIGRATION_VERSION;
  let n;
  e ? n = e : t === "Actor" ? n = Math.min(
    ((r = (l = i.system) == null ? void 0 : l.migrationData) == null ? void 0 : r.version) || s,
    ...(i.items ?? []).map((a) => {
      var c, f;
      return ((f = (c = a == null ? void 0 : a.system) == null ? void 0 : c.migrationData) == null ? void 0 : f.version) || s;
    })
    // ...(document.effects ?? []).map((e) => e?.system?.migrationData?.version ?? latestVer),
  ) : n = ((o = i.system.migrationData) == null ? void 0 : o.version) || s, await tn.ensureSchemaVersion(
    i,
    kr.constructFromVersion(n)
  );
}
u(T9, "handleDocumentImportMigration");
var lh, Kt, O9, D9, I9, bs;
const B$ = class B$ extends Actor {
  // *****************************************************************************************
  constructor(t, s) {
    super(t, s);
    x(this, Kt);
    // Defaults
    x(this, lh, {
      ability: ab,
      abilityBonus: up,
      alignment: fn,
      armor: fn,
      armorClass: db,
      attackBonus: fp,
      conditionImmunities: fn,
      damageBonus: dp,
      damageImmunities: fn,
      damageResistances: fn,
      damageVulnerabilities: fn,
      exertionBonus: pb,
      healingBonus: mp,
      hitPointsBonus: mb,
      health: ub,
      initiative: fb,
      initiativeBonus: pp,
      languages: fn,
      maneuverTraditions: fn,
      movement: gb,
      movementBonus: hb,
      senses: vb,
      sensesBonus: yb,
      size: fn,
      skill: wb,
      skillBonus: hp,
      terrain: fn,
      tools: fn,
      types: fn,
      weapons: fn
    });
    qe(this, "dialogs");
    // Custom
    qe(this, "effectPhases");
    this.dialogs ?? (this.dialogs = {
      abilities: {},
      bonuses: {},
      genericResources: {},
      skills: {},
      notes: {}
    }), this.effectPhases = { beforeDerived: [], afterDerived: [] };
  }
  // *****************************************************************************************
  isType(t) {
    return t === this.type;
  }
  // *****************************************************************************************
  get actorEffects() {
    return this.effects.map((t) => t);
  }
  get isBloodied() {
    const { max: t, value: s } = this.system.attributes.hp;
    return s / t * 100 <= 50;
  }
  get migrationVersion() {
    return this.system.migrationData.version;
  }
  /**
   * An array of ActiveEffect instances which are present on the
   * Actor which have a limited duration.
   */
  // @ts-expect-error
  get temporaryEffects() {
    var s;
    const t = [];
    for (const n of this.allApplicableEffects())
      n.active && (n.isTemporary || ((s = n == null ? void 0 : n.system) == null ? void 0 : s.effectType) === "onUse") && t.push(n);
    return t.sort((n, l) => n.name.localeCompare(l.name));
  }
  get visionData() {
    const { senses: t } = this.system.attributes;
    return {
      hasBlindsight: t.blindsight.distance > 0,
      hasDarkvision: t.darkvision.distance > 0,
      hasTremorsense: t.tremorsense.distance > 0,
      hasTruesight: t.truesight.distance > 0,
      senses: t
    };
  }
  // -------------------------------------------------------------
  // Data Preparation Methods
  // -------------------------------------------------------------
  _initialize(t) {
    this.initialized = !1, this.BonusesManager = null, this.HitDiceManager = null, this.grants = null, this.spellBooks = null, this.RollOverrideManager = null, super._initialize(t);
  }
  /**
   * Sets the order of when to prepare data.
   */
  prepareData() {
    this.initialized || (this.initialized = !0, this.prepareBaseData(), super.prepareEmbeddedDocuments(), this.prepareDerivedData(), this.afterDerivedData(), this.prepareArmorClass(), this.RollOverrideManager.initialize(), this.spellBooks = new x1(this), this.spellBooks.forEach((t) => t.prepareBaseData()));
  }
  /**
   * Prepare base data for the actor.
   */
  prepareBaseData() {
    this.BonusesManager = new Z1(this), this.RollOverrideManager = new eb(this), this.grants = new X1(this), this.system.attributes.ac.changes = {
      override: null,
      bonuses: { components: [], value: 0 }
    };
  }
  /**
   * Apply activeEffects to the actor with the phase 'applyAEs'.
   */
  applyActiveEffects() {
    this.overrides = {}, this.statuses ?? (this.statuses = /* @__PURE__ */ new Set());
    const t = /* @__PURE__ */ new Map();
    Object.values(CONFIG.specialStatusEffects).forEach((n) => {
      t.set(n, this.statuses.has(n));
    }), this.statuses.clear(), this.effectPhases ?? (this.effectPhases = {
      beforeDerived: [],
      afterDerived: []
    }), lc.applyEffects(
      this,
      this.actorEffects,
      "applyAEs",
      "afterDerived",
      (n) => {
        var l;
        return ((l = game.a5e.activeEffects.options[this.type].allOptions[n.key]) == null ? void 0 : l.phase) === "applyAEs";
      }
    );
    let s;
    for (const [n, l] of t) {
      const r = this.statuses.has(n);
      if (r === l) return;
      s ?? (s = this.getActiveTokens()), s.forEach((o) => o._onApplyStatusEffect(n, r));
    }
  }
  /**
   * Prepares derived data for the actor.
   */
  prepareDerivedData() {
    var s;
    const t = this.system;
    Object.entries(t.abilities).forEach(([n, l]) => {
      var o;
      const r = mt(
        [
          // @ts-expect-error
          l.value,
          (o = this.BonusesManager) == null ? void 0 : o.getAbilityBonusesFormula(n, "base").trim()
        ].filter(Boolean).join(" + ")
      );
      l.value = r ?? l.value;
    }), Object.values(t.abilities).forEach((n) => {
      const l = Math.floor((n.value - 10) / 2);
      n.check.mod = l, n.save.mod = l + (n.save.proficient ? t.attributes.prof : 0);
    }), Object.entries(t.abilities).forEach(([n, l]) => {
      ["check", "save"].forEach((r) => {
        var a;
        let o;
        try {
          o = mt(
            [
              // @ts-expect-error
              l[r].mod,
              // @ts-expect-error
              (a = this.BonusesManager) == null ? void 0 : a.getAbilityBonusesFormula(n, r).trim()
            ].filter(Boolean).join(" + "),
            this.getRollData()
          );
        } finally {
          l[r].deterministicBonus = o ?? l[r].mod;
        }
      });
    });
    try {
      t.attributes.maneuverDC = mt(
        [
          8,
          // @ts-expect-error
          t.attributes.prof,
          t.bonuses.maneuverDC,
          // @ts-expect-error
          Math.max(t.abilities.str.check.mod, t.abilities.dex.check.mod)
        ].join(" + "),
        this.getRollData()
      );
    } catch {
      console.error(`Failed to calculate a maneuver DC for ${this.name}`), t.attributes.maneuverDC = null;
    }
    try {
      t.attributes.spellDC = mt(
        [
          8,
          // @ts-expect-error
          t.attributes.prof,
          ((s = t.bonuses) == null ? void 0 : s.spellDC) || 0,
          t.abilities[t.attributes.spellcasting || "int"].check.mod
        ].join(" + "),
        this.getRollData()
      );
    } catch {
      console.error(`Failed to calculate a spell DC for ${this.name}`), t.attributes.spellDC = null;
    }
    this.prepareHitPointBonuses(), this.prepareSkills(), this.prepareMovement(), this.prepareSenses(), foundry.utils.setProperty(this, "system.attributes.ac.changes", this.prepareArmorChanges());
  }
  prepareArmorClass() {
    var a, c, f;
    const t = this.system.attributes.ac.changes ?? {};
    let s = "Natural Armor";
    const n = mt(
      `${this.system.attributes.ac.baseFormula}` || "10 + @dex.mod",
      this.getRollData()
    ), l = foundry.utils.getProperty(this.overrides, "system.attributes.ac.value");
    if (l != null) {
      const d = this.actorEffects.findLast(
        (h) => h.changes.some((_) => _.key.includes("ac.value")) && !h.isSuppressed
      ), p = (((a = t.override) == null ? void 0 : a.value) ?? n) + t.bonuses.value;
      foundry.utils.mergeObject(this.system.attributes.ac, {
        changes: t,
        value: Number.parseInt(p, 10) || 10
      });
      const m = d == null ? void 0 : d.apply(
        this,
        d == null ? void 0 : d.changes.find((h) => h.key.includes("ac.value")),
        // @ts-expect-error
        "afterDerived"
      ), g = ((c = Object.values(m)) == null ? void 0 : c[0]) ?? l;
      s = (d == null ? void 0 : d.name) ?? s, t.override = { name: s, mode: CONFIG.A5E.ARMOR_MODES.OVERRIDE, value: g }, t.bonuses = {
        components: [],
        value: 0
      };
    }
    if (foundry.utils.getProperty(
      this.overrides,
      "system.attributes.ac.baseFormula"
    ) && !l) {
      const d = this.actorEffects.findLast(
        (p) => p.changes.some((m) => m.key.includes("ac.baseFormula")) && !p.isSuppressed
      );
      s = (d == null ? void 0 : d.name) ?? s, t.override = { name: s, mode: CONFIG.A5E.ARMOR_MODES.OVERRIDE, value: n };
    }
    t.override ?? (t.override = {
      name: "Natural Armor",
      mode: CONFIG.A5E.ARMOR_MODES.OVERRIDE,
      formula: this.system.attributes.ac.baseFormula,
      value: n
    });
    const o = (((f = t.override) == null ? void 0 : f.value) ?? n) + t.bonuses.value;
    foundry.utils.mergeObject(this.system.attributes.ac, {
      changes: t,
      value: Number.parseInt(o, 10) || 10
    });
  }
  determineDefenseConfiguration() {
    return this.items.reduce(
      (t, s) => {
        if (s.system.equippedState !== CONFIG.A5E.EQUIPPED_STATES.EQUIPPED) return t;
        const { formula: n } = s.system.ac ?? {};
        return n && (s.system.objectType === "armor" ? t.hasArmor = !0 : s.system.objectType === "shield" && (t.hasShield = !0)), t;
      },
      { hasArmor: !1, hasShield: !1 }
    );
  }
  prepareArmorChanges() {
    const { hasArmor: t, hasShield: s } = this.determineDefenseConfiguration(), n = this.items.reduce(
      (r, o) => {
        var g;
        const {
          formula: a,
          mode: c,
          requiresUnarmored: f,
          requiresNoShield: d
          // @ts-expect-error
        } = o.system.ac ?? {};
        if (!a || o.type === "feature" && c === CONFIG.A5E.ARMOR_MODES.OVERRIDE && t || f && t || d && s || o.type === "object" && // @ts-expect-error
        o.system.equippedState !== CONFIG.A5E.EQUIPPED_STATES.EQUIPPED || o.system.objectType === "armor" && o.system.materialProperties.includes("underarmor") && r.override)
          return r;
        const p = mt(a, this.getRollData()) ?? 0, m = {
          name: o.name,
          id: o.uuid,
          mode: c,
          value: p
        };
        return c === CONFIG.A5E.ARMOR_MODES.OVERRIDE ? r.override = m : o.system.objectType === "shield" && p > (((g = r.shield) == null ? void 0 : g.value) ?? 0) ? r.shield = m : r.bonuses.push(m), r;
      },
      { override: null, shield: null, bonuses: [] }
    );
    n.shield && n.bonuses.unshift(n.shield), delete n.shield;
    const l = n.bonuses.reduce((r, { value: o }) => r + o, 0);
    return n.bonuses = { components: n.bonuses, value: l }, n;
  }
  /**
   * Prepare hit point bonuses for the actor.
   */
  prepareHitPointBonuses() {
    const { max: t } = this.system.attributes.hp, s = mt(
      this.BonusesManager.getHitPointsBonusFormula(),
      this.getRollData()
    );
    foundry.utils.setProperty(this, "system.attributes.hp.max", (t || 0) + s);
  }
  /**
   * Prepare skill data for the actor.
   */
  prepareSkills() {
    var r, o, a;
    const t = this.system, s = t.attributes.prof, n = (o = (r = this.flags) == null ? void 0 : r.a5e) == null ? void 0 : o.jackOfAllTrades;
    Object.values(t.skills).forEach((c) => {
      c.proficient === 2 ? c.mod = s * 2 : c.proficient ? c.mod = s : n ? c.mod = Math.floor(s / 2) : c.mod = 0, c.ability.startsWith("@attributes.spellcasting") && (c.ability = t.attributes.spellcasting);
    });
    const l = (a = this.grants) == null ? void 0 : a.byType("expertiseDice").filter((c) => {
      var f;
      return ((f = c.expertiseDiceData) == null ? void 0 : f.expertiseType) === "skill";
    });
    Object.entries(t.skills).forEach(([c, f]) => {
      const d = f.expertiseDice ?? 0, p = l == null ? void 0 : l.reduce((m, g) => {
        const { expertiseCount: h, keys: _ } = g.expertiseDiceData;
        return _.includes(c) ? Math.clamp(m + Number(h), 0, 5) : m;
      }, d);
      f.expertiseDice = p;
    }), Object.entries(t.skills).forEach(([c, f]) => {
      var m;
      const d = K(CONFIG.A5E.skills[c]);
      let p;
      try {
        p = mt(
          [
            // @ts-expect-error
            f.mod,
            // @ts-expect-error
            (m = this.BonusesManager) == null ? void 0 : m.getSkillBonusesFormula(c, f.ability, "check", !0)
          ].filter(Boolean).join(" + "),
          this.getRollData()
        );
      } catch {
        console.error(`Couldn't calculate a ${d} modifier for ${this.name}`);
      }
      f.deterministicBonus = p ?? f.mod;
      try {
        f.passive = this._calculatePassiveScore(c, f);
      } catch {
        console.error(`Couldn't calculate a ${d} passive score for ${this.name}`), f.passive = null;
      }
    });
  }
  /**
   * Calculate passive score for this actor.
   * @param {String} skillKey - The key of the skill to calculate the passive score for.
   * @param {Object} skill    - The skill object to calculate the passive score for.
   */
  _calculatePassiveScore(t, s) {
    var l, r, o;
    const n = this.getRollData();
    return mt(
      [
        10,
        s.mod,
        ((r = (l = n.abilities[s.ability]) == null ? void 0 : l.check) == null ? void 0 : r.deterministicBonus) ?? 0,
        (o = this.BonusesManager) == null ? void 0 : o.getSkillBonusesFormula(t, s.ability, "passive", !1)
      ].filter(Boolean).join(" + "),
      n
    );
  }
  /**
   * Prepare movement data taking into account any bonuses.
   */
  prepareMovement() {
    var l;
    const { movement: t } = this.system.attributes, s = Object.keys(t), n = [];
    for (const [r, { distance: o }] of Object.entries(t)) {
      const a = (l = this.BonusesManager) == null ? void 0 : l.getMovementBonusFormula(r);
      if (!a) continue;
      if (s.some((f) => a.includes(f))) {
        n.push(r);
        continue;
      }
      const c = mt(a, this.getRollData());
      c && (this.system.attributes.movement[r].distance = o + c);
    }
    n.forEach((r) => {
      var c;
      const o = (c = this.BonusesManager) == null ? void 0 : c.getMovementBonusFormula(r);
      if (!o) return;
      const a = mt(o, this.getRollData());
      a && (this.system.attributes.movement[r].distance = t[r].distance + a);
    });
  }
  /**
   * Prepare senses data taking into account any bonuses.
   */
  prepareSenses() {
    var l;
    const { senses: t } = this.system.attributes, s = Object.keys(t), n = [];
    for (const [r, { distance: o }] of Object.entries(t)) {
      const a = (l = this.BonusesManager) == null ? void 0 : l.getSensesBonusFormula(r);
      if (!a) continue;
      if (a === "unlimited") {
        this.system.attributes.senses[r].distance = 0, this.system.attributes.senses[r].unit = "unlimited";
        continue;
      }
      if (s.some((f) => a.includes(f))) {
        n.push(r);
        continue;
      }
      const c = mt(a, this.getRollData());
      c && (this.system.attributes.senses[r].distance = o + c);
    }
    n.forEach((r) => {
      var c;
      const o = (c = this.BonusesManager) == null ? void 0 : c.getSensesBonusFormula(r);
      if (!o) return;
      const a = mt(o, this.getRollData());
      a && (this.system.attributes.senses[r].distance = t[r].distance + a);
    });
  }
  /**
   * Prepare active effects for the actor with the phase 'afterDerived'.
   */
  afterDerivedData() {
    lc.applyEffects(
      this,
      this.actorEffects,
      "afterDerived",
      null,
      (t) => {
        var s;
        return ((s = game.a5e.activeEffects.options[this.type].allOptions[t.key]) == null ? void 0 : s.phase) === "afterDerived";
      }
    );
  }
  // -------------------------------------------------------------
  // Data Update Helpers
  // -------------------------------------------------------------
  async applyBulkDamage(t) {
    const s = {}, { value: n, temp: l } = this.system.attributes.hp, r = t.reduce(
      (o, [a]) => o + Math.floor(a),
      0
    );
    if (l ? s["system.attributes.hp"] = {
      temp: Math.clamped(l - r, 0, l),
      value: Math.clamped(n + l - r, 0, n)
    } : s["system.attributes.hp.value"] = Math.clamped(n - r, 0, n), game.settings.get("a5e", "enableCascadingDamageAndHealing")) {
      const o = game.settings.get("a5e", "cascadingDamageAndHealingDelay");
      let a = 0;
      t.forEach(([c, f]) => {
        setTimeout(async () => {
          await fd(this, "damage", `-${c}`, f);
        }, a), a += o;
      });
    }
    return Hooks.callAll("a5e.actorDamaged", this, { prevHp: { value: n, temp: l }, damageRolls: t }), this.update(s);
  }
  /**
   * Apply a certain amount of damage to the health pool for Actor, prioritizing temporary hp.
   * Negative damage values will have no effect.
   *
   * @param {number} damage  An amount of damage to apply to the actor.
   * @param {string} damageType A key indicating the type of damage the actor is taking.
   *
   * @returns {Promise<Actor5e>}  A Promise which resolves once the damage has been applied
   */
  async applyDamage(t, s = null) {
    const n = {}, { value: l, temp: r } = this.system.attributes.hp;
    return t = Math.floor(t), r ? n["system.attributes.hp"] = {
      temp: Math.clamp(r - t, 0, r),
      value: Math.clamp(l + r - t, 0, l)
    } : n["system.attributes.hp.value"] = Math.clamp(l - t, 0, l), game.settings.get("a5e", "enableCascadingDamageAndHealing") && fd(this, "damage", `-${t}`, s), Hooks.callAll("a5e.actorDamaged", this, { prevHp: { value: l, temp: r }, damage: t, damageType: s }), this.update(n);
  }
  async applyBulkHealing(t) {
    const s = {}, { value: n, max: l, temp: r } = this.system.attributes.hp;
    let o = !0;
    const { healing: a, temp: c } = t.reduce(
      (f, [d, p]) => (p === "temporaryHealing" ? f.temp += d : f.healing += d, f),
      { healing: 0, temp: 0 }
    );
    if (c && c <= r ? (ui.notifications.warn("A5E.ActionWarningTempHpNotOverwritten", { localize: !0 }), o = !1) : s["system.attributes.hp.temp"] = c, s["system.attributes.hp.value"] = Math.clamp(n + a, n, l), game.settings.get("a5e", "enableCascadingDamageAndHealing")) {
      const f = game.settings.get("a5e", "cascadingDamageAndHealingDelay");
      let d = 0;
      t.forEach(([p, m]) => {
        !o && m === "temporaryHealing" || (setTimeout(async () => {
          await fd(this, "healing", `+${p}`, m);
        }, d), d += f);
      });
    }
    return Hooks.callAll("a5e.actorHealed", this, { prevHp: { value: n, temp: r }, healingRolls: t }), this.update(s);
  }
  /**
   * Apply a certain amount of healing to the health pool for Actor. Temporary healing can be set
   * using a flag in the options object.
   *
   * When dealing with temporary hp, providing a value below the current temp hp of the target will
   * trigger a warning and abort the update of the actor.
   *
   * Negative healing value are ignored.
   *
   * @param {number} healing        An amount of damage to apply to the actor.
   * @param {string} healingType    A flag for indicating whether the healing being applied is
   *                                temporary.
   *
   * @returns {Promise<Actor5e>}  A Promise which resolves once the damage has been applied
   */
  async applyHealing(t, s) {
    const n = {}, { value: l, max: r, temp: o } = this.system.attributes.hp;
    if (t = Math.floor(t), s === "temporaryHealing") {
      if (t <= o)
        return ui.notifications.warn("A5E.ActionWarningTempHpNotOverwritten", { localize: !0 }), this;
      n["system.attributes.hp.temp"] = t;
    } else
      n["system.attributes.hp.value"] = Math.clamp(l + t, l, r);
    return game.settings.get("a5e", "enableCascadingDamageAndHealing") && fd(this, "healing", `+${t}`, s), Hooks.callAll("a5e.actorHealed", this, { prevHp: { value: l, temp: o }, healing: t, healingType: s }), this.update(n);
  }
  /** @inheritdoc */
  getRollData(t = null) {
    var r;
    const s = { ...super.getRollData() }, { abilities: n, skills: l } = this.system;
    if (s.prof = this.system.attributes.prof || 0, Object.entries(n).reduce((o, [a, c]) => (o.abilities ?? (o.abilities = {}), o.abilities[a] = { ...c, mod: c.check.mod }, o[a] = { ...c, mod: c.check.mod }, o), s), Object.entries(l).reduce((o, [a, c]) => (o.skills ?? (o.skills = {}), o.skills[a] = c, o[a] = c, o), s), s.finesse = {
      mod: Math.max(s.dex.mod, s.str.mod)
    }, this.isType("character") && (s.level = this.system.details.level), s.maneuverDC = this.system.attributes.maneuverDC, t && (s.item = t.getRollData()), t && t.isType("spell")) {
      const o = (r = this.spellBooks) == null ? void 0 : r.get(t.system.spellBook);
      o && (s.spell = { mod: o.stats.mod }, s.spellcasting = { mod: o.stats.mod }, s.spellDC = o.stats.dc);
    }
    return (!s.spell || !s.spellDC) && (s.spell = { mod: this._calculateSpellcastingMod() }, s.spellcasting = { mod: s.spell.mod }, s.spellDC = this.system.attributes.spellDC), s;
  }
  _calculateSpellcastingMod() {
    const { abilities: t, attributes: s } = this.system, n = s.spellcasting || "int";
    return t[n].check.mod;
  }
  async modifyTokenAttribute(t, s, n, l) {
    if (t === "attributes.hp") {
      const r = foundry.utils.getProperty(this.system, t), a = r.value + r.temp - s;
      return n ? s <= 0 ? this.applyDamage(-1 * s) : this.applyHealing(s) : a <= 0 ? this.applyHealing(-1 * a) : this.applyDamage(a);
    }
    return super.modifyTokenAttribute(t, s, n, l);
  }
  // -------------------------------------------------------------
  // Resources Reset Handlers
  // -------------------------------------------------------------
  async triggerRest(t = {}) {
    let s;
    if (foundry.utils.isEmpty(t)) {
      const l = K("A5E.RestConfigurationPrompt", { name: this.name }), r = new gi(this, l, bb);
      await r.render(!0), s = await (r == null ? void 0 : r.promise);
    } else
      s = foundry.utils.mergeObject(
        {
          consumeSupply: !1,
          haven: !0,
          recoverStrifeAndFatigue: !0,
          restType: "short"
        },
        t
      );
    if (!s) return;
    await new cp(this, s).restoreResources();
  }
  async updateDeathSavingThrowFigures(t) {
    const { death: s, fatigue: n, strife: l } = this.system.attributes, { success: r, failure: o } = s, a = t.dice[0].total, c = {
      "system.attributes.death": { success: r, failure: o }
    };
    a === 1 ? game.settings.get("a5e", "5eStyleDeathSaves") ? c["system.attributes.death"].failure += 2 : (c["system.attributes.death"].failure += 1, c["system.attributes.fatigue"] = n + 1, c["system.attributes.strife"] = l + 1) : a === 20 ? c["system.attributes.hp.value"] = 1 : a < (this.getFlag("a5e", "deathSaveThreshold") || 10) ? c["system.attributes.death"].failure += 1 : c["system.attributes.death"].success += 1, await this.update(c);
  }
  // TODO: Types - Narrow resource type
  async rechargeGenericResource(t) {
    var d, p, m, g, h, _, y, v;
    if (!this.system.resources[t]) return;
    const s = mt(this.system.resources[t].max, this.getRollData()) ?? 0, n = this.system.resources[t].value, l = ((p = (d = this.system.resources[t]) == null ? void 0 : d.recharge) == null ? void 0 : p.formula) || "1d6", r = ((g = (m = this.system.resources[t]) == null ? void 0 : m.recharge) == null ? void 0 : g.threshold) || 6, o = ((_ = (h = this.system.resources[t]) == null ? void 0 : h.recharge) == null ? void 0 : _.rechargeType) || "custom", a = ((v = (y = this.system.resources[t]) == null ? void 0 : y.recharge) == null ? void 0 : v.rechargeAmount) || "1", c = `system.resources.${t}.value`, f = await new Roll(l, this.getRollData()).evaluate();
    if (f.toMessage(), !(f.total < r))
      if (o === "min") await this.update({ [c]: 0 });
      else if (o === "max") await this.update({ [c]: s });
      else {
        const k = await new Roll(a, this.getRollData()).evaluate();
        await this.update({ [c]: Math.min(s, n + k.total) });
      }
  }
  // -------------------------------------------------------------
  // Sheet Toggles
  // -------------------------------------------------------------
  // -------------------------------------------------------------
  // Roll Handlers
  // -------------------------------------------------------------
  /**
   * Rolls an ability check for a given skill. A dialog is presented to the user so that they can
   * perform choose the size of the expertise die to use for the check.
   *
   * @param abilityKey - A key that can be used to reference a given ability score.
   */
  async rollAbilityCheck(t, s = {}) {
    var g, h;
    let n;
    if (s.skipRollDialog ? n = this.getDefaultAbilityCheckData(t, s) : n = await X(this, Kt, O9).call(this, t, s), !n) return null;
    const { expertiseDie: l, rollFormula: r, rollMode: o, visibilityMode: a } = n, f = await new ns({
      actor: this,
      rolls: [
        {
          ability: t,
          expertiseDie: l,
          rollFormula: r,
          rollMode: o,
          type: "abilityCheck"
        }
      ]
    }).prepareRolls(), d = {
      author: (g = game.user) == null ? void 0 : g.id,
      speaker: ChatMessage.getSpeaker({ actor: this }),
      sound: CONFIG.sounds.dice,
      rolls: f.map(({ roll: _ }) => _),
      rollMode: a ?? game.settings.get("core", "rollMode"),
      system: {
        actorId: this.uuid,
        actorName: this.name,
        img: ((h = this.token) == null ? void 0 : h.texture.src) ?? this.img,
        rollData: f.map(({ roll: _, ...y }) => y),
        rollType: "abilityCheck"
      },
      type: "roll"
    }, p = {
      abilityKey: t,
      expertiseDie: l,
      rollFormula: r,
      rollMode: o
    };
    return Hooks.callAll("a5e.rollAbilityCheck", this, p, f), ChatMessage.applyRollMode(d, a ?? game.settings.get("core", "rollMode")), await ChatMessage.create(d);
  }
  getDefaultAbilityCheckData(t, s = {}) {
    var c, f, d;
    const n = (s == null ? void 0 : s.rollMode) ?? CONFIG.A5E.ROLL_MODE.NORMAL, l = s.expertiseDice ?? this.system.abilities[t].check.expertiseDice ?? 0, r = (c = this.RollOverrideManager) == null ? void 0 : c.getExpertiseDice(
      `system.abilities.${t}.check`,
      l
    ), o = (f = this.RollOverrideManager) == null ? void 0 : f.getRollOverride(
      `system.abilities.${t}.check`,
      n
    ), a = ll(this, {
      ability: t,
      expertiseDie: r,
      rollMode: o,
      situationalMods: s.situationalMods,
      selectedAbilityBonuses: (d = this.BonusesManager) == null ? void 0 : d.getDefaultSelections("abilities", {
        abilityKey: t,
        abilityType: "check"
      }),
      type: "abilityCheck"
    });
    return {
      expertiseDie: r,
      rollFormula: a,
      rollMode: o,
      visibilityMode: s.visibilityMode ?? null
    };
  }
  async rollDeathSavingThrow(t = {}) {
    t.saveType = "death", t.expertiseDice ?? (t.expertiseDice = 0), t.visibilityMode ?? (t.visibilityMode = "gmroll"), game.settings.get("a5e", "blindDeathSaves") && (t.visibilityMode = "blindroll"), this.rollSavingThrow(void 0, t);
  }
  async rollHitDice(t, s = 1) {
    var l;
    return await ((l = this.HitDiceManager) == null ? void 0 : l.rollHitDice(t, s));
  }
  async rollSavingThrow(t, s = {}) {
    var h, _;
    let n;
    if (s.skipRollDialog ? n = this.getDefaultSavingThrowData(t, s) : n = await X(this, Kt, D9).call(this, t, s), n === null) return null;
    const { expertiseDie: l, rollFormula: r, rollMode: o, saveType: a, visibilityMode: c } = n, d = await new ns({
      actor: this,
      rolls: [
        {
          ability: t,
          expertiseDie: l,
          rollFormula: r,
          rollMode: o,
          saveType: a,
          type: "savingThrow"
        }
      ]
    }).prepareRolls(), p = {
      author: (h = game.user) == null ? void 0 : h.id,
      speaker: ChatMessage.getSpeaker({ actor: this }),
      sound: CONFIG.sounds.dice,
      rolls: d.map(({ roll: y }) => y),
      rollMode: c ?? game.settings.get("core", "rollMode"),
      system: {
        actorId: this.uuid,
        actorName: this.name,
        img: ((_ = this.token) == null ? void 0 : _.texture.src) ?? this.img,
        rollData: d.map(({ roll: y, ...v }) => v),
        rollType: "savingThrow"
      },
      type: "roll"
    }, m = {
      abilityKey: t,
      expertiseDie: l,
      rollFormula: r,
      rollMode: o
    };
    return (s == null ? void 0 : s.saveType) === "death" ? (Hooks.callAll("a5e.rollDeathSavingThrow", this, m, d), this.updateDeathSavingThrowFigures(d.map(({ roll: y }) => y)[0])) : Hooks.callAll("a5e.rollSavingThrow", this, m, d), ChatMessage.applyRollMode(p, c ?? game.settings.get("core", "rollMode")), await ChatMessage.create(p);
  }
  getDefaultSavingThrowData(t, s = {}) {
    var f, d, p, m;
    const n = (s == null ? void 0 : s.rollMode) ?? CONFIG.A5E.ROLL_MODE.NORMAL, l = s.expertiseDice ?? ((f = this.system.abilities[t || ""]) == null ? void 0 : f.save.expertiseDice) ?? 0, r = t ? `system.abilities.${t}.save` : "deathSave", o = (d = this.RollOverrideManager) == null ? void 0 : d.getRollOverride(r, n), a = (p = this.RollOverrideManager) == null ? void 0 : p.getExpertiseDice(
      r,
      l
    ), c = ll(this, {
      ability: t,
      expertiseDie: a,
      rollMode: o,
      saveType: s.saveType,
      situationalMods: s.situationalMods,
      selectedAbilityBonuses: (m = this.BonusesManager) == null ? void 0 : m.getDefaultSelections("abilities", {
        abilityKey: t,
        abilityType: "save"
      }),
      type: "savingThrow"
    });
    return {
      expertiseDie: a,
      rollMode: o,
      rollFormula: c,
      visibilityMode: s.visibilityMode ?? null
    };
  }
  /**
   * Rolls a skill check for a given skill. A dialog is presented to the user so that they can
   * perform additional configuration, such as choosing an ability score for the check.
   *
   * @async
   * @method
   * @param {string} skillKey A key that can be used to reference a given skill.
   * @param {object}
   *
   * @returns {Promise<undefined>}
   */
  async rollSkillCheck(t, s = {}) {
    var h, _;
    let n;
    if (s.expertiseDice ?? (s.expertiseDice = this.system.skills[t].expertiseDice ?? 0), s.skipRollDialog ? n = this.getDefaultSkillCheckData(t, s) : n = await X(this, Kt, I9).call(this, t, s), !n) return null;
    const { abilityKey: l, expertiseDie: r, rollFormula: o, rollMode: a, visibilityMode: c } = n, d = await new ns({
      actor: this,
      rolls: [
        {
          ability: l,
          expertiseDie: r,
          rollFormula: o,
          rollMode: a,
          skill: t,
          type: "skillCheck"
        }
      ]
    }).prepareRolls(), p = {
      author: (h = game.user) == null ? void 0 : h.id,
      speaker: ChatMessage.getSpeaker({ actor: this }),
      sound: CONFIG.sounds.dice,
      rolls: d.map(({ roll: y }) => y),
      rollMode: c ?? game.settings.get("core", "rollMode"),
      system: {
        actorId: this.uuid,
        actorName: this.name,
        img: ((_ = this.token) == null ? void 0 : _.texture.src) ?? this.img,
        rollData: d.map(({ roll: y, ...v }) => v),
        rollType: "skillCheck"
      },
      type: "roll"
    }, m = {
      abilityKey: l,
      expertiseDie: r,
      rollFormula: o,
      rollMode: a,
      skillKey: t
    };
    return Hooks.callAll("a5e.rollSkillCheck", this, m, d), ChatMessage.applyRollMode(p, c ?? game.settings.get("core", "rollMode")), await ChatMessage.create(p);
  }
  getDefaultSkillCheckData(t, s = {}) {
    var d, p, m, g;
    const n = this.system.skills[t], l = (s == null ? void 0 : s.abilityKey) ?? n.ability, r = (s == null ? void 0 : s.rollMode) ?? CONFIG.A5E.ROLL_MODE.NORMAL, o = (s == null ? void 0 : s.expertiseDice) ?? n.expertiseDice ?? 0, a = (d = this.RollOverrideManager) == null ? void 0 : d.getExpertiseDice(
      `system.skills.${t}`,
      o,
      { ability: l }
    ), c = (p = this.RollOverrideManager) == null ? void 0 : p.getRollOverride(
      `system.skills.${t}`,
      r,
      { ability: l }
    ), f = ll(this, {
      ability: l,
      expertiseDie: a,
      minRoll: s.minRoll ?? n.minRoll,
      proficient: n.proficient,
      type: "skillCheck",
      rollMode: c,
      skill: t,
      selectedAbilityBonuses: (m = this.BonusesManager) == null ? void 0 : m.getDefaultSelections("abilities", {
        abilityKey: l,
        abilityType: "check"
      }),
      selectedSkillBonuses: (g = this.BonusesManager) == null ? void 0 : g.getDefaultSelections("skills", {
        skillKey: t,
        abilityKey: l
      }),
      situationalMods: s.situationalMods
    });
    return {
      abilityKey: l,
      rollMode: c,
      expertiseDie: a,
      rollFormula: f,
      visibilityMode: s.visibilityMode ?? null
    };
  }
  // -------------------------------------------------------------
  // Config Handlers
  // -------------------------------------------------------------
  addBonus(t = "damage") {
    var n;
    const s = foundry.utils.duplicate(this._source.system.bonuses[t] ?? {});
    (n = Object.keys(CONFIG.A5E.bonusTypes)) != null && n.includes(t) && this.update({
      [`system.bonuses.${t}`]: {
        ...s,
        [foundry.utils.randomID()]: {}
      }
    });
  }
  configureAbilityScore(t = {}, s = {}) {
    const n = K("A5E.AbilityCheckPromptTitle", {
      name: this.name,
      ability: K(CONFIG.A5E.abilities[t.abilityKey])
    });
    X(this, Kt, bs).call(this, "ability", n, t, s);
  }
  configureAlignment(t = {}, s = {}) {
    const n = K("A5E.AlignmentConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.Alignments"), t.propertyKey ?? (t.propertyKey = "system.traits.alignment"), t.configObject ?? (t.configObject = CONFIG.A5E.alignments), t.type ?? (t.type = "alignment"), X(this, Kt, bs).call(this, "alignment", n, t, s);
  }
  configureArmorClass(t = {}, s = {}) {
    const n = K("A5E.ACConfigurationPrompt", { name: this.name });
    X(this, Kt, bs).call(this, "armorClass", n, t, s);
  }
  configureArmorProficiencies(t = {}, s = {}) {
    const n = K("A5E.ArmorProficienciesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.ArmorProficiencies"), t.propertyKey ?? (t.propertyKey = "system.proficiencies.armor"), t.configObject ?? (t.configObject = CONFIG.A5E.armor), t.type ?? (t.type = "armorTypes"), X(this, Kt, bs).call(this, "armor", n, t, s);
  }
  configureConditionImmunities(t = {}, s = {}) {
    const n = K("A5E.ConditionImmunitiesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.ConditionImmunities"), t.configObject ?? (t.configObject = CONFIG.A5E.conditions), t.propertyKey ?? (t.propertyKey = "system.traits.conditionImmunities"), t.type ?? (t.type = "conditionImmunities"), X(this, Kt, bs).call(this, "conditionImmunities", n, t, s);
  }
  configureCreatureTypes(t = {}, s = {}) {
    const n = K("A5E.CreatureTypesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.CreatureTypePlural"), t.configObject ?? (t.configObject = CONFIG.A5E.creatureTypes), t.propertyKey ?? (t.propertyKey = "system.details.creatureTypes"), t.type ?? (t.type = "creatureTypes"), X(this, Kt, bs).call(this, "types", n, t, s);
  }
  configureBonus(t, s = "damage") {
    var r;
    const n = CONFIG.A5E.bonusDialogKeys[s];
    if (!n) return;
    const l = `${this.name} ${K(((r = CONFIG.A5E.bonusLabels[s]) == null ? void 0 : r.dialogName) ?? s)}`;
    X(this, Kt, bs).call(this, n, l, { bonusID: t }, {});
  }
  configureCreatureTerrains(t = {}, s = {}) {
    t.heading ?? (t.heading = "A5E.CreatureTerrainsLabel"), t.configObject ?? (t.configObject = CONFIG.A5E.terrainTypes), t.propertyKey ?? (t.propertyKey = "system.details.terrain"), t.type ?? (t.type = "creatureTerrains"), X(this, Kt, bs).call(this, "terrain", `${this.name}: Configure Creature Terrains`, t, s);
  }
  configureDamageImmunities(t = {}, s = {}) {
    const n = K("A5E.DamageImmunitiesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.DamageTypePlural"), t.configObject ?? (t.configObject = CONFIG.A5E.damageTypes), t.propertyKey ?? (t.propertyKey = "system.traits.damageImmunities"), t.type ?? (t.type = "damageImmunities"), X(this, Kt, bs).call(this, "damageImmunities", n, t, s);
  }
  configureDamageResistances(t = {}, s = {}) {
    const n = K("A5E.DamageResistancesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.DamageTypePlural"), t.configObject ?? (t.configObject = CONFIG.A5E.damageTypes), t.propertyKey ?? (t.propertyKey = "system.traits.damageResistances"), t.type ?? (t.type = "damageResistances"), X(this, Kt, bs).call(this, "damageResistances", n, t, s);
  }
  configureDamageVulnerabilities(t = {}, s = {}) {
    const n = K("A5E.DamageVulnerabilitiesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.DamageTypePlural"), t.configObject ?? (t.configObject = CONFIG.A5E.damageTypes), t.propertyKey ?? (t.propertyKey = "system.traits.damageVulnerabilities"), t.type ?? (t.type = "damageVulnerabilities"), X(this, Kt, bs).call(this, "damageVulnerabilities", n, t, s);
  }
  configureHealth(t = {}, s = {}) {
    const n = K("A5E.HitPointsConfigurationPrompt", { name: this.name });
    s.width ?? (s.width = 380), X(this, Kt, bs).call(this, "health", n, t, s);
  }
  configureInitiative(t = {}, s = {}) {
    const n = K("A5E.InitiativeConfigurationPrompt", { name: this.name });
    X(this, Kt, bs).call(this, "initiative", n, t, { ...s, width: s.width ?? 432 });
  }
  configureLanguages(t = {}, s = {}) {
    const n = K("A5E.LanguagesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.Languages"), t.configObject ?? (t.configObject = CONFIG.A5E.languages), t.propertyKey ?? (t.propertyKey = "system.proficiencies.languages"), t.type ?? (t.type = "languages"), X(this, Kt, bs).call(this, "languages", n, t, s);
  }
  configureMovement(t = {}, s = {}) {
    const n = K("A5E.MovementConfigurationPrompt", { name: this.name });
    X(this, Kt, bs).call(this, "movement", n, t, s);
  }
  configureManeuverTraditions(t = {}, s = {}) {
    const n = K("A5E.ManeuverTraditionsConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.ManeuverTraditionPlural"), t.configObject ?? (t.configObject = CONFIG.A5E.maneuverTraditions), t.propertyKey ?? (t.propertyKey = "system.proficiencies.traditions"), t.type ?? (t.type = "maneuverTraditions"), X(this, Kt, bs).call(this, "maneuverTraditions", n, t, s);
  }
  configureSenses(t = {}, s = {}) {
    const n = K("A5E.SensesConfigurationPrompt", { name: this.name });
    X(this, Kt, bs).call(this, "senses", n, t, s);
  }
  configureSizeCategory(t = {}, s = {}) {
    const n = K("A5E.SizeCategoryConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.SizeCategory"), t.configObject ?? (t.configObject = CONFIG.A5E.actorSizes), t.propertyKey ?? (t.propertyKey = "system.traits.size"), t.type ?? (t.type = "size"), X(this, Kt, bs).call(this, "size", n, t, s);
  }
  configureSkill(t = {}, s = { width: 440 }) {
    const n = K("A5E.SkillConfigurationPrompt", {
      name: this.name,
      skill: K(CONFIG.A5E.skills[t.skillKey])
    });
    X(this, Kt, bs).call(this, "skill", n, t, s);
  }
  configureToolProficiencies(t = {}, s = {}) {
    const n = K("A5E.ToolProficienciesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.ToolProficiencies"), t.configObject ?? (t.configObject = CONFIG.A5E.tools), t.propertyKey ?? (t.propertyKey = "system.proficiencies.tools"), t.type ?? (t.type = "tools"), X(this, Kt, bs).call(this, "tools", n, t, s);
  }
  configureWeaponProficiencies(t = {}, s = {}) {
    const n = K("A5E.WeaponProficienciesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.WeaponPlural"), t.configObject ?? (t.configObject = CONFIG.A5E.weapons), t.propertyKey ?? (t.propertyKey = "system.proficiencies.weapons"), t.type ?? (t.type = "weapons"), X(this, Kt, bs).call(this, "weapons", n, t, s);
  }
  async deleteBonus(t, s = "damage") {
    const n = this.dialogs.bonuses[t];
    await (n == null ? void 0 : n.close()), delete this.dialogs.bonuses[t], await this.update({
      [`system.bonuses.${s}`]: {
        [`-=${t}`]: null
      }
    });
  }
  duplicateBonus(t, s = "damage") {
    let n;
    const l = foundry.utils.duplicate(this._source.system.bonuses[s] ?? {});
    if (foundry.utils.isEmpty(l)) return;
    const r = foundry.utils.duplicate(this.system.bonuses[s][t]);
    s === "damage" ? n = K("A5E.NewDamageBonus") : s === "healing" ? n = K("A5E.NewHealingBonus") : n = "New Bonus", r.label = `${r.label || n} (Copy)`, this.update({
      [`system.bonuses.${s}`]: {
        ...l,
        [foundry.utils.randomID()]: r
      }
    });
  }
  // -------------------------------------------------------------
  // Document Update Hooks
  // -------------------------------------------------------------
  /** @inheritdoc */
  async _preCreate(t, s, n) {
    var o;
    await super._preCreate(t, s, n);
    const l = du.LATEST_MIGRATION_VERSION, r = (o = this.system.migrationData) == null ? void 0 : o.version;
    if (r ? r < l && await T9(this) : this.updateSource({
      // @ts-expect-error
      "system.migrationData": {
        version: l,
        type: "Actor"
      }
    }), this.type === "character") {
      const a = { vision: !0, actorLink: !0, disposition: 1 };
      this.updateSource({ prototypeToken: a });
    }
  }
  /** @inheritdoc */
  async _preUpdate(t, s, n) {
    var d, p, m, g, h, _;
    const l = Object.keys(((d = this.flags) == null ? void 0 : d.a5e) ?? {}).includes("-=autoApplyFSConditions"), r = Object.keys(((p = t == null ? void 0 : t.flags) == null ? void 0 : p.a5e) ?? {}).includes(
      "-=-=autoApplyFSConditions"
    );
    l && !r && await this.unsetFlag("a5e", "-=autoApplyFSConditions"), (((g = (m = t == null ? void 0 : t.flags) == null ? void 0 : m.a5e) == null ? void 0 : g.autoApplyFSConditions) ?? !0) && HW(this, foundry.utils.deepClone(t), n.id), foundry.utils.setProperty(t, "flags.a5e.-=autoApplyFSConditions", null), await super._preUpdate(t, s, n), foundry.utils.getProperty(t, "system.attributes.hp.value") < 0 && foundry.utils.setProperty(t, "system.attributes.hp.value", 0), foundry.utils.getProperty(t, "system.attributes.hp.temp") <= 0 && foundry.utils.setProperty(t, "system.attributes.hp.temp", 0);
    const a = this.system.attributes.hp.value === 0, c = foundry.utils.getProperty(t, "system.attributes.hp.value") > 0;
    if (a && c && (foundry.utils.setProperty(t, "system.attributes.death.success", 0), foundry.utils.setProperty(t, "system.attributes.death.failure", 0)), (((_ = (h = this.flags) == null ? void 0 : h.a5e) == null ? void 0 : _.automatePrototypeTokenSize) ?? game.settings.get("a5e", "automatePrototypeTokenSize") ?? !0) && foundry.utils.getProperty(t, "system.traits.size")) {
      const y = t.system.traits.size;
      (y !== "titan" || (this.prototypeToken.width ?? 1) < 5) && (foundry.utils.setProperty(
        t,
        "prototypeToken.height",
        CONFIG.A5E.tokenDimensions[y]
      ), foundry.utils.setProperty(
        t,
        "prototypeToken.width",
        CONFIG.A5E.tokenDimensions[y]
      ));
    }
  }
  /** @inheritdoc */
  _onUpdate(t, s, n) {
    super._onUpdate(t, s, n);
    const l = game.settings.get("a5e", "automateBloodiedApplication") ?? !0, r = game.settings.get("a5e", "automateUnconsciousApplication") ?? !0;
    l && AD(this, t, n, "bloodied"), r && AD(this, t, n, "unconscious");
  }
  // -------------------------------------------------------------
  // Functionality Patches
  // -------------------------------------------------------------
  async toggleStatusEffect(t, s = { active: !0, overlay: !1 }) {
    const { active: n, overlay: l = !1 } = s, r = CONFIG.statusEffects.find((f) => f.id === t);
    if (!r)
      throw new Error(`Invalid status ID "${t}" provided to Actor#toggleStatusEffect`);
    const o = [], a = [];
    if (r._id) {
      const f = this.effects.get(r._id);
      f && f.id && (o.push(f.id), a.push(f));
    } else
      for (const f of this.effects) {
        const { statuses: d } = f;
        d.size === 1 && d.has(r.id) && f.id && (a.push(f), o.push(f.id));
      }
    if (["corruption", "fatigue", "exhaustion", "inebriated", "strife"].includes(t)) {
      const f = n ? 1 : -1, d = this.system.attributes[t], p = CONFIG.A5E.multiLevelConditionsMaxLevel[t] ?? 7;
      if (f === 1 && d >= p || f === -1 && d <= 0) return;
      const m = t === "fatigue" && game.settings.get("a5e", "replaceFatigueAndStrife") ? "exhaustion" : t, g = Object.entries(CONFIG.A5E.multiLevelConditions[m] ?? {}).reduce(
        (_, [y, v]) => (y > d + f || _.push(...v), _),
        []
      ), h = n ? Math.min(d + 1, p) : Math.max(d - 1, 0);
      if (this.update({
        [`system.attributes.${t}`]: h,
        "flags.a5e.autoApplyFSConditions": !1
      }), o.length && d === 1 && !n)
        return await this.deleteEmbeddedDocuments("ActiveEffect", o), !1;
      if (o.length && d > 0)
        return await a[0].update({ changes: g });
      if (n) {
        const _ = await ActiveEffect.implementation.fromStatusEffect(t);
        return _.updateSource({ changes: g }), ActiveEffect.implementation.create(_, { parent: this, keepId: !0 });
      }
    }
    if (o.length)
      return n ? !0 : (await this.deleteEmbeddedDocuments("ActiveEffect", o), !1);
    if (!n && n !== void 0) return;
    const c = await ActiveEffect.implementation.fromStatusEffect(t);
    return l && c.updateSource({ "flags.core.overlay": !0 }), ActiveEffect.implementation.create(c, { parent: this, keepId: !0 });
  }
};
lh = new WeakMap(), Kt = new WeakSet(), O9 = /* @__PURE__ */ u(async function(t, s = {}, n = {}) {
  const l = K("A5E.AbilityCheckPromptTitle", {
    name: this.name,
    ability: K(CONFIG.A5E.abilities[t])
  }), r = new Ko(
    this,
    l,
    cb,
    { abilityKey: t },
    s,
    n
  );
  return await r.render(!0), await r.promise;
}, "#showAbilityCheckPrompt"), D9 = /* @__PURE__ */ u(async function(t, s = {}, n = {}) {
  let l;
  s.saveType === "death" ? l = K("A5E.DeathSavingThrowPromptTitle", { name: this.name }) : l = K(
    "A5E.SavingThrowPromptTitle",
    // @ts-expect-error
    { name: this.name, ability: K(CONFIG.A5E.abilities[t]) }
  );
  const r = new Ko(
    this,
    l,
    _b,
    { abilityKey: t },
    s,
    n
  );
  return await r.render(!0), await r.promise;
}, "#showSavingThrowPrompt"), I9 = /* @__PURE__ */ u(async function(t, s = {}, n = {}) {
  const l = K("A5E.SkillPromptTitle", {
    name: this.name,
    skill: K(CONFIG.A5E.skills[t])
  }), r = new Ko(
    this,
    l,
    kb,
    { skillKey: t },
    s,
    n
  );
  return await r.render(!0), await r.promise;
}, "#showSkillCheckPrompt"), bs = /* @__PURE__ */ u(function(t, s, n, l) {
  if (!this.isOwner) return;
  const r = P(this, lh)[t];
  let o;
  t === "ability" ? o = this.dialogs.abilities[n.abilityKey] : t === "skill" ? o = this.dialogs.skills[n.skillKey] : Object.values(CONFIG.A5E.bonusDialogKeys).includes(t) ? o = this.dialogs.bonuses[n.bonusID] : o = this.dialogs[t], o || (o = new gi(this, s, r, n, l), t === "ability" ? this.dialogs.abilities[n.abilityKey] = o : t === "skill" ? this.dialogs.skills[n.skillKey] = o : Object.values(CONFIG.A5E.bonusDialogKeys).includes(t) ? this.dialogs.bonuses[n.bonusID] = o : this.dialogs[t] = o), o == null || o.render(!0);
}, "#configure"), u(B$, "BaseActorA5e");
let fc = B$;
var qt, hr, Fa, Ra, Cf, Rb;
const q$ = class q$ {
  constructor(e, t = !0) {
    x(this, Cf);
    x(this, qt);
    x(this, hr);
    x(this, Fa, 0);
    x(this, Ra, 0);
    qe(this, "dieSizes", /* @__PURE__ */ new Set());
    if (Ae(this, qt, e), Ae(this, hr, t), P(this, qt).type === "character" && t) {
      Object.values(P(this, qt).classes).forEach((s) => {
        Ae(this, Fa, P(this, Fa) + s.hitDice.total), Ae(this, Ra, P(this, Ra) + (s.hitDice.total - s.hitDice.current)), this.dieSizes.add(s.hitDice.size);
      });
      return;
    }
    Object.entries(P(this, qt).system.attributes.hitDice ?? {}).forEach(
      ([s, { current: n, total: l }]) => {
        const r = Number.parseInt(s.slice(1), 10);
        Ae(this, Ra, P(this, Ra) + (l - n)), Ae(this, Fa, P(this, Fa) + l), this.dieSizes.add(r);
      }
    );
  }
  get max() {
    return P(this, Fa);
  }
  get value() {
    return P(this, Ra);
  }
  get smallest() {
    return this.dieSizes.size ? Math.min(...this.dieSizes) : 0;
  }
  get largest() {
    return this.dieSizes.size ? Math.max(...this.dieSizes) : 0;
  }
  get bySize() {
    return P(this, qt).type === "character" && P(this, hr) ? Object.values(P(this, qt).classes ?? {}).reduce(
      (t, s) => {
        var o;
        const { current: n, total: l, size: r } = s.hitDice;
        return t[o = `d${r}`] ?? (t[o] = { current: 0, total: 0 }), t[`d${r}`].current += n, t[`d${r}`].total += l, t;
      },
      {}
    ) : P(this, qt).system.attributes.hitDice ?? {};
  }
  async consumeHitDice(e) {
    if (P(this, qt).type === "npc" || !P(this, hr)) {
      const { hitDice: n } = P(this, qt).system.attributes;
      Object.entries(n ?? {}).forEach(([l, { current: r }]) => {
        const o = e[l] ?? 0;
        n[l].current = Math.max(r - o, 0);
      }), await P(this, qt).update({
        "system.attributes.hitDice": n
      });
    }
    const t = P(this, qt).classes ?? {}, s = [];
    Object.entries(e ?? {}).forEach(([n, l]) => {
      const r = Object.values(t).find(
        (o) => o.hitDice.size === Number.parseInt(n.slice(1), 10) && o.hitDice.current - l >= 0
      );
      r && s.push({
        // @ts-expect-error
        _id: r.id,
        // @ts-expect-error
        "system.hp.hitDiceUsed": Math.min(r.system.hp.hitDiceUsed + l, r.classLevels)
      });
    }), await P(this, qt).updateEmbeddedDocuments("Item", s);
  }
  async rollHitDice(e = null, t = 1) {
    const s = P(this, qt).system, n = Number.parseInt(s.abilities.con.check.mod, 10) || 0;
    if (P(this, qt).type === "npc" || !P(this, hr)) {
      const { attributes: p } = s;
      if (!e || p.hitDice[e].current - t < 0) return null;
      const m = `${t}${e} + ${t * n}`, { hookData: g, chatData: h } = await X(this, Cf, Rb).call(this, e, p.hitDice[e].current, t, m);
      P(this, qt).update({
        "system.attributes": {
          [`hitDice.${e}.current`]: p.hitDice[e].current - t
        }
      });
      const _ = await ChatMessage.create(h);
      return Hooks.callAll("a5e.rollHitDice", P(this, qt), g), _;
    }
    const l = P(this, qt).classes ?? {};
    let r;
    if (e) {
      if (r = Object.values(l).find(
        (p) => p.hitDice.size === Number.parseInt(e.slice(1), 10) && p.hitDice.current - t >= 0
      ), !r) return null;
    } else {
      const p = this.largest;
      if (!p || (r = Object.values(l).find(
        (m) => m.hitDice.size === p && m.hitDice.current - t >= 0
      ), !r)) return null;
    }
    const { size: o } = r.hitDice, a = `${t}d${o} + ${t * n}`, { hookData: c, chatData: f } = await X(this, Cf, Rb).call(this, `d${o}`, r.hitDice.current, t, a);
    r.update({
      "system.hp.hitDiceUsed": Math.min(r.system.hp.hitDiceUsed + t, r.classLevels)
    });
    const d = await ChatMessage.create(f);
    return Hooks.callAll("a5e.rollHitDice", P(this, qt), c), d;
  }
  getUpdateData({ upperLimit: e, restoreLargest: t } = {
    upperLimit: 0,
    restoreLargest: !0
  }) {
    if (e || (e = Math.max(Math.floor(this.max / 2), 1) || 1), P(this, qt).type === "character" && P(this, hr)) {
      const r = [];
      let o = 0;
      return Object.values(P(this, qt).classes ?? {}).sort((c, f) => t ? f.hitDice.size - c.hitDice.size : c.hitDice.size - f.hitDice.size).forEach((c) => {
        const f = c.system.hp.hitDiceUsed;
        if (f === 0 || o >= e) return;
        const d = Math.min(f, e - o);
        o += d, r.push({ _id: c.id, "system.hp.hitDiceUsed": f - d });
      }), { updates: r, recovered: o, type: "embedded" };
    }
    const s = {};
    let n = 0;
    return Object.entries(
      P(this, qt).system.attributes.hitDice ?? {}
    ).sort(([r], [o]) => t ? Number.parseInt(o.slice(1), 10) - Number.parseInt(r.slice(1), 10) : Number.parseInt(r.slice(1), 10) - Number.parseInt(o.slice(1), 10)).forEach(
      ([r, { current: o, total: a }]) => {
        const c = a - o;
        if (c === 0 || n >= e) return;
        const f = Math.min(c, e - n);
        n += f, s[`system.attributes.hitDice.${r}.current`] = o + f;
      }
    ), { updates: s, recovered: n, type: "actor" };
  }
};
qt = new WeakMap(), hr = new WeakMap(), Fa = new WeakMap(), Ra = new WeakMap(), Cf = new WeakSet(), Rb = /* @__PURE__ */ u(async function(e, t, s, n) {
  var p, m;
  const { attributes: l } = P(this, qt).system, r = await new Roll(n).roll(), o = K("A5E.HitDiceChatHeader", { dieSize: e.toUpperCase() }), a = {
    author: (p = game.user) == null ? void 0 : p.id,
    //  @ts-expect-error
    speaker: ChatMessage.getSpeaker({ actor: P(this, qt) }),
    sound: CONFIG.sounds.dice,
    rolls: [r],
    flags: {
      a5e: {
        actorId: P(this, qt).uuid,
        img: ((m = P(this, qt).token) == null ? void 0 : m.texture.src) ?? P(this, qt).img,
        name: P(this, qt).name,
        title: o
      }
    }
  }, c = Math.max(r.total, 0), f = l.hp.max;
  return P(this, qt).applyHealing(c), { hookData: {
    dieSize: e,
    dieCount: t - s,
    formula: n,
    newHp: Math.min(l.hp.value + c, f),
    roll: r,
    quantity: s
  }, chatData: a };
}, "#rollHitDice"), u(q$, "HitDiceManager");
let vu = q$;
function WW(i) {
  var s, n, l, r, o, a, c, f;
  const t = Object.values(i.rolls ?? {}).filter(
    (d) => ["damage", "healing"].includes(d.type)
  ).reduce((d, p) => {
    var m, g;
    return (m = p.scaling) != null && m.mode && d.add((g = p.scaling) == null ? void 0 : g.mode), d;
  }, /* @__PURE__ */ new Set());
  return (n = (s = i.target) == null ? void 0 : s.scaling) != null && n.mode && t.add((r = (l = i.target) == null ? void 0 : l.scaling) == null ? void 0 : r.mode), (a = (o = i.area) == null ? void 0 : o.scaling) != null && a.mode && t.add((f = (c = i.area) == null ? void 0 : c.scaling) == null ? void 0 : f.mode), t;
}
u(WW, "getActionScalingModes");
var gs, Zi, lo, Tf, Of, rn, Dn, P9, M9, F9, R9, N9, j9, Na, Fd;
const Go = class Go {
  constructor(e, t, s, n, l) {
    x(this, Dn);
    x(this, gs);
    x(this, Zi);
    x(this, lo);
    x(this, Tf);
    x(this, Of);
    x(this, rn);
    Ae(this, gs, e), Ae(this, Zi, t), Ae(this, lo, s), Ae(this, Tf, n), Ae(this, Of, l), Ae(this, rn, {
      actor: {},
      item: {}
    });
  }
  get action() {
    return P(this, Zi).actions.get(P(this, lo));
  }
  async consumeResources() {
    var r;
    const e = Object.entries(((r = this.action) == null ? void 0 : r.consumers) ?? {}), { actionUses: t, hitDice: s, itemUses: n, spell: l } = P(this, Tf);
    e.forEach(([o, a]) => {
      const c = a.type;
      c && P(this, Of).includes(o) && (c === "actionUses" ? X(this, Dn, P9).call(this, t) : c === "hitDice" ? X(this, Dn, M9).call(this, s) : c === "itemUses" ? X(this, Dn, F9).call(this, n) : c === "spell" ? X(this, Dn, j9).call(this, l) : c === "resource" ? X(this, Dn, N9).call(this, a) : ["ammunition", "quantity"].includes(c) && X(this, Dn, R9).call(this, o, a));
    }), await P(this, Zi).update(P(this, rn).item), await P(this, gs).update(P(this, rn).actor);
  }
  static getDefaultConsumerSelection(e) {
    return Object.entries(e).reduce((s, [n, l]) => {
      var r;
      return n === "resource" ? l.forEach((o) => {
        var a;
        (a = o[1]) != null && a.default && s.push(o[0]);
      }) : (r = l[1]) != null && r.default && s.push(l[0]), s;
    }, []);
  }
  static prepareHitDiceData(e, t) {
    const s = X(this, Na, Fd).call(this, t, "hitDice"), n = {}, l = N5(e).reduce((r, { die: o, total: a }) => (a > 0 && r.push(o), r), []);
    return n.selected = Object.fromEntries(
      l.map((r, o) => [r, o === 0 ? 1 : 0])
    ), n.quantity = s.quantity ?? 1, {
      availableHitDice: l,
      hitDiceData: n
    };
  }
  static prepareSpellData(e, t, s, n) {
    var v, k;
    const l = t.actions.get(n), { A5E: r } = CONFIG, o = Object.entries(r.spellLevels).slice(1), a = e.spellBooks.get(t.system.spellBook), { spellResources: c } = e.system, f = c.artifactCharges.current, d = c.points.current, p = Object.entries(c.slots).reduce(
      (S, [D, I]) => (I.max > 0 && I.current > 0 && S.push(D), S),
      []
    ), m = {}, g = ((v = Object.values(s.spell ?? {})) == null ? void 0 : v[1]) ?? {};
    let h = g.mode ?? "variable";
    if (m.basePoints = g.points ?? 1, m.baseLevel = g.spellLevel ?? t.system.level ?? 1, foundry.utils.isEmpty(g)) {
      m.consume = "noConsume";
      const S = WW(l);
      S.size && (S.has("artifactCharges") ? h = "chargesOnly" : S.has("spellPoints") ? h = "pointsOnly" : S.has("spellSlots") && (h = "slotsOnly"), m.basePoints = 0);
    } else
      h === "chargesOnly" ? m.consume = "artifactCharge" : h === "pointsOnly" ? m.consume = "spellPoint" : h === "slotsOnly" ? m.consume = "spellSlot" : f > 0 ? m.consume = "artifactCharge" : d > 0 ? m.consume = "spellPoint" : p.length > 0 ? m.consume = "spellSlot" : m.consume = "noConsume";
    (t.system.level === null || t.system.level === void 0) && (m.consume = "noConsume"), a != null && a.disableSpellConsumers && (m.consume = "noConsume");
    const _ = g.spellLevel ?? t.system.level ?? 1, y = Math.min(...p.map(Number));
    return m.level = m.consume === "spellSlot" ? Math.max(_, y) : _, m.baseCharges = m.level, m.charges = g.charges ?? m.level ?? 1, m.points = g.points ?? r.spellLevelCost[(k = t.system) == null ? void 0 : k.level] ?? 1, {
      availableCharges: f,
      availablePoints: d,
      availableSpellSlots: p,
      consumer: g,
      mode: h,
      spellData: m,
      spellLevels: o,
      spellResources: c
    };
  }
  static prepareUsesData(e, t, s, n) {
    var g, h;
    const l = t.actions.get(n), r = X(g = Go, Na, Fd).call(g, s, "actionUses"), o = X(h = Go, Na, Fd).call(h, s, "itemUses"), a = {}, c = {};
    a.baseUses = (r == null ? void 0 : r.quantity) ?? 1, a.quantity = (r == null ? void 0 : r.quantity) ?? 1, c.baseUses = (o == null ? void 0 : o.quantity) ?? 1, c.quantity = (o == null ? void 0 : o.quantity) ?? 1;
    const f = (l == null ? void 0 : l.uses) ?? {}, d = t.system.uses, p = mt(d.max, e.getRollData(t));
    return {
      actionMaxUses: mt(f.max ?? 0, e.getRollData(t)),
      actionUses: f,
      actionUsesData: a,
      itemMaxUses: p,
      itemUses: d,
      itemUsesData: c
    };
  }
};
gs = new WeakMap(), Zi = new WeakMap(), lo = new WeakMap(), Tf = new WeakMap(), Of = new WeakMap(), rn = new WeakMap(), Dn = new WeakSet(), P9 = /* @__PURE__ */ u(function({ quantity: e = 0 } = {}) {
  var l;
  const t = (l = this.action) == null ? void 0 : l.uses;
  if (!t || !e || (t == null ? void 0 : t.value) !== 0 && !(t != null && t.value) || !P(this, gs)) return;
  const s = mt(
    (t == null ? void 0 : t.max) ?? t.value,
    P(this, gs).getRollData(P(this, Zi))
  );
  if (!s) return;
  const n = Math.clamp(t.value - e, 0, s);
  P(this, rn).item[`system.actions.${P(this, lo)}.uses.value`] = n;
}, "#consumeActionUses"), // @ts-ignore
M9 = /* @__PURE__ */ u(function({ selected: e } = {}) {
  !e || !P(this, gs) || P(this, gs).HitDiceManager.consumeHitDice(e);
}, "#consumeHitDice"), F9 = /* @__PURE__ */ u(function({ quantity: e = 0 } = {}) {
  const { value: t } = P(this, Zi).system.uses;
  if (t !== 0 && !t || !e || !P(this, gs)) return;
  const s = mt(
    P(this, Zi).system.uses.max ?? t,
    P(this, gs).getRollData(P(this, Zi))
  );
  s && (P(this, rn).item["system.uses.value"] = Math.clamp(t - e, 0, s));
}, "#consumeItemUses"), R9 = /* @__PURE__ */ u(async function(e, t = {}) {
  const { itemId: s, quantity: n = 1, deleteOnZero: l } = t;
  if (!P(this, gs) || s === "") return;
  const r = P(this, gs).items.get(s);
  if (!r || !r.isType("object")) return;
  const o = Math.max((r.system.quantity ?? 0) - n, 0);
  if (l && o === 0) {
    P(this, rn).item[`system.actions.${P(this, lo)}.consumers.${e}.itemId`] = "", r.delete();
    return;
  }
  await P(this, gs).updateEmbeddedDocuments("Item", [
    { _id: r.id, "system.quantity": o }
  ]);
}, "#consumeQuantity"), N9 = /* @__PURE__ */ u(function({
  quantity: e,
  resource: t,
  restore: s,
  classIdentifier: n
} = {}) {
  var c;
  const l = (c = CONFIG.A5E.resourceConsumerConfig) == null ? void 0 : c[t];
  if (!P(this, gs) || !t || !l) return;
  if (t === "classResource") {
    n = n.replace("@classResources.", "");
    const f = foundry.utils.getProperty(
      P(this, gs)._source.system,
      `resources.classResources.${n}`
    ) ?? 0;
    P(this, rn).actor[`system.resources.classResources.${n}`] = Math.max(
      f - e,
      0
    );
    return;
  }
  const { path: r, type: o } = l, a = foundry.utils.getProperty(P(this, gs).system, r) ?? 0;
  o === "boolean" ? P(this, rn).actor[`system.${r}`] = s ?? !1 : P(this, rn).actor[`system.${r}`] = Math.max(a - e, 0);
}, "#consumeResource"), j9 = /* @__PURE__ */ u(function(e) {
  var r, o, a, c;
  if (!e || !P(this, gs)) return;
  const { charges: t, consume: s, level: n, points: l } = e;
  if (s === "spellSlot") {
    const f = (o = (r = P(this, gs).system.spellResources.slots) == null ? void 0 : r[n]) == null ? void 0 : o.current;
    P(this, rn).actor[`system.spellResources.slots.${n}.current`] = Math.max(f - 1, 0);
  } else if (s === "spellPoint")
    if (((c = (a = P(this, gs).system) == null ? void 0 : a.classes) == null ? void 0 : c.startingClass) === "psyknight") {
      const f = P(this, gs).system.attributes.exertion.current;
      P(this, rn).actor["system.attributes.exertion.current"] = Math.max(f - l, 0);
    } else {
      const f = P(this, gs).system.spellResources.points.current;
      P(this, rn).actor["system.spellResources.points.current"] = Math.max(f - l, 0);
    }
  else if (s === "artifactCharge") {
    const f = P(this, gs).system.spellResources.artifactCharges.current;
    P(this, rn).actor["system.spellResources.artifactCharges.current"] = Math.max(
      f - t,
      0
    );
  }
}, "#consumeSpellResource"), Na = new WeakSet(), Fd = /* @__PURE__ */ u(function(e, t) {
  if (foundry.utils.isEmpty(e[t])) return {};
  const [, s] = Object.values(e[t]);
  return s;
}, "#getConsumerType"), x(Go, Na), u(Go, "ResourceConsumptionManager");
let ai = Go;
function Ro(i, e, t = [], s = []) {
  var c, f, d, p, m, g;
  const n = Object.values(i.consumers ?? {}).filter((h) => t.includes(h.type)).length > 0;
  if (!Object.entries(i.consumers ?? {}).reduce((h, [_, { type: y }]) => (t.includes(y) && h.add(_), h), /* @__PURE__ */ new Set()).some((h) => e.includes(h))) return !1;
  const r = (f = (c = Object.values(i.rolls ?? {})) == null ? void 0 : c.filter((h) => ["damage", "healing"].includes(h.type))) == null ? void 0 : f.some((h) => {
    var _;
    return s.includes((_ = h.scaling) == null ? void 0 : _.mode);
  }), o = s.includes((p = (d = i.target) == null ? void 0 : d.scaling) == null ? void 0 : p.mode), a = s.includes((g = (m = i.area) == null ? void 0 : m.scaling) == null ? void 0 : g.mode);
  return n || r || o || a;
}
u(Ro, "showActivationDialogSection");
function ED(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Attack Bonuses",
      options: (
        /*attackBonuses*/
        i[8].map(SD)
      ),
      selected: (
        /*selectedAttackBonuses*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[20]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*attackBonuses*/
      256 && (l.options = /*attackBonuses*/
      s[8].map(SD)), n & /*selectedAttackBonuses*/
      4 && (l.selected = /*selectedAttackBonuses*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(ED, "create_if_block$2c");
function KW(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "id", t = /*$actor*/
      i[5].id + "-" + /*dialog*/
      i[10].id + "-situational-mod");
    },
    m(l, r) {
      T(l, e, r), He(
        e,
        /*situationalMods*/
        i[0]
      ), s || (n = W(
        e,
        "input",
        /*input_input_handler*/
        i[21]
      ), s = !0);
    },
    p(l, r) {
      r & /*$actor*/
      32 && t !== (t = /*$actor*/
      l[5].id + "-" + /*dialog*/
      l[10].id + "-situational-mod") && b(e, "id", t), r & /*situationalMods*/
      1 && e.value !== /*situationalMods*/
      l[0] && He(
        e,
        /*situationalMods*/
        l[0]
      );
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(KW, "create_default_slot$28");
function YW(i) {
  let e, t, s, n, l, r = Object.values(
    /*attackBonuses*/
    i[8]
  ).flat().length, o, a, c, f, d, p, m;
  e = new vr({
    props: {
      selected: (
        /*rollMode*/
        i[3].toString()
      ),
      source: (
        /*rollModeSource*/
        i[6]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[18]
  ), s = new hi({
    props: {
      source: (
        /*expertiseDieSource*/
        i[7]
      ),
      selected: (
        /*expertiseDie*/
        i[4]
      ),
      type: (
        /*$actor*/
        i[5].type
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[19]
  );
  let g = r && ED(i);
  return a = new ie({
    props: {
      heading: "A5E.SituationalMods",
      $$slots: { default: [KW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), n = E("div"), j(s.$$.fragment), l = F(), g && g.c(), o = F(), c = E("div"), j(a.$$.fragment), f = F(), d = E("section"), p = Q(
        /*rollFormula*/
        i[1]
      ), G(n, "display", "contents"), G(n, "--background", "transparent"), G(n, "--padding", "0"), G(c, "display", "contents"), G(c, "--background", "transparent"), G(c, "--gap", "0.25rem"), G(c, "--padding", "0"), b(d, "class", "roll-formula-preview svelte-19bb735");
    },
    m(h, _) {
      R(e, h, _), T(h, t, _), T(h, n, _), R(s, n, null), T(h, l, _), g && g.m(h, _), T(h, o, _), T(h, c, _), R(a, c, null), T(h, f, _), T(h, d, _), A(d, p), m = !0;
    },
    p(h, [_]) {
      const y = {};
      _ & /*rollMode*/
      8 && (y.selected = /*rollMode*/
      h[3].toString()), _ & /*rollModeSource*/
      64 && (y.source = /*rollModeSource*/
      h[6]), e.$set(y);
      const v = {};
      _ & /*expertiseDieSource*/
      128 && (v.source = /*expertiseDieSource*/
      h[7]), _ & /*expertiseDie*/
      16 && (v.selected = /*expertiseDie*/
      h[4]), _ & /*$actor*/
      32 && (v.type = /*$actor*/
      h[5].type), s.$set(v), _ & /*attackBonuses*/
      256 && (r = Object.values(
        /*attackBonuses*/
        h[8]
      ).flat().length), r ? g ? (g.p(h, _), _ & /*attackBonuses*/
      256 && w(g, 1)) : (g = ED(h), g.c(), w(g, 1), g.m(o.parentNode, o)) : g && (ae(), O(g, 1, 1, () => {
        g = null;
      }), ce());
      const k = {};
      _ & /*$$scope, $actor, situationalMods*/
      8388641 && (k.$$scope = { dirty: _, ctx: h }), a.$set(k), (!m || _ & /*rollFormula*/
      2) && be(
        p,
        /*rollFormula*/
        h[1]
      );
    },
    i(h) {
      m || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(g), w(a.$$.fragment, h), m = !0);
    },
    o(h) {
      O(e.$$.fragment, h), O(s.$$.fragment, h), O(g), O(a.$$.fragment, h), m = !1;
    },
    d(h) {
      h && (C(t), C(l), C(o), C(f), C(d)), N(e, h), h && s && C(n), N(s, h), g && g.d(h), h && a && C(c), N(a, h);
    }
  };
}
u(YW, "create_fragment$43");
const SD = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel || ""], "func$b");
function XW(i, e, t) {
  let s, n, l, r, o, a, c, f, d, p, m, { attackRollData: g } = e, { options: h } = e, { attackRoll: _ } = e;
  const y = de("actor");
  pe(i, y, (z) => t(5, m = z));
  const v = de("dialog"), k = de("item");
  pe(i, k, (z) => t(17, p = z));
  function S() {
    t(12, g = {
      ..._,
      expertiseDie: r,
      rollMode: a,
      formula: d
    });
  }
  u(S, "updateData");
  let D = "";
  S();
  const I = /* @__PURE__ */ u(({ detail: z }) => t(3, a = z), "updateSelection_handler"), M = /* @__PURE__ */ u(({ detail: z }) => t(4, r = z), "updateSelection_handler_1"), L = /* @__PURE__ */ u(({ detail: z }) => t(2, f = z), "updateSelection_handler_2");
  function B() {
    D = this.value, t(0, D);
  }
  return u(B, "input_input_handler"), i.$$set = (z) => {
    "attackRollData" in z && t(12, g = z.attackRollData), "options" in z && t(13, h = z.options), "attackRoll" in z && t(14, _ = z.attackRoll);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, $item, attackRoll, options*/
    155680 && t(16, s = ns.prepareAttackRollData(m, p, _, h)), i.$$.dirty & /*parts*/
    65536 && t(15, n = s.attackAbility), i.$$.dirty & /*parts*/
    65536 && t(8, l = s.attackBonuses), i.$$.dirty & /*parts*/
    65536 && t(4, r = s.expertiseDie), i.$$.dirty & /*parts*/
    65536 && t(7, o = s.expertiseDieSource), i.$$.dirty & /*parts*/
    65536 && t(3, a = s.rollMode), i.$$.dirty & /*parts*/
    65536 && t(6, c = s.rollModeSource), i.$$.dirty & /*parts*/
    65536 && t(2, f = s.selectedAttackBonuses), i.$$.dirty & /*$actor, attackAbility, attackRoll, expertiseDie, $item, situationalMods, rollMode, selectedAttackBonuses*/
    180285 && t(1, d = ll(m, {
      ability: n,
      attackBonus: _ == null ? void 0 : _.bonus,
      attackType: _.attackType,
      expertiseDie: r,
      item: p,
      proficient: (_ == null ? void 0 : _.proficient) ?? !0,
      situationalMods: D,
      rollMode: a,
      selectedAttackBonuses: f,
      type: "attack"
    })), i.$$.dirty & /*rollFormula*/
    2 && S();
  }, [
    D,
    d,
    f,
    a,
    r,
    m,
    c,
    o,
    l,
    y,
    v,
    k,
    g,
    h,
    _,
    n,
    s,
    p,
    I,
    M,
    L,
    B
  ];
}
u(XW, "instance$3W");
const G$ = class G$ extends re {
  constructor(e) {
    super(), oe(this, e, XW, YW, le, {
      attackRollData: 12,
      options: 13,
      attackRoll: 14
    });
  }
};
u(G$, "AttackRollSection");
let Nb = G$;
function CD(i, e, t) {
  const s = i.slice();
  return s[5] = e[t][0], s[6] = e[t][1], s;
}
u(CD, "get_each_context$1y");
function TD(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: (
        /*promptHeadingMap*/
        i[2][
          /*promptType*/
          i[5]
        ]
      ),
      options: (
        /*_prompts*/
        i[6].map(DD)
      ),
      disabledOptions: (
        /*disabledPrompts*/
        i[3]
      ),
      selected: (
        /*selectedPrompts*/
        i[0]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*prompts*/
      2 && (l.heading = /*promptHeadingMap*/
      s[2][
        /*promptType*/
        s[5]
      ]), n & /*prompts*/
      2 && (l.options = /*_prompts*/
      s[6].map(DD)), n & /*selectedPrompts*/
      1 && (l.selected = /*selectedPrompts*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(TD, "create_if_block$2b");
function OD(i) {
  let e, t, s = (
    /*_prompts*/
    i[6].length && TD(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*_prompts*/
      n[6].length ? s ? (s.p(n, l), l & /*prompts*/
      2 && w(s, 1)) : (s = TD(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(OD, "create_each_block$1y");
function JW(i) {
  let e, t, s = ue(Object.entries(
    /*prompts*/
    i[1]
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = OD(CD(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("div");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "prompt-wrapper svelte-yau1pu");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o & /*promptHeadingMap, Object, prompts, disabledPrompts, selectedPrompts*/
      15) {
        s = ue(Object.entries(
          /*prompts*/
          r[1]
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = CD(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = OD(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(JW, "create_default_slot$27");
function ZW(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.PromptsHint",
      $$slots: { default: [JW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*$$scope, prompts, selectedPrompts*/
      515 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(ZW, "create_fragment$42");
const DD = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel || ""], "func$a");
function QW(i, e, t) {
  let { selectedPrompts: s } = e, { prompts: n } = e;
  const l = {
    abilityCheck: "Ability Check Prompts",
    effect: "Effect Prompts",
    savingThrow: "Saving Throw Prompts",
    skillCheck: "Skill Check Prompts",
    generic: "Generic Roll Prompts"
  };
  let r = ns.preparePromptsData(n).invalidSelections;
  const o = /* @__PURE__ */ u((a) => t(0, s = a.detail), "updateSelection_handler");
  return i.$$set = (a) => {
    "selectedPrompts" in a && t(0, s = a.selectedPrompts), "prompts" in a && t(1, n = a.prompts);
  }, [
    s,
    n,
    l,
    r,
    o
  ];
}
u(QW, "instance$3V");
const z$ = class z$ extends re {
  constructor(e) {
    super(), oe(this, e, QW, ZW, le, { selectedPrompts: 0, prompts: 1 });
  }
};
u(z$, "PromptsSection");
let jb = z$;
function ID(i, e, t) {
  const s = i.slice();
  return s[6] = e[t][0], s[7] = e[t][1], s;
}
u(ID, "get_each_context$1x");
function xW(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: (
        /*rollHeadingMap*/
        i[1][
          /*rollType*/
          i[6]
        ]
      ),
      options: (
        /*_rolls*/
        i[7].map(sK)
      ),
      disabledOptions: (
        /*disabledRolls*/
        i[2]
      ),
      selected: (
        /*selectedRolls*/
        i[0]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[5]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*selectedRolls*/
      1 && (l.selected = /*selectedRolls*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(xW, "create_if_block$2a");
function PD(i) {
  let e, t, s = (
    /*_rolls*/
    i[7].length && xW(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*_rolls*/
      n[7].length && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(PD, "create_each_block$1x");
function eK(i) {
  let e, t, s = ue(Object.entries(
    /*otherRolls*/
    i[3]
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = PD(ID(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("div");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "roll-wrapper svelte-co0igx");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o & /*rollHeadingMap, Object, otherRolls, disabledRolls, selectedRolls*/
      15) {
        s = ue(Object.entries(
          /*otherRolls*/
          r[3]
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = ID(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = PD(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(eK, "create_default_slot$26");
function tK(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.RollsHint",
      $$slots: { default: [eK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*$$scope, selectedRolls*/
      1025 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(tK, "create_fragment$41");
const sK = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel], "func$9");
function nK(i, e, t) {
  let { selectedRolls: s } = e, { rolls: n } = e;
  const l = {
    abilityCheck: "Ability Checks",
    damage: "Damage Rolls",
    generic: "Generic Rolls",
    healing: "Healing Rolls",
    savingThrow: "Saving Throws",
    skillCheck: "Skill Checks",
    toolCheck: "Tool Checks"
  }, { invalidSelections: r, otherRolls: o } = ns.prepareOtherRollData(n), a = /* @__PURE__ */ u((c) => t(0, s = c.detail), "updateSelection_handler");
  return i.$$set = (c) => {
    "selectedRolls" in c && t(0, s = c.selectedRolls), "rolls" in c && t(4, n = c.rolls);
  }, [
    s,
    l,
    r,
    o,
    n,
    a
  ];
}
u(nK, "instance$3U");
const H$ = class H$ extends re {
  constructor(e) {
    super(), oe(this, e, nK, tK, le, { selectedRolls: 0, rolls: 4 });
  }
};
u(H$, "RollsSection");
let Lb = H$;
function iK(i) {
  let e, t, s = !/*isEmpty*/
  i[7](
    /*consumer*/
    i[9]
  ), n, l;
  e = new Ke({
    props: {
      heading: (
        /*getConsumeHeading*/
        i[4](
          /*spellData*/
          i[0].consume
        )
      ),
      selected: `${/*spellData*/
      i[0].level}`,
      options: (
        /*spellLevels*/
        i[11]
      ),
      allowDeselect: !1,
      disabled: (
        /*disabled*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  );
  let r = s && lK(i);
  return {
    c() {
      j(e.$$.fragment), t = F(), r && r.c(), n = $e();
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a[0] & /*spellData*/
      1 && (c.heading = /*getConsumeHeading*/
      o[4](
        /*spellData*/
        o[0].consume
      )), a[0] & /*spellData*/
      1 && (c.selected = `${/*spellData*/
      o[0].level}`), a[0] & /*disabled*/
      2 && (c.disabled = /*disabled*/
      o[1]), e.$set(c), s && r.p(o, a);
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(r), l = !1;
    },
    d(o) {
      o && (C(t), C(n)), N(e, o), r && r.d(o);
    }
  };
}
u(iK, "create_if_block_4$v");
function lK(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "A5E.ConsumeOptions",
      options: Object.entries(
        /*consumeOptions*/
        i[8]
      ),
      selected: (
        /*spellData*/
        i[0].consume
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[15]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*spellData*/
      1 && (l.selected = /*spellData*/
      s[0].consume), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(lK, "create_if_block_5$m");
function rK(i) {
  let e, t, s, n;
  return e = new ie({
    props: {
      heading: "A5E.ArtifactCharges",
      $$slots: { default: [oK] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      $$slots: { default: [cK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r[0] & /*spellData*/
      1 | r[1] & /*$$scope*/
      4 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r[0] & /*spellData*/
      1 | r[1] & /*$$scope*/
      4 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(rK, "create_if_block_2$Z");
function oK(i) {
  let e, t, s, n, l, r, o, a;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("input"), n = Q(`

            /

            `), l = E("div"), r = E("input"), b(s, "class", "number-input svelte-1olo02y"), b(s, "type", "number"), b(t, "class", "u-flex u-w-10"), b(r, "class", "number-input svelte-1olo02y"), b(r, "type", "number"), r.value = /*spellResources*/
      i[12].artifactCharges.current ?? // @ts-expect-error
      /*spellResources*/
      i[12].artifactCharges.max, r.disabled = !0, b(l, "class", "u-flex u-w-10"), b(e, "class", "u-flex u-gap-md u-align-center");
    },
    m(c, f) {
      T(c, e, f), A(e, t), A(t, s), He(
        s,
        /*spellData*/
        i[0].charges
      ), A(e, n), A(e, l), A(l, r), o || (a = W(
        s,
        "input",
        /*input0_input_handler*/
        i[16]
      ), o = !0);
    },
    p(c, f) {
      f[0] & /*spellData*/
      1 && Hn(s.value) !== /*spellData*/
      c[0].charges && He(
        s,
        /*spellData*/
        c[0].charges
      );
    },
    d(c) {
      c && C(e), o = !1, a();
    }
  };
}
u(oK, "create_default_slot_3$D");
function aK(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.ConsumeSpellPoints",
      checked: (
        /*spellData*/
        i[0].consume === "artifactCharge"
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*spellData*/
      1 && (l.checked = /*spellData*/
      s[0].consume === "artifactCharge"), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(aK, "create_if_block_3$D");
function cK(i) {
  let e = !/*isEmpty*/
  i[7](
    /*consumer*/
    i[9]
  ), t, s, n = e && aK(i);
  return {
    c() {
      n && n.c(), t = $e();
    },
    m(l, r) {
      n && n.m(l, r), T(l, t, r), s = !0;
    },
    p(l, r) {
      e && n.p(l, r);
    },
    i(l) {
      s || (w(n), s = !0);
    },
    o(l) {
      O(n), s = !1;
    },
    d(l) {
      l && C(t), n && n.d(l);
    }
  };
}
u(cK, "create_default_slot_2$W");
function uK(i) {
  let e, t, s, n;
  return e = new ie({
    props: {
      heading: "A5E.SpellPoints",
      $$slots: { default: [fK] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      $$slots: { default: [pK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r[0] & /*spellData*/
      1 | r[1] & /*$$scope*/
      4 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r[0] & /*spellData*/
      1 | r[1] & /*$$scope*/
      4 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(uK, "create_if_block$29");
function fK(i) {
  let e, t, s, n, l, r, o, a;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("input"), n = Q(`

            /

            `), l = E("div"), r = E("input"), b(s, "class", "number-input svelte-1olo02y"), b(s, "type", "number"), b(t, "class", "u-flex u-w-10"), b(r, "class", "number-input svelte-1olo02y"), b(r, "type", "number"), r.value = /*spellResources*/
      i[12].points.current ?? /*spellResources*/
      i[12].points.max, r.disabled = !0, b(l, "class", "u-flex u-w-10"), b(e, "class", "u-flex u-gap-md u-align-center");
    },
    m(c, f) {
      T(c, e, f), A(e, t), A(t, s), He(
        s,
        /*spellData*/
        i[0].points
      ), A(e, n), A(e, l), A(l, r), o || (a = W(
        s,
        "input",
        /*input0_input_handler_1*/
        i[18]
      ), o = !0);
    },
    p(c, f) {
      f[0] & /*spellData*/
      1 && Hn(s.value) !== /*spellData*/
      c[0].points && He(
        s,
        /*spellData*/
        c[0].points
      );
    },
    d(c) {
      c && C(e), o = !1, a();
    }
  };
}
u(fK, "create_default_slot_1$1g");
function dK(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.ConsumeSpellPoints",
      checked: (
        /*spellData*/
        i[0].consume === "spellPoint"
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[19]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*spellData*/
      1 && (l.checked = /*spellData*/
      s[0].consume === "spellPoint"), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(dK, "create_if_block_1$1q");
function pK(i) {
  let e = !/*isEmpty*/
  i[7](
    /*consumer*/
    i[9]
  ), t, s, n = e && dK(i);
  return {
    c() {
      n && n.c(), t = $e();
    },
    m(l, r) {
      n && n.m(l, r), T(l, t, r), s = !0;
    },
    p(l, r) {
      e && n.p(l, r);
    },
    i(l) {
      s || (w(n), s = !0);
    },
    o(l) {
      O(n), s = !1;
    },
    d(l) {
      l && C(t), n && n.d(l);
    }
  };
}
u(pK, "create_default_slot$25");
function mK(i) {
  let e = ["variable", "slotsOnly"].includes(
    /*mode*/
    i[10]
  ), t, s, n, l, r = e && iK(i), o = (
    /*mode*/
    i[10] === "chargesOnly" && rK(i)
  ), a = (
    /*mode*/
    i[10] === "pointsOnly" && uK(i)
  );
  return {
    c() {
      r && r.c(), t = F(), o && o.c(), s = F(), a && a.c(), n = $e();
    },
    m(c, f) {
      r && r.m(c, f), T(c, t, f), o && o.m(c, f), T(c, s, f), a && a.m(c, f), T(c, n, f), l = !0;
    },
    p(c, f) {
      e && r.p(c, f), /*mode*/
      c[10] === "chargesOnly" && o.p(c, f), /*mode*/
      c[10] === "pointsOnly" && a.p(c, f);
    },
    i(c) {
      l || (w(r), w(o), w(a), l = !0);
    },
    o(c) {
      O(r), O(o), O(a), l = !1;
    },
    d(c) {
      c && (C(t), C(s), C(n)), r && r.d(c), o && o.d(c), a && a.d(c);
    }
  };
}
u(mK, "create_fragment$40");
function hK(i, e, t) {
  let s, n, { consumers: l } = e, { spellData: r } = e;
  function o(ne) {
    t(0, r.charges = ne, r), t(0, r.level = ne, r), t(0, r.points = v.spellLevelCost[r.level], r);
  }
  u(o, "updateSpellResourceData");
  function a(ne) {
    t(0, r.consume = ne, r), ne === "artifactCharge" ? c() : ne === "spellSlot" ? d() : ne === "spellPoint" ? p() : f(), t(0, r.level = g(), r);
  }
  u(a, "updateConsumeOption");
  function c() {
    var Ee;
    const ne = z.spellLevel ?? (s.isType("spell") ? (Ee = s.system) == null ? void 0 : Ee.level : 1) ?? 1;
    t(1, D = U.reduce(
      (Pe, [ye]) => {
        const me = Number(ye);
        return ne > me && Pe.push(ye), me > M && Pe.push(ye), Pe;
      },
      []
    ));
  }
  u(c, "disableArtifactChargeOptions");
  function f() {
    var Ee;
    const ne = z.spellLevel ?? (s.isType("spell") ? (Ee = s.system) == null ? void 0 : Ee.level : 1) ?? 1;
    t(1, D = U.slice(0, ne - 1).map((Pe) => Pe[0]));
  }
  u(f, "disableBaseSlotOptions");
  function d() {
    var Pe;
    const ne = new Set(U.map((ye) => ye[0])), Ee = z.spellLevel ?? (s.isType("spell") ? (Pe = s.system) == null ? void 0 : Pe.level : 1) ?? 1;
    t(1, D = [
      ...ne.difference(new Set(B)),
      ...U.slice(0, Ee - 1).map((ye) => ye[0])
    ]);
  }
  u(d, "disableSpellSlotOptions");
  function p() {
    var Pe;
    const ne = z.spellLevel ?? (s.isType("spell") ? (Pe = s.system) == null ? void 0 : Pe.level : 1) ?? 1, Ee = Object.entries(v.spellLevelCost).reduce(
      (ye, [me, Ce]) => (Number(Ce) <= L && (ye = Number(me)), ye),
      0
    );
    t(1, D = [
      ...U.slice(0, ne - 1).map((ye) => ye[0]),
      ...U.map((ye) => ye[0]).slice(Ee)
    ]);
  }
  u(p, "disableSpellPointOptions");
  function m(ne) {
    return r.consume === "artifactCharge" ? `${K("A5E.SpellLevel")} (${r.charges} charges)` : r.consume === "spellPoint" ? `${K("A5E.SpellLevel")} (${r.points} points)` : K("A5E.SpellLevel");
  }
  u(m, "getConsumeHeading");
  function g() {
    var ye;
    const ne = z.spellLevel ?? (s.isType("spell") ? (ye = s.system) == null ? void 0 : ye.level : 1) ?? 1, Ee = Math.min(...B.map(Number));
    return r.consume === "spellSlot" ? Math.max(ne, Ee) : ne;
  }
  u(g, "getBaseSpellLevel");
  const h = de("actionId"), _ = de("actor");
  pe(i, _, (ne) => t(21, n = ne));
  const y = de("item");
  pe(i, y, (ne) => t(20, s = ne));
  const { A5E: v } = CONFIG, { isEmpty: k } = foundry.utils, S = {
    artifactCharge: "A5E.ArtifactCharges",
    spellSlot: "A5E.ConsumeSpellSlot",
    spellPoint: "A5E.SpellPoints",
    // inventions: "A5E.SpellInventions",
    noConsume: "A5E.ConsumeNothing"
  };
  let D = [];
  const I = ai.prepareSpellData(n, s, l, h);
  let { availableCharges: M, availablePoints: L, availableSpellSlots: B, consumer: z, mode: q, spellLevels: U, spellResources: H } = I;
  r = I.spellData, r.consume === "artifactCharge" ? c() : r.consume === "spellPoint" ? p() : r.consume === "spellSlot" ? d() : f();
  const V = /* @__PURE__ */ u(({ detail: ne }) => o(Number(ne)), "updateSelection_handler"), Y = /* @__PURE__ */ u(({ detail: ne }) => a(ne), "updateSelection_handler_1");
  function J() {
    r.charges = Hn(this.value), t(0, r);
  }
  u(J, "input0_input_handler");
  const fe = /* @__PURE__ */ u(({ detail: ne }) => {
    t(0, r.consume = ne ? "artifactCharge" : "noConsume", r);
  }, "updateSelection_handler_2");
  function ke() {
    r.points = Hn(this.value), t(0, r);
  }
  u(ke, "input0_input_handler_1");
  const ee = /* @__PURE__ */ u(({ detail: ne }) => {
    t(0, r.consume = ne ? "spellPoint" : "noConsume", r);
  }, "updateSelection_handler_3");
  return i.$$set = (ne) => {
    "consumers" in ne && t(13, l = ne.consumers), "spellData" in ne && t(0, r = ne.spellData);
  }, [
    r,
    D,
    o,
    a,
    m,
    _,
    y,
    k,
    S,
    z,
    q,
    U,
    H,
    l,
    V,
    Y,
    J,
    fe,
    ke,
    ee
  ];
}
u(hK, "instance$3T");
const U$ = class U$ extends re {
  constructor(e) {
    super(), oe(this, e, hK, mK, le, { consumers: 13, spellData: 0 }, null, [-1, -1]);
  }
};
u(U$, "SpellSection");
let Bb = U$;
function MD(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.ActionUses",
      $$slots: { default: [gK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, actionMaxUses, actionUses, actionUsesData*/
      131169 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(MD, "create_if_block_1$1p");
function gK(i) {
  let e, t, s, n, l, r, o, a = (
    /*actionUses*/
    i[6].value + ""
  ), c, f, d, p, m = K("A5E.UsesRemaining") + "", g, h, _, y;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("input"), l = F(), r = E("p"), o = Q("( "), c = Q(a), f = Q(" / "), d = Q(
        /*actionMaxUses*/
        i[5]
      ), p = F(), g = Q(m), h = Q(")"), b(s, "class", "number-input svelte-1irj1sq"), b(s, "type", "number"), b(s, "min", "0"), b(s, "max", n = /*actionUses*/
      i[6].max), b(t, "class", "u-flex u-w-10"), b(r, "class", "u-text-xs"), b(e, "class", "u-flex u-gap-md u-align-center");
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(t, s), He(
        s,
        /*actionUsesData*/
        i[0].quantity
      ), A(e, l), A(e, r), A(r, o), A(r, c), A(r, f), A(r, d), A(r, p), A(r, g), A(r, h), _ || (y = W(
        s,
        "input",
        /*input_input_handler*/
        i[11]
      ), _ = !0);
    },
    p(v, k) {
      k & /*actionUses*/
      64 && n !== (n = /*actionUses*/
      v[6].max) && b(s, "max", n), k & /*actionUsesData*/
      1 && Hn(s.value) !== /*actionUsesData*/
      v[0].quantity && He(
        s,
        /*actionUsesData*/
        v[0].quantity
      ), k & /*actionUses*/
      64 && a !== (a = /*actionUses*/
      v[6].value + "") && be(c, a), k & /*actionMaxUses*/
      32 && be(
        d,
        /*actionMaxUses*/
        v[5]
      );
    },
    d(v) {
      v && C(e), _ = !1, y();
    }
  };
}
u(gK, "create_default_slot_1$1f");
function FD(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.ItemUses",
      $$slots: { default: [bK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, itemMaxUses, itemUses, itemUsesData*/
      131098 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(FD, "create_if_block$28");
function bK(i) {
  let e, t, s, n, l, r, o, a = (
    /*itemUses*/
    i[4].value + ""
  ), c, f, d, p, m = K("A5E.UsesRemaining") + "", g, h, _, y;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("input"), l = F(), r = E("p"), o = Q("( "), c = Q(a), f = Q(" / "), d = Q(
        /*itemMaxUses*/
        i[3]
      ), p = F(), g = Q(m), h = Q(")"), b(s, "class", "number-input svelte-1irj1sq"), b(s, "type", "number"), b(s, "min", "0"), b(s, "max", n = /*itemUses*/
      i[4].max), b(t, "class", "u-flex u-w-10"), b(r, "class", "u-text-xs"), b(e, "class", "u-flex u-gap-md u-align-center");
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(t, s), He(
        s,
        /*itemUsesData*/
        i[1].quantity
      ), A(e, l), A(e, r), A(r, o), A(r, c), A(r, f), A(r, d), A(r, p), A(r, g), A(r, h), _ || (y = W(
        s,
        "input",
        /*input_input_handler_1*/
        i[12]
      ), _ = !0);
    },
    p(v, k) {
      k & /*itemUses*/
      16 && n !== (n = /*itemUses*/
      v[4].max) && b(s, "max", n), k & /*itemUsesData*/
      2 && Hn(s.value) !== /*itemUsesData*/
      v[1].quantity && He(
        s,
        /*itemUsesData*/
        v[1].quantity
      ), k & /*itemUses*/
      16 && a !== (a = /*itemUses*/
      v[4].value + "") && be(c, a), k & /*itemMaxUses*/
      8 && be(
        d,
        /*itemMaxUses*/
        v[3]
      );
    },
    d(v) {
      v && C(e), _ = !1, y();
    }
  };
}
u(bK, "create_default_slot$24");
function _K(i) {
  var a, c;
  let e, t = Ro(
    /*action*/
    i[9],
    /*selectedConsumers*/
    i[2],
    ["actionUses"],
    ["actionUses"]
  ) && /*actionUses*/
  ((a = i[6]) == null ? void 0 : a.max), s, n = Ro(
    /*action*/
    i[9],
    /*selectedConsumers*/
    i[2],
    ["itemUses"],
    ["itemUses"]
  ) && /*itemUses*/
  ((c = i[4]) == null ? void 0 : c.max), l, r = t && MD(i), o = n && FD(i);
  return {
    c() {
      e = E("div"), r && r.c(), s = F(), o && o.c(), b(e, "class", "side-by-side svelte-1irj1sq");
    },
    m(f, d) {
      T(f, e, d), r && r.m(e, null), A(e, s), o && o.m(e, null), l = !0;
    },
    p(f, [d]) {
      var p, m;
      d & /*selectedConsumers, actionUses*/
      68 && (t = Ro(
        /*action*/
        f[9],
        /*selectedConsumers*/
        f[2],
        ["actionUses"],
        ["actionUses"]
      ) && /*actionUses*/
      ((p = f[6]) == null ? void 0 : p.max)), t ? r ? (r.p(f, d), d & /*selectedConsumers, actionUses*/
      68 && w(r, 1)) : (r = MD(f), r.c(), w(r, 1), r.m(e, s)) : r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce()), d & /*selectedConsumers, itemUses*/
      20 && (n = Ro(
        /*action*/
        f[9],
        /*selectedConsumers*/
        f[2],
        ["itemUses"],
        ["itemUses"]
      ) && /*itemUses*/
      ((m = f[4]) == null ? void 0 : m.max)), n ? o ? (o.p(f, d), d & /*selectedConsumers, itemUses*/
      20 && w(o, 1)) : (o = FD(f), o.c(), w(o, 1), o.m(e, null)) : o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce());
    },
    i(f) {
      l || (w(r), w(o), l = !0);
    },
    o(f) {
      O(r), O(o), l = !1;
    },
    d(f) {
      f && C(e), r && r.d(), o && o.d();
    }
  };
}
u(_K, "create_fragment$3$");
function yK(i, e, t) {
  let s, n, l, r, o, a, { consumers: c } = e, { selectedConsumers: f } = e, { actionUsesData: d } = e, { itemUsesData: p } = e;
  const m = de("actor");
  pe(i, m, (S) => t(14, a = S));
  const g = de("item");
  pe(i, g, (S) => t(13, o = S));
  const h = de("actionId"), _ = o.actions.get(h);
  let y = ai.prepareUsesData(a, o, c, h);
  d = y.actionUsesData, p = y.itemUsesData;
  function v() {
    d.quantity = Hn(this.value), t(0, d);
  }
  u(v, "input_input_handler");
  function k() {
    p.quantity = Hn(this.value), t(1, p);
  }
  return u(k, "input_input_handler_1"), i.$$set = (S) => {
    "consumers" in S && t(10, c = S.consumers), "selectedConsumers" in S && t(2, f = S.selectedConsumers), "actionUsesData" in S && t(0, d = S.actionUsesData), "itemUsesData" in S && t(1, p = S.itemUsesData);
  }, t(6, s = y.actionUses), t(5, n = y.actionMaxUses), t(4, l = y.itemUses), t(3, r = y.itemMaxUses), [
    d,
    p,
    f,
    r,
    l,
    n,
    s,
    m,
    g,
    _,
    c,
    v,
    k
  ];
}
u(yK, "instance$3S");
const V$ = class V$ extends re {
  constructor(e) {
    super(), oe(this, e, yK, _K, le, {
      consumers: 10,
      selectedConsumers: 2,
      actionUsesData: 0,
      itemUsesData: 1
    });
  }
};
u(V$, "UsesSection");
let qb = V$;
function RD(i, e, t) {
  const s = i.slice();
  return s[11] = e[t], s[12] = e, s[13] = t, s;
}
u(RD, "get_each_context$1w");
function ND(i) {
  let e, t, s, n, l, r, o, a, c, f, d;
  function p() {
    return (
      /*click_handler*/
      i[6](
        /*die*/
        i[11]
      )
    );
  }
  u(p, "click_handler");
  function m() {
    return (
      /*auxclick_handler*/
      i[7](
        /*die*/
        i[11]
      )
    );
  }
  u(m, "auxclick_handler");
  function g() {
    i[8].call(
      r,
      /*die*/
      i[11]
    );
  }
  return u(g, "input0_input_handler"), {
    c() {
      e = E("div"), t = E("button"), s = E("span"), s.textContent = `${/*die*/
      i[11]}`, n = F(), l = E("div"), r = E("input"), o = Q(`

                    /

                    `), a = E("input"), c = F(), b(s, "class", "a5e-hit-die__label"), b(t, "class", "a5e-hit-die a5e-hit-die--rollable a5e-hit-die--" + /*die*/
      i[11] + " svelte-1sq6p9w"), t.disabled = /*hitDice*/
      i[4][
        /*die*/
        i[11]
      ].current === 0, Z(
        t,
        "disabled",
        /*hitDice*/
        i[4][
          /*die*/
          i[11]
        ].current === 0
      ), b(r, "type", "number"), b(r, "min", "0"), b(
        r,
        "max",
        /*hitDice*/
        i[4][
          /*die*/
          i[11]
        ].current
      ), b(r, "class", "svelte-1sq6p9w"), b(a, "type", "number"), a.value = /*hitDice*/
      i[4][
        /*die*/
        i[11]
      ].current, a.disabled = !0, b(a, "class", "svelte-1sq6p9w"), b(l, "class", "quantity__wrapper svelte-1sq6p9w"), b(e, "class", "a5e-hit-die-wrapper");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(t, s), A(e, n), A(e, l), A(l, r), He(
        r,
        /*hitDiceData*/
        i[0].selected[
          /*die*/
          i[11]
        ]
      ), A(l, o), A(l, a), A(e, c), f || (d = [
        W(t, "click", st(p)),
        W(t, "auxclick", st(m)),
        W(r, "input", g)
      ], f = !0);
    },
    p(h, _) {
      i = h, _ & /*hitDiceData, availableHitDice*/
      9 && Hn(r.value) !== /*hitDiceData*/
      i[0].selected[
        /*die*/
        i[11]
      ] && He(
        r,
        /*hitDiceData*/
        i[0].selected[
          /*die*/
          i[11]
        ]
      );
    },
    d(h) {
      h && C(e), f = !1, Me(d);
    }
  };
}
u(ND, "create_each_block$1w");
function vK(i) {
  let e, t = ue(
    /*availableHitDice*/
    i[3]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = ND(RD(i, t, n));
  return {
    c() {
      e = E("div");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "u-flex u-gap-md u-text-md");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*hitDice, availableHitDice, hitDiceData, updateSelected*/
      27) {
        t = ue(
          /*availableHitDice*/
          n[3]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = RD(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = ND(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(vK, "create_default_slot$23");
function kK(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.HitDiceLabel",
      $$slots: { default: [vK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*$$scope, hitDiceData*/
      16385 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(kK, "create_fragment$3_");
function wK(i, e, t) {
  let s, { consumers: n } = e, { hitDiceData: l } = e;
  function r(g, h = !1) {
    const _ = l.selected[g], y = h ? _ - 1 : _ + 1;
    t(0, l.selected[g] = Math.max(y, 0), l);
  }
  u(r, "updateSelected");
  const o = de("actor");
  pe(i, o, (g) => t(9, s = g));
  const a = ai.prepareHitDiceData(s, n), { availableHitDice: c } = a;
  l = a.hitDiceData;
  let f = s.system.attributes.hitDice;
  const d = /* @__PURE__ */ u((g) => r(g), "click_handler"), p = /* @__PURE__ */ u((g) => r(g, !0), "auxclick_handler");
  function m(g) {
    l.selected[g] = Hn(this.value), t(0, l);
  }
  return u(m, "input0_input_handler"), i.$$set = (g) => {
    "consumers" in g && t(5, n = g.consumers), "hitDiceData" in g && t(0, l = g.hitDiceData);
  }, [
    l,
    r,
    o,
    c,
    f,
    n,
    d,
    p,
    m
  ];
}
u(wK, "instance$3R");
const W$ = class W$ extends re {
  constructor(e) {
    super(), oe(this, e, wK, kK, le, { consumers: 5, hitDiceData: 0 });
  }
};
u(W$, "HitDiceSection");
let Gb = W$;
var Df, ro, If, Kn, L9, B9, Hb, q9, G9;
const K$ = class K$ {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  constructor(e, t, s, ...n) {
    x(this, Kn);
    x(this, Df);
    x(this, ro);
    x(this, If);
    qe(this, "availableConsumers");
    qe(this, "warnings");
    Ae(this, Df, s), Ae(this, ro, e), Ae(this, If, t), this.availableConsumers = Object.entries((s == null ? void 0 : s.consumers) ?? {}), this.warnings = [];
  }
  get VALIDATE_FUNCTION_MAP() {
    return {
      actionUses: X(this, Kn, L9),
      ammunition: X(this, Kn, Hb),
      hitDice: X(this, Kn, B9),
      itemUses: X(this, Kn, q9),
      quantity: X(this, Kn, Hb),
      resource: X(this, Kn, G9)
    };
  }
  validateData(e, t) {
    return this.warnings.length = 0, this.availableConsumers.forEach(([s, n]) => {
      if (!t.includes(s)) return;
      const l = this.VALIDATE_FUNCTION_MAP[n.type];
      l == null || l.call(this, e == null ? void 0 : e[n.type], n);
    }), this.warnings;
  }
};
Df = new WeakMap(), ro = new WeakMap(), If = new WeakMap(), Kn = new WeakSet(), L9 = /* @__PURE__ */ u(function(e) {
  const { uses: t } = P(this, Df) ?? {};
  foundry.utils.isEmpty(t) || t.value >= e.quantity || this.warnings.push(K("A5E.validations.warnings.actionUses"));
}, "#validateActionUses"), B9 = /* @__PURE__ */ u(function(e) {
  const t = P(this, ro).system.attributes.hitDice, s = e.selected;
  Object.keys(s ?? {}).every(
    (l) => t[l].current >= s[l]
  ) || this.warnings.push(K("A5E.validations.warnings.hitDice"));
}, "#validateHitDice"), Hb = /* @__PURE__ */ u(function(e, t) {
  const s = P(this, ro).items.get(t.itemId);
  s && ((s.isType("object") ? s.system.quantity : 0) ?? 0) >= t.quantity || (t.type === "ammunition" ? this.warnings.push(K("A5E.validations.warnings.ammunition")) : this.warnings.push(K("A5E.validations.warnings.quantity", { name: s == null ? void 0 : s.name })));
}, "#validateItemQuantity"), q9 = /* @__PURE__ */ u(function(e) {
  const { uses: t } = P(this, If).system ?? {};
  foundry.utils.isEmpty(t) || t.value >= e.quantity || this.warnings.push(K("A5E.validations.warnings.itemUses"));
}, "#validateItemUses"), G9 = /* @__PURE__ */ u(function(e, t) {
  var o;
  const s = (o = CONFIG.A5E.resourceConsumerConfig) == null ? void 0 : o[t.resource];
  if (!s) return;
  const { path: n, type: l } = s;
  if (l !== "value") return;
  const r = foundry.utils.getProperty(P(this, ro).system, n);
  typeof r == "number" && (r >= t.quantity || this.warnings.push(K("A5E.validations.warnings.resource", { type: t.resource })));
}, "#validateResource"), u(K$, "ConsumptionValidator");
let zb = K$;
function jD(i, e, t) {
  const s = i.slice();
  return s[61] = e[t], s;
}
u(jD, "get_each_context$1v");
function LD(i) {
  let e, t = ue(
    /*warnings*/
    i[13]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = BD(jD(i, t, n));
  return {
    c() {
      e = E("section");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "warning__wrapper svelte-tjinp5");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l[0] & /*warnings*/
      8192) {
        t = ue(
          /*warnings*/
          n[13]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = jD(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = BD(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(LD, "create_if_block_12$4");
function BD(i) {
  let e, t, s, n = (
    /*warning*/
    i[61] + ""
  ), l, r;
  return {
    c() {
      e = E("p"), t = E("i"), s = F(), l = Q(n), r = F(), b(t, "class", "fa-solid fa-circle-exclamation"), b(e, "class", "warning svelte-tjinp5"), G(e, "color", "var(--a5e-color-warning)");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(e, l), A(e, r);
    },
    p(o, a) {
      a[0] & /*warnings*/
      8192 && n !== (n = /*warning*/
      o[61] + "") && be(l, n);
    },
    d(o) {
      o && C(e);
    }
  };
}
u(BD, "create_each_block$1v");
function $K(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Attack Roll Config",
      $$slots: { default: [AK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l[0] & /*options, attackRollData, visibilityMode*/
      4129 | l[2] & /*$$scope*/
      4 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u($K, "create_if_block_11$6");
function AK(i) {
  let e, t, s, n, l, r;
  function o(d) {
    i[42](d);
  }
  u(o, "outputvisibilitysection_visibilityMode_binding");
  let a = {};
  /*visibilityMode*/
  i[12] !== void 0 && (a.visibilityMode = /*visibilityMode*/
  i[12]), e = new cc({ props: a }), rt.push(() => Ot(e, "visibilityMode", o));
  function c(d) {
    i[43](d);
  }
  u(c, "attackrollsection_attackRollData_binding");
  let f = {
    attackRoll: (
      /*attackRoll*/
      i[27]
    ),
    options: (
      /*options*/
      i[0]
    )
  };
  return (
    /*attackRollData*/
    i[5] !== void 0 && (f.attackRollData = /*attackRollData*/
    i[5]), n = new Nb({ props: f }), rt.push(() => Ot(n, "attackRollData", c)), {
      c() {
        j(e.$$.fragment), s = F(), j(n.$$.fragment);
      },
      m(d, p) {
        R(e, d, p), T(d, s, p), R(n, d, p), r = !0;
      },
      p(d, p) {
        const m = {};
        !t && p[0] & /*visibilityMode*/
        4096 && (t = !0, m.visibilityMode = /*visibilityMode*/
        d[12], It(() => t = !1)), e.$set(m);
        const g = {};
        p[0] & /*options*/
        1 && (g.options = /*options*/
        d[0]), !l && p[0] & /*attackRollData*/
        32 && (l = !0, g.attackRollData = /*attackRollData*/
        d[5], It(() => l = !1)), n.$set(g);
      },
      i(d) {
        r || (w(e.$$.fragment, d), w(n.$$.fragment, d), r = !0);
      },
      o(d) {
        O(e.$$.fragment, d), O(n.$$.fragment, d), r = !1;
      },
      d(d) {
        d && C(s), N(e, d), N(n, d);
      }
    }
  );
}
u(AK, "create_default_slot_7$b");
function EK(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Rolls Config",
      $$slots: { default: [SK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l[0] & /*selectedRolls*/
      1024 | l[2] & /*$$scope*/
      4 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(EK, "create_if_block_10$9");
function SK(i) {
  let e, t, s;
  function n(r) {
    i[44](r);
  }
  u(n, "rollssection_selectedRolls_binding");
  let l = { rolls: (
    /*rolls*/
    i[24]
  ) };
  return (
    /*selectedRolls*/
    i[10] !== void 0 && (l.selectedRolls = /*selectedRolls*/
    i[10]), e = new Lb({ props: l }), rt.push(() => Ot(e, "selectedRolls", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        !t && o[0] & /*selectedRolls*/
        1024 && (t = !0, a.selectedRolls = /*selectedRolls*/
        r[10], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(SK, "create_default_slot_6$f");
function CK(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Bonuses Config",
      $$slots: { default: [DK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l[0] & /*selectedHealingBonuses, selectedDamageBonuses*/
      384 | l[2] & /*$$scope*/
      4 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(CK, "create_if_block_7$g");
function TK(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Damage Bonuses",
      options: (
        /*damageBonuses*/
        i[25].map(GK)
      ),
      selected: (
        /*selectedDamageBonuses*/
        i[7]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[45]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*selectedDamageBonuses*/
      128 && (l.selected = /*selectedDamageBonuses*/
      s[7]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(TK, "create_if_block_9$b");
function OK(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Healing Bonuses",
      options: (
        /*healingBonuses*/
        i[26].map(zK)
      ),
      selected: (
        /*selectedHealingBonuses*/
        i[8]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[46]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*selectedHealingBonuses*/
      256 && (l.selected = /*selectedHealingBonuses*/
      s[8]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(OK, "create_if_block_8$d");
function DK(i) {
  let e, t, s, n = (
    /*showDamageBonuses*/
    i[31] && TK(i)
  ), l = (
    /*showHealingBonuses*/
    i[32] && OK(i)
  );
  return {
    c() {
      n && n.c(), e = F(), l && l.c(), t = $e();
    },
    m(r, o) {
      n && n.m(r, o), T(r, e, o), l && l.m(r, o), T(r, t, o), s = !0;
    },
    p(r, o) {
      /*showDamageBonuses*/
      r[31] && n.p(r, o), /*showHealingBonuses*/
      r[32] && l.p(r, o);
    },
    i(r) {
      s || (w(n), w(l), s = !0);
    },
    o(r) {
      O(n), O(l), s = !1;
    },
    d(r) {
      r && (C(e), C(t)), n && n.d(r), l && l.d(r);
    }
  };
}
u(DK, "create_default_slot_5$j");
function IK(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Prompts Config",
      $$slots: { default: [PK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l[0] & /*selectedPrompts*/
      512 | l[2] & /*$$scope*/
      4 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(IK, "create_if_block_6$j");
function PK(i) {
  let e, t, s;
  function n(r) {
    i[47](r);
  }
  u(n, "promptssection_selectedPrompts_binding");
  let l = { prompts: (
    /*prompts*/
    i[23]
  ) };
  return (
    /*selectedPrompts*/
    i[9] !== void 0 && (l.selectedPrompts = /*selectedPrompts*/
    i[9]), e = new jb({ props: l }), rt.push(() => Ot(e, "selectedPrompts", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        !t && o[0] & /*selectedPrompts*/
        512 && (t = !0, a.selectedPrompts = /*selectedPrompts*/
        r[9], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(PK, "create_default_slot_4$o");
function qD(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Consumers Config",
      $$slots: { default: [FK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l[0] & /*hitDiceData, showHitDiceSection, selectedConsumers, actionUsesData, itemUsesData, showUsesSection, spellData, showSpellSection*/
      229470 | l[2] & /*$$scope*/
      4 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(qD, "create_if_block_2$Y");
function MK(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Selected Consumers to apply on roll",
      options: (
        /*consumerOptions*/
        i[28]
      ),
      selected: (
        /*selectedConsumers*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[48]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*selectedConsumers*/
      2 && (l.selected = /*selectedConsumers*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(MK, "create_default_slot_3$C");
function GD(i) {
  let e, t, s;
  function n(r) {
    i[49](r);
  }
  u(n, "spellsection_spellData_binding");
  let l = { consumers: (
    /*consumers*/
    i[21]
  ) };
  return (
    /*spellData*/
    i[6] !== void 0 && (l.spellData = /*spellData*/
    i[6]), e = new Bb({ props: l }), rt.push(() => Ot(e, "spellData", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        !t && o[0] & /*spellData*/
        64 && (t = !0, a.spellData = /*spellData*/
        r[6], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(GD, "create_if_block_5$l");
function zD(i) {
  let e, t, s, n;
  function l(a) {
    i[50](a);
  }
  u(l, "usessection_actionUsesData_binding");
  function r(a) {
    i[51](a);
  }
  u(r, "usessection_itemUsesData_binding");
  let o = {
    consumers: (
      /*consumers*/
      i[21]
    ),
    selectedConsumers: (
      /*selectedConsumers*/
      i[1]
    )
  };
  return (
    /*actionUsesData*/
    i[2] !== void 0 && (o.actionUsesData = /*actionUsesData*/
    i[2]), /*itemUsesData*/
    i[4] !== void 0 && (o.itemUsesData = /*itemUsesData*/
    i[4]), e = new qb({ props: o }), rt.push(() => Ot(e, "actionUsesData", l)), rt.push(() => Ot(e, "itemUsesData", r)), {
      c() {
        j(e.$$.fragment);
      },
      m(a, c) {
        R(e, a, c), n = !0;
      },
      p(a, c) {
        const f = {};
        c[0] & /*selectedConsumers*/
        2 && (f.selectedConsumers = /*selectedConsumers*/
        a[1]), !t && c[0] & /*actionUsesData*/
        4 && (t = !0, f.actionUsesData = /*actionUsesData*/
        a[2], It(() => t = !1)), !s && c[0] & /*itemUsesData*/
        16 && (s = !0, f.itemUsesData = /*itemUsesData*/
        a[4], It(() => s = !1)), e.$set(f);
      },
      i(a) {
        n || (w(e.$$.fragment, a), n = !0);
      },
      o(a) {
        O(e.$$.fragment, a), n = !1;
      },
      d(a) {
        N(e, a);
      }
    }
  );
}
u(zD, "create_if_block_4$u");
function HD(i) {
  let e, t, s;
  function n(r) {
    i[52](r);
  }
  u(n, "hitdicesection_hitDiceData_binding");
  let l = { consumers: (
    /*consumers*/
    i[21]
  ) };
  return (
    /*hitDiceData*/
    i[3] !== void 0 && (l.hitDiceData = /*hitDiceData*/
    i[3]), e = new Gb({ props: l }), rt.push(() => Ot(e, "hitDiceData", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        !t && o[0] & /*hitDiceData*/
        8 && (t = !0, a.hitDiceData = /*hitDiceData*/
        r[3], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(HD, "create_if_block_3$C");
function FK(i) {
  let e, t, s, n, l, r;
  e = new ie({
    props: {
      hint: "These consumers are the only ones that will apply when the item is rolled.",
      $$slots: { default: [MK] },
      $$scope: { ctx: i }
    }
  });
  let o = (
    /*showSpellSection*/
    i[17] && GD(i)
  ), a = (
    /*showUsesSection*/
    i[16] && zD(i)
  ), c = (
    /*showHitDiceSection*/
    i[15] && HD(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), o && o.c(), s = F(), a && a.c(), n = F(), c && c.c(), l = $e();
    },
    m(f, d) {
      R(e, f, d), T(f, t, d), o && o.m(f, d), T(f, s, d), a && a.m(f, d), T(f, n, d), c && c.m(f, d), T(f, l, d), r = !0;
    },
    p(f, d) {
      const p = {};
      d[0] & /*selectedConsumers*/
      2 | d[2] & /*$$scope*/
      4 && (p.$$scope = { dirty: d, ctx: f }), e.$set(p), /*showSpellSection*/
      f[17] ? o ? (o.p(f, d), d[0] & /*showSpellSection*/
      131072 && w(o, 1)) : (o = GD(f), o.c(), w(o, 1), o.m(s.parentNode, s)) : o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce()), /*showUsesSection*/
      f[16] ? a ? (a.p(f, d), d[0] & /*showUsesSection*/
      65536 && w(a, 1)) : (a = zD(f), a.c(), w(a, 1), a.m(n.parentNode, n)) : a && (ae(), O(a, 1, 1, () => {
        a = null;
      }), ce()), /*showHitDiceSection*/
      f[15] ? c ? (c.p(f, d), d[0] & /*showHitDiceSection*/
      32768 && w(c, 1)) : (c = HD(f), c.c(), w(c, 1), c.m(l.parentNode, l)) : c && (ae(), O(c, 1, 1, () => {
        c = null;
      }), ce());
    },
    i(f) {
      r || (w(e.$$.fragment, f), w(o), w(a), w(c), r = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(o), O(a), O(c), r = !1;
    },
    d(f) {
      f && (C(t), C(s), C(n), C(l)), N(e, f), o && o.d(f), a && a.d(f), c && c.d(f);
    }
  };
}
u(FK, "create_default_slot_2$V");
function RK(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Effects Config",
      $$slots: { default: [NK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l[0] & /*selectedEffects*/
      2048 | l[2] & /*$$scope*/
      4 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(RK, "create_if_block_1$1o");
function NK(i) {
  let e, t;
  return e = new tt({
    props: {
      options: (
        /*effects*/
        i[22].map(HK)
      ),
      selected: (
        /*selectedEffects*/
        i[11]
      ),
      hint: "Select which effects to activate/display on chat card"
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[53]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*selectedEffects*/
      2048 && (l.selected = /*selectedEffects*/
      s[11]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(NK, "create_default_slot_1$1e");
function jK(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fa-solid fa-dice");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(jK, "create_else_block$H");
function LK(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fa-solid fa-circle-exclamation"), G(e, "color", "var(--a5e-color-warning)");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(LK, "create_if_block$27");
function BK(i) {
  let e, t, s = K("A5E.DialogSubmitRoll") + "", n, l, r, o;
  function a(d, p) {
    return (
      /*warnings*/
      d[13].length ? LK : jK
    );
  }
  u(a, "select_block_type");
  let c = a(i), f = c(i);
  return {
    c() {
      e = E("button"), f.c(), t = F(), n = Q(s), b(e, "type", "submit"), e.disabled = l = /*preventActionRollOnWarning*/
      i[35] && !!/*warnings*/
      i[13].length;
    },
    m(d, p) {
      T(d, e, p), f.m(e, null), A(e, t), A(e, n), r || (o = W(e, "click", st(
        /*onSubmit*/
        i[18]
      )), r = !0);
    },
    p(d, p) {
      c !== (c = a(d)) && (f.d(1), f = c(d), f && (f.c(), f.m(e, t))), p[0] & /*warnings*/
      8192 && l !== (l = /*preventActionRollOnWarning*/
      d[35] && !!/*warnings*/
      d[13].length) && (e.disabled = l);
    },
    d(d) {
      d && C(e), f.d(), r = !1, o();
    }
  };
}
u(BK, "create_default_slot$22");
function qK(i) {
  let e, t, s, n, l, r, o, a, c, f, d = (
    /*warnings*/
    i[13].length && LD(i)
  ), p = (
    /*showAttackRoll*/
    i[29] && $K(i)
  ), m = (
    /*showOtherRolls*/
    i[30] && EK(i)
  ), g = (
    /*showBonusesSection*/
    i[33] && CK(i)
  ), h = (
    /*showPrompts*/
    i[34] && IK(i)
  ), _ = (
    /*showConsumersSection*/
    i[14] && qD(i)
  ), y = (
    /*effects*/
    i[22].length && RK(i)
  );
  return c = new De({
    props: {
      $$slots: { default: [BK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), d && d.c(), t = F(), p && p.c(), s = F(), m && m.c(), n = F(), g && g.c(), l = F(), h && h.c(), r = F(), _ && _.c(), o = F(), y && y.c(), a = F(), j(c.$$.fragment), b(e, "class", "svelte-tjinp5");
    },
    m(v, k) {
      T(v, e, k), d && d.m(e, null), A(e, t), p && p.m(e, null), A(e, s), m && m.m(e, null), A(e, n), g && g.m(e, null), A(e, l), h && h.m(e, null), A(e, r), _ && _.m(e, null), A(e, o), y && y.m(e, null), A(e, a), R(c, e, null), f = !0;
    },
    p(v, k) {
      /*warnings*/
      v[13].length ? d ? d.p(v, k) : (d = LD(v), d.c(), d.m(e, t)) : d && (d.d(1), d = null), /*showAttackRoll*/
      v[29] && p.p(v, k), /*showOtherRolls*/
      v[30] && m.p(v, k), /*showBonusesSection*/
      v[33] && g.p(v, k), /*showPrompts*/
      v[34] && h.p(v, k), /*showConsumersSection*/
      v[14] ? _ ? (_.p(v, k), k[0] & /*showConsumersSection*/
      16384 && w(_, 1)) : (_ = qD(v), _.c(), w(_, 1), _.m(e, o)) : _ && (ae(), O(_, 1, 1, () => {
        _ = null;
      }), ce()), /*effects*/
      v[22].length && y.p(v, k);
      const S = {};
      k[0] & /*warnings*/
      8192 | k[2] & /*$$scope*/
      4 && (S.$$scope = { dirty: k, ctx: v }), c.$set(S);
    },
    i(v) {
      f || (w(p), w(m), w(g), w(h), w(_), w(y), w(c.$$.fragment, v), f = !0);
    },
    o(v) {
      O(p), O(m), O(g), O(h), O(_), O(y), O(c.$$.fragment, v), f = !1;
    },
    d(v) {
      v && C(e), d && d.d(), p && p.d(), m && m.d(), g && g.d(), h && h.d(), _ && _.d(), y && y.d(), N(c);
    }
  };
}
u(qK, "create_fragment$3Z");
const GK = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel || ""], "func$8"), zK = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel || ""], "func_1$3"), HK = /* @__PURE__ */ u((i) => [i.id, i.name], "func_2$1");
function UK(i, e, t) {
  var Eo, Ie, nt, Ft;
  let s, n, l, r, o, a, c, f, { application: d } = de("#external"), { application: p = d } = e, { actionId: m, options: g, dialog: h } = p, { actionId: _ = m, options: y = g, dialog: v = h } = e, { actorDocument: k, itemDocument: S } = p, { actorDocument: D = k, itemDocument: I = S } = e;
  function M() {
    v.submit({
      attack: Re,
      consumers: {
        actionUses: ge,
        hitDice: je,
        itemUses: Be,
        spell: Ze
      },
      damageBonuses: ns.getSelectedBonuses(f, "damage", Ge),
      effects: Fe,
      healingBonuses: ns.getSelectedBonuses(f, "healing", Se),
      prompts: ns.getSelectedPrompts(f, c, _, _e),
      rolls: ns.getSelectedRolls(c, _, we),
      selectedConsumers: Ee,
      visibilityMode: xe
    });
  }
  u(M, "onSubmit");
  const L = new Zt(D);
  pe(i, L, (Qe) => t(55, f = Qe));
  const B = new Zt(I);
  pe(i, B, (Qe) => t(54, c = Qe));
  const z = c.actions.get(_), { BonusesManager: q } = f, { isEmpty: U } = foundry.utils, H = ns.prepareConsumers(c, _), V = ns.prepareEffects(c, _), Y = ns.preparePrompts(c, _), J = ns.prepareRolls(c, _), fe = q.prepareGlobalDamageBonuses(c, J), ke = q.prepareGlobalHealingBonuses(c, J), ee = (Eo = J.attack) != null && Eo.length ? J.attack[0][1] : {}, ne = Object.entries(H ?? {}).reduce(
    (Qe, [_n, Wl]) => (_n === "resource" ? Wl.forEach((Mr, Tc) => Qe.push([Mr[0], Mr[1].label || `Resource Consumer #${Tc + 1}`])) : Qe.push([Wl[0], Wl[1].label || `${_n.capitalize()} Consumer `]), Qe),
    []
  );
  let Ee = ai.getDefaultConsumerSelection(H);
  const Pe = !U(ee), ye = !!Object.values(J).flat().length, me = !!Object.values(fe).flat().length, Ce = !!Object.values(ke).flat().length, Je = me || Ce, Ne = !!Object.values(Y).flat().length;
  let Re = {}, ge = {}, je = {}, Be = {}, Ze = {}, Ge = q.getDefaultSelectionsFromBonuses({ damageBonuses: fe }), Se = q.getDefaultSelectionsFromBonuses({ healingBonuses: ke }), _e = q.getDefaultSelectionsFromBonuses(Y), we = q.getDefaultSelectionsFromBonuses(J), Fe = ns.getDefaultSelectedEffects(V), xe = (Ie = game.settings) == null ? void 0 : Ie.get("core", "rollMode");
  game.settings.get("a5e", "placeItemTemplateDefault") || (nt = z == null ? void 0 : z.area) != null && nt.placeTemplate;
  const vt = new zb(f, c, z, H), ps = ((Ft = game.settings) == null ? void 0 : Ft.get("a5e", "preventActionRollOnWarning")) ?? !1;
  lt("actionId", _), lt("actor", L), lt("dialog", v), lt("item", B);
  function As(Qe) {
    xe = Qe, t(12, xe);
  }
  u(As, "outputvisibilitysection_visibilityMode_binding");
  function zs(Qe) {
    Re = Qe, t(5, Re);
  }
  u(zs, "attackrollsection_attackRollData_binding");
  function sn(Qe) {
    we = Qe, t(10, we);
  }
  u(sn, "rollssection_selectedRolls_binding");
  const St = /* @__PURE__ */ u(({ detail: Qe }) => t(7, Ge = Qe), "updateSelection_handler"), ws = /* @__PURE__ */ u(({ detail: Qe }) => t(8, Se = Qe), "updateSelection_handler_1");
  function _i(Qe) {
    _e = Qe, t(9, _e);
  }
  u(_i, "promptssection_selectedPrompts_binding");
  const es = /* @__PURE__ */ u(({ detail: Qe }) => t(1, Ee = Qe), "updateSelection_handler_2");
  function yi(Qe) {
    Ze = Qe, t(6, Ze);
  }
  u(yi, "spellsection_spellData_binding");
  function Ir(Qe) {
    ge = Qe, t(2, ge);
  }
  u(Ir, "usessection_actionUsesData_binding");
  function Pr(Qe) {
    Be = Qe, t(4, Be);
  }
  u(Pr, "usessection_itemUsesData_binding");
  function Ao(Qe) {
    je = Qe, t(3, je);
  }
  u(Ao, "hitdicesection_hitDiceData_binding");
  const Bi = /* @__PURE__ */ u(({ detail: Qe }) => t(11, Fe = Qe), "updateSelection_handler_3");
  return i.$$set = (Qe) => {
    "application" in Qe && t(36, p = Qe.application), "actionId" in Qe && t(37, _ = Qe.actionId), "options" in Qe && t(0, y = Qe.options), "dialog" in Qe && t(38, v = Qe.dialog), "actorDocument" in Qe && t(39, D = Qe.actorDocument), "itemDocument" in Qe && t(40, I = Qe.itemDocument);
  }, i.$$.update = () => {
    var Qe;
    i.$$.dirty[0] & /*selectedConsumers*/
    2 && t(17, s = Ro(z, Ee, ["spell"], ["spellLevel", "spellPoints"])), i.$$.dirty[0] & /*selectedConsumers*/
    2 && t(16, n = Ro(z, Ee, ["actionUses", "itemUses"], ["actionUses", "itemUses"])), i.$$.dirty[0] & /*selectedConsumers*/
    2 && t(15, l = !!Object.values(H.hitDice ?? {}).flat().length && Ee.includes((Qe = H == null ? void 0 : H.hitDice) == null ? void 0 : Qe[0])), i.$$.dirty[0] & /*actionUsesData, hitDiceData, itemUsesData*/
    28 && t(41, o = {
      actionUses: ge,
      hitDice: je,
      itemUses: Be
    }), i.$$.dirty[0] & /*selectedConsumers*/
    2 | i.$$.dirty[1] & /*consumerData*/
    1024 && t(13, a = vt.validateData(o, Ee));
  }, t(14, r = Object.values(H ?? {}).flat().length > 0), [
    y,
    Ee,
    ge,
    je,
    Be,
    Re,
    Ze,
    Ge,
    Se,
    _e,
    we,
    Fe,
    xe,
    a,
    r,
    l,
    n,
    s,
    M,
    L,
    B,
    H,
    V,
    Y,
    J,
    fe,
    ke,
    ee,
    ne,
    Pe,
    ye,
    me,
    Ce,
    Je,
    Ne,
    ps,
    p,
    _,
    v,
    D,
    I,
    o,
    As,
    zs,
    sn,
    St,
    ws,
    _i,
    es,
    yi,
    Ir,
    Pr,
    Ao,
    Bi
  ];
}
u(UK, "instance$3Q");
var ja;
let VK = (ja = class extends re {
  constructor(e) {
    super(), oe(
      this,
      e,
      UK,
      qK,
      le,
      {
        application: 36,
        actionId: 37,
        options: 0,
        dialog: 38,
        actorDocument: 39,
        itemDocument: 40
      },
      null,
      [-1, -1, -1]
    );
  }
}, u(ja, "ActionActivationDialog"), ja);
var Pf, Vb;
const Y$ = class Y$ extends Un {
  constructor({ actionId: t, actorDocument: s, itemDocument: n, options: l = {} }) {
    super(
      {
        title: `${s.name}: Activate ${n.actions.get(t).name}`,
        content: {
          class: VK,
          props: {
            actionId: t,
            actorDocument: s,
            itemDocument: n,
            options: l
          }
        },
        zIndex: null
      },
      {
        classes: ["a5e-sheet", "a5e-activation-dialog"],
        width: 420
      }
    );
    x(this, Pf);
    this.data.content.props.dialog = this, this.promise = new Promise((r) => {
      this.resolve = r;
    });
  }
  /** @inheritdoc */
  close(t) {
    return X(this, Pf, Vb).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return X(this, Pf, Vb).call(this, t), super.close();
  }
};
Pf = new WeakSet(), Vb = /* @__PURE__ */ u(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), u(Y$, "ActionActivationDialog");
let Ub = Y$;
const X$ = class X$ extends fc {
  get classes() {
    return this._classes !== void 0 ? this._classes : (this._classes = this.items.reduce((e, t) => (t.type !== "class" || (e[t.slug] = t), e), {}), this._classes);
  }
  // -------------------------------------------------------------
  // Data Preparation Methods
  // -------------------------------------------------------------
  _initialize(e) {
    this._classes = void 0, this.classAutomationFlags = {}, super._initialize(e);
  }
  /**
   * Sets the order of when to prepare data.
   */
  prepareData() {
    super.prepareData();
  }
  /**
   * Prepare base data for the actor.
   */
  prepareBaseData() {
    super.prepareBaseData();
    const e = Object.keys(this.classes ?? {}).length > 0;
    this.automationAvailable = e, this.classAutomationFlags = {
      classes: this.getFlag("a5e", "automateClasses") ?? e ?? !1,
      hitDice: this.getFlag("a5e", "automateHitDice") ?? e ?? !1,
      hitPoints: this.getFlag("a5e", "automateHitPoints") ?? e ?? !1,
      spellResources: this.getFlag("a5e", "automateSpellResources") ?? e ?? !1
    }, this.prepareLevelData(), this.system.attributes.prof = Math.max(2, Math.floor((this.levels.character + 7) / 4));
  }
  /**
   * Prepares derived data for the actor.
   */
  prepareDerivedData() {
    this.HitDiceManager = new vu(this, this.classAutomationFlags.hitDice), super.prepareDerivedData();
    const e = this.system;
    e.attributes.attunement.current = this.items.reduce((t, s) => {
      const { requiresAttunement: n, attuned: l } = s.system;
      return n && l ? t + 1 : t;
    }, 0), this.system.attributes.hitDice = foundry.utils.mergeObject(
      this.system.attributes.hitDice,
      this.HitDiceManager.bySize
    ), foundry.utils.setProperty(e, "attributes.exertion.max", this.prepareMaxExertion()), foundry.utils.setProperty(
      e,
      "attributes.favorPoints.max",
      this.prepareMaxFavorPoints()
    ), this.prepareHitPoints(), this.prepareSpellResources(), this.prepareResources();
  }
  prepareMaxExertion() {
    var l, r;
    const { max: e } = this.system.attributes.exertion;
    if (!this.automationAvailable) return e;
    let t = 0;
    const s = (l = this.grants) == null ? void 0 : l.byType("exertion").reduce((o, { exertionData: a }) => (a && a.exertionType === "pool" && o.push(a.poolType), o), []);
    s.length === 0 ? t = e : s.includes("doubleProf") ? t = this.system.attributes.prof * 2 : s.includes("prof") ? t = this.system.attributes.prof : t = e;
    const n = mt((r = this.BonusesManager) == null ? void 0 : r.getExertionBonusFormula(), this.getRollData()) ?? 0;
    return t + n;
  }
  prepareMaxFavorPoints() {
    return this.system.abilities.cha.mod;
  }
  prepareHitPoints() {
    if (!this.classAutomationFlags.hitPoints) {
      const { baseMax: l, bonus: r } = this.system.attributes.hp;
      this.system.attributes.hp.max = l + r, this.prepareHitPointBonuses();
      return;
    }
    const { classes: e } = this, t = this.system.attributes.hp.bonus ?? 0, s = Object.values(e ?? {}).reduce((l, r) => l + r.maxHP, 0), n = (this.system.abilities.con.check.mod ?? 0) * this.levels.character;
    this.system.attributes.hp.max = s + n + t, super.prepareHitPointBonuses();
  }
  /**
   * Prepares detailed level data for the actor.
   */
  prepareLevelData() {
    const e = this.items.filter((s) => s.type === "class");
    if (!this.classAutomationFlags.classes) {
      this.levels = {
        character: this.system.details.level,
        classes: {}
      };
      return;
    }
    const t = Object.values(e ?? {}).reduce(
      (s, n) => {
        const l = n.system.classLevels;
        return l && (s.classes[n.system.slug || n.name.slugify({ strict: !0 })] = l, s.character += l), s;
      },
      { character: 0, classes: {} }
    );
    this.levels = t;
  }
  prepareSpellResources() {
    const e = this.system, { classes: t } = this, { spellResources: s } = e;
    if (!this.classAutomationFlags.spellResources) {
      Object.entries(s.slots).forEach(([l, { override: r }]) => {
        e.spellResources.slots[l].max = r || 0;
      }), e.spellResources.points.max = s.points.override || 0, e.spellResources.inventions.max = s.inventions.override || 0, e.spellResources.artifactCharges.max = s.artifactCharges.override || 0;
      return;
    }
    Object.entries(s.slots).forEach(([l]) => {
      e.spellResources.slots[l].max = 0;
    }), e.spellResources.points.max = 0, e.spellResources.inventions.max = 0, e.spellResources.artifactCharges.max = 0;
    const n = {
      slots: [],
      additionalSlots: [],
      points: [],
      inventions: [],
      artifactCharges: []
    };
    if (Object.values(t).forEach((l) => {
      const { progressionType: r, resource: o } = (l == null ? void 0 : l.casting) ?? {};
      r && (r === "multiplier" ? n.slots.push(l) : o === "artifactCharges" ? n.artifactCharges.push(l) : o === "inventions" ? n.inventions.push(l) : o === "points" ? n.points.push(l) : o === "slots" && n.additionalSlots.push(l));
    }), n.slots.length === 1) {
      const l = n.slots[0], { slots: r } = l.casting;
      Object.entries(r ?? {}).forEach(([o, a]) => {
        const { max: c, override: f } = e.spellResources.slots[o];
        e.spellResources.slots[o].max = f || (c || 0) + (a || 0);
      });
    }
    if (n.points.length === 1) {
      const l = n.points[0], { points: r } = l.casting, { max: o, override: a } = e.spellResources.points;
      e.spellResources.points.max = a || (o || 0) + (r || 0);
    }
    if (n.inventions.length === 1) {
      const l = n.inventions[0], { inventions: r } = l.casting, { max: o, override: a } = e.spellResources.inventions;
      e.spellResources.inventions.max = a || (o || 0) + (r || 0);
    }
    if (n.artifactCharges.length === 1) {
      const l = n.artifactCharges[0], { charges: r } = l.casting, { max: o, override: a } = e.spellResources.artifactCharges;
      e.spellResources.artifactCharges.max = a || (o || 0) + (r || 0);
    }
    if (n.slots.length > 1) {
      const l = n.slots.reduce((r, o) => {
        const { classLevels: a } = o, c = CONFIG.A5E.casterProgression[o.casting.casterType];
        if (!c) return r;
        let f = Math.floor;
        return c.roundUp && c.roundUpMulti && (f = Math.ceil), r + f(a * c.multiplier);
      }, 0);
      CONFIG.A5E.SPELL_SLOT_TABLE[l].forEach((r, o) => {
        const { max: a, override: c } = e.spellResources.slots[o + 1];
        e.spellResources.slots[o + 1].max = c || (a || 0) + (r || 0);
      });
    }
    n.points.length > 1 && n.points.forEach((l) => {
      const { points: r, multiclassMode: o } = l.casting;
      if (o !== "ADD") return;
      const { max: a, override: c } = e.spellResources.points;
      e.spellResources.points.max = c || (a || 0) + (r || 0);
    }), n.additionalSlots.forEach((l) => {
      const { slots: r } = l.casting;
      Object.entries(r ?? {}).forEach(([o, a]) => {
        const { max: c, override: f } = e.spellResources.slots[o];
        e.spellResources.slots[o].max = f || (c || 0) + (a || 0);
      });
    }), Object.values(e.spellResources.slots).forEach((l) => {
      l.max === void 0 && (l.max = 0);
    }), e.spellResources.points.max = s.points.max ?? 0, e.spellResources.inventions.max = s.inventions.max ?? 0, e.spellResources.artifactCharges.max = s.artifactCharges.max ?? 0, e.spellResources.maxSpellLevel = Object.values(t).reduce((l, r) => {
      const { maxLevel: o } = (r == null ? void 0 : r.casting) ?? {};
      return o && (l[r.slug] = o), l;
    }, {});
  }
  prepareResources() {
    const e = this._source.system.resources, t = foundry.utils.deepClone(e);
    delete t.classResources;
    const s = e.classResources, n = this.items.reduce((r, o) => {
      if (!["class", "archetype"].includes(o.type)) return r;
      const a = foundry.utils.deepClone(o.resources.consumableResources).filter((f) => f.displayOnCore), c = o.resources.level;
      return a.forEach((f) => {
        r[f.slug] = {
          label: f.name,
          value: s[f.slug] ?? f.reference[c] ?? 0,
          max: f.reference[c] ?? 0,
          per: f.recovery,
          hideMax: !1,
          recharge: {
            formula: "1d6",
            threshold: 6
          }
        };
      }), r;
    }, {}), l = { ...t, ...n };
    this.system.resources = l;
  }
  /**
   * @inheritdoc
   */
  getRollData(e = null) {
    var n;
    const t = { ...super.getRollData(e) };
    t.level = ((n = this.levels) == null ? void 0 : n.character) ?? t.level ?? this.system.details.level;
    const s = {};
    return t.classes = Object.entries(this.classes ?? {}).reduce((l, [r, o]) => {
      var c;
      const a = ((c = o.getRollData()) == null ? void 0 : c.actorTransfer) ?? {};
      return l[r] = a, Object.assign(s, a.resources), l;
    }, {}), t.classResources = s, t;
  }
  // -------------------------------------------------------------
  // Resources Reset Handlers
  // -------------------------------------------------------------
  // TODO: Resource Manager - Move to resource manager
  async recoverExertionUsingHitDice() {
    const { current: e, max: t } = this.system.attributes.exertion, [s] = Object.entries(this.system.attributes.hitDice ?? {}).find(
      // @ts-expect-error
      ([, { current: o, total: a }]) => o > 0 && a > 0
    );
    if (!s) {
      ui.notifications.warn(`${this.name} has no hit dice remaining.`);
      return;
    }
    const n = await new Roll("1d4");
    await n.toMessage();
    const l = Math.min((e ?? 0) + (n.total ?? 0), t), r = this.system.attributes.hitDice[s].current - 1;
    await this.update({
      "system.attributes": {
        "exertion.current": l,
        [`hitDice.${s}.current`]: r
      }
    });
  }
  async recoverPsionicPointsUsingHitDice() {
    const { current: e, max: t } = this.system.spellResources.points, s = Object.entries(this.system.attributes.hitDice ?? {}).find(
      // @ts-expect-error
      ([, { current: o, total: a }]) => o > 0 && a > 0
    );
    if (!s) {
      ui.notifications.warn(`${this.name} has no hit dice remaining.`);
      return;
    }
    const [n] = s, l = new Roll(`1${n}`);
    await l.toMessage();
    const r = Math.min((e ?? 0) + (l.total ?? 0), t);
    this.HitDiceManager.consumeHitDice({ [n]: 1 }), this.update({
      "system.spellResources.points.current": r
    });
  }
  // -------------------------------------------------------------
  // Sheet Toggles
  // -------------------------------------------------------------
  toggleInspiration() {
    const e = this.system.attributes.inspiration;
    this.update({ "system.attributes.inspiration": !e }), e ? Hooks.callAll("a5e.inspirationUsed", this) : Hooks.callAll("a5e.inspirationGained", this);
  }
  // -------------------------------------------------------------
  // Document Update Hooks
  // -------------------------------------------------------------
  /** @inheritdoc */
  async _preCreate(e, t, s) {
    await super._preCreate(e, t, s);
  }
  /** @inheritdoc */
  async _preUpdate(e, t, s) {
    await super._preUpdate(e, t, s);
  }
  /** @inheritdoc */
  _onCreate(e, t, s) {
    super._onCreate(e, t, s);
  }
  /** @inheritdoc */
  _onUpdate(e, t, s) {
    super._onUpdate(e, t, s);
  }
};
u(X$, "CharacterActorA5E");
let Wb = X$;
const J$ = class J$ extends fc {
  // -------------------------------------------------------------
  // Data Preparation Methods
  // -------------------------------------------------------------
  get hitPointFormula() {
    const { hitDice: e } = this.system.attributes, { mod: t } = this.system.abilities.con;
    let s = 0;
    const n = [];
    return Object.entries(e).forEach(([l, { total: r }]) => {
      r && (n.push(`${r}${l}`), s += r);
    }), s === 0 ? "" : `${n.join(" + ")} + ${s * t}`;
  }
  /**
   * Prepare base data for the actor.
   */
  prepareBaseData() {
    super.prepareBaseData(), this.system.attributes.prof = Math.max(2, Math.floor((this.system.details.cr + 7) / 4));
  }
  /**
   * Prepares derived data for the actor.
   */
  prepareDerivedData() {
    this.HitDiceManager = new vu(this, !1), super.prepareDerivedData();
    const { baseMax: e, bonus: t } = this.system.attributes.hp;
    this.system.attributes.hp.max = e + t, super.prepareHitPointBonuses();
  }
  // -------------------------------------------------------------
  // Sheet Toggles
  // -------------------------------------------------------------
  toggleElite() {
    this.update({ "system.details.elite": !this.system.details.elite });
  }
  // -------------------------------------------------------------
  // Document Update Hooks
  // -------------------------------------------------------------
  /** @inheritdoc */
  async _preCreate(e, t, s) {
    await super._preCreate(e, t, s);
  }
  /** @inheritdoc */
  async _preUpdate(e, t, s) {
    await super._preUpdate(e, t, s);
  }
  /** @inheritdoc */
  _onCreate(e, t, s) {
    super._onCreate(e, t, s);
  }
  /** @inheritdoc */
  _onUpdate(e, t, s) {
    super._onUpdate(e, t, s);
  }
};
u(J$, "NPCActorA5E");
let Kb = J$;
function WK(i, e) {
  if (foundry.utils.isEmpty(e)) return "";
  const { activation: t } = e;
  let s = "";
  return foundry.utils.isEmpty(t) || !t.type ? null : (t.type === "reaction" ? t.reactionTrigger ? s = `${K("A5E.ActionActivationReaction")} (${t.reactionTrigger})` : s = K("A5E.ActionActivationReaction") : t.cost === 0 || t.cost > 1 ? s = `${t.cost} ${CONFIG.A5E.abilityActivationTypesPlural[t.type]}` : ["none", "special"].includes(t.type) ? s = CONFIG.A5E.abilityActivationTypes[t == null ? void 0 : t.type] : s = `${t.cost ?? 1} ${CONFIG.A5E.abilityActivationTypes[t.type]}`, i.isType("spell") && i.system.ritual && (s += " (Ritual)"), s);
}
u(WK, "getActivationCostLabel$1");
function KK(i) {
  if (foundry.utils.isEmpty(i) || (i.quantity ?? (i.quantity = 1), !(i != null && i.shape)) || i.quantity <= 0) return !1;
  if (i.shape === "cone" || i.shape === "wall") {
    let e = i == null ? void 0 : i.length;
    if (typeof e == "string" && (e = parseInt(e, 10)), !e || e <= 0) return !1;
  } else if (i.shape === "cube" || i.shape === "square") {
    let e = i == null ? void 0 : i.width;
    if (typeof e == "string" && (e = parseInt(e, 10)), !e || e <= 0) return !1;
  } else if (["circle", "cylinder", "emanation", "sphere"].includes(i.shape)) {
    let e = i == null ? void 0 : i.radius;
    if (typeof e == "string" && (e = parseInt(e, 10)), !e || e <= 0) return !1;
  } else if (i.shape === "line") {
    let e = i == null ? void 0 : i.length, t = i == null ? void 0 : i.width;
    if (typeof e == "string" && (e = parseInt(e, 10)), typeof t == "string" && (t = parseInt(t, 10)), !e || !t || e <= 0 || t <= 0) return !1;
  }
  return !0;
}
u(KK, "validateTemplateData");
function YK(i) {
  const e = i == null ? void 0 : i.area;
  let t;
  if (!KK(i.area)) return "";
  if (e.shape === "circle")
    t = K("A5E.AreaCircleSpecific", { radius: e.radius });
  else if (e.shape === "cone")
    t = K("A5E.AreaConeSpecific", { length: e.length });
  else if (e.shape === "cube")
    t = K("A5E.AreaCubeSpecific", { width: e.width });
  else if (e.shape === "cylinder" && e.height)
    t = K("A5E.AreaCylinderSpecific", { height: e.height, radius: e.radius });
  else if (e.shape === "cylinder")
    t = K("A5E.AreaCylinderSpecificNoHeight", { radius: e.radius });
  else if (e.shape === "emanation")
    t = K("A5E.AreaEmanationSpecific", { radius: e.radius });
  else if (e.shape === "line")
    t = K("A5E.AreaLineSpecific", { width: e.width ?? 5, length: e.length });
  else if (e.shape === "sphere")
    t = K("A5E.AreaSphereSpecific", { radius: e.radius });
  else if (e.shape === "square")
    t = K("A5E.AreaSquareSpecific", { width: e.width });
  else if (e.shape === "wall" && e.height && e.width)
    t = K("A5E.AreaWallSpecific", {
      height: e.height,
      length: e.length,
      width: e.width
    });
  else if (e.shape === "wall" && e.height)
    t = K("A5E.AreaWallSpecificNoWidth", {
      height: e.height,
      length: e.length
    });
  else if (e.shape === "wall" && e.width)
    t = K("A5E.AreaWallSpecificNoHeight", {
      length: e.length,
      width: e.width
    });
  else if (e.shape === "wall")
    t = K("A5E.AreaWallSpecificNoWidthOrHeight", { length: e.length });
  else
    return "";
  return e.quantity > 1 && (t += `(× ${e == null ? void 0 : e.quantity})`), t;
}
u(YK, "getAreaLabel");
function XK(i, e) {
  var n;
  const { duration: t } = e;
  let s = "";
  return foundry.utils.isEmpty(t) || !t.unit ? "" : (["instantaneous", "permanent", "special"].includes(t.unit) ? s = CONFIG.A5E.timePeriods[t.unit] : t.value === 0 || t.value > 1 ? s = `${t.value} ${CONFIG.A5E.timePeriodsPlural[t.unit]}` : s = `${t.value ?? 1} ${CONFIG.A5E.timePeriods[t.unit]}`, i.isType("spell") && ((n = i == null ? void 0 : i.system) != null && n.concentration) && (s += ` (${K("A5E.SpellConcentration")})`), s.trim());
}
u(XK, "getDurationLabel");
function JK(i) {
  const e = i == null ? void 0 : i.ranges, { distanceAbbreviations: t, rangeValues: s, rangeDescriptors: n } = CONFIG.A5E;
  return foundry.utils.isEmpty(e) ? "" : Object.values(e).map(({ range: l, unit: r }) => ["short", "medium", "long"].includes(l) ? `${n[l]} (${s[l]} ${t.feet})` : ["fiveFeet", "self", "touch"].includes(l) ? n[l] : r ? `${l} ${t[r]}` : l).join(", ");
}
u(JK, "getRangeLabels");
function ZK(i) {
  if (foundry.utils.isEmpty(i)) return "";
  const e = i == null ? void 0 : i.prompts;
  return foundry.utils.isEmpty(e) || Object.keys(e).length > 1 ? null : Object.values(e ?? {}).reduce((s, n) => {
    if (n.type !== "savingThrow") return s;
    const l = n.onSave, r = n.ability;
    return l ? s.push(`${K(CONFIG.A5E.abilities[r])} (${l})`) : s.push(`${K(CONFIG.A5E.abilities[r])}`), s;
  }, []).join(", ");
}
u(ZK, "getSavingThrowLabel");
function QK(i) {
  const e = i == null ? void 0 : i.target;
  return foundry.utils.isEmpty(e) || !e.type || e.type === "none" ? "" : e.type === "self" ? K("A5E.TargetSelf") : e.type === "other" ? K("A5E.TargetOther") : e.quantity === 0 || e.quantity > 1 ? `${e.quantity} ${CONFIG.A5E.targetTypesPlural[e.type]}` : `${e.quantity || 1} ${CONFIG.A5E.targetTypes[e.type]}`;
}
u(QK, "getTargetLabel");
function xK(i, e) {
  return {
    activationCost: WK(i, e),
    area: YK(e),
    damage: void 0,
    duration: XK(i, e),
    ranges: JK(e),
    savingThrow: ZK(e),
    targets: QK(e)
  };
}
u(xK, "getBaseActionSummaryData");
function eY(i, e) {
  return {};
}
u(eY, "getFeatureSummaryData");
function tY(i, e) {
  if (!i.isType("maneuver"))
    return { maneuverProperties: "" };
  const t = CONFIG.A5E.maneuverDegrees[i.system.degree], s = CONFIG.A5E.maneuverTraditions[i.system.tradition] ?? "", n = i.system.isStance ? "Stance" : "", l = i.system.exertionCost ? `(${i.system.exertionCost}
    ${K(i.system.exertionCost > 1 ? "A5E.ExertionPointPlural" : "A5E.ExertionPoint")})` : "";
  return { maneuverProperties: [t, s, n, l].filter(Boolean).join(" ") };
}
u(tY, "getManeuverSummaryData");
function sY(i) {
  const { armorProperties: e } = CONFIG.A5E;
  return i.system.armorProperties.map(
    (t) => e[t] ?? t
  );
}
u(sY, "getArmorProperties");
function nY(i) {
  return i.system.craftingComponents ?? "";
}
u(nY, "getCraftingComponentsLabel");
function z9(i) {
  const { flaws: e, materialProperties: t, modPorts: s } = CONFIG.A5E;
  return i.system.materialProperties.map((n) => {
    var l, r, o;
    if (n === "flaw") {
      const a = (o = (r = (l = i.system.flaws) == null ? void 0 : l.map((c) => K(e[c]) ?? null)) == null ? void 0 : r.filter(Boolean)) == null ? void 0 : o.sort((c, f) => c.localeCompare(f));
      return a.length ? K("A5E.MaterialPropertyFlawSpecific", { type: a.join(", ") }) : t.flaw;
    }
    if (n === "spacefaring") {
      if (i.system.modPorts) {
        if (i.system.modPorts !== "1") {
          const c = s[i.system.modPorts];
          return K("A5E.MaterialPropertySpacefaringSpecificPlural", { type: c });
        }
        const a = s[i.system.modPorts];
        return K("A5E.MaterialPropertySpacefaringSpecific", { type: a });
      }
      return K("A5E.MaterialPropertySpacefaring");
    }
    return t[n] ?? n;
  });
}
u(z9, "getMaterialPropertiesSummary");
function iY(i) {
  const { requiresAttunement: e, attuned: t } = i.system;
  return e ? t ? K("A5E.Attuned") : i.actor ? `${K("A5E.AttunementRequiredPrompt")} - ${K("A5E.AttunedNot")}` : K("A5E.AttunementRequiredPrompt") : "";
}
u(iY, "getAttunementLabel");
function lY(i) {
  var s;
  const { unidentified: e, rarity: t } = i.system ?? {};
  return !((s = game.user) != null && s.isGM) && e || !t || t === "mundane" ? "" : CONFIG.A5E.itemRarity[t] ?? t;
}
u(lY, "getRarityLabel$1");
function rY(i, e) {
  const t = iY(i), { price: s } = i.system, n = lY(i), l = t && !(e != null && e.hideAttunementData), r = s && !(e != null && e.hidePrice);
  return n && !(e != null && e.hideRarity) ? r && l ? `${n} (${t}; Cost ${s})` : r ? `${n} (Cost ${s})` : l ? `${n} (${t})` : n : r && l ? `${t}; Cost ${s}` : r ? `Cost ${s}` : l ? t : "";
}
u(rY, "getObjectMechanicsLabel");
function oY(i) {
  const { shieldProperties: e } = CONFIG.A5E;
  return i.system.shieldProperties.map(
    (t) => e[t] ?? t
  );
}
u(oY, "getShieldProperties");
function aY(i) {
  var n, l, r;
  const { breakerProperties: e, weaponProperties: t } = CONFIG.A5E, s = (r = (l = (n = i.system.breakerProperties) == null ? void 0 : n.map((o) => e[o] ?? null)) == null ? void 0 : l.filter(Boolean)) == null ? void 0 : r.sort((o, a) => o.localeCompare(a));
  return s.length ? K("A5E.weaponProperties.breakerSpecific", { type: s.join(", ") }) : t.breaker;
}
u(aY, "getBreakerProperties");
function cY(i) {
  const { defensiveProperties: e, weaponProperties: t } = CONFIG.A5E;
  if (i.system.defensiveProperties) {
    const s = e[i.system.defensiveProperties];
    return K("A5E.weaponProperties.defensiveSpecific", { type: s });
  }
  return t.defensive;
}
u(cY, "getDefensiveProperties");
function uY(i) {
  var n, l, r;
  const { versatileOptions: e, weaponProperties: t } = CONFIG.A5E, s = (r = (l = (n = i.system.mounted) == null ? void 0 : n.map((o) => e[o] ?? null)) == null ? void 0 : l.filter(Boolean)) == null ? void 0 : r.sort((o, a) => {
    const c = /d(?<die>\d+)/;
    return o.match(c).groups.die - a.match(c).groups.die;
  });
  return s.length ? K("A5E.weaponProperties.mountedSpecific", { dice: s.join(" / ") }) : t.mounted;
}
u(uY, "getMountedProperties");
function fY(i) {
  const { versatileOptions: e, weaponProperties: t } = CONFIG.A5E;
  if (i.system.versatile) {
    const s = e[i.system.versatile];
    return K("A5E.weaponProperties.versatileSpecific", { die: s });
  }
  return t.versatile;
}
u(fY, "getVersatileProperties");
function H9(i) {
  const { weaponProperties: e } = CONFIG.A5E;
  return i.system.weaponProperties.map((t) => {
    switch (t) {
      case "defensive":
        return cY(i);
      case "breaker":
        return aY(i);
      case "mounted":
        return uY(i);
      case "versatile":
        return fY(i);
      default:
        return e[t] ?? null;
    }
  }).filter(Boolean);
}
u(H9, "getWeaponProperties");
function dY(i, e) {
  const t = {}, { objectType: s } = i.system, n = z9(i);
  return s === "armor" ? n.push(...sY(i)) : s === "shield" ? n.push(...oY(i)) : s === "weapon" && n.push(...H9(i)), n.sort((l, r) => l.localeCompare(r)), t.objectProperties = n.join(", "), e != null && e.hideCraftingComponents || (t.craftingComponents = nY(i)), t.objectMechanics = rY(i, e), t;
}
u(dY, "getObjectSummaryData");
function pY(i) {
  const { classSpellLists: e } = CONFIG.A5E, t = [...i.system.classes ?? []], s = [];
  return [
    ["elementalistAir", "Air"],
    ["elementalistEarth", "Earth"],
    ["elementalistFire", "Fire"],
    ["elementalistWater", "Water"]
  ].forEach(([l, r]) => {
    t.includes(l) && (s.push(r), t.splice(t.indexOf(l), 1));
  }), s.length === 4 ? t.push(K("A5E.characterClasses.elementalistCustom", { elements: "All" })) : s.length && t.push(
    K("A5E.characterClasses.elementalistCustom", { elements: s.join(", ") })
  ), t.map((l) => e[l] ?? l).sort((l, r) => l.localeCompare(r)).join(", ");
}
u(pY, "getClassesLabel");
function mY(i) {
  var t, s, n, l;
  const e = Object.entries(i.system.components).reduce((r, [o, a]) => (a && r.push(CONFIG.A5E.spellComponentAbbreviations[o]), r), []).join(", ");
  return typeof ((t = i == null ? void 0 : i.system) == null ? void 0 : t.materials) == "string" && ((n = (s = i == null ? void 0 : i.system) == null ? void 0 : s.materials) != null && n.trim()) ? `${e} (${(l = i == null ? void 0 : i.system) == null ? void 0 : l.materials})` : e;
}
u(mY, "getSpellComponentsLabel");
function hY(i) {
  const { spellSchools: e } = CONFIG.A5E, { schools: t } = i.system, s = e.primary[t.primary] ?? t.primary, n = t.secondary.map(
    (l) => e.secondary[l] ?? l
  );
  return n.sort((l, r) => l.localeCompare(r)), [s, ...n];
}
u(hY, "getSpellSchools");
function gY(i, e) {
  const t = pY(i), s = mY(i), n = CONFIG.A5E.spellLevels[i.system.level] ?? "", l = hY(i), r = K(CONFIG.A5E.psionicDisciplines[i.system.discipline] ?? ""), o = [];
  return e != null && e.hideSpellLevel || o.push(n), o.push(...l), o.push(r), {
    spellClasses: e != null && e.hideSpellClasses ? "" : t,
    spellComponents: e != null && e.hideSpellComponents ? "" : s,
    spellProperties: o.filter(Boolean).join(", ")
  };
}
u(gY, "getSpellSummaryData");
function nd(i, e, t = {}) {
  var l;
  const s = {}, { mergeObject: n } = foundry.utils;
  return !e && !i.actions ? "" : ((!foundry.utils.isEmpty(e) || ((l = i.actions) == null ? void 0 : l.count) === 1) && n(s, xK(i, e ?? i.actions.first)), foundry.utils.isEmpty(e) && (i.type === "feature" ? n(s, eY()) : i.type === "maneuver" ? n(s, tY(i)) : i.isType("object") ? n(s, dY(i, t)) : i.isType("spell") && n(s, gY(i, t))), s);
}
u(nd, "getSummaryData");
const Z$ = class Z$ extends Item {
  constructor(t, s) {
    super(t, s);
    qe(this, "dialogs");
    this.dialogs ?? (this.dialogs = {
      actions: {},
      areaScaling: {},
      rollScaling: {},
      targetScaling: {}
    });
  }
  // *****************************************************************************************
  isType(t) {
    return t === this.type;
  }
  // *****************************************************************************************
  get sourceId() {
    var t;
    return this._stats.compendiumSource || ((t = this.flags.core) == null ? void 0 : t.sourceId) || null;
  }
  /** ------------------------------------------------------ */
  /**                      Data Prep                         */
  /** ------------------------------------------------------ */
  _initialize(t) {
    this.initialized = !1, super._initialize(t);
  }
  prepareData() {
    this.initialized || (!this.parent || this.parent.initialized) && (this.initialized = !0, super.prepareData());
  }
  prepareBaseData() {
  }
  prepareDerivedData() {
  }
  /** @inheritdoc */
  getRollData() {
    return { ...super.getRollData() };
  }
  // *****************************************************************************************
  /**
    * A handler for activating an item. An actionId can be passed to this method to use a specific
    * action defined on the item. If there are no actions defined, this method defaults to
    * outputting the item's description.
    *
   //  * This method accepts an options object to further customize the activation process.
    *
    * @param {string} actionId
    * @param {object options
    * @returns
    */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async activate(t, s) {
    var n;
    !this.actor || !(this != null && this.actor.isOwner) || ((((n = this.actor) == null ? void 0 : n.getFlag("a5e", "automaticallyExecuteAvailableMacros")) ?? !0) && (s.executeMacro ?? (s.executeMacro = this.system.macro.trim().length > 0)), this.shareItemDescription(null, s));
  }
  async shareItemDescription(t, s) {
    var r, o, a, c, f, d, p, m, g, h, _;
    const n = {
      author: (r = game.user) == null ? void 0 : r.id,
      speaker: ChatMessage.getSpeaker({ actor: this.actor }),
      system: {
        actorId: (o = this.actor) == null ? void 0 : o.uuid,
        actorName: this.name,
        actionName: t == null ? void 0 : t.name,
        img: (t == null ? void 0 : t.img) ?? this.img,
        itemId: this.uuid,
        actionDescription: (a = t == null ? void 0 : t.descriptionOutputs) != null && a.includes("action") ? await TextEditor.enrichHTML(t.description, {
          secrets: this.isOwner,
          relativeTo: this,
          rollData: ((c = this == null ? void 0 : this.actor) == null ? void 0 : c.getRollData(this)) ?? {}
        }) : null,
        itemDescription: ((f = t == null ? void 0 : t.descriptionOutputs) == null ? void 0 : f.includes("item")) ?? !0 ? await TextEditor.enrichHTML(this.system.description, {
          secrets: this.isOwner,
          relativeTo: this,
          rollData: ((d = this == null ? void 0 : this.actor) == null ? void 0 : d.getRollData(this)) ?? {}
        }) : null,
        unidentifiedDescription: ((p = t == null ? void 0 : t.descriptionOutputs) == null ? void 0 : p.includes("item")) ?? !0 ? (
          // @ts-expect-error
          await TextEditor.enrichHTML(this.system.unidentifiedDescription, {
            secrets: this.isOwner,
            relativeTo: this,
            rollData: ((m = this == null ? void 0 : this.actor) == null ? void 0 : m.getRollData(this)) ?? {}
          })
        ) : null,
        summaryData: nd(this, t, {
          hideSpellClasses: !0,
          hideSpellComponents: !0,
          hideSpellLevel: !0
        })
      },
      type: "item"
    };
    ChatMessage.applyRollMode(n, game.settings.get("core", "rollMode"));
    const l = ChatMessage.create(n);
    if (s.executeMacro) {
      if (!(((g = this.system.macro) == null ? void 0 : g.trim().length) > 0))
        return (h = ui.notifications) == null || h.error(`There is no macro configured for ${this.name}.`), l;
      try {
        const { macro: y } = this.system, v = (/* @__PURE__ */ u(async function() {
        }, "_")).constructor;
        v("actor", "item", "options", y)(this.actor, this, { options: s });
      } catch (y) {
        (_ = ui.notifications) == null || _.error(
          `Could not execute the macro for ${this.name}. See the browser console for more details.`
        ), console.error(y);
      }
    }
    return Hooks.callAll("a5e.itemActivate", this, { action: t }), l;
  }
  async configureItem() {
    var t;
    await ((t = this.sheet) == null ? void 0 : t.render(!0));
  }
  duplicateItem() {
    const t = this.actor, s = foundry.utils.duplicate(this);
    s.name = `${s.name} (Copy)`, s.type === "object" && (s.system.containerId = null), t ? t.createEmbeddedDocuments("Item", [s]) : Item.createDocuments([s]);
  }
  async toggleFavorite() {
    this.actor && await this.update({
      "system.favorite": !this.system.favorite
    });
  }
  async revitalize(t = {}) {
    var a, c, f, d, p, m, g, h, _;
    if (!await foundry.applications.api.DialogV2.confirm({
      // @ts-expect-error
      window: { title: `Confirm Revitalize - ${this.name}` },
      content: "<p>Confirm updating item from compendium source?</p>",
      modal: !0
    })) return null;
    t.notify ?? (t.notify = !0), t.update ?? (t.update = !0), t.updateImg ?? (t.updateImg = !0), t.updateEffects ?? (t.updateEffects = !0), t.updateName ?? (t.updateName = !0);
    const { sourceId: n } = this;
    if (!n)
      return t.notify !== !1 && ((a = ui.notifications) == null || a.error("Cannot revitalize an item without a source ID.")), null;
    if (this.uuid === n)
      return t.notify !== !1 && ((c = ui.notifications) == null || c.error("Cannot revitalize an item that is already the source.")), null;
    if (!n.startsWith("Compendium."))
      return t.notify !== !1 && ((f = ui.notifications) == null || f.error("Cannot revitalize an item that is not from a compendium.")), null;
    const l = this.toObject(), r = (d = await fromUuid(n)) == null ? void 0 : d.toObject();
    if (!r)
      return t.notify !== !1 && ((p = ui.notifications) == null || p.error("Unable to find source.")), null;
    if (l.type !== r.type)
      return t.notify !== !1 && ((m = ui.notifications) == null || m.error("Cannot revitalize an item with a different type.")), null;
    const o = {
      name: t.updateName ? r.name : l.name,
      img: t.updateImg ? r.img : l.img,
      system: foundry.utils.deepClone(r.system),
      _stats: { compendiumSource: n }
    };
    if ((g = this.system) != null && g.grants && (o.system.grants = this.system.grants), o.system.favorite = this.system.favorite, (h = this.system.uses) != null && h.max && (o.system.uses.value = this.system.uses.value), this.isType("archetype") && (o.system.spellcasting.ability.base = this.system.spellcasting.ability.base), this.isType("class") && (o.system.classLevels = this.system.classLevels, o.system.hp = this.system.hp, o.system.spellcasting.ability.base = this.system.spellcasting.ability.base), this.isType("object") && (o.system.containerId = this.system.containerId, o.system.items = this.system.items, o.system.damagedState = this.system.damagedState, o.system.equippedState = this.system.equippedState, o.system.unidentified = this.system.unidentified, o.system.proficient = this.system.proficient, o.system.quantity = this.system.quantity), this.isType("spell") && (o.system.spellBook = this.system.spellBook), r.system.actions) {
      const y = this.system.actions, v = r.system.actions, k = Object.entries(v).reduce((S, [D, I]) => {
        var B, z;
        const M = foundry.utils.deepClone(I), L = y[D];
        return L ? ((B = I.uses) != null && B.value && foundry.utils.setProperty(M, "uses.value", (z = L.uses) == null ? void 0 : z.value), S[D] = M, S) : (S[D] = M, S);
      }, {});
      o.system.actions = k;
    }
    if (t.updateEffects) {
      const y = [...this.effects], k = [...r.effects].reduce((S, D) => {
        const I = foundry.utils.deepClone(D), M = y.find((L) => L._id === D._id);
        return M ? (I.flags = M.flags, S.push(I), S) : (S.push(I), S);
      }, []);
      o.effects = k;
    }
    return t.update && await this.update(o, { diff: !1, recursive: !1 }), t.notify !== !1 && ((_ = ui.notifications) == null || _.info("Item revitalized.")), o;
  }
  /** @inheritdoc */
  async _preCreate(t, s, n) {
    var o;
    await super._preCreate(t, s, n);
    const l = du.LATEST_MIGRATION_VERSION, r = (o = this.system.migrationData) == null ? void 0 : o.version;
    r ? r < l && await T9(this) : this.updateSource({
      // @ts-expect-error
      "this.system.migrationData": {
        version: l,
        type: "Item"
      }
    });
  }
  async _preUpdate(t, s, n) {
    super._preUpdate(t, s, n);
  }
  _onCreate(t, s, n) {
    if (super._onCreate(t, s, n), n !== game.userId) return;
    const r = this.effects.contents.map((o) => ({ _id: o._id, origin: this.uuid }));
    this.updateEmbeddedDocuments("ActiveEffect", r);
  }
  _onDelete(t, s) {
    super._onDelete(t, s);
  }
  static async _onCreateOperation(t, s, n) {
    var a;
    if (((a = game.user) == null ? void 0 : a.id) !== n.id || !((fromUuidSync(s.parentUuid) ?? {}) instanceof Actor))
      return Item._onCreateOperation(t, s, n);
    const r = [];
    return t.forEach((c) => {
      c.effects.forEach((f) => {
        var m, g;
        if (!(((g = (m = f.flags) == null ? void 0 : m.a5e) == null ? void 0 : g.transferType) === "passive")) return;
        const p = f.toObject();
        p.origin = c.uuid, r.push(p);
      });
    }), r.length && await getDocumentClass("ActiveEffect").createDocuments(r, s), Item._onCreateOperation(t, s, n);
  }
};
u(Z$, "BaseItemA5e");
let ku = Z$;
var rh, A5;
const Q$ = class Q$ extends Zd {
  constructor(t, s = {}) {
    super(t, s);
    x(this, rh, null);
    x(this, A5, null);
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return {
      _id: new t.DocumentIdField({ initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
      img: new t.StringField({ required: !0, initial: "" }),
      grantType: new t.StringField({ required: !0, initial: "" }),
      label: new t.StringField({ required: !0, initial: "" }),
      level: new t.NumberField({ nullable: !1, initial: 1, min: 1 }),
      levelType: new t.StringField({ required: !0, initial: "character" }),
      optional: new t.BooleanField({ required: !0, initial: !1 })
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getApplyData(t, s) {
    return {};
  }
  getSelectionComponent() {
    return P(this, rh);
  }
  getSelectionComponentProps(t) {
    return { ...t };
  }
  requiresConfig() {
    return !1;
  }
  async configureGrant(t, s, n, l = {}) {
    const r = new ac(t, n, s, l);
    await r.render(!0);
    const o = await r.promise;
    return o || {};
  }
  async deleteGrant() {
    var n;
    await this.parent.update({
      [`system.grants.-=${this._id}`]: null
    });
    const s = (n = this.parent) == null ? void 0 : n.parent;
    !s || s.documentName !== "Actor" || s.grants.removeGrant(this._id);
  }
};
rh = new WeakMap(), A5 = new WeakMap(), u(Q$, "BaseGrant");
let Is = Q$;
function bY(i, e) {
  const t = [];
  return e === "abilities" && (t.push(
    {
      heading: "Base Abilities",
      options: Object.entries(CONFIG.A5E.abilities),
      selectedProperty: "abilities.base",
      component: "TagGroup"
    },
    {
      heading: "Ability Choices",
      options: Object.entries(CONFIG.A5E.abilities),
      selectedProperty: "abilities.options",
      component: "TagGroup"
    },
    {
      heading: "Select Ability Bonus Automatically in Roll Prompt",
      selectedProperty: "context.default",
      component: "Checkbox"
    }
  ), t.push(
    {
      heading: "Selectable Options Count",
      selectedProperty: "abilities.total",
      component: "Number"
    },
    {
      heading: "A5E.contexts.bonusTypes",
      options: Object.entries(CONFIG.A5E.abilityBonusContexts),
      selectedProperty: "context.types",
      component: "TagGroup"
    },
    {
      heading: "A5E.contexts.requiresProficiency",
      selectedProperty: "context.requiresProficiency",
      component: "Checkbox"
    }
  )), e === "attacks" && (t.push(
    {
      heading: "Base Attack Types",
      options: Object.entries(CONFIG.A5E.attackTypes),
      selectedProperty: "attackTypes.base",
      component: "TagGroup"
    },
    {
      heading: "Attack Type Choices",
      options: Object.entries(CONFIG.A5E.attackTypes),
      selectedProperty: "attackTypes.options",
      component: "TagGroup"
    },
    {
      heading: "Select Attack Bonus Automatically in Roll Prompt",
      selectedProperty: "context.default",
      component: "Checkbox"
    }
  ), t.push(
    {
      heading: "Selectable Options Count",
      selectedProperty: "attackTypes.total",
      component: "Number"
    },
    {
      heading: "A5E.contexts.spellLevel",
      options: Object.entries(CONFIG.A5E.spellLevels),
      selectedProperty: "context.spellLevels",
      component: "TagGroup"
    },
    {
      heading: "A5E.contexts.requiresProficiency",
      selectedProperty: "context.requiresProficiency",
      component: "Checkbox"
    }
  )), e === "damage" && (t.push(
    {
      heading: "A5E.contexts.attackType",
      options: Object.entries(CONFIG.A5E.damageBonusContexts),
      selectedProperty: "context.attackTypes",
      component: "TagGroup"
    },
    {
      heading: "A5E.contexts.damageType",
      options: Object.entries(CONFIG.A5E.damageTypes),
      selectedProperty: "context.damageTypes",
      component: "TagGroup"
    },
    {
      heading: "A5E.contexts.spellLevel",
      options: Object.entries(CONFIG.A5E.spellLevels),
      selectedProperty: "context.spellLevels",
      component: "TagGroup"
    },
    {
      heading: "This bonus only applies to critical hits.",
      selectedProperty: "context.isCritBonus",
      component: "Checkbox"
    }
  ), t.push({
    heading: "Select Damage Bonus Automatically in Roll Prompt",
    selectedProperty: "context.default",
    component: "Checkbox"
  })), e === "healing" && (t.push(
    {
      heading: "A5E.contexts.healingType",
      options: Object.entries(CONFIG.A5E.healingBonusContexts),
      selectedProperty: "context.healingTypes",
      component: "TagGroup"
    },
    {
      heading: "A5E.contexts.spellLevel",
      options: Object.entries(CONFIG.A5E.spellLevels),
      selectedProperty: "context.spellLevels",
      component: "TagGroup"
    }
  ), t.push({
    heading: "Select Healing Bonus Automatically in Roll Prompt",
    selectedProperty: "context.default",
    component: "Checkbox"
  })), e === "hitPoint" && t.push({
    heading: "A5E.contexts.perLevel",
    selectedProperty: "context.perLevel",
    component: "Checkbox"
  }), e === "initiative" && (t.push(
    {
      heading: "A5E.contexts.abilities",
      options: Object.entries(CONFIG.A5E.abilities),
      selectedProperty: "context.abilities",
      component: "TagGroup"
    },
    {
      heading: "A5E.contexts.skills",
      options: Object.entries(CONFIG.A5E.skills),
      selectedProperty: "context.skills",
      component: "TagGroup"
    }
  ), t.push({
    heading: "Select Initiative Bonus Automatically in Roll Prompt",
    selectedProperty: "context.default",
    component: "Checkbox"
  })), e === "movement" && (t.push(
    {
      heading: "Base Movement Types",
      options: Object.entries(CONFIG.A5E.movementAbbreviations),
      selectedProperty: "movementTypes.base",
      component: "TagGroup"
    },
    {
      heading: "Movement Type Choices",
      options: Object.entries(CONFIG.A5E.movementAbbreviations),
      selectedProperty: "movementTypes.options",
      component: "TagGroup"
    }
  ), t.push(
    {
      heading: "Selectable Options Count",
      selectedProperty: "movementTypes.total",
      component: "Number"
    },
    // {
    //   heading: 'Value If Original Is Zero',
    //   selectedProperty: 'context.valueIfOriginalIsZero',
    //   component: 'String'
    // },
    {
      heading: "Is Hover For Flying Speed",
      selectedProperty: "context.isHover",
      component: "Checkbox"
    }
  )), e === "senses" && (t.push(
    {
      heading: "Base Senses",
      options: Object.entries(CONFIG.A5E.senses),
      selectedProperty: "senses.base",
      component: "TagGroup"
    },
    {
      heading: "Senses Type Choices",
      options: Object.entries(CONFIG.A5E.senses),
      selectedProperty: "senses.options",
      component: "TagGroup"
    }
  ), t.push(
    {
      heading: "Selectable Options Count",
      selectedProperty: "senses.total",
      component: "Number"
    },
    // {
    //   heading: 'Value If Original Is Zero',
    //   selectedProperty: 'context.valueIfOriginalIsZero',
    //   component: 'String'
    // },
    {
      heading: "Is Blind Beyond Vision Range",
      selectedProperty: "context.otherwiseBlind",
      component: "Checkbox"
    }
  )), e === "skills" && (t.push(
    {
      heading: "Base Skills",
      options: Object.entries(CONFIG.A5E.skills),
      selectedProperty: "skills.base",
      component: "TagGroup"
    },
    {
      heading: "Skill Choices",
      options: Object.entries(CONFIG.A5E.skills),
      selectedProperty: "skills.options",
      component: "TagGroup"
    },
    {
      heading: "Select Skill Bonus Automatically in Roll Prompt",
      selectedProperty: "context.default",
      component: "Checkbox"
    }
  ), t.push(
    {
      heading: "Selectable Options Count",
      selectedProperty: "skills.total",
      component: "Number"
    },
    {
      heading: "A5E.contexts.requiresProficiency",
      selectedProperty: "context.requiresProficiency",
      component: "Checkbox"
    },
    {
      heading: "A5E.contexts.passiveOnly",
      selectedProperty: "context.passiveOnly",
      component: "Checkbox"
    }
  )), t;
}
u(bY, "getContextsMap");
function UD(i, e, t) {
  const s = i.slice();
  return s[12] = e[t], s;
}
u(UD, "get_each_context$1u");
function _Y(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: (
        /*context*/
        i[12].heading
      ),
      $$slots: { default: [wY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--background", "none"), G(t, "--padding", "0"), G(t, "--margin", "0 0 0.5rem 0 ");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, grant*/
      32769 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(_Y, "create_if_block_3$B");
function yY(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: (
        /*context*/
        i[12].heading
      ),
      $$slots: { default: [$Y] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--background", "none"), G(t, "--padding", "0"), G(t, "--margin", "0 0 0.5rem 0 ");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, grant*/
      32769 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(yY, "create_if_block_2$X");
function vY(i) {
  let e, t;
  function s(...n) {
    return (
      /*updateSelection_handler_1*/
      i[7](
        /*context*/
        i[12],
        ...n
      )
    );
  }
  return u(s, "updateSelection_handler_1"), e = new Te({
    props: {
      label: (
        /*context*/
        i[12].heading
      ),
      checked: (
        /*getProperty*/
        i[2](
          /*grant*/
          i[0],
          /*context*/
          i[12].selectedProperty
        )
      )
    }
  }), e.$on("updateSelection", s), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      i = n;
      const r = {};
      l & /*grant*/
      1 && (r.checked = /*getProperty*/
      i[2](
        /*grant*/
        i[0],
        /*context*/
        i[12].selectedProperty
      )), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(vY, "create_if_block_1$1n");
function kY(i) {
  let e, t;
  function s(...n) {
    return (
      /*updateSelection_handler*/
      i[6](
        /*context*/
        i[12],
        ...n
      )
    );
  }
  return u(s, "updateSelection_handler"), e = new tt({
    props: {
      heading: (
        /*context*/
        i[12].heading
      ),
      options: (
        /*context*/
        i[12].options
      ),
      selected: (
        /*getProperty*/
        i[2](
          /*grant*/
          i[0],
          /*context*/
          i[12].selectedProperty
        )
      ),
      showToggleAllButton: !0
    }
  }), e.$on("updateSelection", s), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      i = n;
      const r = {};
      l & /*grant*/
      1 && (r.selected = /*getProperty*/
      i[2](
        /*grant*/
        i[0],
        /*context*/
        i[12].selectedProperty
      )), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(kY, "create_if_block$26");
function wY(i) {
  let e, t, s, n, l;
  function r(...o) {
    return (
      /*change_handler_1*/
      i[9](
        /*context*/
        i[12],
        ...o
      )
    );
  }
  return u(r, "change_handler_1"), {
    c() {
      e = E("input"), s = F(), b(e, "type", "text"), e.value = t = /*getProperty*/
      i[2](
        /*grant*/
        i[0],
        /*context*/
        i[12].selectedProperty
      ) || "";
    },
    m(o, a) {
      T(o, e, a), T(o, s, a), n || (l = W(e, "change", r), n = !0);
    },
    p(o, a) {
      i = o, a & /*grant*/
      1 && t !== (t = /*getProperty*/
      i[2](
        /*grant*/
        i[0],
        /*context*/
        i[12].selectedProperty
      ) || "") && e.value !== t && (e.value = t);
    },
    d(o) {
      o && (C(e), C(s)), n = !1, l();
    }
  };
}
u(wY, "create_default_slot_2$U");
function $Y(i) {
  let e, t, s, n, l;
  function r(...o) {
    return (
      /*change_handler*/
      i[8](
        /*context*/
        i[12],
        ...o
      )
    );
  }
  return u(r, "change_handler"), {
    c() {
      e = E("input"), s = F(), b(e, "type", "number"), e.value = t = /*getProperty*/
      i[2](
        /*grant*/
        i[0],
        /*context*/
        i[12].selectedProperty
      ) ?? 0;
    },
    m(o, a) {
      T(o, e, a), T(o, s, a), n || (l = W(e, "change", r), n = !0);
    },
    p(o, a) {
      i = o, a & /*grant*/
      1 && t !== (t = /*getProperty*/
      i[2](
        /*grant*/
        i[0],
        /*context*/
        i[12].selectedProperty
      ) ?? 0) && e.value !== t && (e.value = t);
    },
    d(o) {
      o && (C(e), C(s)), n = !1, l();
    }
  };
}
u($Y, "create_default_slot_1$1d");
function VD(i) {
  let e, t, s, n;
  const l = [kY, vY, yY, _Y], r = [];
  function o(a, c) {
    return (
      /*context*/
      a[12].component === "TagGroup" ? 0 : (
        /*context*/
        a[12].component === "Checkbox" ? 1 : (
          /*context*/
          a[12].component === "Number" ? 2 : (
            /*context*/
            a[12].component === "String" ? 3 : -1
          )
        )
      )
    );
  }
  return u(o, "select_block_type"), ~(e = o(i)) && (t = r[e] = l[e](i)), {
    c() {
      t && t.c(), s = $e();
    },
    m(a, c) {
      ~e && r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      t && t.p(a, c);
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), ~e && r[e].d(a);
    }
  };
}
u(VD, "create_each_block$1u");
function AY(i) {
  let e, t, s = ue(
    /*contextMap*/
    i[3]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = VD(UD(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o & /*contextMap, getProperty, grant, onUpdateValue, Number*/
      29) {
        s = ue(
          /*contextMap*/
          r[3]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = UD(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = VD(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(AY, "create_default_slot$21");
function EY(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Contexts",
      hint: "The context determines when the bonus applies",
      $$slots: { default: [AY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, grant*/
      32769 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(EY, "create_fragment$3Y");
function SY(i, e, t) {
  let s, n;
  const l = de("item");
  pe(i, l, (h) => t(5, n = h));
  const r = de("grantId"), o = de("grantType"), a = foundry.utils.getProperty, c = bY("grant", o);
  function f(h, _) {
    h = `system.grants.${r}.${h}`, te(n, h, _);
  }
  u(f, "onUpdateValue");
  const d = /* @__PURE__ */ u((h, { detail: _ }) => {
    f(h.selectedProperty, _);
  }, "updateSelection_handler"), p = /* @__PURE__ */ u((h, { detail: _ }) => {
    f(h.selectedProperty, _);
  }, "updateSelection_handler_1"), m = /* @__PURE__ */ u((h, { target: _ }) => {
    f(h.selectedProperty, Number(_.value));
  }, "change_handler"), g = /* @__PURE__ */ u((h, { target: _ }) => {
    f(h.selectedProperty, _.value);
  }, "change_handler_1");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    32 && t(0, s = n.system.grants[r]);
  }, [
    s,
    l,
    a,
    c,
    f,
    n,
    d,
    p,
    m,
    g
  ];
}
u(SY, "instance$3P");
const x$ = class x$ extends re {
  constructor(e) {
    super(), oe(this, e, SY, EY, le, {});
  }
};
u(x$, "NumericalGrantContexts");
let Yb = x$;
function CY(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      i[0].level ?? 1, b(e, "min", "1");
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      r & /*grant*/
      1 && t !== (t = /*grant*/
      l[0].level ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(CY, "create_default_slot_1$1c");
function TY(i) {
  let e, t, s, n, l, r, o;
  const a = (
    /*#slots*/
    i[5].default
  ), c = Gt(
    a,
    i,
    /*$$scope*/
    i[9],
    null
  );
  return t = new ie({
    props: {
      heading: "A5E.Level",
      $$slots: { default: [CY] },
      $$scope: { ctx: i }
    }
  }), n = new Ke({
    props: {
      heading: "A5E.classes.levelType",
      options: Object.entries(
        /*levelTypes*/
        i[2]
      ),
      selected: (
        /*grant*/
        i[0].levelType
      ),
      allowDeselect: !1
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), r = new Te({
    props: {
      label: "Mark grant as optional",
      checked: (
        /*grant*/
        i[0].optional ?? !1
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), {
    c() {
      c && c.c(), e = F(), j(t.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment);
    },
    m(f, d) {
      c && c.m(f, d), T(f, e, d), R(t, f, d), T(f, s, d), R(n, f, d), T(f, l, d), R(r, f, d), o = !0;
    },
    p(f, d) {
      c && c.p && (!o || d & /*$$scope*/
      512) && Ht(
        c,
        a,
        f,
        /*$$scope*/
        f[9],
        o ? zt(
          a,
          /*$$scope*/
          f[9],
          d,
          null
        ) : Ut(
          /*$$scope*/
          f[9]
        ),
        null
      );
      const p = {};
      d & /*$$scope, grant*/
      513 && (p.$$scope = { dirty: d, ctx: f }), t.$set(p);
      const m = {};
      d & /*grant*/
      1 && (m.selected = /*grant*/
      f[0].levelType), n.$set(m);
      const g = {};
      d & /*grant*/
      1 && (g.checked = /*grant*/
      f[0].optional ?? !1), r.$set(g);
    },
    i(f) {
      o || (w(c, f), w(t.$$.fragment, f), w(n.$$.fragment, f), w(r.$$.fragment, f), o = !0);
    },
    o(f) {
      O(c, f), O(t.$$.fragment, f), O(n.$$.fragment, f), O(r.$$.fragment, f), o = !1;
    },
    d(f) {
      f && (C(e), C(s), C(l)), c && c.d(f), N(t, f), N(n, f), N(r, f);
    }
  };
}
u(TY, "create_default_slot$20");
function OY(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Grant Config",
      $$slots: { default: [TY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, grant*/
      513 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(OY, "create_fragment$3X");
function DY(i, e, t) {
  let s, n, { $$slots: l = {}, $$scope: r } = e;
  const o = de("item");
  pe(i, o, (g) => t(4, n = g));
  const a = de("grantId"), c = CONFIG.A5E.classLevelTypes;
  function f(g, h) {
    g = `system.grants.${a}.${g}`, te(n, g, h);
  }
  u(f, "onUpdateValue");
  const d = /* @__PURE__ */ u(({ target: g }) => {
    f("level", Math.max(Number(g.value), 1));
  }, "change_handler"), p = /* @__PURE__ */ u(({ detail: g }) => f("levelType", g), "updateSelection_handler"), m = /* @__PURE__ */ u(({ detail: g }) => f("optional", g), "updateSelection_handler_1");
  return i.$$set = (g) => {
    "$$scope" in g && t(9, r = g.$$scope);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item*/
    16 && t(0, s = n.system.grants[a]);
  }, [
    s,
    o,
    c,
    f,
    n,
    l,
    d,
    p,
    m,
    r
  ];
}
u(DY, "instance$3O");
const e2 = class e2 extends re {
  constructor(e) {
    super(), oe(this, e, DY, OY, le, {});
  }
};
u(e2, "GrantConfig");
let Mi = e2;
function WD(i, e, t) {
  const s = i.slice();
  return s[14] = e[t][0], s[15] = e[t][1], s;
}
u(WD, "get_each_context$1t");
function IY(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*grant*/
      i[3].bonus ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[12]
      ), s = !0);
    },
    p(l, r) {
      r & /*grant*/
      8 && t !== (t = /*grant*/
      l[3].bonus ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(IY, "create_default_slot_2$T");
function PY(i) {
  var n;
  let e, t, s;
  return e = new ie({
    props: {
      heading: (
        /*configObject*/
        ((n = i[7][
          /*grantType*/
          i[0]
        ]) == null ? void 0 : n.selectHeading) ?? ""
      ),
      $$slots: { default: [MY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--background", "none"), G(t, "--direction", "column"), G(t, "--padding", "0");
    },
    m(l, r) {
      T(l, t, r), R(e, t, null), s = !0;
    },
    p(l, r) {
      var a;
      const o = {};
      r & /*grantType*/
      1 && (o.heading = /*configObject*/
      ((a = l[7][
        /*grantType*/
        l[0]
      ]) == null ? void 0 : a.selectHeading) ?? ""), r & /*$$scope, grantType, grant, selectProperty*/
      262157 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
    },
    i(l) {
      s || (w(e.$$.fragment, l), s = !0);
    },
    o(l) {
      O(e.$$.fragment, l), s = !1;
    },
    d(l) {
      l && e && C(t), N(e, l);
    }
  };
}
u(PY, "create_if_block$25");
function KD(i, e) {
  let t, s = K(
    /*name*/
    e[15]
  ) + "", n, l, r, o;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = Q(s), l = F(), t.__value = r = /*key*/
      e[14], He(t, t.__value), t.selected = o = /*grant*/
      e[3][
        /*selectProperty*/
        e[2]
      ] === /*key*/
      e[14], this.first = t;
    },
    m(a, c) {
      T(a, t, c), A(t, n), A(t, l);
    },
    p(a, c) {
      e = a, c & /*grantType*/
      1 && s !== (s = K(
        /*name*/
        e[15]
      ) + "") && be(n, s), c & /*grantType*/
      1 && r !== (r = /*key*/
      e[14]) && (t.__value = r, He(t, t.__value)), c & /*grant, selectProperty, grantType*/
      13 && o !== (o = /*grant*/
      e[3][
        /*selectProperty*/
        e[2]
      ] === /*key*/
      e[14]) && (t.selected = o);
    },
    d(a) {
      a && C(t);
    }
  };
}
u(KD, "create_each_block$1t");
function MY(i) {
  let e, t, s = K("A5E.None") + "", n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, f, d = ue(Object.entries(
    /*configObject*/
    i[7][
      /*grantType*/
      i[0]
    ].selectTypes
  ));
  const p = /* @__PURE__ */ u((m) => (
    /*key*/
    m[14]
  ), "get_key");
  for (let m = 0; m < d.length; m += 1) {
    let g = WD(i, d, m), h = p(g);
    a.set(h, o[m] = KD(h, g));
  }
  return {
    c() {
      e = E("select"), t = E("option"), n = Q(s), l = F();
      for (let m = 0; m < o.length; m += 1)
        o[m].c();
      t.__value = null, He(t, t.__value), t.selected = r = /*grant*/
      i[3][
        /*selectProperty*/
        i[2]
      ] === "null" || /*grant*/
      i[3][
        /*selectProperty*/
        i[2]
      ] === null, b(e, "class", "u-w-fit damage-type-select");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, n), A(t, l);
      for (let h = 0; h < o.length; h += 1)
        o[h] && o[h].m(e, null);
      c || (f = W(
        e,
        "change",
        /*change_handler_2*/
        i[13]
      ), c = !0);
    },
    p(m, g) {
      g & /*grant, selectProperty*/
      12 && r !== (r = /*grant*/
      m[3][
        /*selectProperty*/
        m[2]
      ] === "null" || /*grant*/
      m[3][
        /*selectProperty*/
        m[2]
      ] === null) && (t.selected = r), g & /*Object, configObject, grantType, grant, selectProperty*/
      141 && (d = ue(Object.entries(
        /*configObject*/
        m[7][
          /*grantType*/
          m[0]
        ].selectTypes
      )), o = Lt(o, g, p, 1, m, d, a, e, an, KD, null, WD));
    },
    d(m) {
      m && C(e);
      for (let g = 0; g < o.length; g += 1)
        o[g].d();
      c = !1, f();
    }
  };
}
u(MY, "create_default_slot_1$1b");
function FY(i) {
  let e, t, s, n, l;
  e = new ie({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [IY] },
      $$scope: { ctx: i }
    }
  });
  let r = (
    /*hasSelectDialog*/
    i[8] && PY(i)
  );
  return {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), r && r.c(), n = $e(), G(t, "display", "contents"), G(
        t,
        "--a5e-field-wrapper-grow",
        /*hasSelectDialog*/
        i[8] ? "1" : "0"
      );
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, grant*/
      262152 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c), /*hasSelectDialog*/
      o[8] && r.p(o, a);
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(r), l = !1;
    },
    d(o) {
      o && (C(s), C(n)), o && e && C(t), N(e, o), r && r.d(o);
    }
  };
}
u(FY, "create_default_slot$1$");
function RY(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k;
  return d = new De({
    props: {
      $$slots: { default: [FY] },
      $$scope: { ctx: i }
    }
  }), g = new Yb({}), _ = new Mi({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), j(g.$$.fragment), h = F(), j(_.$$.fragment), b(s, "class", "grant-image svelte-18b23t6"), ze(s.src, n = /*grant*/
      i[3].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[3].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[3].label ?? "", b(a, "class", "grant-name svelte-18b23t6"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-18b23t6"), b(t, "class", "sheet-header svelte-18b23t6"), G(p, "display", "contents"), G(p, "--a5e-section-margin", "0.25rem 0"), G(
        p,
        "--a5e-section-body-direction",
        /*hasSelectDialog*/
        i[8] ? "row" : "column"
      ), b(e, "class", "svelte-18b23t6");
    },
    m(S, D) {
      T(S, e, D), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), R(g, e, null), A(e, h), R(_, e, null), y = !0, v || (k = [
        W(
          s,
          "click",
          /*updateImage*/
          i[4]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[11]
        )
      ], v = !0);
    },
    p(S, [D]) {
      (!y || D & /*grant, $item*/
      10 && !ze(s.src, n = /*grant*/
      S[3].img || /*$item*/
      S[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!y || D & /*grant*/
      8 && l !== (l = /*grant*/
      S[3].label)) && b(s, "alt", l), (!y || D & /*grant*/
      8 && c !== (c = /*grant*/
      S[3].label ?? "") && a.value !== c) && (a.value = c);
      const I = {};
      D & /*$$scope, grantType, grant, selectProperty*/
      262157 && (I.$$scope = { dirty: D, ctx: S }), d.$set(I);
    },
    i(S) {
      y || (w(d.$$.fragment, S), w(g.$$.fragment, S), w(_.$$.fragment, S), y = !0);
    },
    o(S) {
      O(d.$$.fragment, S), O(g.$$.fragment, S), O(_.$$.fragment, S), y = !1;
    },
    d(S) {
      S && C(e), N(d), N(g), N(_), v = !1, Me(k);
    }
  };
}
u(RY, "create_fragment$3W");
function NY(i, e, t) {
  let s, n, l, { document: r, grantId: o, grantType: a } = de("#external").application, { document: c = r, grantId: f = o, grantType: d = a } = e;
  function p() {
    const S = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: S,
      callback: /* @__PURE__ */ u((I) => {
        m("img", I);
      }, "callback")
    }).browse();
  }
  u(p, "updateImage");
  function m(S, D) {
    S = `system.grants.${f}.${S}`, te(l, S, D);
  }
  u(m, "onUpdateValue"), Qt(() => {
    g.destroy();
  });
  const g = new Zt(c);
  pe(i, g, (S) => t(1, l = S));
  const h = {
    abilities: {},
    damage: {
      selectHeading: "A5E.DamageType",
      selectTypes: CONFIG.A5E.damageTypes,
      selectProperty: "damageType"
    },
    healing: {
      selectHeading: "A5E.HealingType",
      selectTypes: CONFIG.A5E.healingTypes,
      selectProperty: "healingType"
    },
    movement: {
      selectHeading: "A5E.Unit",
      selectTypes: CONFIG.A5E.distanceUnits,
      selectProperty: "unit"
    },
    senses: {
      selectHeading: "A5E.Unit",
      selectTypes: CONFIG.A5E.visionUnits,
      selectProperty: "unit"
    },
    skills: {}
  }, _ = ["damage", "healing", "movement", "senses"].includes(d);
  lt("item", g), lt("grantId", f), lt("grantType", d);
  const y = /* @__PURE__ */ u(({ target: S }) => m("label", S.value), "change_handler"), v = /* @__PURE__ */ u(({ target: S }) => m("bonus", S.value), "change_handler_1"), k = /* @__PURE__ */ u(({ target: S }) => {
    var D;
    return m((D = h[d]) == null ? void 0 : D.selectProperty, S.value);
  }, "change_handler_2");
  return i.$$set = (S) => {
    "document" in S && t(9, c = S.document), "grantId" in S && t(10, f = S.grantId), "grantType" in S && t(0, d = S.grantType);
  }, i.$$.update = () => {
    var S;
    i.$$.dirty & /*$item, grantId*/
    1026 && t(3, s = l.system.grants[f]), i.$$.dirty & /*grantType*/
    1 && t(2, n = (S = h[d]) == null ? void 0 : S.selectProperty);
  }, [
    d,
    l,
    n,
    s,
    p,
    m,
    g,
    h,
    _,
    c,
    f,
    y,
    v,
    k
  ];
}
u(NY, "instance$3N");
const t2 = class t2 extends re {
  constructor(e) {
    super(), oe(this, e, NY, RY, le, { document: 9, grantId: 10, grantType: 0 });
  }
};
u(t2, "NumericalGrantConfig");
let Fi = t2;
function jY(i) {
  let e, t;
  return e = new tt({
    props: {
      options: (
        /*getOptions*/
        i[9](
          /*choicesLocked*/
          i[5]
        )
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[3]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*choicesLocked*/
      32 && (l.options = /*getOptions*/
      s[9](
        /*choicesLocked*/
        s[5]
      )), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      8 && (l.orange = /*choices*/
      s[3]), n & /*selected, totalCount*/
      17 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(jY, "create_default_slot_2$S");
function LY(i) {
  let e;
  return {
    c() {
      e = Q(
        /*summary*/
        i[6]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      64 && be(
        e,
        /*summary*/
        t[6]
      );
    },
    d(t) {
      t && C(e);
    }
  };
}
u(LY, "create_default_slot_1$1a");
function BY(i) {
  let e, t, s, n, l;
  return e = new ie({
    props: {
      warning: (
        /*remainingSelections*/
        i[7] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[7]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[4]
      ),
      $$slots: { default: [jY] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      $$slots: { default: [LY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), T(r, s, o), R(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*remainingSelections*/
      128 && (a.warning = /*remainingSelections*/
      r[7] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      r[7]} choices remaining.`), o & /*selected, totalCount*/
      17 && (a.showWarning = /*selected*/
      r[0].length < /*totalCount*/
      r[4]), o & /*$$scope, choicesLocked, selected, choices, totalCount*/
      131129 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, summary*/
      131136 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(s), r && e && C(t), N(e, r), N(n, r);
    }
  };
}
u(BY, "create_default_slot$1_");
function qY(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: (
        /*heading*/
        i[2] + " - " + /*grant*/
        i[1].label
      ),
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*func*/
            i[14]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[5] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[5] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [BY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*heading, grant*/
      6 && (r.heading = /*heading*/
      n[2] + " - " + /*grant*/
      n[1].label), l & /*choicesLocked*/
      32 && (r.headerButtons = [
        {
          classes: "add-button",
          handler: (
            /*func*/
            n[14]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          n[5] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            n[5] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), l & /*$$scope, summary, remainingSelections, selected, totalCount, choicesLocked, choices*/
      131321 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(qY, "create_fragment$3V");
function GY(i, e, t) {
  let s, n, l, { grant: r } = e, { heading: o } = e, { base: a } = e, { choices: c } = e, { configObject: f = {} } = e, { count: d } = e, { bonus: p } = e, { selected: m } = e;
  function g(S, D) {
    return ` This grant provides a bonus of ${S} to ${D.map((I) => f[I]).join(", ")}.`;
  }
  u(g, "getGrantSummary");
  function h({ detail: S }) {
    t(0, m = S), y("updateSelection", { selected: m, summary: l });
  }
  u(h, "onUpdateSelection");
  function _(S) {
    if (!S) return Object.entries(f);
    const D = [];
    for (const [I, M] of Object.entries(f))
      c.includes(I) && D.push([I, M]);
    return D;
  }
  u(_, "getOptions");
  const y = ft();
  let v = !0;
  const k = /* @__PURE__ */ u(() => t(5, v = !v), "func");
  return i.$$set = (S) => {
    "grant" in S && t(1, r = S.grant), "heading" in S && t(2, o = S.heading), "base" in S && t(10, a = S.base), "choices" in S && t(3, c = S.choices), "configObject" in S && t(11, f = S.configObject), "count" in S && t(12, d = S.count), "bonus" in S && t(13, p = S.bonus), "selected" in S && t(0, m = S.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, count*/
    5120 && t(4, s = a.length + d), i.$$.dirty & /*base, selected*/
    1025 && t(0, m = [...new Set(a.concat(m))]), i.$$.dirty & /*totalCount, selected*/
    17 && t(7, n = s - m.length), i.$$.dirty & /*bonus, selected*/
    8193 && t(6, l = g(p, m));
  }, [
    m,
    r,
    o,
    c,
    s,
    v,
    l,
    n,
    h,
    _,
    a,
    f,
    d,
    p,
    k
  ];
}
u(GY, "instance$3M");
const s2 = class s2 extends re {
  constructor(e) {
    super(), oe(this, e, GY, qY, le, {
      grant: 1,
      heading: 2,
      base: 10,
      choices: 3,
      configObject: 11,
      count: 12,
      bonus: 13,
      selected: 0
    });
  }
};
u(s2, "NumericalGrantSelectionDialog");
let mo = s2;
function U9(i) {
  const { fields: e } = foundry.data, t = {
    types: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
      initial: ["check", "save"]
    }),
    // @ts-expect-error
    requiresProficiency: new e.BooleanField({ required: !0, initial: !1 })
  };
  return i === "bonus" && (t.abilities = new e.ArrayField(
    new e.StringField({ required: !0, initial: "" }),
    { initial: [] }
  )), i === "grant" && (t.default = new e.BooleanField({ required: !0, initial: !0 })), t;
}
u(U9, "getAbilitiesBonusContext");
function V9(i) {
  const { fields: e } = foundry.data, t = {
    spellLevels: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
      initial: []
    }),
    // @ts-expect-error
    requiresProficiency: new e.BooleanField({ required: !0, initial: !1 })
  };
  return i === "bonus" && (t.attackTypes = new e.ArrayField(
    new e.StringField({ required: !0, initial: "" }),
    { initial: [] }
  )), i === "grant" && (t.default = new e.BooleanField({ required: !0, initial: !0 })), t;
}
u(V9, "getAttackBonusContext");
function W9(i) {
  const { fields: e } = foundry.data, t = {
    attackTypes: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
      initial: []
    }),
    damageTypes: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
      initial: []
    }),
    // @ts-expect-error
    isCritBonus: new e.BooleanField({ required: !0, initial: !1 }),
    spellLevels: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
      initial: []
    })
  };
  return i === "grant" && (t.default = new e.BooleanField({ required: !0, initial: !0 })), t;
}
u(W9, "getDamageBonusContext");
function K9(i) {
  const { fields: e } = foundry.data, t = {
    healingTypes: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
      initial: ["healing"]
    }),
    spellLevels: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
      initial: []
    })
  };
  return i === "grant" && (t.default = new e.BooleanField({ required: !0, initial: !0 })), t;
}
u(K9, "getHealingBonusContext");
function Y9() {
  const { fields: i } = foundry.data;
  return {
    // @ts-expect-error
    perLevel: new i.BooleanField({ required: !0, initial: !1 })
  };
}
u(Y9, "getHitPointsBonusContext");
function X9(i) {
  const { fields: e } = foundry.data, t = {
    abilities: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
      initial: Object.keys(CONFIG.A5E.abilities)
    }),
    skills: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
      initial: Object.keys(CONFIG.A5E.skills)
    })
  };
  return i === "grant" && (t.default = new e.BooleanField({ required: !0, initial: !0 })), t;
}
u(X9, "getInitiativeBonusContext");
function J9(i) {
  const { fields: e } = foundry.data, t = {
    // @ts-expect-error
    isHover: new e.BooleanField({ required: !0, initial: !1 })
    // valueIfOriginalIsZero: new fields.StringField({ required: true, initial: '' })
  };
  return i === "bonus" && (t.movementTypes = new e.ArrayField(
    new e.StringField({ required: !0, initial: "" }),
    { initial: [] }
  )), t;
}
u(J9, "getMovementBonusContext");
function Z9(i) {
  const { fields: e } = foundry.data, t = {
    // @ts-expect-error
    otherwiseBlind: new e.BooleanField({ required: !0, initial: !1 })
    // valueIfOriginalIsZero: new fields.StringField({ required: true, initial: '' })
  };
  return i === "bonus" && (t.senses = new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
    initial: []
  })), t;
}
u(Z9, "getSensesBonusContext");
function Q9(i) {
  const { fields: e } = foundry.data, t = {
    // @ts-expect-error
    passiveOnly: new e.BooleanField({ required: !0, initial: !1 }),
    // @ts-expect-error
    requiresProficiency: new e.BooleanField({ required: !0, initial: !1 })
  };
  return i === "bonus" && (t.skills = new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
    initial: []
  })), i === "grant" && (t.default = new e.BooleanField({ required: !0, initial: !0 })), t;
}
u(Q9, "getSkillBonusContext");
var oh, ah, E5;
const n2 = class n2 extends Is {
  constructor() {
    super(...arguments);
    x(this, oh, mo);
    x(this, ah, Fi);
    x(this, E5, "ability");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "ability" }),
      abilities: new t.SchemaField({
        base: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        options: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(U9("grant")),
      label: new t.StringField({ required: !0, initial: "New Ability Grant" })
    });
  }
  getApplyData(t, s) {
    var a, c;
    if (!t) return {};
    const n = (s == null ? void 0 : s.selected) ?? this.abilities.base ?? [], l = foundry.utils.randomID(), r = {
      context: {
        abilities: n,
        ...this.context
      },
      formula: this.bonus,
      label: this.label || ((a = this.parent) == null ? void 0 : a.name) || "Ability Grant",
      default: this.context.default ?? !0,
      img: this.img || ((c = this == null ? void 0 : this.parent) == null ? void 0 : c.img)
    };
    delete r.context.default;
    const o = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: l,
      type: "abilities",
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.abilities.${l}`]: r,
      "system.grants": {
        ...t.system.grants,
        [this._id]: o
      }
    };
  }
  getSelectionComponent() {
    return P(this, oh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.abilities.base,
      bonus: this.bonus,
      choices: this.abilities.options,
      configObject: CONFIG.A5E.abilities,
      count: this.abilities.total,
      heading: "Ability Grant Selection",
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.abilities.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: "abilities"
    };
    super.configureGrant("Configure Ability Grant", t, P(this, ah), {
      width: 400
    });
  }
};
oh = new WeakMap(), ah = new WeakMap(), E5 = new WeakMap(), u(n2, "AbilityGrant");
let Xb = n2;
var ch, uh, S5;
const i2 = class i2 extends Is {
  constructor() {
    super(...arguments);
    x(this, ch, mo);
    x(this, uh, Fi);
    x(this, S5, "attack");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "attack" }),
      attackTypes: new t.SchemaField({
        base: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        options: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(V9("grant")),
      label: new t.StringField({ required: !0, initial: "New Attack Grant" })
    });
  }
  getApplyData(t, s) {
    var a, c;
    if (!t) return {};
    const n = (s == null ? void 0 : s.selected) ?? this.attackTypes.base ?? [], l = foundry.utils.randomID(), r = {
      context: {
        attackTypes: n,
        ...this.context
      },
      formula: this.bonus,
      label: this.label || ((a = this.parent) == null ? void 0 : a.name) || "Attack Grant",
      default: this.context.default ?? !0,
      img: this.img || ((c = this == null ? void 0 : this.parent) == null ? void 0 : c.img)
    };
    delete r.context.default;
    const o = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: l,
      type: "attacks",
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.attacks.${l}`]: r,
      "system.grants": {
        ...t.system.grants,
        [this._id]: o
      }
    };
  }
  getSelectionComponent() {
    return P(this, ch);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.attackTypes.base ?? [],
      bonus: this.bonus,
      choices: this.attackTypes.options,
      configObject: CONFIG.A5E.attackTypes,
      count: this.attackTypes.total,
      heading: "Attack Grant Selection",
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.attackTypes.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: "attacks"
    };
    super.configureGrant("Configure Attack Grant", t, P(this, uh), {
      width: 400
    });
  }
};
ch = new WeakMap(), uh = new WeakMap(), S5 = new WeakMap(), u(i2, "AttackGrant");
let Jb = i2;
var fh, dh;
const l2 = class l2 extends Is {
  constructor() {
    super(...arguments);
    x(this, fh, Fi);
    x(this, dh, "damage");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "damage" }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      damageType: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(W9("grant")),
      label: new t.StringField({ required: !0, initial: "New Damage Grant" })
    });
  }
  getApplyData(t) {
    var r, o;
    if (!t) return {};
    const s = foundry.utils.randomID(), n = {
      context: this.context,
      formula: this.bonus,
      label: this.label || ((r = this.parent) == null ? void 0 : r.name) || "Damage Grant",
      default: this.context.default ?? !0,
      img: this.img || ((o = this == null ? void 0 : this.parent) == null ? void 0 : o.img)
    };
    delete n.context.default;
    const l = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: s,
      type: "damage",
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.damage.${s}`]: n,
      "system.grants": {
        ...t.system.grants,
        [this._id]: l
      }
    };
  }
  getSelectionComponent() {
    return null;
  }
  getSelectionComponentProps() {
    return null;
  }
  requiresConfig() {
    return !1;
  }
  async configureGrant() {
    const t = {
      document: this.parent,
      grantId: this._id,
      grantType: P(this, dh)
    };
    super.configureGrant("Configure Damage Grant", t, P(this, fh), {
      width: 500
    });
  }
};
fh = new WeakMap(), dh = new WeakMap(), u(l2, "DamageGrant");
let Zb = l2;
function zY(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [UY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, grant*/
      16385 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(zY, "create_else_block$G");
function HY(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "Exertion Pool Type",
      options: Object.entries(
        /*exertionPoolTypes*/
        i[6]
      ),
      selected: (
        /*grant*/
        i[0].poolType
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[12]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*grant*/
      1 && (l.selected = /*grant*/
      s[0].poolType), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(HY, "create_if_block$24");
function UY(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*grant*/
      i[0].bonus ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[13]
      ), s = !0);
    },
    p(l, r) {
      r & /*grant*/
      1 && t !== (t = /*grant*/
      l[0].bonus ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(UY, "create_default_slot_1$19");
function VY(i) {
  let e, t, s, n, l, r;
  e = new Ke({
    props: {
      heading: "Exertion Bonus Mode",
      options: [["bonus", "Bonus"], ["pool", "Pool"]],
      selected: (
        /*exertionType*/
        i[2]
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[11]
  );
  const o = [HY, zY], a = [];
  function c(f, d) {
    return (
      /*exertionType*/
      f[2] === "pool" ? 0 : 1
    );
  }
  return u(c, "select_block_type"), s = c(i), n = a[s] = o[s](i), {
    c() {
      j(e.$$.fragment), t = F(), n.c(), l = $e();
    },
    m(f, d) {
      R(e, f, d), T(f, t, d), a[s].m(f, d), T(f, l, d), r = !0;
    },
    p(f, d) {
      const p = {};
      d & /*exertionType*/
      4 && (p.selected = /*exertionType*/
      f[2]), e.$set(p);
      let m = s;
      s = c(f), s === m ? a[s].p(f, d) : (ae(), O(a[m], 1, 1, () => {
        a[m] = null;
      }), ce(), n = a[s], n ? n.p(f, d) : (n = a[s] = o[s](f), n.c()), w(n, 1), n.m(l.parentNode, l));
    },
    i(f) {
      r || (w(e.$$.fragment, f), w(n), r = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(n), r = !1;
    },
    d(f) {
      f && (C(t), C(l)), N(e, f), a[s].d(f);
    }
  };
}
u(VY, "create_default_slot$1Z");
function WY(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y;
  return d = new De({
    props: {
      heading: "Exertion Bonus Configuration",
      $$slots: { default: [VY] },
      $$scope: { ctx: i }
    }
  }), g = new Mi({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), j(g.$$.fragment), b(s, "class", "grant-image svelte-18b23t6"), ze(s.src, n = /*grant*/
      i[0].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[0].label ?? "", b(a, "class", "grant-name svelte-18b23t6"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-18b23t6"), b(t, "class", "sheet-header svelte-18b23t6"), G(p, "display", "contents"), G(p, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-18b23t6");
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), R(g, e, null), h = !0, _ || (y = [
        W(
          s,
          "click",
          /*updateImage*/
          i[3]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[10]
        )
      ], _ = !0);
    },
    p(v, [k]) {
      (!h || k & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      v[0].img || /*$item*/
      v[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!h || k & /*grant*/
      1 && l !== (l = /*grant*/
      v[0].label)) && b(s, "alt", l), (!h || k & /*grant*/
      1 && c !== (c = /*grant*/
      v[0].label ?? "") && a.value !== c) && (a.value = c);
      const S = {};
      k & /*$$scope, grant, exertionType*/
      16389 && (S.$$scope = { dirty: k, ctx: v }), d.$set(S);
    },
    i(v) {
      h || (w(d.$$.fragment, v), w(g.$$.fragment, v), h = !0);
    },
    o(v) {
      O(d.$$.fragment, v), O(g.$$.fragment, v), h = !1;
    },
    d(v) {
      v && C(e), N(d), N(g), _ = !1, Me(y);
    }
  };
}
u(WY, "create_fragment$3U");
function KY(i, e, t) {
  let s, n, l, { document: r, grantId: o, grantType: a } = de("#external").application, { document: c = r, grantId: f = o, grantType: d = a } = e;
  function p() {
    const S = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: S,
      callback: /* @__PURE__ */ u((I) => {
        m("img", I);
      }, "callback")
    }).browse();
  }
  u(p, "updateImage");
  function m(S, D) {
    S = `system.grants.${f}.${S}`, te(l, S, D);
  }
  u(m, "onUpdateValue"), Qt(() => {
    g.destroy();
  });
  const g = new Zt(c);
  pe(i, g, (S) => t(1, l = S));
  const { exertionPoolTypes: h } = CONFIG.A5E;
  lt("item", g), lt("grantId", f), lt("grantType", d);
  const _ = /* @__PURE__ */ u(({ target: S }) => m("label", S.value), "change_handler"), y = /* @__PURE__ */ u(({ detail: S }) => m("exertionType", S), "updateSelection_handler"), v = /* @__PURE__ */ u(({ detail: S }) => m("poolType", S), "updateSelection_handler_1"), k = /* @__PURE__ */ u(({ target: S }) => m("bonus", S.value), "change_handler_1");
  return i.$$set = (S) => {
    "document" in S && t(7, c = S.document), "grantId" in S && t(8, f = S.grantId), "grantType" in S && t(9, d = S.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    258 && t(0, s = l.system.grants[f]), i.$$.dirty & /*grant*/
    1 && t(2, n = s == null ? void 0 : s.exertionType);
  }, [
    s,
    l,
    n,
    p,
    m,
    g,
    h,
    c,
    f,
    d,
    _,
    y,
    v,
    k
  ];
}
u(KY, "instance$3L");
const r2 = class r2 extends re {
  constructor(e) {
    super(), oe(this, e, KY, WY, le, { document: 7, grantId: 8, grantType: 9 });
  }
};
u(r2, "ExertionGrantConfig");
let Qb = r2;
var C5, ph, Mf;
const o2 = class o2 extends Is {
  constructor() {
    super(...arguments);
    x(this, C5, null);
    x(this, ph, Qb);
    x(this, Mf, "exertion");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "exertion" }),
      exertionType: new t.StringField({
        required: !0,
        initial: "bonus",
        choices: ["bonus", "pool"]
      }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      poolType: new t.StringField({
        required: !0,
        initial: "none",
        choices: ["none", "prof", "doubleProf"]
      }),
      label: new t.StringField({ required: !0, initial: "New Exertion Grant" })
    });
  }
  getApplyData(t) {
    var r, o;
    if (!t) return {};
    const s = {}, n = foundry.utils.randomID();
    if (this.exertionType === "bonus") {
      const a = {
        formula: this.bonus,
        label: this.label || ((r = this.parent) == null ? void 0 : r.name) || "Exertion Grant",
        img: this.img || ((o = this == null ? void 0 : this.parent) == null ? void 0 : o.img)
      };
      s[`system.bonuses.exertion.${n}`] = a;
    }
    const l = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      exertionData: {
        exertionType: this.exertionType,
        bonusId: this.exertionType === "bonus" ? n : void 0,
        poolType: this.poolType
      },
      grantType: P(this, Mf),
      level: this.level
    };
    return s["system.grants"] = {
      ...t.system.grants,
      [this._id]: l
    }, s;
  }
  getSelectionComponent() {
    return null;
  }
  getSelectionComponentProps() {
    return null;
  }
  requiresConfig() {
    return !1;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: P(this, Mf)
    };
    super.configureGrant("Configure Exertion Grant", t, P(this, ph), {
      width: 400
    });
  }
};
C5 = new WeakMap(), ph = new WeakMap(), Mf = new WeakMap(), u(o2, "ExertionGrant");
let xb = o2;
function YD(i) {
  var o, a, c, f, d, p, m, g, h, _;
  let e, t, s, n, l, r;
  return e = new tt({
    props: {
      heading: "Base Options",
      options: (
        /*configObject*/
        (o = i[6][
          /*expertiseType*/
          i[2]
        ]) == null ? void 0 : o.options
      ),
      selected: (
        /*grant*/
        (c = (a = i[0]) == null ? void 0 : a.keys) == null ? void 0 : c.base
      ),
      showToggleAllButton: !0,
      disabledOptions: (
        /*grant*/
        (d = (f = i[0]) == null ? void 0 : f.keys) == null ? void 0 : d.options
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), s = new tt({
    props: {
      heading: "Optional Choices",
      options: (
        /*configObject*/
        (p = i[6][
          /*expertiseType*/
          i[2]
        ]) == null ? void 0 : p.options
      ),
      selected: (
        /*grant*/
        (g = (m = i[0]) == null ? void 0 : m.keys) == null ? void 0 : g.options
      ),
      disabledOptions: (
        /*grant*/
        (_ = (h = i[0]) == null ? void 0 : h.keys) == null ? void 0 : _.base
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[14]
  ), l = new ie({
    props: {
      heading: "Selectable Options Count",
      $$slots: { default: [YY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(y, v) {
      R(e, y, v), T(y, t, v), R(s, y, v), T(y, n, v), R(l, y, v), r = !0;
    },
    p(y, v) {
      var I, M, L, B, z, q, U, H, V, Y;
      const k = {};
      v & /*expertiseType*/
      4 && (k.options = /*configObject*/
      (I = y[6][
        /*expertiseType*/
        y[2]
      ]) == null ? void 0 : I.options), v & /*grant*/
      1 && (k.selected = /*grant*/
      (L = (M = y[0]) == null ? void 0 : M.keys) == null ? void 0 : L.base), v & /*grant*/
      1 && (k.disabledOptions = /*grant*/
      (z = (B = y[0]) == null ? void 0 : B.keys) == null ? void 0 : z.options), e.$set(k);
      const S = {};
      v & /*expertiseType*/
      4 && (S.options = /*configObject*/
      (q = y[6][
        /*expertiseType*/
        y[2]
      ]) == null ? void 0 : q.options), v & /*grant*/
      1 && (S.selected = /*grant*/
      (H = (U = y[0]) == null ? void 0 : U.keys) == null ? void 0 : H.options), v & /*grant*/
      1 && (S.disabledOptions = /*grant*/
      (Y = (V = y[0]) == null ? void 0 : V.keys) == null ? void 0 : Y.base), s.$set(S);
      const D = {};
      v & /*$$scope, grant*/
      131073 && (D.$$scope = { dirty: v, ctx: y }), l.$set(D);
    },
    i(y) {
      r || (w(e.$$.fragment, y), w(s.$$.fragment, y), w(l.$$.fragment, y), r = !0);
    },
    o(y) {
      O(e.$$.fragment, y), O(s.$$.fragment, y), O(l.$$.fragment, y), r = !1;
    },
    d(y) {
      y && (C(t), C(n)), N(e, y), N(s, y), N(l, y);
    }
  };
}
u(YD, "create_if_block$23");
function YY(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      ((r = (l = i[0]) == null ? void 0 : l.keys) == null ? void 0 : r.total) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r & /*grant*/
      1 && t !== (t = /*grant*/
      ((a = (o = l[0]) == null ? void 0 : o.keys) == null ? void 0 : a.total) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(YY, "create_default_slot_1$18");
function XY(i) {
  var o, a, c;
  let e, t, s, n, l;
  e = new Ke({
    props: {
      heading: "Expertise Type",
      options: Object.entries(
        /*configObject*/
        i[6]
      ).map(ZY),
      selected: (
        /*expertiseType*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  );
  let r = (
    /*configObject*/
    ((a = (o = i[6][
      /*expertiseType*/
      i[2]
    ]) == null ? void 0 : o.options) == null ? void 0 : a.length) && YD(i)
  );
  return n = new Ke({
    props: {
      heading: "Expertise Die Size",
      options: (
        /*expertiseDiceOptions*/
        i[7]
      ),
      selected: (
        /*grant*/
        ((c = i[0]) == null ? void 0 : c.expertiseCount) ?? 1
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment), t = F(), r && r.c(), s = F(), j(n.$$.fragment);
    },
    m(f, d) {
      R(e, f, d), T(f, t, d), r && r.m(f, d), T(f, s, d), R(n, f, d), l = !0;
    },
    p(f, d) {
      var g, h, _;
      const p = {};
      d & /*expertiseType*/
      4 && (p.selected = /*expertiseType*/
      f[2]), e.$set(p), /*configObject*/
      (h = (g = f[6][
        /*expertiseType*/
        f[2]
      ]) == null ? void 0 : g.options) != null && h.length ? r ? (r.p(f, d), d & /*expertiseType*/
      4 && w(r, 1)) : (r = YD(f), r.c(), w(r, 1), r.m(s.parentNode, s)) : r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce());
      const m = {};
      d & /*grant*/
      1 && (m.selected = /*grant*/
      ((_ = f[0]) == null ? void 0 : _.expertiseCount) ?? 1), n.$set(m);
    },
    i(f) {
      l || (w(e.$$.fragment, f), w(r), w(n.$$.fragment, f), l = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(r), O(n.$$.fragment, f), l = !1;
    },
    d(f) {
      f && (C(t), C(s)), N(e, f), r && r.d(f), N(n, f);
    }
  };
}
u(XY, "create_default_slot$1Y");
function JY(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y;
  return d = new De({
    props: {
      heading: "Expertise Configuration",
      $$slots: { default: [XY] },
      $$scope: { ctx: i }
    }
  }), g = new Mi({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), j(g.$$.fragment), b(s, "class", "grant-image svelte-18b23t6"), ze(s.src, n = /*grant*/
      i[0].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[0].label ?? "", b(a, "class", "grant-name svelte-18b23t6"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-18b23t6"), b(t, "class", "sheet-header svelte-18b23t6"), G(p, "display", "contents"), G(p, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-18b23t6");
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), R(g, e, null), h = !0, _ || (y = [
        W(
          s,
          "click",
          /*updateImage*/
          i[3]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[11]
        )
      ], _ = !0);
    },
    p(v, [k]) {
      (!h || k & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      v[0].img || /*$item*/
      v[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!h || k & /*grant*/
      1 && l !== (l = /*grant*/
      v[0].label)) && b(s, "alt", l), (!h || k & /*grant*/
      1 && c !== (c = /*grant*/
      v[0].label ?? "") && a.value !== c) && (a.value = c);
      const S = {};
      k & /*$$scope, grant, expertiseType*/
      131077 && (S.$$scope = { dirty: k, ctx: v }), d.$set(S);
    },
    i(v) {
      h || (w(d.$$.fragment, v), w(g.$$.fragment, v), h = !0);
    },
    o(v) {
      O(d.$$.fragment, v), O(g.$$.fragment, v), h = !1;
    },
    d(v) {
      v && C(e), N(d), N(g), _ = !1, Me(y);
    }
  };
}
u(JY, "create_fragment$3T");
const ZY = /* @__PURE__ */ u(([i, { label: e }]) => [i, e], "func$7");
function QY(i, e, t) {
  let s, n, l, { document: r, grantId: o, grantType: a } = de("#external").application, { document: c = r, grantId: f = o, grantType: d = a } = e;
  function p() {
    const M = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: M,
      callback: /* @__PURE__ */ u((B) => {
        m("img", B);
      }, "callback")
    }).browse();
  }
  u(p, "updateImage");
  function m(M, L) {
    M === "expertiseType" && te(l, `system.grants.${f}.keys`, { base: [], options: [], total: 0 }), M = `system.grants.${f}.${M}`, te(l, M, L);
  }
  u(m, "onUpdateValue"), Qt(() => {
    g.destroy();
  });
  const g = new Zt(c);
  pe(i, g, (M) => t(1, l = M));
  const h = {
    abilityCheck: {
      label: "A5E.AbilityCheck",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    abilitySave: {
      label: "A5E.SavingThrow",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    attack: {
      label: "A5E.ActionOptionAttack",
      options: Object.entries(CONFIG.A5E.attackTypes)
    },
    initiative: { label: "A5E.Initiative", options: [] },
    skill: {
      label: "A5E.Skill",
      options: Object.entries(CONFIG.A5E.skills)
    }
  }, _ = E9();
  lt("item", g), lt("grantId", f), lt("grantType", d);
  const y = /* @__PURE__ */ u(({ target: M }) => m("label", M.value), "change_handler"), v = /* @__PURE__ */ u(({ detail: M }) => {
    m("expertiseType", M);
  }, "updateSelection_handler"), k = /* @__PURE__ */ u(({ detail: M }) => {
    m("keys.base", M);
  }, "updateSelection_handler_1"), S = /* @__PURE__ */ u(({ detail: M }) => {
    m("keys.options", M);
  }, "updateSelection_handler_2"), D = /* @__PURE__ */ u(({ target: M }) => m("keys.total", Number(M.value)), "change_handler_1"), I = /* @__PURE__ */ u(({ detail: M }) => {
    m("expertiseCount", M);
  }, "updateSelection_handler_3");
  return i.$$set = (M) => {
    "document" in M && t(8, c = M.document), "grantId" in M && t(9, f = M.grantId), "grantType" in M && t(10, d = M.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    514 && t(0, s = l.system.grants[f]), i.$$.dirty & /*grant*/
    1 && t(2, n = (s == null ? void 0 : s.expertiseType) || "abilityCheck");
  }, [
    s,
    l,
    n,
    p,
    m,
    g,
    h,
    _,
    c,
    f,
    d,
    y,
    v,
    k,
    S,
    D,
    I
  ];
}
u(QY, "instance$3K");
const a2 = class a2 extends re {
  constructor(e) {
    super(), oe(this, e, QY, JY, le, { document: 8, grantId: 9, grantType: 10 });
  }
};
u(a2, "ExpertiseDiceGrantConfig");
let e_ = a2;
function xY(i) {
  let e, t;
  return e = new tt({
    props: {
      options: (
        /*getOptions*/
        i[8](
          /*choicesLocked*/
          i[4]
        )
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[2]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*choicesLocked*/
      16 && (l.options = /*getOptions*/
      s[8](
        /*choicesLocked*/
        s[4]
      )), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      4 && (l.orange = /*choices*/
      s[2]), n & /*selected, totalCount*/
      9 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(xY, "create_default_slot_2$R");
function eX(i) {
  let e;
  return {
    c() {
      e = Q(
        /*summary*/
        i[5]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      32 && be(
        e,
        /*summary*/
        t[5]
      );
    },
    d(t) {
      t && C(e);
    }
  };
}
u(eX, "create_default_slot_1$17");
function tX(i) {
  let e, t, s, n, l;
  return e = new ie({
    props: {
      warning: (
        /*remainingSelections*/
        i[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[6]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[3]
      ),
      $$slots: { default: [xY] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      $$slots: { default: [eX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), T(r, s, o), R(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*remainingSelections*/
      64 && (a.warning = /*remainingSelections*/
      r[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      r[6]} choices remaining.`), o & /*selected, totalCount*/
      9 && (a.showWarning = /*selected*/
      r[0].length < /*totalCount*/
      r[3]), o & /*$$scope, choicesLocked, selected, choices, totalCount*/
      65565 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, summary*/
      65568 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(s), r && e && C(t), N(e, r), N(n, r);
    }
  };
}
u(tX, "create_default_slot$1X");
function sX(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Expertise Dice Grant - " + /*grant*/
      i[1].label,
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*func*/
            i[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [tX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*grant*/
      2 && (r.heading = "Expertise Dice Grant - " + /*grant*/
      n[1].label), l & /*choicesLocked*/
      16 && (r.headerButtons = [
        {
          classes: "add-button",
          handler: (
            /*func*/
            n[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          n[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            n[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), l & /*$$scope, summary, remainingSelections, selected, totalCount, choicesLocked, choices*/
      65661 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(sX, "create_fragment$3S");
function nX(i, e, t) {
  let s, n, l, { grant: r } = e, { base: o } = e, { choices: a } = e, { count: c } = e, { expertiseType: f } = e, { selected: d } = e;
  function p(k) {
    return "";
  }
  u(p, "getGrantSummary");
  function m({ detail: k }) {
    t(0, d = k), h("updateSelection", { selected: d, summary: l });
  }
  u(m, "onUpdateSelection");
  function g(k) {
    var D, I;
    if (!k) return ((D = _[f]) == null ? void 0 : D.options) ?? [];
    const S = [];
    for (const [M, L] of ((I = _[f]) == null ? void 0 : I.options) ?? [])
      a.includes(M) && S.push([M, L]);
    return S;
  }
  u(g, "getOptions");
  const h = ft(), _ = {
    abilityCheck: {
      label: "A5E.AbilityCheck",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    abilitySave: {
      label: "A5E.SavingThrow",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    attack: {
      label: "A5E.ActionOptionAttack",
      options: Object.entries(CONFIG.A5E.attackTypes)
    },
    initiative: { label: "A5E.Initiative", options: [] },
    skill: {
      label: "A5E.Skill",
      options: Object.entries(CONFIG.A5E.skills)
    }
  };
  let y = !0;
  const v = /* @__PURE__ */ u(() => t(4, y = !y), "func");
  return i.$$set = (k) => {
    "grant" in k && t(1, r = k.grant), "base" in k && t(9, o = k.base), "choices" in k && t(2, a = k.choices), "count" in k && t(10, c = k.count), "expertiseType" in k && t(11, f = k.expertiseType), "selected" in k && t(0, d = k.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    513 && t(0, d = [...new Set(o.concat(d))]), i.$$.dirty & /*base, count*/
    1536 && t(3, s = o.length + c), i.$$.dirty & /*totalCount, selected*/
    9 && t(6, n = s - d.length), i.$$.dirty & /*selected*/
    1 && t(5, l = p());
  }, [
    d,
    r,
    a,
    s,
    y,
    l,
    n,
    m,
    g,
    o,
    c,
    f,
    v
  ];
}
u(nX, "instance$3J");
const c2 = class c2 extends re {
  constructor(e) {
    super(), oe(this, e, nX, sX, le, {
      grant: 1,
      base: 9,
      choices: 2,
      count: 10,
      expertiseType: 11,
      selected: 0
    });
  }
};
u(c2, "ExpertiseDiceSelectionDialog");
let t_ = c2;
var mh, hh, gh;
const u2 = class u2 extends Is {
  constructor() {
    super(...arguments);
    x(this, mh, t_);
    x(this, hh, e_);
    x(this, gh, "expertiseDice");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "expertiseDice" }),
      keys: new t.SchemaField({
        base: new t.ArrayField(new t.StringField({ nullable: !1, initial: "" }), {
          required: !0,
          initial: []
        }),
        options: new t.ArrayField(new t.StringField({ nullable: !1, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new t.NumberField({ nullable: !1, initial: 0, integer: !0 })
      }),
      expertiseCount: new t.NumberField({ nullable: !1, initial: 1, integer: !0 }),
      expertiseType: new t.StringField({ required: !1, initial: "abilityCheck" }),
      label: new t.StringField({ required: !0, initial: "New Expertise Dice Grant" })
    });
  }
  getApplyData(t, s) {
    if (!t) return {};
    const n = (s == null ? void 0 : s.selected) ?? this.keys.base ?? [], l = this.keys.total, r = {}, o = {
      expertiseDiceData: {
        keys: n,
        total: l,
        expertiseType: this.expertiseType,
        expertiseCount: this.expertiseCount
      },
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: P(this, gh),
      level: this.level
    };
    return r["system.grants"] = {
      ...t.system.grants,
      [this._id]: o
    }, r;
  }
  getSelectionComponent() {
    return P(this, mh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.keys.base ?? [],
      choices: this.keys.options,
      count: this.keys.total,
      expertiseType: this.expertiseType,
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return !!this.keys.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: "expertiseDice"
    };
    super.configureGrant("Configure Expertise Grant", t, P(this, hh), {
      width: 400
    });
  }
};
mh = new WeakMap(), hh = new WeakMap(), gh = new WeakMap(), u(u2, "ExpertiseDiceGrant");
let s_ = u2;
function iX(i) {
  let e, t;
  return e = new tt({
    props: {
      options: (
        /*getOptions*/
        i[8](
          /*choicesLocked*/
          i[4]
        )
      ),
      selected: (
        /*selectedOptions*/
        i[2]
      ),
      orange: (
        /*choices*/
        i[1].map(XD)
      ),
      disabled: (
        /*selectedOptions*/
        i[2].length >= /*totalCount*/
        i[3]
      ),
      disabledOptions: (
        /*disabledOptions*/
        i[9]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*choicesLocked*/
      16 && (l.options = /*getOptions*/
      s[8](
        /*choicesLocked*/
        s[4]
      )), n & /*selectedOptions*/
      4 && (l.selected = /*selectedOptions*/
      s[2]), n & /*choices*/
      2 && (l.orange = /*choices*/
      s[1].map(XD)), n & /*selectedOptions, totalCount*/
      12 && (l.disabled = /*selectedOptions*/
      s[2].length >= /*totalCount*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(iX, "create_default_slot_2$Q");
function lX(i) {
  let e;
  return {
    c() {
      e = Q(
        /*summary*/
        i[5]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      32 && be(
        e,
        /*summary*/
        t[5]
      );
    },
    d(t) {
      t && C(e);
    }
  };
}
u(lX, "create_default_slot_1$16");
function rX(i) {
  let e, t, s, n, l;
  return e = new ie({
    props: {
      warning: (
        /*remainingSelections*/
        i[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[6]} choices remaining.`
      ),
      showWarning: (
        /*selectedOptions*/
        i[2].length < /*totalCount*/
        i[3]
      ),
      $$slots: { default: [iX] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      $$slots: { default: [lX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), T(r, s, o), R(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*remainingSelections*/
      64 && (a.warning = /*remainingSelections*/
      r[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      r[6]} choices remaining.`), o & /*selectedOptions, totalCount*/
      12 && (a.showWarning = /*selectedOptions*/
      r[2].length < /*totalCount*/
      r[3]), o & /*$$scope, choicesLocked, selectedOptions, choices, totalCount*/
      4194334 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, summary*/
      4194336 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(s), r && e && C(t), N(e, r), N(n, r);
    }
  };
}
u(rX, "create_default_slot$1W");
function oX(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Feature Grant - " + /*grant*/
      i[0].label,
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*func_1*/
            i[13]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [rX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*grant*/
      1 && (r.heading = "Feature Grant - " + /*grant*/
      n[0].label), l & /*choicesLocked*/
      16 && (r.headerButtons = [
        {
          classes: "add-button",
          handler: (
            /*func_1*/
            n[13]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          n[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            n[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), l & /*$$scope, summary, remainingSelections, selectedOptions, totalCount, choicesLocked, choices*/
      4194430 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(oX, "create_fragment$3R");
function aX(i) {
  return "";
}
u(aX, "getGrantSummary");
const XD = /* @__PURE__ */ u((i) => i.uuid, "func$6");
function cX(i, e, t) {
  let s, n, l, r, { grant: o } = e, { base: a } = e, { choices: c } = e, { count: f } = e, { selected: d } = e;
  const p = ft(), m = de("actor");
  function g({ detail: B }) {
    t(2, s = B), p("updateSelection", { uuids: s, summary: r });
  }
  u(g, "onUpdateSelection");
  function h() {
    const B = [];
    return [...m.grants.grantedFeatureDocuments.entries()].forEach(([z, q]) => {
      const U = k.get(z);
      if (!U) return B.push(z);
      const H = q.length;
      !U.limitedReselection || U.selectionLimit > H || B.push(z);
    }), new Set(B);
  }
  u(h, "getExistingSelections");
  function _() {
    const B = [];
    for (const [z] of v) {
      const q = z.split(".").pop();
      I.has(q || "") && B.push(z);
    }
    return B;
  }
  u(_, "getDisabledOptions");
  function y(B) {
    if (!B) return v;
    const z = [];
    for (const [q, U] of v) {
      const H = q.split(".").pop(), V = I.has(H || "");
      S.includes(q) && !V && z.push([q, U]);
    }
    return z;
  }
  u(y, "getOptions");
  const v = [...a, ...c].map((B) => {
    const z = fromUuidSync(B.uuid);
    return [B.uuid, z.name];
  }), k = a.concat(c).reduce(
    (B, z) => {
      const q = z.uuid.split(".").pop();
      return q && B.set(q, z), B;
    },
    /* @__PURE__ */ new Map()
  ), S = c.map((B) => B.uuid);
  let D = !0, I = h(), M = _();
  const L = /* @__PURE__ */ u(() => t(4, D = !D), "func_1");
  return i.$$set = (B) => {
    "grant" in B && t(0, o = B.grant), "base" in B && t(10, a = B.base), "choices" in B && t(1, c = B.choices), "count" in B && t(11, f = B.count), "selected" in B && t(12, d = B.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    5120 && t(2, s = [...new Set(a.map((B) => B.uuid).concat(d))]), i.$$.dirty & /*base, count*/
    3072 && t(3, n = a.length + f), i.$$.dirty & /*totalCount, selectedOptions*/
    12 && t(6, l = n - s.length), i.$$.dirty & /*selectedOptions*/
    4 && t(5, r = aX());
  }, [
    o,
    c,
    s,
    n,
    D,
    r,
    l,
    g,
    y,
    M,
    a,
    f,
    d,
    L
  ];
}
u(cX, "instance$3I");
const f2 = class f2 extends re {
  constructor(e) {
    super(), oe(this, e, cX, oX, le, {
      grant: 0,
      base: 10,
      choices: 1,
      count: 11,
      selected: 12
    });
  }
};
u(f2, "FeatureGrantSelectionDialog");
let n_ = f2;
function uX(i) {
  let e, t, s;
  return {
    c() {
      e = E("div"), e.innerHTML = '<i class="drop-icon fa-sold fa-plus svelte-3t0g8e"></i>', b(e, "class", "drop-area svelte-3t0g8e");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(e, "drop", Ve(st(
        /*onDrop*/
        i[0]
      ))), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(uX, "create_default_slot$1V");
function fX(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [uX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*$$scope*/
      16 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(fX, "create_fragment$3Q");
function dX(i, e, t) {
  let { type: s = "" } = e, { documentType: n = "" } = e;
  function l(o) {
    if (s || r("document-dropped", o), s === "uuid")
      try {
        const a = o.dataTransfer;
        if (!a) return;
        const { uuid: c, type: f } = JSON.parse(a.getData("text/plain"));
        if (f !== n) return;
        r("document-dropped", { dragEvent: o, uuid: c });
      } catch (a) {
        console.error(a);
      }
  }
  u(l, "onDrop");
  const r = ft();
  return i.$$set = (o) => {
    "type" in o && t(1, s = o.type), "documentType" in o && t(2, n = o.documentType);
  }, [l, s, n];
}
u(dX, "instance$3H");
const d2 = class d2 extends re {
  constructor(e) {
    super(), oe(this, e, dX, fX, le, { type: 1, documentType: 2 });
  }
};
u(d2, "DropArea");
let ho = d2;
function JD(i, e, t) {
  const s = i.slice();
  return s[24] = e[t], s[26] = t, s;
}
u(JD, "get_each_context$1s");
function ZD(i, e, t) {
  const s = i.slice();
  return s[24] = e[t], s[26] = t, s;
}
u(ZD, "get_each_context_1$l");
function QD(i) {
  let e, t, s, n, l, r = ue(
    /*baseFeatures*/
    i[3]
  ), o = [];
  for (let a = 0; a < r.length; a += 1)
    o[a] = xD(ZD(i, r, a));
  return {
    c() {
      e = E("div"), t = E("header"), t.innerHTML = '<span class="feature-table__heading svelte-o96mgs"></span> <span class="feature-table__heading svelte-o96mgs"></span> <span class="feature-table__heading svelte-o96mgs">Limited Reselection</span> <span class="feature-table__heading svelte-o96mgs">Selection Limit</span> <span class="feature-table__heading svelte-o96mgs"></span>', s = F(), n = E("hr"), l = F();
      for (let a = 0; a < o.length; a += 1)
        o[a].c();
      b(t, "class", "feature-table__header svelte-o96mgs"), b(n, "class", "feature-table__rule svelte-o96mgs"), b(e, "class", "feature-table svelte-o96mgs");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, s), A(e, n), A(e, l);
      for (let f = 0; f < o.length; f += 1)
        o[f] && o[f].m(e, null);
    },
    p(a, c) {
      if (c & /*onUpdateValue, baseFeatures, updateFeature, Number, openDocument*/
      104) {
        r = ue(
          /*baseFeatures*/
          a[3]
        );
        let f;
        for (f = 0; f < r.length; f += 1) {
          const d = ZD(a, r, f);
          o[f] ? o[f].p(d, c) : (o[f] = xD(d), o[f].c(), o[f].m(e, null));
        }
        for (; f < o.length; f += 1)
          o[f].d(1);
        o.length = r.length;
      }
    },
    d(a) {
      a && C(e), Le(o, a);
    }
  };
}
u(QD, "create_if_block_2$W");
function pX(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fa-solid fa-infinity");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    d(t) {
      t && C(e);
    }
  };
}
u(pX, "create_else_block_1$7");
function mX(i) {
  let e, t, s, n;
  function l(...r) {
    return (
      /*change_handler_2*/
      i[16](
        /*idx*/
        i[26],
        ...r
      )
    );
  }
  return u(l, "change_handler_2"), {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--slim a5e-input--small"), b(e, "type", "number"), e.value = t = /*feature*/
      i[24].selectionLimit ?? 1;
    },
    m(r, o) {
      T(r, e, o), s || (n = W(e, "change", l), s = !0);
    },
    p(r, o) {
      i = r, o & /*baseFeatures*/
      8 && t !== (t = /*feature*/
      i[24].selectionLimit ?? 1) && e.value !== t && (e.value = t);
    },
    d(r) {
      r && C(e), s = !1, n();
    }
  };
}
u(mX, "create_if_block_3$A");
function xD(i) {
  let e, t, s, n, l, r = (
    /*feature*/
    i[24].name + ""
  ), o, a, c, f, d, p, m, g, h, _;
  function y() {
    return (
      /*click_handler*/
      i[14](
        /*feature*/
        i[24]
      )
    );
  }
  u(y, "click_handler");
  function v(...M) {
    return (
      /*change_handler_1*/
      i[15](
        /*idx*/
        i[26],
        ...M
      )
    );
  }
  u(v, "change_handler_1");
  function k(M, L) {
    return (
      /*feature*/
      M[24].limitedReselection ? mX : pX
    );
  }
  u(k, "select_block_type");
  let S = k(i), D = S(i);
  function I() {
    return (
      /*click_handler_1*/
      i[17](
        /*idx*/
        i[26]
      )
    );
  }
  return u(I, "click_handler_1"), {
    c() {
      e = E("img"), n = F(), l = E("span"), o = Q(r), a = F(), c = E("input"), d = F(), p = E("span"), D.c(), m = F(), g = E("button"), g.innerHTML = '<i class="fa-solid fa-trash"></i> ', b(e, "class", "feature-table__img svelte-o96mgs"), ze(e.src, t = /*feature*/
      i[24].img) || b(e, "src", t), b(e, "alt", s = /*feature*/
      i[24].name), b(l, "class", "feature-table__name svelte-o96mgs"), b(c, "class", "feature-table__limited-reselection svelte-o96mgs"), b(c, "type", "checkbox"), c.checked = f = /*feature*/
      i[24].limitedReselection ?? !0, b(p, "class", "feature-table__selection-limit svelte-o96mgs"), b(g, "class", "feature-table__delete-button svelte-o96mgs");
    },
    m(M, L) {
      T(M, e, L), T(M, n, L), T(M, l, L), A(l, o), T(M, a, L), T(M, c, L), T(M, d, L), T(M, p, L), D.m(p, null), T(M, m, L), T(M, g, L), h || (_ = [
        W(l, "click", y),
        W(c, "change", v),
        W(g, "click", Ve(st(I)))
      ], h = !0);
    },
    p(M, L) {
      i = M, L & /*baseFeatures*/
      8 && !ze(e.src, t = /*feature*/
      i[24].img) && b(e, "src", t), L & /*baseFeatures*/
      8 && s !== (s = /*feature*/
      i[24].name) && b(e, "alt", s), L & /*baseFeatures*/
      8 && r !== (r = /*feature*/
      i[24].name + "") && be(o, r), L & /*baseFeatures*/
      8 && f !== (f = /*feature*/
      i[24].limitedReselection ?? !0) && (c.checked = f), S === (S = k(i)) && D ? D.p(i, L) : (D.d(1), D = S(i), D && (D.c(), D.m(p, null)));
    },
    d(M) {
      M && (C(e), C(n), C(l), C(a), C(c), C(d), C(p), C(m), C(g)), D.d(), h = !1, Me(_);
    }
  };
}
u(xD, "create_each_block_1$l");
function hX(i) {
  let e, t, s, n;
  e = new ho({
    props: { type: "uuid", documentType: "Item" }
  }), e.$on(
    "document-dropped",
    /*document_dropped_handler*/
    i[13]
  );
  let l = (
    /*baseFeatures*/
    i[3].length > 0 && QD(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), l && l.c(), s = $e();
    },
    m(r, o) {
      R(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      /*baseFeatures*/
      r[3].length > 0 ? l ? l.p(r, o) : (l = QD(r), l.c(), l.m(s.parentNode, s)) : l && (l.d(1), l = null);
    },
    i(r) {
      n || (w(e.$$.fragment, r), n = !0);
    },
    o(r) {
      O(e.$$.fragment, r), n = !1;
    },
    d(r) {
      r && (C(t), C(s)), N(e, r), l && l.d(r);
    }
  };
}
u(hX, "create_default_slot_3$B");
function e4(i) {
  let e, t, s, n, l, r = ue(
    /*optionalFeatures*/
    i[2]
  ), o = [];
  for (let a = 0; a < r.length; a += 1)
    o[a] = t4(JD(i, r, a));
  return {
    c() {
      e = E("div"), t = E("header"), t.innerHTML = '<span class="feature-table__heading svelte-o96mgs"></span> <span class="feature-table__heading svelte-o96mgs"></span> <span class="feature-table__heading svelte-o96mgs">Limited Reselection</span> <span class="feature-table__heading svelte-o96mgs">Selection Limit</span> <span class="feature-table__heading svelte-o96mgs"></span>', s = F(), n = E("hr"), l = F();
      for (let a = 0; a < o.length; a += 1)
        o[a].c();
      b(t, "class", "feature-table__header svelte-o96mgs"), b(n, "class", "feature-table__rule svelte-o96mgs"), b(e, "class", "feature-table svelte-o96mgs");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, s), A(e, n), A(e, l);
      for (let f = 0; f < o.length; f += 1)
        o[f] && o[f].m(e, null);
    },
    p(a, c) {
      if (c & /*onUpdateValue, optionalFeatures, updateFeature, Number, openDocument*/
      100) {
        r = ue(
          /*optionalFeatures*/
          a[2]
        );
        let f;
        for (f = 0; f < r.length; f += 1) {
          const d = JD(a, r, f);
          o[f] ? o[f].p(d, c) : (o[f] = t4(d), o[f].c(), o[f].m(e, null));
        }
        for (; f < o.length; f += 1)
          o[f].d(1);
        o.length = r.length;
      }
    },
    d(a) {
      a && C(e), Le(o, a);
    }
  };
}
u(e4, "create_if_block$22");
function gX(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fa-solid fa-infinity");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    d(t) {
      t && C(e);
    }
  };
}
u(gX, "create_else_block$F");
function bX(i) {
  let e, t, s, n;
  function l(...r) {
    return (
      /*change_handler_4*/
      i[21](
        /*idx*/
        i[26],
        ...r
      )
    );
  }
  return u(l, "change_handler_4"), {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--slim a5e-input--small"), b(e, "type", "number"), e.value = t = /*feature*/
      i[24].selectionLimit ?? 1;
    },
    m(r, o) {
      T(r, e, o), s || (n = W(e, "change", l), s = !0);
    },
    p(r, o) {
      i = r, o & /*optionalFeatures*/
      4 && t !== (t = /*feature*/
      i[24].selectionLimit ?? 1) && e.value !== t && (e.value = t);
    },
    d(r) {
      r && C(e), s = !1, n();
    }
  };
}
u(bX, "create_if_block_1$1m");
function t4(i) {
  let e, t, s, n, l, r = (
    /*feature*/
    i[24].name + ""
  ), o, a, c, f, d, p, m, g, h, _;
  function y() {
    return (
      /*click_handler_2*/
      i[19](
        /*feature*/
        i[24]
      )
    );
  }
  u(y, "click_handler_2");
  function v(...M) {
    return (
      /*change_handler_3*/
      i[20](
        /*idx*/
        i[26],
        ...M
      )
    );
  }
  u(v, "change_handler_3");
  function k(M, L) {
    return (
      /*feature*/
      M[24].limitedReselection ? bX : gX
    );
  }
  u(k, "select_block_type_1");
  let S = k(i), D = S(i);
  function I() {
    return (
      /*click_handler_3*/
      i[22](
        /*idx*/
        i[26]
      )
    );
  }
  return u(I, "click_handler_3"), {
    c() {
      e = E("img"), n = F(), l = E("span"), o = Q(r), a = F(), c = E("input"), d = F(), p = E("span"), D.c(), m = F(), g = E("button"), g.innerHTML = '<i class="fa-solid fa-trash"></i> ', b(e, "class", "feature-table__img svelte-o96mgs"), ze(e.src, t = /*feature*/
      i[24].img) || b(e, "src", t), b(e, "alt", s = /*feature*/
      i[24].name), b(l, "class", "feature-table__name svelte-o96mgs"), b(c, "class", "feature-table__limited-reselection svelte-o96mgs"), b(c, "type", "checkbox"), c.checked = f = /*feature*/
      i[24].limitedReselection ?? !0, b(p, "class", "feature-table__selection-limit svelte-o96mgs"), b(g, "class", "feature-table__delete-button svelte-o96mgs");
    },
    m(M, L) {
      T(M, e, L), T(M, n, L), T(M, l, L), A(l, o), T(M, a, L), T(M, c, L), T(M, d, L), T(M, p, L), D.m(p, null), T(M, m, L), T(M, g, L), h || (_ = [
        W(l, "click", y),
        W(c, "change", v),
        W(g, "click", Ve(st(I)))
      ], h = !0);
    },
    p(M, L) {
      i = M, L & /*optionalFeatures*/
      4 && !ze(e.src, t = /*feature*/
      i[24].img) && b(e, "src", t), L & /*optionalFeatures*/
      4 && s !== (s = /*feature*/
      i[24].name) && b(e, "alt", s), L & /*optionalFeatures*/
      4 && r !== (r = /*feature*/
      i[24].name + "") && be(o, r), L & /*optionalFeatures*/
      4 && f !== (f = /*feature*/
      i[24].limitedReselection ?? !0) && (c.checked = f), S === (S = k(i)) && D ? D.p(i, L) : (D.d(1), D = S(i), D && (D.c(), D.m(p, null)));
    },
    d(M) {
      M && (C(e), C(n), C(l), C(a), C(c), C(d), C(p), C(m), C(g)), D.d(), h = !1, Me(_);
    }
  };
}
u(t4, "create_each_block$1s");
function _X(i) {
  let e, t, s, n;
  e = new ho({
    props: { type: "uuid", documentType: "Item" }
  }), e.$on(
    "document-dropped",
    /*document_dropped_handler_1*/
    i[18]
  );
  let l = (
    /*optionalFeatures*/
    i[2].length > 0 && e4(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), l && l.c(), s = $e();
    },
    m(r, o) {
      R(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      /*optionalFeatures*/
      r[2].length > 0 ? l ? l.p(r, o) : (l = e4(r), l.c(), l.m(s.parentNode, s)) : l && (l.d(1), l = null);
    },
    i(r) {
      n || (w(e.$$.fragment, r), n = !0);
    },
    o(r) {
      O(e.$$.fragment, r), n = !1;
    },
    d(r) {
      r && (C(t), C(s)), N(e, r), l && l.d(r);
    }
  };
}
u(_X, "create_default_slot_2$P");
function yX(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      i[0].features.total ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_5*/
        i[23]
      ), s = !0);
    },
    p(l, r) {
      r & /*grant*/
      1 && t !== (t = /*grant*/
      l[0].features.total ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(yX, "create_default_slot_1$15");
function vX(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "Selectable Options Count",
      $$slots: { default: [yX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, grant*/
      268435457 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(vX, "create_default_slot$1U");
function kX(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S;
  return d = new De({
    props: {
      heading: "Base Features",
      $$slots: { default: [hX] },
      $$scope: { ctx: i }
    }
  }), g = new De({
    props: {
      heading: "Optional Features",
      $$slots: { default: [_X] },
      $$scope: { ctx: i }
    }
  }), y = new Mi({
    props: {
      $$slots: { default: [vX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), h = E("div"), j(g.$$.fragment), _ = F(), j(y.$$.fragment), b(s, "class", "grant-image svelte-o96mgs"), ze(s.src, n = /*grant*/
      i[0].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[0].label ?? "", b(a, "class", "grant-name svelte-o96mgs"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-o96mgs"), b(t, "class", "sheet-header svelte-o96mgs"), G(p, "display", "contents"), G(p, "--a5e-section-margin", "0.25rem 0"), G(h, "display", "contents"), G(h, "--a5e-section-margin", "0.25rem 0"), b(e, "class", "svelte-o96mgs");
    },
    m(D, I) {
      T(D, e, I), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), A(e, h), R(g, h, null), A(e, _), R(y, e, null), v = !0, k || (S = [
        W(
          s,
          "click",
          /*updateImage*/
          i[4]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[12]
        )
      ], k = !0);
    },
    p(D, [I]) {
      (!v || I & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      D[0].img || /*$item*/
      D[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!v || I & /*grant*/
      1 && l !== (l = /*grant*/
      D[0].label)) && b(s, "alt", l), (!v || I & /*grant*/
      1 && c !== (c = /*grant*/
      D[0].label ?? "") && a.value !== c) && (a.value = c);
      const M = {};
      I & /*$$scope, baseFeatures*/
      268435464 && (M.$$scope = { dirty: I, ctx: D }), d.$set(M);
      const L = {};
      I & /*$$scope, optionalFeatures*/
      268435460 && (L.$$scope = { dirty: I, ctx: D }), g.$set(L);
      const B = {};
      I & /*$$scope, grant*/
      268435457 && (B.$$scope = { dirty: I, ctx: D }), y.$set(B);
    },
    i(D) {
      v || (w(d.$$.fragment, D), w(g.$$.fragment, D), w(y.$$.fragment, D), v = !0);
    },
    o(D) {
      O(d.$$.fragment, D), O(g.$$.fragment, D), O(y.$$.fragment, D), v = !1;
    },
    d(D) {
      D && C(e), N(d), N(g), N(y), k = !1, Me(S);
    }
  };
}
u(kX, "create_fragment$3P");
async function s4(i) {
  (await fromUuid(i)).sheet.render(!0);
}
u(s4, "openDocument");
function n4(i) {
  return i.map((e) => {
    const t = fromUuidSync(e.uuid);
    return {
      uuid: e.uuid,
      name: (t == null ? void 0 : t.name) || "Unknown Feature",
      img: (t == null ? void 0 : t.img) || "",
      limitedReselection: e.limitedReselection,
      selectionLimit: e.selectionLimit
    };
  });
}
u(n4, "getFeatureData");
function wX(i, e, t) {
  let s, n, l, r, { document: o, grantId: a, grantType: c } = de("#external").application, { document: f = o, grantId: d = a, grantType: p = c } = e;
  function m() {
    const V = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: V,
      callback: /* @__PURE__ */ u((J) => {
        g("img", J);
      }, "callback")
    }).browse();
  }
  u(m, "updateImage");
  function g(V, Y) {
    V = `system.grants.${d}.${V}`, te(r, V, Y);
  }
  u(g, "onUpdateValue");
  function h(V, Y, J, fe) {
    const ke = V === "base" ? n : l, ee = ke[Y];
    ee[J] = fe, g(`features.${V}`, ke);
  }
  u(h, "updateFeature");
  function _(V, Y) {
    const J = fromUuidSync(Y);
    if (!J) return;
    if (J.type !== "feature")
      return ui.notifications.error("Invalid Document - Must be a Feature.");
    const fe = {
      uuid: Y,
      limitedReselection: !0,
      selectionLimit: 1
    };
    V === "features.base" && g(V, [...n, fe]), V === "features.options" && g(V, [...l, fe]);
  }
  u(_, "onDropUpdate"), Qt(() => {
    y.destroy();
  });
  const y = new Zt(f);
  pe(i, y, (V) => t(1, r = V)), lt("item", y), lt("grantId", d), lt("grantType", p);
  const v = /* @__PURE__ */ u(({ target: V }) => g("label", V.value), "change_handler"), k = /* @__PURE__ */ u(({ detail: V }) => _("features.base", V.uuid), "document_dropped_handler"), S = /* @__PURE__ */ u((V) => s4(V.uuid), "click_handler"), D = /* @__PURE__ */ u((V, { target: Y }) => h("base", V, "limitedReselection", Y.checked), "change_handler_1"), I = /* @__PURE__ */ u((V, { target: Y }) => h("base", V, "selectionLimit", Number(Y.value)), "change_handler_2"), M = /* @__PURE__ */ u((V) => g("features.base", n.filter((Y, J) => J !== V)), "click_handler_1"), L = /* @__PURE__ */ u(({ detail: V }) => _("features.options", V.uuid), "document_dropped_handler_1"), B = /* @__PURE__ */ u((V) => s4(V.uuid), "click_handler_2"), z = /* @__PURE__ */ u((V, { target: Y }) => h("options", V, "limitedReselection", Y.checked), "change_handler_3"), q = /* @__PURE__ */ u((V, { target: Y }) => h("options", V, "selectionLimit", Number(Y.value)), "change_handler_4"), U = /* @__PURE__ */ u((V) => g("features.options", l.filter((Y, J) => J !== V)), "click_handler_3"), H = /* @__PURE__ */ u(({ target: V }) => g("features.total", Number(V.value)), "change_handler_5");
  return i.$$set = (V) => {
    "document" in V && t(9, f = V.document), "grantId" in V && t(10, d = V.grantId), "grantType" in V && t(11, p = V.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    1026 && t(0, s = r.system.grants[d]), i.$$.dirty & /*grant*/
    1 && t(3, n = n4(s.features.base ?? [])), i.$$.dirty & /*grant*/
    1 && t(2, l = n4(s.features.options ?? []));
  }, [
    s,
    r,
    l,
    n,
    m,
    g,
    h,
    _,
    y,
    f,
    d,
    p,
    v,
    k,
    S,
    D,
    I,
    M,
    L,
    B,
    z,
    q,
    U,
    H
  ];
}
u(wX, "instance$3G");
const p2 = class p2 extends re {
  constructor(e) {
    super(), oe(this, e, wX, kX, le, { document: 9, grantId: 10, grantType: 11 });
  }
};
u(p2, "FeatureGrantConfig");
let i_ = p2;
var bh, _h, yh;
const m2 = class m2 extends Is {
  constructor() {
    super(...arguments);
    x(this, bh, n_);
    x(this, _h, i_);
    x(this, yh, "feature");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "feature" }),
      features: new t.SchemaField({
        base: new t.ArrayField(
          new t.SchemaField({
            uuid: new t.StringField({ required: !0, initial: "" }),
            limitedReselection: new t.BooleanField({ required: !0, initial: !0 }),
            selectionLimit: new t.NumberField({ nullable: !1, initial: 1 })
          }),
          { required: !0, default: [] }
        ),
        options: new t.ArrayField(
          new t.SchemaField({
            uuid: new t.StringField({ required: !0, initial: "" }),
            limitedReselection: new t.BooleanField({ required: !0, initial: !0 }),
            selectionLimit: new t.NumberField({ nullable: !1, initial: 1 })
          }),
          { required: !0, default: [] }
        ),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      label: new t.StringField({ required: !0, initial: "New Feature Grant" })
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getApplyData(t, s) {
    if (!t) return {};
    const n = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: "feature",
      level: this.level
    };
    return {
      "system.grants": {
        ...t.system.grants,
        [this._id]: n
      }
    };
  }
  getSelectionComponent() {
    return P(this, bh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.features.base,
      choices: this.features.options,
      count: this.features.total,
      selected: (t == null ? void 0 : t.uuids) ?? []
    };
  }
  requiresConfig() {
    return !!this.features.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: P(this, yh)
    };
    super.configureGrant("Configure Feature Grant", t, P(this, _h), {
      width: 550
    });
  }
};
bh = new WeakMap(), _h = new WeakMap(), yh = new WeakMap(), u(m2, "FeatureGrant");
let l_ = m2;
var vh, kh;
const h2 = class h2 extends Is {
  constructor() {
    super(...arguments);
    x(this, vh, Fi);
    x(this, kh, "healing");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "healing" }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(K9("grant")),
      healingType: new t.StringField({ required: !0, initial: "healing" }),
      label: new t.StringField({ required: !0, initial: "New Healing Grant" })
    });
  }
  getApplyData(t) {
    var r, o;
    if (!t) return {};
    const s = foundry.utils.randomID(), n = {
      context: this.context,
      formula: this.bonus,
      label: this.label || ((r = this.parent) == null ? void 0 : r.name) || "Healing Grant",
      default: this.context.default ?? !0,
      img: this.img || ((o = this == null ? void 0 : this.parent) == null ? void 0 : o.img)
    };
    delete n.context.default;
    const l = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: s,
      type: "healing",
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.healing.${s}`]: n,
      "system.grants": {
        ...t.system.grants,
        [this._id]: l
      }
    };
  }
  getSelectionComponent() {
    return null;
  }
  getSelectionComponentProps() {
    return null;
  }
  requiresConfig() {
    return !1;
  }
  async configureGrant() {
    const t = {
      document: this.parent,
      grantId: this._id,
      grantType: P(this, kh)
    };
    super.configureGrant("Configure Healing Grant", t, P(this, vh), {
      width: 400
    });
  }
};
vh = new WeakMap(), kh = new WeakMap(), u(h2, "HealingGrant");
let r_ = h2;
var wh, Ff;
const g2 = class g2 extends Is {
  constructor() {
    super(...arguments);
    x(this, wh, Fi);
    x(this, Ff, "hitPoint");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "hitPoint" }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(Y9()),
      label: new t.StringField({ required: !0, initial: "New Hit Point Grant" })
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getApplyData(t, s = {}) {
    var o, a;
    if (!t) return {};
    const n = foundry.utils.randomID(), l = {
      context: { ...this.context },
      formula: this.bonus,
      label: this.label || ((o = this.parent) == null ? void 0 : o.name) || "HitPoint Grant",
      img: this.img || ((a = this == null ? void 0 : this.parent) == null ? void 0 : a.img)
    }, r = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: n,
      type: P(this, Ff),
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.hitPoint.${n}`]: l,
      "system.grants": {
        ...t.system.grants,
        [this._id]: r
      }
    };
  }
  getSelectionComponent() {
    return null;
  }
  getSelectionComponentProps() {
    return {};
  }
  requiresConfig() {
    return !1;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: P(this, Ff)
    };
    super.configureGrant("Configure Hit Points Grant", t, P(this, wh), {
      width: 400
    });
  }
};
wh = new WeakMap(), Ff = new WeakMap(), u(g2, "HitPointGrant");
let o_ = g2;
var $h, Ah;
const b2 = class b2 extends Is {
  constructor() {
    super(...arguments);
    x(this, $h, Fi);
    x(this, Ah, "initiative");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "initiative" }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(X9("grant")),
      label: new t.StringField({ required: !0, initial: "New Initiative Grant" })
    });
  }
  getApplyData(t) {
    var r, o;
    if (!t) return {};
    const s = foundry.utils.randomID(), n = {
      context: this.context,
      formula: this.bonus,
      label: this.label || ((r = this.parent) == null ? void 0 : r.name) || "Initiative Grant",
      default: this.context.default ?? !0,
      img: this.img || ((o = this == null ? void 0 : this.parent) == null ? void 0 : o.img)
    };
    delete n.context.default;
    const l = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: s,
      type: "initiative",
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.initiative.${s}`]: n,
      "system.grants": {
        ...t.system.grants,
        [this._id]: l
      }
    };
  }
  getSelectionComponent() {
    return null;
  }
  getSelectionComponentProps() {
    return null;
  }
  requiresConfig() {
    return !1;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: P(this, Ah)
    };
    super.configureGrant("Configure Initiative Grant", t, P(this, $h), {
      width: 500
    });
  }
};
$h = new WeakMap(), Ah = new WeakMap(), u(b2, "InitiativeGrant");
let a_ = b2;
function $X(i) {
  let e, t;
  return e = new tt({
    props: {
      options: (
        /*options*/
        i[7]
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[2]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[6]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      4 && (l.orange = /*choices*/
      s[2]), n & /*selected, totalCount*/
      9 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u($X, "create_default_slot_2$O");
function AX(i) {
  let e;
  return {
    c() {
      e = Q(
        /*summary*/
        i[4]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      16 && be(
        e,
        /*summary*/
        t[4]
      );
    },
    d(t) {
      t && C(e);
    }
  };
}
u(AX, "create_default_slot_1$14");
function EX(i) {
  let e, t, s, n;
  return e = new ie({
    props: {
      warning: (
        /*remainingSelections*/
        i[5] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[5]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[3]
      ),
      $$slots: { default: [$X] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      $$slots: { default: [AX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*remainingSelections*/
      32 && (o.warning = /*remainingSelections*/
      l[5] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      l[5]} choices remaining.`), r & /*selected, totalCount*/
      9 && (o.showWarning = /*selected*/
      l[0].length < /*totalCount*/
      l[3]), r & /*$$scope, selected, choices, totalCount*/
      8205 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, summary*/
      8208 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(EX, "create_default_slot$1T");
function SX(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Item Grant - " + /*grant*/
      i[1].label,
      $$slots: { default: [EX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*grant*/
      2 && (r.heading = "Item Grant - " + /*grant*/
      n[1].label), l & /*$$scope, summary, remainingSelections, selected, totalCount, choices*/
      8253 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(SX, "create_fragment$3O");
function CX(i, e, t) {
  let s, n, l, { grant: r } = e, { base: o } = e, { choices: a } = e, { count: c } = e, { selected: f } = e;
  const d = ft();
  de("actor");
  function p(h) {
    return "";
  }
  u(p, "getGrantSummary");
  function m({ detail: h }) {
    t(0, f = h), d("updateSelection", { uuids: f, summary: l });
  }
  u(m, "onUpdateSelection");
  const g = [...o, ...a].map((h) => {
    var y;
    const _ = fromUuidSync(h);
    return _ ? [h, _.name] : ((y = ui.notifications) == null || y.error(`Could not find document with UUID ${h} in grant ${r.label}.`), null);
  }).filter(Boolean);
  return i.$$set = (h) => {
    "grant" in h && t(1, r = h.grant), "base" in h && t(8, o = h.base), "choices" in h && t(2, a = h.choices), "count" in h && t(9, c = h.count), "selected" in h && t(0, f = h.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    257 && t(0, f = [...new Set(o.concat(f))]), i.$$.dirty & /*base, count*/
    768 && t(3, s = o.length + c), i.$$.dirty & /*totalCount, selected*/
    9 && t(5, n = s - f.length), i.$$.dirty & /*selected*/
    1 && t(4, l = p());
  }, [
    f,
    r,
    a,
    s,
    l,
    n,
    m,
    g,
    o,
    c
  ];
}
u(CX, "instance$3F");
const _2 = class _2 extends re {
  constructor(e) {
    super(), oe(this, e, CX, SX, le, {
      grant: 1,
      base: 8,
      choices: 2,
      count: 9,
      selected: 0
    });
  }
};
u(_2, "ItemGrantSelectionDialog");
let c_ = _2;
function i4(i, e, t) {
  const s = i.slice();
  return s[10] = e[t][0], s[11] = e[t][1], s[12] = e[t][2], s[14] = t, s;
}
u(i4, "get_each_context$1r");
function l4(i) {
  let e, t, s, n;
  function l(...r) {
    return (
      /*change_handler*/
      i[6](
        /*idx*/
        i[14],
        ...r
      )
    );
  }
  return u(l, "change_handler"), {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "class", "tag-count svelte-11jd1jn"), e.value = t = /*quantity*/
      i[12];
    },
    m(r, o) {
      T(r, e, o), s || (n = W(e, "change", l), s = !0);
    },
    p(r, o) {
      i = r, o & /*documents*/
      2 && t !== (t = /*quantity*/
      i[12]) && e.value !== t && (e.value = t);
    },
    d(r) {
      r && C(e), s = !1, n();
    }
  };
}
u(l4, "create_if_block$21");
function r4(i) {
  let e, t, s, n, l, r, o = (
    /*name*/
    i[11] + ""
  ), a, c, f, d, p, m, g, h = (
    /*type*/
    i[0] === "item" && l4(i)
  );
  function _() {
    return (
      /*click_handler*/
      i[7](
        /*idx*/
        i[14]
      )
    );
  }
  return u(_, "click_handler"), {
    c() {
      e = E("div"), t = E("img"), l = F(), r = E("span"), a = Q(o), c = F(), h && h.c(), f = F(), d = E("button"), d.innerHTML = '<i class="fa-solid fa-x"></i>', p = F(), ze(t.src, s = /*img*/
      i[10]) || b(t, "src", s), b(t, "alt", n = /*name*/
      i[11]), b(t, "class", "tag-img svelte-11jd1jn"), b(r, "class", "tag-name"), b(d, "class", "tag-delete-button svelte-11jd1jn"), b(e, "class", "tag-wrapper svelte-11jd1jn");
    },
    m(y, v) {
      T(y, e, v), A(e, t), A(e, l), A(e, r), A(r, a), A(e, c), h && h.m(e, null), A(e, f), A(e, d), A(e, p), m || (g = W(d, "click", Ve(st(_))), m = !0);
    },
    p(y, v) {
      i = y, v & /*documents*/
      2 && !ze(t.src, s = /*img*/
      i[10]) && b(t, "src", s), v & /*documents*/
      2 && n !== (n = /*name*/
      i[11]) && b(t, "alt", n), v & /*documents*/
      2 && o !== (o = /*name*/
      i[11] + "") && be(a, o), /*type*/
      i[0] === "item" ? h ? h.p(i, v) : (h = l4(i), h.c(), h.m(e, f)) : h && (h.d(1), h = null);
    },
    d(y) {
      y && C(e), h && h.d(), m = !1, g();
    }
  };
}
u(r4, "create_each_block$1r");
function TX(i) {
  let e, t = ue(
    /*documents*/
    i[1]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = r4(i4(i, t, n));
  return {
    c() {
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      e = $e();
    },
    m(n, l) {
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(n, l);
      T(n, e, l);
    },
    p(n, l) {
      if (l & /*onClick, documents, onUpdateQuantity, type*/
      15) {
        t = ue(
          /*documents*/
          n[1]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = i4(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = r4(o), s[r].c(), s[r].m(e.parentNode, e));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(TX, "create_default_slot$1S");
function OX(i) {
  let e, t, s;
  return e = new ie({
    props: {
      $$slots: { default: [TX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-direction", "row");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, documents, type*/
      32771 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(OX, "create_fragment$3N");
function DX(i, e, t) {
  let s, { uuids: n = [] } = e, { embeddedData: l = [] } = e, { type: r = "feature" } = e;
  const o = ft();
  function a(m) {
    r === "feature" && (t(4, n = n.filter((g, h) => h !== m)), o("updateSelection", n)), r === "item" && (t(5, l = l.filter((g, h) => h !== m)), o("updateSelection", l));
  }
  u(a, "onClick");
  function c(m, g) {
    r === "item" && (t(5, l[m].quantityOverride = g, l), o("updateSelection", l), t(5, l));
  }
  u(c, "onUpdateQuantity");
  function f(m) {
    return m === "feature" ? n.map((g) => {
      const h = fromUuidSync(g);
      return [h.img, h.name];
    }) : m === "item" ? l.map(({ uuid: g, quantityOverride: h }) => {
      const _ = fromUuidSync(g);
      return [_.img, _.name, h || _.system.quantity || 1];
    }) : [];
  }
  u(f, "getDocuments");
  const d = /* @__PURE__ */ u((m, { target: g }) => {
    c(m, g.value);
  }, "change_handler"), p = /* @__PURE__ */ u((m) => a(m), "click_handler");
  return i.$$set = (m) => {
    "uuids" in m && t(4, n = m.uuids), "embeddedData" in m && t(5, l = m.embeddedData), "type" in m && t(0, r = m.type);
  }, i.$$.update = () => {
    i.$$.dirty & /*type, uuids, embeddedData*/
    49 && t(1, s = f(r));
  }, [
    r,
    s,
    a,
    c,
    n,
    l,
    d,
    p
  ];
}
u(DX, "instance$3E");
const y2 = class y2 extends re {
  constructor(e) {
    super(), oe(this, e, DX, OX, le, { uuids: 4, embeddedData: 5, type: 0 });
  }
};
u(y2, "DropTag");
let bp = y2;
function IX(i) {
  let e, t, s, n;
  return e = new ho({
    props: { type: "uuid", documentType: "Item" }
  }), e.$on(
    "document-dropped",
    /*document_dropped_handler*/
    i[10]
  ), s = new bp({
    props: {
      embeddedData: (
        /*grant*/
        i[0].items.base
      ),
      type: "item"
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[11]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*grant*/
      1 && (o.embeddedData = /*grant*/
      l[0].items.base), s.$set(o);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(IX, "create_default_slot_3$A");
function PX(i) {
  let e, t, s, n;
  return e = new ho({
    props: { type: "uuid", documentType: "Item" }
  }), e.$on(
    "document-dropped",
    /*document_dropped_handler_1*/
    i[12]
  ), s = new bp({
    props: {
      embeddedData: (
        /*grant*/
        i[0].items.options
      ),
      type: "item"
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*grant*/
      1 && (o.embeddedData = /*grant*/
      l[0].items.options), s.$set(o);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(PX, "create_default_slot_2$N");
function MX(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      i[0].items.total ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*grant*/
      1 && t !== (t = /*grant*/
      l[0].items.total ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(MX, "create_default_slot_1$13");
function FX(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "Total Count",
      $$slots: { default: [MX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, grant*/
      131073 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(FX, "create_default_slot$1R");
function RX(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S;
  return d = new De({
    props: {
      heading: "Base Items",
      $$slots: { default: [IX] },
      $$scope: { ctx: i }
    }
  }), g = new De({
    props: {
      heading: "Optional Items",
      $$slots: { default: [PX] },
      $$scope: { ctx: i }
    }
  }), y = new Mi({
    props: {
      $$slots: { default: [FX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), h = E("div"), j(g.$$.fragment), _ = F(), j(y.$$.fragment), b(s, "class", "grant-image svelte-11uxnqq"), ze(s.src, n = /*grant*/
      i[0].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[0].label ?? "", b(a, "class", "grant-name svelte-11uxnqq"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-11uxnqq"), b(t, "class", "sheet-header svelte-11uxnqq"), G(p, "display", "contents"), G(p, "--a5e-section-margin", "0.25rem 0"), G(h, "display", "contents"), G(h, "--a5e-section-margin", "0.25rem 0"), b(e, "class", "svelte-11uxnqq");
    },
    m(D, I) {
      T(D, e, I), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), A(e, h), R(g, h, null), A(e, _), R(y, e, null), v = !0, k || (S = [
        W(
          s,
          "click",
          /*updateImage*/
          i[2]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[9]
        )
      ], k = !0);
    },
    p(D, [I]) {
      (!v || I & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      D[0].img || /*$item*/
      D[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!v || I & /*grant*/
      1 && l !== (l = /*grant*/
      D[0].label)) && b(s, "alt", l), (!v || I & /*grant*/
      1 && c !== (c = /*grant*/
      D[0].label ?? "") && a.value !== c) && (a.value = c);
      const M = {};
      I & /*$$scope, grant*/
      131073 && (M.$$scope = { dirty: I, ctx: D }), d.$set(M);
      const L = {};
      I & /*$$scope, grant*/
      131073 && (L.$$scope = { dirty: I, ctx: D }), g.$set(L);
      const B = {};
      I & /*$$scope, grant*/
      131073 && (B.$$scope = { dirty: I, ctx: D }), y.$set(B);
    },
    i(D) {
      v || (w(d.$$.fragment, D), w(g.$$.fragment, D), w(y.$$.fragment, D), v = !0);
    },
    o(D) {
      O(d.$$.fragment, D), O(g.$$.fragment, D), O(y.$$.fragment, D), v = !1;
    },
    d(D) {
      D && C(e), N(d), N(g), N(y), k = !1, Me(S);
    }
  };
}
u(RX, "create_fragment$3M");
function NX(i, e, t) {
  let s, n, l, r, { document: o, grantId: a, grantType: c } = de("#external").application, { document: f = o, grantId: d = a, grantType: p = c } = e;
  function m() {
    const M = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: M,
      callback: /* @__PURE__ */ u((B) => {
        g("img", B);
      }, "callback")
    }).browse();
  }
  u(m, "updateImage");
  function g(M, L) {
    M = `system.grants.${d}.${M}`, te(r, M, L);
  }
  u(g, "onUpdateValue");
  function h(M, L) {
    if (M === "items.base") {
      if (n.includes(L)) return;
      const B = [...s.items.base ?? []], z = fromUuidSync(L);
      B.push({
        uuid: L,
        quantity: z.system.quantity
      }), g(M, B);
    }
    if (M === "items.options") {
      if (l.includes(L)) return;
      const B = [...s.items.options ?? []], z = fromUuidSync(L);
      B.push({
        uuid: L,
        quantity: z.system.quantity
      }), g(M, B);
    }
  }
  u(h, "onDropUpdate"), Qt(() => {
    _.destroy();
  });
  const _ = new Zt(f);
  pe(i, _, (M) => t(1, r = M)), lt("item", _), lt("grantId", d), lt("grantType", p);
  const y = /* @__PURE__ */ u(({ target: M }) => g("label", M.value), "change_handler"), v = /* @__PURE__ */ u(({ detail: M }) => h("items.base", M.uuid), "document_dropped_handler"), k = /* @__PURE__ */ u(({ detail: M }) => g("items.base", M), "updateSelection_handler"), S = /* @__PURE__ */ u(({ detail: M }) => h("items.options", M.uuid), "document_dropped_handler_1"), D = /* @__PURE__ */ u(({ detail: M }) => g("items.options", M), "updateSelection_handler_1"), I = /* @__PURE__ */ u(({ target: M }) => g("items.total", Number(M.value)), "change_handler_1");
  return i.$$set = (M) => {
    "document" in M && t(6, f = M.document), "grantId" in M && t(7, d = M.grantId), "grantType" in M && t(8, p = M.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    130 && t(0, s = r.system.grants[d]), i.$$.dirty & /*grant*/
    1 && (n = s.items.base.map((M) => M.uuid) ?? []), i.$$.dirty & /*grant*/
    1 && (l = s.items.options.map((M) => M.uuid) ?? []);
  }, [
    s,
    r,
    m,
    g,
    h,
    _,
    f,
    d,
    p,
    y,
    v,
    k,
    S,
    D,
    I
  ];
}
u(NX, "instance$3D");
const v2 = class v2 extends re {
  constructor(e) {
    super(), oe(this, e, NX, RX, le, { document: 6, grantId: 7, grantType: 8 });
  }
};
u(v2, "ItemGrantConfig");
let u_ = v2;
var Eh, Sh, Rf;
const k2 = class k2 extends Is {
  constructor() {
    super(...arguments);
    x(this, Eh, c_);
    x(this, Sh, u_);
    x(this, Rf, "item");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "item" }),
      items: new t.SchemaField({
        base: new t.ArrayField(
          new t.SchemaField({
            uuid: new t.StringField({ required: !0, initial: "" }),
            quantityOverride: new t.NumberField({ required: !0, initial: 0, integer: !0 })
          }),
          { required: !0, default: [] }
        ),
        options: new t.ArrayField(
          new t.SchemaField({
            uuid: new t.StringField({ required: !0, initial: "" }),
            quantityOverride: new t.NumberField({ required: !0, initial: 0, integer: !0 })
          })
        ),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      label: new t.StringField({ required: !0, initial: "New Item Grant" })
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getApplyData(t, s) {
    if (!t) return {};
    const n = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: P(this, Rf),
      level: this.level
    };
    return {
      "system.grants": {
        ...t.system.grants,
        [this._id]: n
      }
    };
  }
  getSelectionComponent() {
    return P(this, Eh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.items.base.map(({ uuid: s }) => s) ?? [],
      choices: this.items.options.map(({ uuid: s }) => s) ?? [],
      count: this.items.total,
      selected: (t == null ? void 0 : t.uuids) ?? []
    };
  }
  requiresConfig() {
    return !!this.items.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: P(this, Rf)
    };
    super.configureGrant("Configure Item Grant", t, P(this, Sh), { width: 400 });
  }
};
Eh = new WeakMap(), Sh = new WeakMap(), Rf = new WeakMap(), u(k2, "ItemGrant");
let f_ = k2;
var Ch, Th, Oh;
const w2 = class w2 extends Is {
  constructor() {
    super(...arguments);
    x(this, Ch, mo);
    x(this, Th, Fi);
    x(this, Oh, "movement");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "movement" }),
      movementTypes: new t.SchemaField({
        base: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        options: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      unit: new t.StringField({ required: !0, initial: "feet" }),
      context: new t.SchemaField(J9("grant")),
      label: new t.StringField({ required: !0, initial: "New Movement Grant" })
    });
  }
  getApplyData(t, s) {
    var o, a;
    if (!t) return {};
    const n = foundry.utils.randomID(), l = {
      context: {
        movementTypes: (s == null ? void 0 : s.selected) ?? this.movementTypes.base ?? [],
        ...this.context
      },
      formula: this.bonus,
      unit: this.unit || "feet",
      label: this.label || ((o = this.parent) == null ? void 0 : o.name) || "Movement Grant",
      img: this.img || ((a = this == null ? void 0 : this.parent) == null ? void 0 : a.img)
    }, r = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: n,
      type: P(this, Oh),
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.movement.${n}`]: l,
      "system.grants": {
        ...t.system.grants,
        [this._id]: r
      }
    };
  }
  getSelectionComponent() {
    return P(this, Ch);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.movementTypes.base ?? [],
      bonus: this.bonus,
      choices: this.movementTypes.options ?? [],
      configObject: CONFIG.A5E.movementAbbreviations,
      count: this.movementTypes.total,
      unit: this.unit,
      heading: "Movement Grant Selection",
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.movementTypes.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: "movement"
    };
    super.configureGrant("Configure Movement Grant", t, P(this, Th), {
      width: 400
    });
  }
};
Ch = new WeakMap(), Th = new WeakMap(), Oh = new WeakMap(), u(w2, "MovementGrant");
let d_ = w2;
function jX(i) {
  var l, r, o, a, c, f, d, p;
  let e, t, s, n;
  return e = new Pi({
    props: {
      heading: "Base Options",
      options: (
        /*options*/
        i[3]
      ),
      selected: (
        /*grant*/
        (r = (l = i[1]) == null ? void 0 : l.keys) == null ? void 0 : r.base
      ),
      showToggleAllButton: !0,
      disabledOptions: (
        /*grant*/
        (a = (o = i[1]) == null ? void 0 : o.keys) == null ? void 0 : a.options
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[20]
  ), s = new Pi({
    props: {
      heading: "Optional Choices",
      options: (
        /*options*/
        i[3]
      ),
      selected: (
        /*grant*/
        (f = (c = i[1]) == null ? void 0 : c.keys) == null ? void 0 : f.options
      ),
      disabledOptions: (
        /*grant*/
        (p = (d = i[1]) == null ? void 0 : d.keys) == null ? void 0 : p.base
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[21]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(m, g) {
      R(e, m, g), T(m, t, g), R(s, m, g), n = !0;
    },
    p(m, g) {
      var y, v, k, S, D, I, M, L;
      const h = {};
      g & /*options*/
      8 && (h.options = /*options*/
      m[3]), g & /*grant*/
      2 && (h.selected = /*grant*/
      (v = (y = m[1]) == null ? void 0 : y.keys) == null ? void 0 : v.base), g & /*grant*/
      2 && (h.disabledOptions = /*grant*/
      (S = (k = m[1]) == null ? void 0 : k.keys) == null ? void 0 : S.options), e.$set(h);
      const _ = {};
      g & /*options*/
      8 && (_.options = /*options*/
      m[3]), g & /*grant*/
      2 && (_.selected = /*grant*/
      (I = (D = m[1]) == null ? void 0 : D.keys) == null ? void 0 : I.options), g & /*grant*/
      2 && (_.disabledOptions = /*grant*/
      (L = (M = m[1]) == null ? void 0 : M.keys) == null ? void 0 : L.base), s.$set(_);
    },
    i(m) {
      n || (w(e.$$.fragment, m), w(s.$$.fragment, m), n = !0);
    },
    o(m) {
      O(e.$$.fragment, m), O(s.$$.fragment, m), n = !1;
    },
    d(m) {
      m && C(t), N(e, m), N(s, m);
    }
  };
}
u(jX, "create_else_block$E");
function LX(i) {
  var l, r, o, a, c, f, d, p;
  let e, t, s, n;
  return e = new tt({
    props: {
      heading: "Base Options",
      options: (
        /*options*/
        i[3]
      ),
      selected: (
        /*grant*/
        (r = (l = i[1]) == null ? void 0 : l.keys) == null ? void 0 : r.base
      ),
      showToggleAllButton: !0,
      disabledOptions: (
        /*grant*/
        (a = (o = i[1]) == null ? void 0 : o.keys) == null ? void 0 : a.options
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[18]
  ), s = new tt({
    props: {
      heading: "Optional Choices",
      options: (
        /*options*/
        i[3]
      ),
      selected: (
        /*grant*/
        (f = (c = i[1]) == null ? void 0 : c.keys) == null ? void 0 : f.options
      ),
      disabledOptions: (
        /*grant*/
        (p = (d = i[1]) == null ? void 0 : d.keys) == null ? void 0 : p.base
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[19]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(m, g) {
      R(e, m, g), T(m, t, g), R(s, m, g), n = !0;
    },
    p(m, g) {
      var y, v, k, S, D, I, M, L;
      const h = {};
      g & /*options*/
      8 && (h.options = /*options*/
      m[3]), g & /*grant*/
      2 && (h.selected = /*grant*/
      (v = (y = m[1]) == null ? void 0 : y.keys) == null ? void 0 : v.base), g & /*grant*/
      2 && (h.disabledOptions = /*grant*/
      (S = (k = m[1]) == null ? void 0 : k.keys) == null ? void 0 : S.options), e.$set(h);
      const _ = {};
      g & /*options*/
      8 && (_.options = /*options*/
      m[3]), g & /*grant*/
      2 && (_.selected = /*grant*/
      (I = (D = m[1]) == null ? void 0 : D.keys) == null ? void 0 : I.options), g & /*grant*/
      2 && (_.disabledOptions = /*grant*/
      (L = (M = m[1]) == null ? void 0 : M.keys) == null ? void 0 : L.base), s.$set(_);
    },
    i(m) {
      n || (w(e.$$.fragment, m), w(s.$$.fragment, m), n = !0);
    },
    o(m) {
      O(e.$$.fragment, m), O(s.$$.fragment, m), n = !1;
    },
    d(m) {
      m && C(t), N(e, m), N(s, m);
    }
  };
}
u(LX, "create_if_block_2$V");
function BX(i) {
  let e, t, s, n;
  return e = new De({
    props: {
      heading: "Base Options",
      $$slots: { default: [qX] },
      $$scope: { ctx: i }
    }
  }), s = new De({
    props: {
      heading: "Optional Choices",
      $$slots: { default: [GX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, options, grant, proficiencyType*/
      16777227 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, options, grant, proficiencyType*/
      16777227 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(BX, "create_if_block_1$1l");
function qX(i) {
  var s, n, l, r;
  let e, t;
  return e = new uc({
    props: {
      heading: "Base Options",
      configObject: (
        /*options*/
        i[3]
      ),
      existingProperties: (
        /*grant*/
        (n = (s = i[1]) == null ? void 0 : s.keys) == null ? void 0 : n.base
      ),
      disabledProperties: (
        /*grant*/
        (r = (l = i[1]) == null ? void 0 : l.keys) == null ? void 0 : r.options
      ),
      headings: (
        /*proficiencyType*/
        i[0] === "tool" ? (
          /*toolCategories*/
          i[9]
        ) : (
          /*weaponCategories*/
          i[8]
        )
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), t = !0;
    },
    p(o, a) {
      var f, d, p, m;
      const c = {};
      a & /*options*/
      8 && (c.configObject = /*options*/
      o[3]), a & /*grant*/
      2 && (c.existingProperties = /*grant*/
      (d = (f = o[1]) == null ? void 0 : f.keys) == null ? void 0 : d.base), a & /*grant*/
      2 && (c.disabledProperties = /*grant*/
      (m = (p = o[1]) == null ? void 0 : p.keys) == null ? void 0 : m.options), a & /*proficiencyType*/
      1 && (c.headings = /*proficiencyType*/
      o[0] === "tool" ? (
        /*toolCategories*/
        o[9]
      ) : (
        /*weaponCategories*/
        o[8]
      )), e.$set(c);
    },
    i(o) {
      t || (w(e.$$.fragment, o), t = !0);
    },
    o(o) {
      O(e.$$.fragment, o), t = !1;
    },
    d(o) {
      N(e, o);
    }
  };
}
u(qX, "create_default_slot_3$z");
function GX(i) {
  var s, n, l, r;
  let e, t;
  return e = new uc({
    props: {
      configObject: (
        /*options*/
        i[3]
      ),
      existingProperties: (
        /*grant*/
        (n = (s = i[1]) == null ? void 0 : s.keys) == null ? void 0 : n.options
      ),
      disabledProperties: (
        /*grant*/
        (r = (l = i[1]) == null ? void 0 : l.keys) == null ? void 0 : r.base
      ),
      headings: (
        /*proficiencyType*/
        i[0] === "tool" ? (
          /*toolCategories*/
          i[9]
        ) : (
          /*weaponCategories*/
          i[8]
        )
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), t = !0;
    },
    p(o, a) {
      var f, d, p, m;
      const c = {};
      a & /*options*/
      8 && (c.configObject = /*options*/
      o[3]), a & /*grant*/
      2 && (c.existingProperties = /*grant*/
      (d = (f = o[1]) == null ? void 0 : f.keys) == null ? void 0 : d.options), a & /*grant*/
      2 && (c.disabledProperties = /*grant*/
      (m = (p = o[1]) == null ? void 0 : p.keys) == null ? void 0 : m.base), a & /*proficiencyType*/
      1 && (c.headings = /*proficiencyType*/
      o[0] === "tool" ? (
        /*toolCategories*/
        o[9]
      ) : (
        /*weaponCategories*/
        o[8]
      )), e.$set(c);
    },
    i(o) {
      t || (w(e.$$.fragment, o), t = !0);
    },
    o(o) {
      O(e.$$.fragment, o), t = !1;
    },
    d(o) {
      N(e, o);
    }
  };
}
u(GX, "create_default_slot_2$M");
function o4(i) {
  let e, t, s, n, l, r;
  const o = [BX, LX, jX], a = [];
  function c(f, d) {
    return d & /*proficiencyType*/
    1 && (e = null), d & /*proficiencyType*/
    1 && (t = null), e == null && (e = !!["tool", "weapon"].includes(
      /*proficiencyType*/
      f[0]
    )), e ? 0 : (t == null && (t = !!["skill", "savingThrow"].includes(
      /*proficiencyType*/
      f[0]
    )), t ? 1 : 2);
  }
  return u(c, "select_block_type"), s = c(i, -1), n = a[s] = o[s](i), {
    c() {
      n.c(), l = $e();
    },
    m(f, d) {
      a[s].m(f, d), T(f, l, d), r = !0;
    },
    p(f, d) {
      let p = s;
      s = c(f, d), s === p ? a[s].p(f, d) : (ae(), O(a[p], 1, 1, () => {
        a[p] = null;
      }), ce(), n = a[s], n ? n.p(f, d) : (n = a[s] = o[s](f), n.c()), w(n, 1), n.m(l.parentNode, l));
    },
    i(f) {
      r || (w(n), r = !0);
    },
    o(f) {
      O(n), r = !1;
    },
    d(f) {
      f && C(l), a[s].d(f);
    }
  };
}
u(o4, "create_key_block$3");
function zX(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      ((r = (l = i[1]) == null ? void 0 : l.keys) == null ? void 0 : r.total) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[22]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r & /*grant*/
      2 && t !== (t = /*grant*/
      ((a = (o = l[1]) == null ? void 0 : o.keys) == null ? void 0 : a.total) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(zX, "create_default_slot_1$12");
function a4(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Grant 5e expertise in these instead of proficiency",
      checked: (
        /*grant*/
        i[1].isExpertise ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[23]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*grant*/
      2 && (l.checked = /*grant*/
      s[1].isExpertise ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(a4, "create_if_block$20");
function HX(i) {
  let e, t, s = (
    /*proficiencyType*/
    i[0]
  ), n, l, r, o, a;
  e = new Ke({
    props: {
      options: Object.entries(
        /*configObject*/
        i[7]
      ).map(
        /*func*/
        i[14]
      ),
      selected: (
        /*proficiencyType*/
        i[0]
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[15]
  );
  let c = o4(i);
  l = new ie({
    props: {
      heading: "Selectable Options Count",
      $$slots: { default: [zX] },
      $$scope: { ctx: i }
    }
  });
  let f = (
    /*proficiencyType*/
    i[0] === "skill" && a4(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), c.c(), n = F(), j(l.$$.fragment), r = F(), f && f.c(), o = $e();
    },
    m(d, p) {
      R(e, d, p), T(d, t, p), c.m(d, p), T(d, n, p), R(l, d, p), T(d, r, p), f && f.m(d, p), T(d, o, p), a = !0;
    },
    p(d, p) {
      const m = {};
      p & /*proficiencyType*/
      1 && (m.selected = /*proficiencyType*/
      d[0]), e.$set(m), p & /*proficiencyType*/
      1 && le(s, s = /*proficiencyType*/
      d[0]) ? (ae(), O(c, 1, 1, se), ce(), c = o4(d), c.c(), w(c, 1), c.m(n.parentNode, n)) : c.p(d, p);
      const g = {};
      p & /*$$scope, grant*/
      16777218 && (g.$$scope = { dirty: p, ctx: d }), l.$set(g), /*proficiencyType*/
      d[0] === "skill" ? f ? (f.p(d, p), p & /*proficiencyType*/
      1 && w(f, 1)) : (f = a4(d), f.c(), w(f, 1), f.m(o.parentNode, o)) : f && (ae(), O(f, 1, 1, () => {
        f = null;
      }), ce());
    },
    i(d) {
      a || (w(e.$$.fragment, d), w(c), w(l.$$.fragment, d), w(f), a = !0);
    },
    o(d) {
      O(e.$$.fragment, d), O(c), O(l.$$.fragment, d), O(f), a = !1;
    },
    d(d) {
      d && (C(t), C(n), C(r), C(o)), N(e, d), c.d(d), N(l, d), f && f.d(d);
    }
  };
}
u(HX, "create_default_slot$1Q");
function UX(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y;
  return d = new De({
    props: {
      heading: "Proficiency Config",
      $$slots: { default: [HX] },
      $$scope: { ctx: i }
    }
  }), g = new Mi({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), j(g.$$.fragment), b(s, "class", "grant-image svelte-1k5niy5"), ze(s.src, n = /*grant*/
      i[1].img || /*$item*/
      i[2].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[1].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[1].label ?? "", b(a, "class", "grant-name svelte-1k5niy5"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1k5niy5"), b(t, "class", "sheet-header svelte-1k5niy5"), G(p, "display", "contents"), G(p, "--a5e-section-margin", "0.25rem 0"), G(p, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1k5niy5");
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), R(g, e, null), h = !0, _ || (y = [
        W(
          s,
          "click",
          /*updateImage*/
          i[4]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[13]
        )
      ], _ = !0);
    },
    p(v, [k]) {
      (!h || k & /*grant, $item*/
      6 && !ze(s.src, n = /*grant*/
      v[1].img || /*$item*/
      v[2].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!h || k & /*grant*/
      2 && l !== (l = /*grant*/
      v[1].label)) && b(s, "alt", l), (!h || k & /*grant*/
      2 && c !== (c = /*grant*/
      v[1].label ?? "") && a.value !== c) && (a.value = c);
      const S = {};
      k & /*$$scope, grant, proficiencyType, options*/
      16777227 && (S.$$scope = { dirty: k, ctx: v }), d.$set(S);
    },
    i(v) {
      h || (w(d.$$.fragment, v), w(g.$$.fragment, v), h = !0);
    },
    o(v) {
      O(d.$$.fragment, v), O(g.$$.fragment, v), h = !1;
    },
    d(v) {
      v && C(e), N(d), N(g), _ = !1, Me(y);
    }
  };
}
u(UX, "create_fragment$3L");
function VX(i, e, t) {
  let s, n, l, r, { document: o, grantId: a, grantType: c } = de("#external").application, { document: f = o, grantId: d = a, grantType: p = c } = e;
  function m() {
    const V = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: V,
      callback: /* @__PURE__ */ u((J) => {
        g("img", J);
      }, "callback")
    }).browse();
  }
  u(m, "updateImage");
  function g(V, Y) {
    V === "proficiencyType" && te(r, `system.grants.${d}.keys`, { base: [], options: [], total: 0 }), V = `system.grants.${d}.${V}`, te(r, V, Y);
  }
  u(g, "onUpdateValue"), Qt(() => {
    h.destroy();
  });
  const h = new Zt(f);
  pe(i, h, (V) => t(2, r = V));
  const _ = cg(), { weaponCategories: y, toolCategories: v } = CONFIG.A5E;
  lt("item", h), lt("grantId", d), lt("grantType", p);
  const k = /* @__PURE__ */ u(({ target: V }) => g("label", V.value), "change_handler"), S = /* @__PURE__ */ u(([V, { label: Y }]) => [V, K(Y)], "func"), D = /* @__PURE__ */ u(({ detail: V }) => g("proficiencyType", V), "updateSelection_handler"), I = /* @__PURE__ */ u(({ detail: V }) => {
    g("keys.base", V);
  }, "updateSelection_handler_1"), M = /* @__PURE__ */ u(({ detail: V }) => {
    g("keys.options", V);
  }, "updateSelection_handler_2"), L = /* @__PURE__ */ u(({ detail: V }) => {
    g("keys.base", V);
  }, "updateSelection_handler_3"), B = /* @__PURE__ */ u(({ detail: V }) => {
    g("keys.options", V);
  }, "updateSelection_handler_4"), z = /* @__PURE__ */ u(({ detail: V }) => {
    g("keys.base", V);
  }, "updateSelection_handler_5"), q = /* @__PURE__ */ u(({ detail: V }) => {
    g("keys.options", V);
  }, "updateSelection_handler_6"), U = /* @__PURE__ */ u(({ target: V }) => g("keys.total", Number(V.value)), "change_handler_1"), H = /* @__PURE__ */ u(({ detail: V }) => g("isExpertise", V), "updateSelection_handler_7");
  return i.$$set = (V) => {
    "document" in V && t(10, f = V.document), "grantId" in V && t(11, d = V.grantId), "grantType" in V && t(12, p = V.grantType);
  }, i.$$.update = () => {
    var V;
    i.$$.dirty & /*$item, grantId*/
    2052 && t(1, s = r.system.grants[d]), i.$$.dirty & /*grant*/
    2 && t(0, n = (s == null ? void 0 : s.proficiencyType) || "armor"), i.$$.dirty & /*proficiencyType*/
    1 && t(3, l = ((V = _[n]) == null ? void 0 : V.config) ?? []);
  }, [
    n,
    s,
    r,
    l,
    m,
    g,
    h,
    _,
    y,
    v,
    f,
    d,
    p,
    k,
    S,
    D,
    I,
    M,
    L,
    B,
    z,
    q,
    U,
    H
  ];
}
u(VX, "instance$3C");
const $2 = class $2 extends re {
  constructor(e) {
    super(), oe(this, e, VX, UX, le, { document: 10, grantId: 11, grantType: 12 });
  }
};
u($2, "ProficiencyGrantConfig");
let p_ = $2;
function WX(i) {
  let e, t;
  return e = new tt({
    props: {
      options: (
        /*getOptions*/
        i[9](
          /*choicesLocked*/
          i[5]
        )
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[2]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*choicesLocked*/
      32 && (l.options = /*getOptions*/
      s[9](
        /*choicesLocked*/
        s[5]
      )), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      4 && (l.orange = /*choices*/
      s[2]), n & /*selected, totalCount*/
      17 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(WX, "create_default_slot_2$L");
function KX(i) {
  let e;
  return {
    c() {
      e = Q(
        /*summary*/
        i[6]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      64 && be(
        e,
        /*summary*/
        t[6]
      );
    },
    d(t) {
      t && C(e);
    }
  };
}
u(KX, "create_default_slot_1$11");
function YX(i) {
  let e, t, s, n, l;
  return e = new ie({
    props: {
      warning: (
        /*remainingSelections*/
        i[7] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[7]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[4]
      ),
      $$slots: { default: [WX] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      $$slots: { default: [KX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), T(r, s, o), R(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*remainingSelections*/
      128 && (a.warning = /*remainingSelections*/
      r[7] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      r[7]} choices remaining.`), o & /*selected, totalCount*/
      17 && (a.showWarning = /*selected*/
      r[0].length < /*totalCount*/
      r[4]), o & /*$$scope, choicesLocked, selected, choices, totalCount*/
      65589 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, summary*/
      65600 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(s), r && e && C(t), N(e, r), N(n, r);
    }
  };
}
u(YX, "create_default_slot$1P");
function XX(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Proficiency Grant - " + /*grant*/
      i[1].label,
      headerButtons: ["tools", "weapons"].includes(
        /*proficiencyType*/
        i[3]
      ) ? [] : [
        {
          classes: "add-button",
          handler: (
            /*func*/
            i[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[5] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[5] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [YX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*grant*/
      2 && (r.heading = "Proficiency Grant - " + /*grant*/
      n[1].label), l & /*proficiencyType, choicesLocked*/
      40 && (r.headerButtons = ["tools", "weapons"].includes(
        /*proficiencyType*/
        n[3]
      ) ? [] : [
        {
          classes: "add-button",
          handler: (
            /*func*/
            n[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          n[5] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            n[5] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), l & /*$$scope, summary, remainingSelections, selected, totalCount, choicesLocked, choices*/
      65781 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(XX, "create_fragment$3K");
function JX(i, e, t) {
  let s, n, l, { grant: r } = e, { base: o } = e, { choices: a } = e, { count: c } = e, { proficiencyType: f } = e, { selected: d } = e;
  function p(k) {
    return "";
  }
  u(p, "getGrantSummary");
  function m({ detail: k }) {
    t(0, d = k), h("updateSelection", { selected: d, summary: l });
  }
  u(m, "onUpdateSelection");
  function g(k) {
    var L, B, z, q;
    const S = [];
    let D;
    ["weapon", "tool"].includes(f) ? D = Object.values(((L = _[f]) == null ? void 0 : L.config) ?? {}).flatMap((H) => Object.entries(H).map(([V]) => V)) : D = ((B = _[f]) == null ? void 0 : B.config.map(([U]) => U)) ?? [];
    const I = a.filter((U) => !D.includes(U)), M = [
      ...["weapon", "tool"].includes(f) ? Object.values(((z = _[f]) == null ? void 0 : z.config) ?? {}).flatMap((U) => Object.entries(U)) : ((q = _[f]) == null ? void 0 : q.config) ?? [],
      ...I.map((U) => [U, U])
    ];
    if (!k) return M;
    for (const [U, H] of M)
      a.includes(U) && S.push([U, H]);
    return S;
  }
  u(g, "getOptions");
  const h = ft(), _ = cg();
  let y = !0;
  const v = /* @__PURE__ */ u(() => t(5, y = !y), "func");
  return i.$$set = (k) => {
    "grant" in k && t(1, r = k.grant), "base" in k && t(10, o = k.base), "choices" in k && t(2, a = k.choices), "count" in k && t(11, c = k.count), "proficiencyType" in k && t(3, f = k.proficiencyType), "selected" in k && t(0, d = k.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    1025 && t(0, d = [...new Set(o.concat(d))]), i.$$.dirty & /*base, count*/
    3072 && t(4, s = o.length + c), i.$$.dirty & /*totalCount, selected*/
    17 && t(7, n = s - d.length), i.$$.dirty & /*selected*/
    1 && t(6, l = p());
  }, [
    d,
    r,
    a,
    f,
    s,
    y,
    l,
    n,
    m,
    g,
    o,
    c,
    v
  ];
}
u(JX, "instance$3B");
const A2 = class A2 extends re {
  constructor(e) {
    super(), oe(this, e, JX, XX, le, {
      grant: 1,
      base: 10,
      choices: 2,
      count: 11,
      proficiencyType: 3,
      selected: 0
    });
  }
};
u(A2, "ProficiencyGrantSelection");
let m_ = A2;
var Dh, Ih, Ph;
const E2 = class E2 extends Is {
  constructor() {
    super(...arguments);
    x(this, Dh, m_);
    x(this, Ih, p_);
    x(this, Ph, "proficiency");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "proficiency" }),
      keys: new t.SchemaField({
        base: new t.ArrayField(new t.StringField({ nullable: !1, initial: "" }), {
          required: !0,
          initial: []
        }),
        options: new t.ArrayField(new t.StringField({ nullable: !1, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      proficiencyType: new t.StringField({ required: !1, initial: "armor" }),
      isExpertise: new t.BooleanField({ required: !1, initial: !1 }),
      label: new t.StringField({ required: !0, initial: "New Proficiency Grant" })
    });
  }
  getApplyData(t, s) {
    if (!t) return {};
    const n = (s == null ? void 0 : s.selected) ?? this.keys.base ?? [], l = this.keys.total, r = {}, o = {
      proficiencyData: {
        keys: n,
        total: l,
        proficiencyType: this.proficiencyType
      },
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: P(this, Ph),
      level: this.level
    };
    if (r["system.grants"] = {
      ...t.system.grants,
      [this._id]: o
    }, this.proficiencyType === "savingThrow")
      n.forEach((a) => {
        r[`system.abilities.${a}.save.proficient`] = !0;
      });
    else if (this.proficiencyType === "skill")
      n.forEach((a) => {
        r[`system.skills.${a}.proficient`] = this.isExpertise ? 2 : 1;
      });
    else {
      const a = cg(), { propertyKey: c } = a[this.proficiencyType] ?? {};
      if (!c) return {};
      if (!n.length) return {};
      const f = /* @__PURE__ */ new Set([
        ...n,
        ...foundry.utils.getProperty(t, c) ?? []
      ]);
      r[c] = [...f];
    }
    return r;
  }
  getSelectionComponent() {
    return P(this, Dh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.keys.base ?? [],
      choices: this.keys.options,
      count: this.keys.total,
      proficiencyType: this.proficiencyType,
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return !!this.keys.options.length;
  }
  async configureGrant() {
    const t = {
      document: this.parent,
      grantId: this._id
    };
    super.configureGrant("Configure Proficiency Grant", t, P(this, Ih), {
      width: 400
    });
  }
};
Dh = new WeakMap(), Ih = new WeakMap(), Ph = new WeakMap(), u(E2, "ProficiencyGrant");
let h_ = E2;
function c4(i) {
  var o, a, c, f, d, p, m, g, h, _;
  let e, t, s, n, l, r;
  return e = new tt({
    props: {
      heading: "Base Options",
      options: (
        /*configObject*/
        (o = i[6][
          /*rollOverrideType*/
          i[2]
        ]) == null ? void 0 : o.options
      ),
      selected: (
        /*grant*/
        (c = (a = i[0]) == null ? void 0 : a.keys) == null ? void 0 : c.base
      ),
      showToggleAllButton: !0,
      disabledOptions: (
        /*grant*/
        (d = (f = i[0]) == null ? void 0 : f.keys) == null ? void 0 : d.options
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), s = new tt({
    props: {
      heading: "Optional Choices",
      options: (
        /*configObject*/
        (p = i[6][
          /*rollOverrideType*/
          i[2]
        ]) == null ? void 0 : p.options
      ),
      selected: (
        /*grant*/
        (g = (m = i[0]) == null ? void 0 : m.keys) == null ? void 0 : g.options
      ),
      disabledOptions: (
        /*grant*/
        (_ = (h = i[0]) == null ? void 0 : h.keys) == null ? void 0 : _.base
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[14]
  ), l = new ie({
    props: {
      heading: "Selectable Options Count",
      $$slots: { default: [ZX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(y, v) {
      R(e, y, v), T(y, t, v), R(s, y, v), T(y, n, v), R(l, y, v), r = !0;
    },
    p(y, v) {
      var I, M, L, B, z, q, U, H, V, Y;
      const k = {};
      v & /*rollOverrideType*/
      4 && (k.options = /*configObject*/
      (I = y[6][
        /*rollOverrideType*/
        y[2]
      ]) == null ? void 0 : I.options), v & /*grant*/
      1 && (k.selected = /*grant*/
      (L = (M = y[0]) == null ? void 0 : M.keys) == null ? void 0 : L.base), v & /*grant*/
      1 && (k.disabledOptions = /*grant*/
      (z = (B = y[0]) == null ? void 0 : B.keys) == null ? void 0 : z.options), e.$set(k);
      const S = {};
      v & /*rollOverrideType*/
      4 && (S.options = /*configObject*/
      (q = y[6][
        /*rollOverrideType*/
        y[2]
      ]) == null ? void 0 : q.options), v & /*grant*/
      1 && (S.selected = /*grant*/
      (H = (U = y[0]) == null ? void 0 : U.keys) == null ? void 0 : H.options), v & /*grant*/
      1 && (S.disabledOptions = /*grant*/
      (Y = (V = y[0]) == null ? void 0 : V.keys) == null ? void 0 : Y.base), s.$set(S);
      const D = {};
      v & /*$$scope, grant*/
      131073 && (D.$$scope = { dirty: v, ctx: y }), l.$set(D);
    },
    i(y) {
      r || (w(e.$$.fragment, y), w(s.$$.fragment, y), w(l.$$.fragment, y), r = !0);
    },
    o(y) {
      O(e.$$.fragment, y), O(s.$$.fragment, y), O(l.$$.fragment, y), r = !1;
    },
    d(y) {
      y && (C(t), C(n)), N(e, y), N(s, y), N(l, y);
    }
  };
}
u(c4, "create_if_block$1$");
function ZX(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      ((r = (l = i[0]) == null ? void 0 : l.keys) == null ? void 0 : r.total) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r & /*grant*/
      1 && t !== (t = /*grant*/
      ((a = (o = l[0]) == null ? void 0 : o.keys) == null ? void 0 : a.total) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(ZX, "create_default_slot_1$10");
function QX(i) {
  var o, a, c;
  let e, t, s, n, l;
  e = new Ke({
    props: {
      heading: "Override Type",
      options: Object.entries(
        /*configObject*/
        i[6]
      ).map(eJ),
      selected: (
        /*rollOverrideType*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  );
  let r = (
    /*configObject*/
    ((a = (o = i[6][
      /*rollOverrideType*/
      i[2]
    ]) == null ? void 0 : o.options) == null ? void 0 : a.length) && c4(i)
  );
  return n = new Ke({
    props: {
      heading: "Roll Mode",
      options: (
        /*rollModes*/
        i[7]
      ),
      selected: (
        /*grant*/
        ((c = i[0]) == null ? void 0 : c.rollMode) ?? 0
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment), t = F(), r && r.c(), s = F(), j(n.$$.fragment);
    },
    m(f, d) {
      R(e, f, d), T(f, t, d), r && r.m(f, d), T(f, s, d), R(n, f, d), l = !0;
    },
    p(f, d) {
      var g, h, _;
      const p = {};
      d & /*rollOverrideType*/
      4 && (p.selected = /*rollOverrideType*/
      f[2]), e.$set(p), /*configObject*/
      (h = (g = f[6][
        /*rollOverrideType*/
        f[2]
      ]) == null ? void 0 : g.options) != null && h.length ? r ? (r.p(f, d), d & /*rollOverrideType*/
      4 && w(r, 1)) : (r = c4(f), r.c(), w(r, 1), r.m(s.parentNode, s)) : r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce());
      const m = {};
      d & /*grant*/
      1 && (m.selected = /*grant*/
      ((_ = f[0]) == null ? void 0 : _.rollMode) ?? 0), n.$set(m);
    },
    i(f) {
      l || (w(e.$$.fragment, f), w(r), w(n.$$.fragment, f), l = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(r), O(n.$$.fragment, f), l = !1;
    },
    d(f) {
      f && (C(t), C(s)), N(e, f), r && r.d(f), N(n, f);
    }
  };
}
u(QX, "create_default_slot$1O");
function xX(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y;
  return d = new De({
    props: {
      heading: "Roll Override Configuration",
      $$slots: { default: [QX] },
      $$scope: { ctx: i }
    }
  }), g = new Mi({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), j(g.$$.fragment), b(s, "class", "grant-image svelte-18b23t6"), ze(s.src, n = /*grant*/
      i[0].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[0].label ?? "", b(a, "class", "grant-name svelte-18b23t6"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-18b23t6"), b(t, "class", "sheet-header svelte-18b23t6"), G(p, "display", "contents"), G(p, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-18b23t6");
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), R(g, e, null), h = !0, _ || (y = [
        W(
          s,
          "click",
          /*updateImage*/
          i[3]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[11]
        )
      ], _ = !0);
    },
    p(v, [k]) {
      (!h || k & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      v[0].img || /*$item*/
      v[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!h || k & /*grant*/
      1 && l !== (l = /*grant*/
      v[0].label)) && b(s, "alt", l), (!h || k & /*grant*/
      1 && c !== (c = /*grant*/
      v[0].label ?? "") && a.value !== c) && (a.value = c);
      const S = {};
      k & /*$$scope, grant, rollOverrideType*/
      131077 && (S.$$scope = { dirty: k, ctx: v }), d.$set(S);
    },
    i(v) {
      h || (w(d.$$.fragment, v), w(g.$$.fragment, v), h = !0);
    },
    o(v) {
      O(d.$$.fragment, v), O(g.$$.fragment, v), h = !1;
    },
    d(v) {
      v && C(e), N(d), N(g), _ = !1, Me(y);
    }
  };
}
u(xX, "create_fragment$3J");
const eJ = /* @__PURE__ */ u(([i, { label: e }]) => [i, e], "func$5");
function tJ(i, e, t) {
  let s, n, l, { document: r, grantId: o, grantType: a } = de("#external").application, { document: c = r, grantId: f = o, grantType: d = a } = e;
  function p() {
    const M = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: M,
      callback: /* @__PURE__ */ u((B) => {
        m("img", B);
      }, "callback")
    }).browse();
  }
  u(p, "updateImage");
  function m(M, L) {
    M === "expertiseType" && te(l, `system.grants.${f}.keys`, { base: [], options: [], total: 0 }), M = `system.grants.${f}.${M}`, te(l, M, L);
  }
  u(m, "onUpdateValue"), Qt(() => {
    g.destroy();
  });
  const g = new Zt(c);
  pe(i, g, (M) => t(1, l = M));
  const h = {
    abilityCheck: {
      label: "A5E.AbilityCheck",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    abilitySave: {
      label: "A5E.SavingThrow",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    attack: {
      label: "A5E.ActionOptionAttack",
      options: Object.entries(CONFIG.A5E.attackTypes)
    },
    initiative: { label: "A5E.Initiative", options: [] },
    concentration: {
      label: "A5E.ConditionConcentration",
      options: []
    },
    deathSave: { label: "Death Save", options: [] },
    skill: {
      label: "A5E.Skill",
      options: Object.entries(CONFIG.A5E.skills)
    }
  }, _ = Object.entries(CONFIG.A5E.rollModes ?? {}).map(([M, L]) => [CONFIG.A5E.ROLL_MODE[M.toUpperCase()], K(L)]);
  lt("item", g), lt("grantId", f), lt("grantType", d);
  const y = /* @__PURE__ */ u(({ target: M }) => m("label", M.value), "change_handler"), v = /* @__PURE__ */ u(({ detail: M }) => {
    m("rollOverrideType", M);
  }, "updateSelection_handler"), k = /* @__PURE__ */ u(({ detail: M }) => {
    m("keys.base", M);
  }, "updateSelection_handler_1"), S = /* @__PURE__ */ u(({ detail: M }) => {
    m("keys.options", M);
  }, "updateSelection_handler_2"), D = /* @__PURE__ */ u(({ target: M }) => m("keys.total", Number(M.value)), "change_handler_1"), I = /* @__PURE__ */ u(({ detail: M }) => {
    m("rollMode", M);
  }, "updateSelection_handler_3");
  return i.$$set = (M) => {
    "document" in M && t(8, c = M.document), "grantId" in M && t(9, f = M.grantId), "grantType" in M && t(10, d = M.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    514 && t(0, s = l.system.grants[f]), i.$$.dirty & /*grant*/
    1 && t(2, n = (s == null ? void 0 : s.rollOverrideType) || "ability");
  }, [
    s,
    l,
    n,
    p,
    m,
    g,
    h,
    _,
    c,
    f,
    d,
    y,
    v,
    k,
    S,
    D,
    I
  ];
}
u(tJ, "instance$3A");
const S2 = class S2 extends re {
  constructor(e) {
    super(), oe(this, e, tJ, xX, le, { document: 8, grantId: 9, grantType: 10 });
  }
};
u(S2, "RollOverrideGrantConfig");
let g_ = S2;
function sJ(i) {
  let e, t;
  return e = new tt({
    props: {
      options: (
        /*getOptions*/
        i[8](
          /*choicesLocked*/
          i[4]
        )
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[2]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*choicesLocked*/
      16 && (l.options = /*getOptions*/
      s[8](
        /*choicesLocked*/
        s[4]
      )), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      4 && (l.orange = /*choices*/
      s[2]), n & /*selected, totalCount*/
      9 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(sJ, "create_default_slot_2$K");
function nJ(i) {
  let e;
  return {
    c() {
      e = Q(
        /*summary*/
        i[5]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      32 && be(
        e,
        /*summary*/
        t[5]
      );
    },
    d(t) {
      t && C(e);
    }
  };
}
u(nJ, "create_default_slot_1$$");
function iJ(i) {
  let e, t, s, n, l;
  return e = new ie({
    props: {
      warning: (
        /*remainingSelections*/
        i[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[6]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[3]
      ),
      $$slots: { default: [sJ] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      $$slots: { default: [nJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), T(r, s, o), R(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*remainingSelections*/
      64 && (a.warning = /*remainingSelections*/
      r[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      r[6]} choices remaining.`), o & /*selected, totalCount*/
      9 && (a.showWarning = /*selected*/
      r[0].length < /*totalCount*/
      r[3]), o & /*$$scope, choicesLocked, selected, choices, totalCount*/
      65565 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, summary*/
      65568 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(s), r && e && C(t), N(e, r), N(n, r);
    }
  };
}
u(iJ, "create_default_slot$1N");
function lJ(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Roll Override Grant - " + /*grant*/
      i[1].label,
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*func*/
            i[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [iJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*grant*/
      2 && (r.heading = "Roll Override Grant - " + /*grant*/
      n[1].label), l & /*choicesLocked*/
      16 && (r.headerButtons = [
        {
          classes: "add-button",
          handler: (
            /*func*/
            n[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          n[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            n[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), l & /*$$scope, summary, remainingSelections, selected, totalCount, choicesLocked, choices*/
      65661 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(lJ, "create_fragment$3I");
function rJ(i, e, t) {
  let s, n, l, { grant: r } = e, { base: o } = e, { choices: a } = e, { count: c } = e, { rollOverrideType: f } = e, { selected: d } = e;
  function p(k) {
    return "";
  }
  u(p, "getGrantSummary");
  function m({ detail: k }) {
    t(0, d = k), h("updateSelection", { selected: d, summary: l });
  }
  u(m, "onUpdateSelection");
  function g(k) {
    var D, I;
    if (!k) return ((D = _[f]) == null ? void 0 : D.options) ?? [];
    const S = [];
    for (const [M, L] of ((I = _[f]) == null ? void 0 : I.options) ?? [])
      a.includes(M) && S.push([M, L]);
    return S;
  }
  u(g, "getOptions");
  const h = ft(), _ = {
    abilityCheck: {
      label: "A5E.AbilityCheck",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    abilitySave: {
      label: "A5E.SavingThrow",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    attack: {
      label: "A5E.ActionOptionAttack",
      options: Object.entries(CONFIG.A5E.attackTypes)
    },
    initiative: { label: "A5E.Initiative", options: [] },
    concentration: {
      label: "A5E.ConditionConcentration",
      options: []
    },
    deathSave: { label: "Death Save", options: [] },
    skill: {
      label: "A5E.Skill",
      options: Object.entries(CONFIG.A5E.skills)
    }
  };
  let y = !0;
  const v = /* @__PURE__ */ u(() => t(4, y = !y), "func");
  return i.$$set = (k) => {
    "grant" in k && t(1, r = k.grant), "base" in k && t(9, o = k.base), "choices" in k && t(2, a = k.choices), "count" in k && t(10, c = k.count), "rollOverrideType" in k && t(11, f = k.rollOverrideType), "selected" in k && t(0, d = k.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    513 && t(0, d = [...new Set(o.concat(d))]), i.$$.dirty & /*base, count*/
    1536 && t(3, s = o.length + c), i.$$.dirty & /*totalCount, selected*/
    9 && t(6, n = s - d.length), i.$$.dirty & /*selected*/
    1 && t(5, l = p());
  }, [
    d,
    r,
    a,
    s,
    y,
    l,
    n,
    m,
    g,
    o,
    c,
    f,
    v
  ];
}
u(rJ, "instance$3z");
const C2 = class C2 extends re {
  constructor(e) {
    super(), oe(this, e, rJ, lJ, le, {
      grant: 1,
      base: 9,
      choices: 2,
      count: 10,
      rollOverrideType: 11,
      selected: 0
    });
  }
};
u(C2, "RollOverrideGrantSelectionDialog");
let b_ = C2;
var Mh, Fh, Nf;
const T2 = class T2 extends Is {
  constructor() {
    super(...arguments);
    x(this, Mh, b_);
    x(this, Fh, g_);
    x(this, Nf, "rollOverride");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "rollOverride" }),
      keys: new t.SchemaField({
        base: new t.ArrayField(new t.StringField({ nullable: !1, initial: "" }), {
          required: !0,
          initial: []
        }),
        options: new t.ArrayField(new t.StringField({ nullable: !1, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new t.NumberField({ nullable: !1, initial: 0, integer: !0 })
      }),
      rollMode: new t.NumberField({ nullable: !1, initial: 0 }),
      rollOverrideType: new t.StringField({ required: !1, initial: "abilityCheck" }),
      label: new t.StringField({ required: !0, initial: "New Roll Override Grant" })
    });
  }
  getApplyData(t, s) {
    if (!t) return {};
    const n = (s == null ? void 0 : s.selected) ?? this.keys.base ?? [], l = this.keys.total, r = {}, o = {
      rollOverrideData: {
        keys: n,
        total: l,
        rollOverrideType: this.rollOverrideType,
        rollMode: this.rollMode
      },
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: P(this, Nf),
      level: this.level
    };
    return r["system.grants"] = {
      ...t.system.grants,
      [this._id]: o
    }, r;
  }
  getSelectionComponent() {
    return P(this, Mh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.keys.base ?? [],
      choices: this.keys.options ?? [],
      count: this.keys.total,
      rollOverrideType: this.rollOverrideType,
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return !!this.keys.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: P(this, Nf)
    };
    super.configureGrant("Configure Roll Override Grant", t, P(this, Fh), {
      width: 400
    });
  }
};
Mh = new WeakMap(), Fh = new WeakMap(), Nf = new WeakMap(), u(T2, "RollOverrideGrant");
let __ = T2;
var Rh, Nh, jh;
const O2 = class O2 extends Is {
  constructor() {
    super(...arguments);
    x(this, Rh, mo);
    x(this, Nh, Fi);
    x(this, jh, "senses");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "senses" }),
      senses: new t.SchemaField({
        base: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        options: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      unit: new t.StringField({ required: !0, initial: "feet" }),
      context: new t.SchemaField(Z9("grant")),
      label: new t.StringField({ required: !0, initial: "New Senses Grant" })
    });
  }
  getApplyData(t, s) {
    var o, a;
    if (!t) return {};
    const n = foundry.utils.randomID(), l = {
      context: {
        senses: (s == null ? void 0 : s.selected) ?? this.senses.base ?? [],
        ...this.context
      },
      formula: this.bonus,
      unit: this.unit || "feet",
      label: this.label || ((o = this.parent) == null ? void 0 : o.name) || "Senses Grant",
      img: this.img || ((a = this == null ? void 0 : this.parent) == null ? void 0 : a.img)
    }, r = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: n,
      type: P(this, jh),
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.senses.${n}`]: l,
      "system.grants": {
        ...t.system.grants,
        [this._id]: r
      }
    };
  }
  getSelectionComponent() {
    return P(this, Rh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.senses.base ?? [],
      bonus: this.bonus,
      choices: this.senses.options ?? [],
      configObject: CONFIG.A5E.senses,
      count: this.senses.total,
      unit: this.unit,
      heading: "Senses Grant Selection",
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.senses.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: "senses"
    };
    super.configureGrant("Configure Senses Grant", t, P(this, Nh), {
      width: 400
    });
  }
};
Rh = new WeakMap(), Nh = new WeakMap(), jh = new WeakMap(), u(O2, "SensesGrant");
let y_ = O2;
var Lh, Bh, T5;
const D2 = class D2 extends Is {
  constructor() {
    super(...arguments);
    x(this, Lh, mo);
    x(this, Bh, Fi);
    x(this, T5, "skill");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "skill" }),
      skills: new t.SchemaField({
        base: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        options: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(Q9("grant")),
      label: new t.StringField({ required: !0, initial: "New Skill Grant" })
    });
  }
  getApplyData(t, s = {}) {
    var a, c;
    if (!t) return {};
    const n = (s == null ? void 0 : s.selected) ?? this.skills.base ?? [], l = foundry.utils.randomID(), r = {
      context: {
        skills: n,
        ...this.context
      },
      formula: this.bonus,
      label: this.label || ((a = this.parent) == null ? void 0 : a.name) || "Skill Grant",
      default: this.context.default ?? !0,
      img: this.img || ((c = this == null ? void 0 : this.parent) == null ? void 0 : c.img)
    };
    delete r.context.default;
    const o = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: l,
      type: "skills",
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.skills.${l}`]: r,
      "system.grants": {
        ...t.system.grants,
        [this._id]: o
      }
    };
  }
  getSelectionComponent() {
    return P(this, Lh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.skills.base,
      bonus: this.bonus,
      choices: this.skills.options,
      configObject: CONFIG.A5E.skills,
      count: this.skills.total,
      heading: "Skill Grant Selection",
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.skills.options.length;
  }
  async configureGrant() {
    const t = {
      document: this.parent,
      grantId: this._id,
      grantType: "skills"
    };
    super.configureGrant("Configure Skill Grant", t, P(this, Bh), {
      width: 400
    });
  }
};
Lh = new WeakMap(), Bh = new WeakMap(), T5 = new WeakMap(), u(D2, "SkillGrant");
let v_ = D2;
function oJ(i) {
  let e, t;
  return e = new Ke({
    props: {
      options: Object.entries(
        /*skills*/
        i[7]
      ),
      selected: (
        /*skill*/
        i[0]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skill*/
      1 && (l.selected = /*skill*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(oJ, "create_default_slot_1$_");
function aJ(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      ((r = (l = i[1]) == null ? void 0 : l.specialties) == null ? void 0 : r.total) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r & /*grant*/
      2 && t !== (t = /*grant*/
      ((a = (o = l[1]) == null ? void 0 : o.specialties) == null ? void 0 : a.total) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(aJ, "create_default_slot$1M");
function u4(i) {
  var o, a, c, f, d, p, m, g;
  let e, t, s, n, l, r;
  return e = new Pi({
    props: {
      heading: "Base Options",
      options: Object.entries(
        /*specialties*/
        i[3]
      ),
      selected: (
        /*grant*/
        (a = (o = i[1]) == null ? void 0 : o.specialties) == null ? void 0 : a.base
      ),
      disabledOptions: (
        /*grant*/
        (f = (c = i[1]) == null ? void 0 : c.specialties) == null ? void 0 : f.options
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), s = new Pi({
    props: {
      heading: "Optional Choices",
      options: Object.entries(
        /*specialties*/
        i[3]
      ),
      selected: (
        /*grant*/
        (p = (d = i[1]) == null ? void 0 : d.specialties) == null ? void 0 : p.options
      ),
      disabledOptions: (
        /*grant*/
        (g = (m = i[1]) == null ? void 0 : m.specialties) == null ? void 0 : g.base
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[14]
  ), l = new ie({
    props: {
      heading: "Selectable Options Count",
      $$slots: { default: [aJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(h, _) {
      R(e, h, _), T(h, t, _), R(s, h, _), T(h, n, _), R(l, h, _), r = !0;
    },
    p(h, _) {
      var S, D, I, M, L, B, z, q;
      const y = {};
      _ & /*specialties*/
      8 && (y.options = Object.entries(
        /*specialties*/
        h[3]
      )), _ & /*grant*/
      2 && (y.selected = /*grant*/
      (D = (S = h[1]) == null ? void 0 : S.specialties) == null ? void 0 : D.base), _ & /*grant*/
      2 && (y.disabledOptions = /*grant*/
      (M = (I = h[1]) == null ? void 0 : I.specialties) == null ? void 0 : M.options), e.$set(y);
      const v = {};
      _ & /*specialties*/
      8 && (v.options = Object.entries(
        /*specialties*/
        h[3]
      )), _ & /*grant*/
      2 && (v.selected = /*grant*/
      (B = (L = h[1]) == null ? void 0 : L.specialties) == null ? void 0 : B.options), _ & /*grant*/
      2 && (v.disabledOptions = /*grant*/
      (q = (z = h[1]) == null ? void 0 : z.specialties) == null ? void 0 : q.base), s.$set(v);
      const k = {};
      _ & /*$$scope, grant*/
      131074 && (k.$$scope = { dirty: _, ctx: h }), l.$set(k);
    },
    i(h) {
      r || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(l.$$.fragment, h), r = !0);
    },
    o(h) {
      O(e.$$.fragment, h), O(s.$$.fragment, h), O(l.$$.fragment, h), r = !1;
    },
    d(h) {
      h && (C(t), C(n)), N(e, h), N(s, h), N(l, h);
    }
  };
}
u(u4, "create_key_block$2");
function cJ(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g = (
    /*skill*/
    i[0]
  ), h, _, y, v, k;
  d = new De({
    props: {
      heading: "Skill Specialty Selection",
      $$slots: { default: [oJ] },
      $$scope: { ctx: i }
    }
  });
  let S = u4(i);
  return _ = new Mi({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), S.c(), h = F(), j(_.$$.fragment), b(s, "class", "grant-image svelte-1k5niy5"), ze(s.src, n = /*grant*/
      i[1].img || /*$item*/
      i[2].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[1].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[1].label ?? "", b(a, "class", "grant-name svelte-1k5niy5"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1k5niy5"), b(t, "class", "sheet-header svelte-1k5niy5"), G(p, "display", "contents"), G(p, "--a5e-section-margin", "0.25rem 0"), G(p, "--a5e-section-body-direction", "row"), b(e, "class", "svelte-1k5niy5");
    },
    m(D, I) {
      T(D, e, I), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), S.m(e, null), A(e, h), R(_, e, null), y = !0, v || (k = [
        W(
          s,
          "click",
          /*updateImage*/
          i[4]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[11]
        )
      ], v = !0);
    },
    p(D, [I]) {
      (!y || I & /*grant, $item*/
      6 && !ze(s.src, n = /*grant*/
      D[1].img || /*$item*/
      D[2].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!y || I & /*grant*/
      2 && l !== (l = /*grant*/
      D[1].label)) && b(s, "alt", l), (!y || I & /*grant*/
      2 && c !== (c = /*grant*/
      D[1].label ?? "") && a.value !== c) && (a.value = c);
      const M = {};
      I & /*$$scope, skill*/
      131073 && (M.$$scope = { dirty: I, ctx: D }), d.$set(M), I & /*skill*/
      1 && le(g, g = /*skill*/
      D[0]) ? (ae(), O(S, 1, 1, se), ce(), S = u4(D), S.c(), w(S, 1), S.m(e, h)) : S.p(D, I);
    },
    i(D) {
      y || (w(d.$$.fragment, D), w(S), w(_.$$.fragment, D), y = !0);
    },
    o(D) {
      O(d.$$.fragment, D), O(S), O(_.$$.fragment, D), y = !1;
    },
    d(D) {
      D && C(e), N(d), S.d(D), N(_), v = !1, Me(k);
    }
  };
}
u(cJ, "create_fragment$3H");
function uJ(i, e, t) {
  let s, n, l, r, { document: o, grantId: a, grantType: c } = de("#external").application, { document: f = o, grantId: d = a, grantType: p = c } = e;
  function m() {
    const M = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: M,
      callback: /* @__PURE__ */ u((B) => {
        g("img", B);
      }, "callback")
    }).browse();
  }
  u(m, "updateImage");
  function g(M, L) {
    M === "skill" && te(r, `system.grants.${d}.specialties`, { base: [], options: [], total: 0 }), M = `system.grants.${d}.${M}`, te(r, M, L);
  }
  u(g, "onUpdateValue"), Qt(() => {
    h.destroy();
  });
  const h = new Zt(f);
  pe(i, h, (M) => t(2, r = M));
  const { skills: _, skillSpecialties: y } = CONFIG.A5E;
  lt("item", h), lt("grantId", d), lt("grantType", p);
  const v = /* @__PURE__ */ u(({ target: M }) => g("label", M.value), "change_handler"), k = /* @__PURE__ */ u(({ detail: M }) => {
    g("skill", M);
  }, "updateSelection_handler"), S = /* @__PURE__ */ u(({ detail: M }) => {
    g("specialties.base", M);
  }, "updateSelection_handler_1"), D = /* @__PURE__ */ u(({ detail: M }) => {
    g("specialties.options", M);
  }, "updateSelection_handler_2"), I = /* @__PURE__ */ u(({ target: M }) => g("specialties.total", Number(M.value)), "change_handler_1");
  return i.$$set = (M) => {
    "document" in M && t(8, f = M.document), "grantId" in M && t(9, d = M.grantId), "grantType" in M && t(10, p = M.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    516 && t(1, s = r.system.grants[d]), i.$$.dirty & /*grant*/
    2 && t(0, n = (s == null ? void 0 : s.skill) || "acr"), i.$$.dirty & /*skill*/
    1 && t(3, l = y[n]);
  }, [
    n,
    s,
    r,
    l,
    m,
    g,
    h,
    _,
    f,
    d,
    p,
    v,
    k,
    S,
    D,
    I
  ];
}
u(uJ, "instance$3y");
const I2 = class I2 extends re {
  constructor(e) {
    super(), oe(this, e, uJ, cJ, le, { document: 8, grantId: 9, grantType: 10 });
  }
};
u(I2, "SkillSpecialtyConfig");
let k_ = I2;
function fJ(i) {
  let e, t;
  return e = new tt({
    props: {
      options: Object.entries(
        /*skillSpecialties*/
        i[8][
          /*skill*/
          i[3]
        ]
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[2]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skill*/
      8 && (l.options = Object.entries(
        /*skillSpecialties*/
        s[8][
          /*skill*/
          s[3]
        ]
      )), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      4 && (l.orange = /*choices*/
      s[2]), n & /*selected, totalCount*/
      17 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(fJ, "create_default_slot_1$Z");
function dJ(i) {
  let e, t;
  return e = new ie({
    props: {
      warning: (
        /*remainingSelections*/
        i[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[6]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[4]
      ),
      $$slots: { default: [fJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*remainingSelections*/
      64 && (l.warning = /*remainingSelections*/
      s[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      s[6]} choices remaining.`), n & /*selected, totalCount*/
      17 && (l.showWarning = /*selected*/
      s[0].length < /*totalCount*/
      s[4]), n & /*$$scope, skill, selected, choices, totalCount*/
      32797 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(dJ, "create_default_slot$1L");
function pJ(i) {
  let e, t;
  return e = new De({
    props: {
      heading: "Skill Specialty Grant - " + /*grant*/
      i[1].label,
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*func*/
            i[11]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[5] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[5] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [dJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*grant*/
      2 && (l.heading = "Skill Specialty Grant - " + /*grant*/
      s[1].label), n & /*choicesLocked*/
      32 && (l.headerButtons = [
        {
          classes: "add-button",
          handler: (
            /*func*/
            s[11]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          s[5] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            s[5] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), n & /*$$scope, remainingSelections, selected, totalCount, skill, choices*/
      32861 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(pJ, "create_fragment$3G");
function mJ(i, e, t) {
  let s, n, l, { grant: r } = e, { base: o } = e, { choices: a } = e, { count: c } = e, { skill: f } = e, { selected: d } = e;
  function p(v) {
    return "";
  }
  u(p, "getGrantSummary");
  function m({ detail: v }) {
    t(0, d = v), g("updateSelection", { selected: d, summary: l });
  }
  u(m, "onUpdateSelection");
  const g = ft(), { skillSpecialties: h } = CONFIG.A5E;
  let _ = !0;
  const y = /* @__PURE__ */ u(() => t(5, _ = !_), "func");
  return i.$$set = (v) => {
    "grant" in v && t(1, r = v.grant), "base" in v && t(9, o = v.base), "choices" in v && t(2, a = v.choices), "count" in v && t(10, c = v.count), "skill" in v && t(3, f = v.skill), "selected" in v && t(0, d = v.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    513 && t(0, d = [...new Set(o.concat(d))]), i.$$.dirty & /*count, base*/
    1536 && t(4, s = c + o.length), i.$$.dirty & /*totalCount, selected*/
    17 && t(6, n = s - d.length), i.$$.dirty & /*selected*/
    1 && (l = p());
  }, [
    d,
    r,
    a,
    f,
    s,
    _,
    n,
    m,
    h,
    o,
    c,
    y
  ];
}
u(mJ, "instance$3x");
const P2 = class P2 extends re {
  constructor(e) {
    super(), oe(this, e, mJ, pJ, le, {
      grant: 1,
      base: 9,
      choices: 2,
      count: 10,
      skill: 3,
      selected: 0
    });
  }
};
u(P2, "SkillSpecialtyGrantSelectionDialog");
let w_ = P2;
var qh, Gh, jf;
const M2 = class M2 extends Is {
  constructor() {
    super(...arguments);
    x(this, qh, w_);
    x(this, Gh, k_);
    x(this, jf, "skillSpecialty");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "skillSpecialty" }),
      skill: new t.StringField({ required: !0, initial: "acr" }),
      specialties: new t.SchemaField({
        base: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        options: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      label: new t.StringField({ required: !0, initial: "New Skill Specialty Grant" })
    });
  }
  getApplyData(t, s) {
    if (!t) return {};
    const n = (s == null ? void 0 : s.selected) ?? this.specialties.base ?? [], l = (s == null ? void 0 : s.skill) ?? this.skill ?? "acr", r = this.specialties.total;
    if (!l) return {};
    const o = {
      specialtyData: {
        specialties: n,
        skill: l,
        total: r
      },
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: P(this, jf),
      level: this.level
    }, a = `system.skills.${l}.specialties`, c = foundry.utils.getProperty(t, a) ?? [], f = /* @__PURE__ */ new Set([...n, ...c]);
    return {
      [a]: [...f],
      "system.grants": {
        ...t.system.grants,
        [this._id]: o
      }
    };
  }
  getSelectionComponent() {
    return P(this, qh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.specialties.base ?? [],
      choices: this.specialties.options,
      count: this.specialties.total,
      skill: this.skill,
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.specialties.options.length;
  }
  async configureGrant() {
    const t = {
      document: this.parent,
      grantId: this._id,
      grantType: P(this, jf)
    };
    super.configureGrant("Configure Skill Specialty Grant", t, P(this, Gh), {
      width: 400
    });
  }
};
qh = new WeakMap(), Gh = new WeakMap(), jf = new WeakMap(), u(M2, "SkillSpecialtyGrant");
let $_ = M2;
function f4(i) {
  var l, r, o, a, c, f, d, p;
  let e, t, s, n;
  return e = new Pi({
    props: {
      heading: "Base Options",
      options: (
        /*options*/
        i[3]
      ),
      selected: (
        /*grant*/
        (r = (l = i[1]) == null ? void 0 : l.traits) == null ? void 0 : r.base
      ),
      disabledOptions: (
        /*grant*/
        (a = (o = i[1]) == null ? void 0 : o.traits) == null ? void 0 : a.options
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[14]
  ), s = new Pi({
    props: {
      heading: "Optional Choices",
      options: (
        /*options*/
        i[3]
      ),
      selected: (
        /*grant*/
        (f = (c = i[1]) == null ? void 0 : c.traits) == null ? void 0 : f.options
      ),
      disabledOptions: (
        /*grant*/
        (p = (d = i[1]) == null ? void 0 : d.traits) == null ? void 0 : p.base
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[15]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(m, g) {
      R(e, m, g), T(m, t, g), R(s, m, g), n = !0;
    },
    p(m, g) {
      var y, v, k, S, D, I, M, L;
      const h = {};
      g & /*options*/
      8 && (h.options = /*options*/
      m[3]), g & /*grant*/
      2 && (h.selected = /*grant*/
      (v = (y = m[1]) == null ? void 0 : y.traits) == null ? void 0 : v.base), g & /*grant*/
      2 && (h.disabledOptions = /*grant*/
      (S = (k = m[1]) == null ? void 0 : k.traits) == null ? void 0 : S.options), e.$set(h);
      const _ = {};
      g & /*options*/
      8 && (_.options = /*options*/
      m[3]), g & /*grant*/
      2 && (_.selected = /*grant*/
      (I = (D = m[1]) == null ? void 0 : D.traits) == null ? void 0 : I.options), g & /*grant*/
      2 && (_.disabledOptions = /*grant*/
      (L = (M = m[1]) == null ? void 0 : M.traits) == null ? void 0 : L.base), s.$set(_);
    },
    i(m) {
      n || (w(e.$$.fragment, m), w(s.$$.fragment, m), n = !0);
    },
    o(m) {
      O(e.$$.fragment, m), O(s.$$.fragment, m), n = !1;
    },
    d(m) {
      m && C(t), N(e, m), N(s, m);
    }
  };
}
u(f4, "create_key_block$1");
function hJ(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      ((r = (l = i[1]) == null ? void 0 : l.traits) == null ? void 0 : r.total) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[16]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r & /*grant*/
      2 && t !== (t = /*grant*/
      ((a = (o = l[1]) == null ? void 0 : o.traits) == null ? void 0 : a.total) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(hJ, "create_default_slot_1$Y");
function gJ(i) {
  let e, t, s = (
    /*traitType*/
    i[0]
  ), n, l, r;
  e = new Ke({
    props: {
      heading: "Trait Type",
      options: Object.entries(
        /*configObject*/
        i[7]
      ).map(
        /*func*/
        i[12]
      ),
      selected: (
        /*traitType*/
        i[0]
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[13]
  );
  let o = f4(i);
  return l = new ie({
    props: {
      heading: "Selectable Options Count",
      $$slots: { default: [hJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), o.c(), n = F(), j(l.$$.fragment);
    },
    m(a, c) {
      R(e, a, c), T(a, t, c), o.m(a, c), T(a, n, c), R(l, a, c), r = !0;
    },
    p(a, c) {
      const f = {};
      c & /*traitType*/
      1 && (f.selected = /*traitType*/
      a[0]), e.$set(f), c & /*traitType*/
      1 && le(s, s = /*traitType*/
      a[0]) ? (ae(), O(o, 1, 1, se), ce(), o = f4(a), o.c(), w(o, 1), o.m(n.parentNode, n)) : o.p(a, c);
      const d = {};
      c & /*$$scope, grant*/
      131074 && (d.$$scope = { dirty: c, ctx: a }), l.$set(d);
    },
    i(a) {
      r || (w(e.$$.fragment, a), w(o), w(l.$$.fragment, a), r = !0);
    },
    o(a) {
      O(e.$$.fragment, a), O(o), O(l.$$.fragment, a), r = !1;
    },
    d(a) {
      a && (C(t), C(n)), N(e, a), o.d(a), N(l, a);
    }
  };
}
u(gJ, "create_default_slot$1K");
function bJ(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y;
  return d = new De({
    props: {
      heading: "Trait Config",
      $$slots: { default: [gJ] },
      $$scope: { ctx: i }
    }
  }), g = new Mi({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), p = E("div"), j(d.$$.fragment), m = F(), j(g.$$.fragment), b(s, "class", "grant-image svelte-1k5niy5"), ze(s.src, n = /*grant*/
      i[1].img || /*$item*/
      i[2].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[1].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[1].label ?? "", b(a, "class", "grant-name svelte-1k5niy5"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1k5niy5"), b(t, "class", "sheet-header svelte-1k5niy5"), G(p, "display", "contents"), G(p, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1k5niy5");
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, f), A(e, p), R(d, p, null), A(e, m), R(g, e, null), h = !0, _ || (y = [
        W(
          s,
          "click",
          /*updateImage*/
          i[4]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[11]
        )
      ], _ = !0);
    },
    p(v, [k]) {
      (!h || k & /*grant, $item*/
      6 && !ze(s.src, n = /*grant*/
      v[1].img || /*$item*/
      v[2].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!h || k & /*grant*/
      2 && l !== (l = /*grant*/
      v[1].label)) && b(s, "alt", l), (!h || k & /*grant*/
      2 && c !== (c = /*grant*/
      v[1].label ?? "") && a.value !== c) && (a.value = c);
      const S = {};
      k & /*$$scope, grant, traitType, options*/
      131083 && (S.$$scope = { dirty: k, ctx: v }), d.$set(S);
    },
    i(v) {
      h || (w(d.$$.fragment, v), w(g.$$.fragment, v), h = !0);
    },
    o(v) {
      O(d.$$.fragment, v), O(g.$$.fragment, v), h = !1;
    },
    d(v) {
      v && C(e), N(d), N(g), _ = !1, Me(y);
    }
  };
}
u(bJ, "create_fragment$3F");
function _J(i, e, t) {
  let s, n, l, r, { document: o, grantId: a, grantType: c } = de("#external").application, { document: f = o, grantId: d = a, grantType: p = c } = e;
  function m() {
    const M = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: M,
      callback: /* @__PURE__ */ u((B) => {
        g("img", B);
      }, "callback")
    }).browse();
  }
  u(m, "updateImage");
  function g(M, L) {
    M === "traits.traitType" && te(r, `system.grants.${d}.traits`, { base: [], options: [], total: 0 }), M = `system.grants.${d}.${M}`, te(r, M, L);
  }
  u(g, "onUpdateValue"), Qt(() => {
    h.destroy();
  });
  const h = new Zt(f);
  pe(i, h, (M) => t(2, r = M));
  const _ = ug();
  lt("item", h), lt("grantId", d), lt("grantType", p);
  const y = /* @__PURE__ */ u(({ target: M }) => g("label", M.value), "change_handler"), v = /* @__PURE__ */ u(([M, { label: L }]) => [M, K(L)], "func"), k = /* @__PURE__ */ u(({ detail: M }) => {
    g("traits.traitType", M);
  }, "updateSelection_handler"), S = /* @__PURE__ */ u(({ detail: M }) => {
    g("traits.base", M);
  }, "updateSelection_handler_1"), D = /* @__PURE__ */ u(({ detail: M }) => {
    g("traits.options", M);
  }, "updateSelection_handler_2"), I = /* @__PURE__ */ u(({ target: M }) => g("traits.total", Number(M.value)), "change_handler_1");
  return i.$$set = (M) => {
    "document" in M && t(8, f = M.document), "grantId" in M && t(9, d = M.grantId), "grantType" in M && t(10, p = M.grantType);
  }, i.$$.update = () => {
    var M, L;
    i.$$.dirty & /*$item, grantId*/
    516 && t(1, s = r.system.grants[d]), i.$$.dirty & /*grant*/
    2 && t(0, n = ((M = s == null ? void 0 : s.traits) == null ? void 0 : M.traitType) || "armorTypes"), i.$$.dirty & /*traitType*/
    1 && t(3, l = ((L = _[n]) == null ? void 0 : L.config) ?? []);
  }, [
    n,
    s,
    r,
    l,
    m,
    g,
    h,
    _,
    f,
    d,
    p,
    y,
    v,
    k,
    S,
    D,
    I
  ];
}
u(_J, "instance$3w");
const F2 = class F2 extends re {
  constructor(e) {
    super(), oe(this, e, _J, bJ, le, { document: 8, grantId: 9, grantType: 10 });
  }
};
u(F2, "TraitGrantConfig");
let A_ = F2;
function yJ(i) {
  let e, t;
  return e = new tt({
    props: {
      options: (
        /*getOptions*/
        i[8](
          /*choicesLocked*/
          i[4]
        )
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[2]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*choicesLocked*/
      16 && (l.options = /*getOptions*/
      s[8](
        /*choicesLocked*/
        s[4]
      )), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      4 && (l.orange = /*choices*/
      s[2]), n & /*selected, totalCount*/
      9 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(yJ, "create_default_slot_2$J");
function vJ(i) {
  let e;
  return {
    c() {
      e = Q(
        /*summary*/
        i[5]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      32 && be(
        e,
        /*summary*/
        t[5]
      );
    },
    d(t) {
      t && C(e);
    }
  };
}
u(vJ, "create_default_slot_1$X");
function kJ(i) {
  let e, t, s, n, l;
  return e = new ie({
    props: {
      warning: (
        /*remainingSelections*/
        i[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[6]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[3]
      ),
      $$slots: { default: [yJ] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      $$slots: { default: [vJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), T(r, s, o), R(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*remainingSelections*/
      64 && (a.warning = /*remainingSelections*/
      r[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      r[6]} choices remaining.`), o & /*selected, totalCount*/
      9 && (a.showWarning = /*selected*/
      r[0].length < /*totalCount*/
      r[3]), o & /*$$scope, choicesLocked, selected, choices, totalCount*/
      65565 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, summary*/
      65568 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(s), r && e && C(t), N(e, r), N(n, r);
    }
  };
}
u(kJ, "create_default_slot$1J");
function wJ(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Trait Grant - " + /*grant*/
      i[1].label,
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*func*/
            i[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [kJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*grant*/
      2 && (r.heading = "Trait Grant - " + /*grant*/
      n[1].label), l & /*choicesLocked*/
      16 && (r.headerButtons = [
        {
          classes: "add-button",
          handler: (
            /*func*/
            n[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          n[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            n[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), l & /*$$scope, summary, remainingSelections, selected, totalCount, choicesLocked, choices*/
      65661 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(wJ, "create_fragment$3E");
function $J(i, e, t) {
  let s, n, l, { grant: r } = e, { base: o } = e, { choices: a } = e, { count: c } = e, { selected: f } = e, { traitType: d } = e;
  function p(k) {
    return "";
  }
  u(p, "getGrantSummary");
  function m({ detail: k }) {
    t(0, f = k), h("updateSelection", { selected: f, summary: l });
  }
  u(m, "onUpdateSelection");
  function g(k) {
    var L, B;
    const S = [], D = ((L = _[d]) == null ? void 0 : L.config.map(([z]) => z)) ?? [], I = a.filter((z) => !D.includes(z)), M = [...((B = _[d]) == null ? void 0 : B.config) ?? [], ...I.map((z) => [z, z])];
    if (!k) return M;
    for (const [z, q] of M)
      a.includes(z) && S.push([z, q]);
    return S;
  }
  u(g, "getOptions");
  const h = ft(), _ = ug();
  let y = !0;
  const v = /* @__PURE__ */ u(() => t(4, y = !y), "func");
  return i.$$set = (k) => {
    "grant" in k && t(1, r = k.grant), "base" in k && t(9, o = k.base), "choices" in k && t(2, a = k.choices), "count" in k && t(10, c = k.count), "selected" in k && t(0, f = k.selected), "traitType" in k && t(11, d = k.traitType);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    513 && t(0, f = [...new Set(o.concat(f))]), i.$$.dirty & /*base, count*/
    1536 && t(3, s = o.length + c), i.$$.dirty & /*totalCount, selected*/
    9 && t(6, n = s - f.length), i.$$.dirty & /*selected*/
    1 && t(5, l = p());
  }, [
    f,
    r,
    a,
    s,
    y,
    l,
    n,
    m,
    g,
    o,
    c,
    d,
    v
  ];
}
u($J, "instance$3v");
const R2 = class R2 extends re {
  constructor(e) {
    super(), oe(this, e, $J, wJ, le, {
      grant: 1,
      base: 9,
      choices: 2,
      count: 10,
      selected: 0,
      traitType: 11
    });
  }
};
u(R2, "TraitGrantSelectionDialog");
let E_ = R2;
var zh, Hh, Uh;
const N2 = class N2 extends Is {
  constructor() {
    super(...arguments);
    x(this, zh, E_);
    x(this, Hh, A_);
    x(this, Uh, "trait");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "trait" }),
      traits: new t.SchemaField({
        base: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        options: new t.ArrayField(new t.StringField({ required: !0, initial: "" }), {
          required: !0,
          initial: []
        }),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 }),
        traitType: new t.StringField({ required: !0, initial: "conditionImmunities" })
      }),
      label: new t.StringField({ required: !0, initial: "New Trait Grant" })
    });
  }
  getApplyData(t, s) {
    if (!t) return {};
    const n = (s == null ? void 0 : s.selected) ?? this.traits.base ?? [], l = this.traits.total, r = {
      traitData: {
        traits: n,
        total: l,
        traitType: this.traits.traitType
      },
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: P(this, Uh),
      level: this.level
    }, o = ug(), { propertyKey: a } = o[this.traits.traitType] ?? {};
    if (!a) return {};
    if (!n.length) return {};
    let c;
    return this.traits.traitType === "size" ? c = /* @__PURE__ */ new Set([n[0]]) : c = /* @__PURE__ */ new Set([
      ...n,
      ...foundry.utils.getProperty(t, a) ?? []
    ]), {
      [a]: [...c],
      "system.grants": {
        ...t.system.grants,
        [this._id]: r
      }
    };
  }
  getSelectionComponent() {
    return P(this, zh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.traits.base ?? [],
      choices: this.traits.options,
      count: this.traits.total,
      traitType: this.traits.traitType,
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.traits.options.length;
  }
  async configureGrant() {
    const t = {
      document: this.parent,
      grantId: this._id
    };
    super.configureGrant("Configure Trait Grant", t, P(this, Hh), {
      width: 400
    });
  }
};
zh = new WeakMap(), Hh = new WeakMap(), Uh = new WeakMap(), u(N2, "TraitGrant");
let S_ = N2;
const d4 = {
  base: Is,
  ability: Xb,
  attack: Jb,
  damage: Zb,
  exertion: xb,
  expertiseDice: s_,
  feature: l_,
  healing: r_,
  hitPoint: o_,
  initiative: a_,
  item: f_,
  movement: d_,
  proficiency: h_,
  rollOverride: __,
  senses: y_,
  skill: v_,
  skillSpecialty: $_,
  trait: S_
};
var Ln;
const Vh = class Vh extends Map {
  constructor(t) {
    super();
    x(this, Ln);
    Ae(this, Ln, t), Object.entries(P(this, Ln).system.grants ?? {}).forEach(([s, n]) => {
      n._id = s;
      let l = d4[n.grantType];
      l || console.warn(`Grant ${s} has no class mapping.`), l ?? (l = d4.base);
      const r = new l(n, { parent: t });
      this.set(s, r);
    });
  }
  get optionalGrants() {
    return [...this.values()].filter((t) => t.optional);
  }
  /**
   * @param {String} type
   * @returns
   */
  byType(t) {
    return [...this.values()].filter((s) => s.grantType === t);
  }
  byLevel(t) {
    return [...this.values()].filter((s) => s.level === t);
  }
  byLevelType(t) {
    return [...this.values()].filter((s) => s.levelType === t);
  }
  byLevelAndType(t, s) {
    return [...this.values()].filter(
      (n) => n.level === t && n.grantType === s
    );
  }
  /** ************************************************
   *               External methods
   * ************************************************ */
  async add(t = {}) {
    await Vh.addGrant(P(this, Ln), t);
  }
  // configure(id: string): void {
  //   const grant = this.get(id);
  //   if (!grant) return;
  //   grant.configureDialog();
  // }
  async clear() {
    await P(this, Ln).update({
      "system.-=grants": null
    }), await P(this, Ln).update({ "system.grants": {} });
  }
  async duplicate(t) {
    const s = foundry.utils.duplicate(P(this, Ln).system.grants[t]);
    s.name = `${s.name} (Copy)`, await P(this, Ln).update({
      "system.grants": {
        ...P(this, Ln).system.grants,
        // @ts-ignore
        [foundry.utils.randomID()]: s
      }
    });
  }
  // @ts-ignore
  async delete(t) {
    super.delete(t), await P(this, Ln).update({
      "system.grants": {
        [`-=${t}`]: null
      }
    });
    const s = P(this, Ln).parent;
    !s || s.documentName !== "Actor" || s.grants.removeGrant(t);
  }
  /** ************************************************
   *                Static methods
   * ************************************************ */
  static async addGrant(t, s = {}, n = !0, l = !1) {
    const r = foundry.utils.mergeObject(
      {
        grantType: "skill",
        level: 1,
        levelType: ["class", "archetype"].includes(t.type) ? "class" : "character"
      },
      s
    ), o = foundry.utils.randomID();
    r._id = o;
    const a = {
      "system.grants": {
        ...t.system.grants,
        // @ts-ignore
        [o]: r
      }
    };
    return n && await t.update(a), l ? [o, a] : a;
  }
};
Ln = new WeakMap(), u(Vh, "ItemGrantsManager");
let dc = Vh;
const j2 = class j2 extends ku {
  prepareBaseData() {
    super.prepareBaseData(), this.grants = new dc(this);
  }
  async _preCreate(e, t, s) {
    if (s._id !== game.userId) {
      super._preCreate(e, t, s);
      return;
    }
    if (this.parent && this.parent.documentName === "Actor") {
      const n = this.parent;
      t.keepId = !0, t.noGrant || n.grants.createInitialGrants(this, !1);
    }
    await super._preCreate(e, t, s);
  }
  async _onCreate(e, t, s) {
    super._onCreate(e, t, s);
  }
  async _onDelete(e, t) {
    var n;
    if (super._onDelete(e, t), !this.parent || ((n = this.parent) == null ? void 0 : n.documentName) !== "Actor") return;
    await this.parent.grants.removeGrantsByItem(this.uuid);
  }
};
u(j2, "OriginItemA5e");
let _r = j2;
const L2 = class L2 extends Map {
  constructor(t) {
    super();
    qe(this, "item");
    qe(this, "rollData", {});
    this.item = t, (this.item.system.resources ?? []).forEach((n) => {
      const l = n, r = l.slug || l.name.slugify({ strict: !0 });
      l.slug = r, this.set(r, l);
    }), this.rollData = {}, this.prepareResources();
  }
  get consumableResources() {
    return [...this.values()].filter((t) => t.consumable);
  }
  get level() {
    if (this.item.isType("class")) return this.item.system.classLevels;
    const t = this.item.class;
    return t ? t.system.classLevels : null;
  }
  prepareResources() {
    const { level: t } = this;
    t && [...this.entries()].forEach(([s, n]) => {
      var o;
      const l = ((o = n.reference) == null ? void 0 : o[t]) || "";
      let r = null;
      try {
        const a = this.item.isEmbedded ? this.item.parent ?? this.item : this.item;
        r = mt(
          l,
          // TODO: Types - Remove when types are fixed
          // @ts-ignore
          a.getRollData(this.item),
          { strict: !0 }
        );
      } catch {
        r = l;
      }
      r || (r = 0), this.rollData[s] = r;
    });
  }
  // @ts-ignore
  async add(t = {}) {
    if (!(t != null && t.name)) {
      const s = [...this].reduce(
        (n, [, { name: l }]) => l === "New Resource" ? n + 1 : n,
        0
      );
      s > 0 ? t.name = `New Resource ${s + 1}` : t.name = "New Resource";
    }
    t != null && t.recovery || (t.recovery = "longRest"), t != null && t.reference || (t.reference = {}), await this.item.update({
      "system.resources": [...this.item.system.resources, t]
    });
  }
  async remove(t) {
    const s = this.item.system.resources.filter(
      (n) => {
        var l;
        return n.slug !== t || ((l = n.name) == null ? void 0 : l.slugify({ strict: !0 })) !== t;
      }
    );
    await this.item.update({
      "system.resources": s
    });
  }
  async removeAll() {
    await this.item.update({
      "system.resources": []
    });
  }
};
u(L2, "ClassResourceManager");
let _p = L2;
const B2 = class B2 extends _r {
  get classLevels() {
    const e = this.class;
    return e ? e.system.classLevels : 0;
  }
  get slug() {
    return this.system.slug || this.name.slugify({ strict: !0 });
  }
  prepareBaseData() {
    super.prepareBaseData(), this.class = this.prepareClass(), this.resources = new _p(this), this.casting = this.prepareCasterData();
  }
  prepareClass() {
    var s, n;
    if (!this.isEmbedded) return null;
    this.system.class || (s = ui.notifications) == null || s.error("Archetype is missing a class reference.");
    const e = this.system.class, t = (n = this.actor) == null ? void 0 : n.items.find((l) => l.type === "class" && l.slug === e);
    return t || null;
  }
  prepareCasterData() {
    const { casterType: e } = this.system.spellcasting;
    if (!e || e === "none") return null;
    const t = CONFIG.A5E.casterProgression[e] ?? null;
    if (!t) return null;
    const { type: s, config: n, resource: l, multiplier: r, roundUp: o, multiclassMode: a } = t, c = { casterType: e, resource: l, progressionType: s };
    if (s === "multiplier" && l === "slots") {
      const f = Math.ceil, d = n[f(this.classLevels * (r ?? 1))] ?? [];
      c.slots = Object.fromEntries(
        d.map((p, m) => {
          const g = Math.round(1 / r) > this.classLevels;
          return r < 1 && g && !o ? [m + 1, 0] : [m + 1, p];
        })
      );
    }
    if (s === "reference") {
      const f = n[this.classLevels];
      c.multiclassMode = a, l === "slots" ? c.slots = { [f.level]: f.slots } : l === "points" ? (c.points = f.points, c.maxLevel = f.level) : l === "inventions" ? (c.inventions = f.count, c.maxLevel = f.level) : l === "artifactCharges" && (c.charges = f.charges, c.maxLevel = f.level);
    }
    return c;
  }
  getRollData() {
    var s;
    const e = { ...super.getRollData() }, t = ((s = this == null ? void 0 : this.resources) == null ? void 0 : s.rollData) ?? {};
    return e.actorTransfer = {
      resources: t,
      ...t
    }, e;
  }
  async _preCreate(e, t, s) {
    super._preCreate(e, t, s);
  }
  async _preUpdate(e, t, s) {
    super._preUpdate(e, t, s);
  }
  async _onCreate(e, t, s) {
    super._onCreate(e, t, s);
  }
  _onUpdate(e, t, s) {
    super._onUpdate(e, t, s);
  }
  async _onDelete(e, t) {
    super._onDelete(e, t);
  }
};
u(B2, "ArchetypeItemA5e");
let C_ = B2;
const Wh = class Wh extends foundry.data.fields.ObjectField {
  // TODO: Add unknown keys
  constructor(t, s, n) {
    super(n);
    qe(this, "keyField");
    qe(this, "valueField");
    if (!this._isValidKeyFieldType(t))
      throw new Error("key field must be a StringField or a NumberField");
    if (this.keyField = t, !(s instanceof foundry.data.fields.DataField))
      throw new Error(`${this.name} must have a DataField as its contained field`);
    this.valueField = s;
  }
  _isValidKeyFieldType(t) {
    if (t instanceof foundry.data.fields.StringField || t instanceof foundry.data.fields.NumberField) {
      if (t.options.required !== !0 || t.options.nullable === !0)
        throw new Error("key field must be required and non-nullable");
      return !0;
    }
    return !1;
  }
  // eslint-disable-next-line consistent-return
  _validateValues(t, s = {}) {
    const n = foundry.data.validation.DataModelValidationFailure, l = new n();
    for (const [r, o] of Object.entries(t)) {
      if (r.startsWith("-=") && (s != null && s.partial)) continue;
      const a = this.keyField.validate(r, s);
      a && l.elements.push({ id: r, failure: a });
      const c = this.valueField.validate(o, s);
      c && l.elements.push({ id: `${r}-value`, failure: c });
    }
    if (l.elements.length)
      return l;
  }
  _cleanType(t, s) {
    for (const [n, l] of Object.entries(t))
      t[n] = this.valueField.clean(l, s);
    return t;
  }
  _validateType(t, s = {}) {
    return t instanceof Object ? this._validateValues(t, s) : new foundry.data.validation.DataModelValidationFailure({
      message: "must be an Object"
    });
  }
  initialize(t, s, n) {
    if (!t) return {};
    const l = {};
    for (const [r, o] of Object.entries(t))
      l[r] = this.valueField.initialize(o, s, n);
    return l;
  }
};
u(Wh, "RecordField"), qe(Wh, "recursive", !0);
let Vs = Wh;
const { fields: qs } = foundry.data, Vl = /* @__PURE__ */ u(() => ({
  quantity: new qs.NumberField({ required: !0, nullable: !1, initial: 1 }),
  scaling: new qs.ObjectField({ required: !0, nullable: !1 }),
  // TODO: Actions
  placeTemplate: new qs.BooleanField({ required: !0, nullable: !1, initial: !0 }),
  default: new qs.BooleanField({ required: !0, nullable: !1, initial: !0 }),
  label: new qs.StringField({ required: !0, nullable: !1, initial: "" }),
  shape: new qs.StringField({ required: !0, nullable: !1, initial: "" })
}), "baseSchema$4"), AJ = /* @__PURE__ */ u(() => ({
  radius: new qs.NumberField({ required: !0, nullable: !1, initial: 0 }),
  ...Vl()
}), "circleAreaSchema"), EJ = /* @__PURE__ */ u(() => ({
  length: new qs.NumberField({ required: !0, nullable: !1, initial: 0 }),
  ...Vl()
}), "coneAreaSchema"), SJ = /* @__PURE__ */ u(() => ({
  width: new qs.NumberField({ required: !0, nullable: !1, initial: 0 }),
  ...Vl()
}), "cubeAreaSchema"), CJ = /* @__PURE__ */ u(() => ({
  radius: new qs.NumberField({ required: !0, nullable: !1, initial: 0 }),
  height: new qs.NumberField({ required: !0, nullable: !1, initial: 0 }),
  ...Vl()
}), "cylinderAreaSchema"), TJ = /* @__PURE__ */ u(() => ({
  radius: new qs.NumberField({ required: !0, nullable: !1, initial: 0 }),
  ...Vl()
}), "emanationAreaSchema"), OJ = /* @__PURE__ */ u(() => ({
  length: new qs.NumberField({ required: !0, nullable: !1, initial: 0 }),
  width: new qs.NumberField({ required: !0, nullable: !1, initial: 5 }),
  ...Vl()
}), "lineAreaSchema"), DJ = /* @__PURE__ */ u(() => ({
  radius: new qs.NumberField({ required: !0, nullable: !1, initial: 0 }),
  ...Vl()
}), "sphereAreaSchema"), IJ = /* @__PURE__ */ u(() => ({
  width: new qs.NumberField({ required: !0, nullable: !1, initial: 0 }),
  ...Vl()
}), "squareAreaSchema"), PJ = /* @__PURE__ */ u(() => ({
  height: new qs.NumberField({ required: !0, nullable: !1, initial: 0 }),
  length: new qs.NumberField({ required: !0, nullable: !1, initial: 0 }),
  width: new qs.NumberField({ required: !0, nullable: !1, initial: 0 }),
  ...Vl()
}), "wallAreaSchema"), q2 = class q2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...AJ()
    };
  }
};
u(q2, "CircleAreaData");
let T_ = q2;
const G2 = class G2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...EJ()
    };
  }
};
u(G2, "ConeAreaData");
let O_ = G2;
const z2 = class z2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...SJ()
    };
  }
};
u(z2, "CubeAreaData");
let D_ = z2;
const H2 = class H2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...CJ()
    };
  }
};
u(H2, "CylinderAreaData");
let I_ = H2;
const U2 = class U2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...TJ()
    };
  }
};
u(U2, "EmanationAreaData");
let P_ = U2;
const V2 = class V2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...OJ()
    };
  }
};
u(V2, "LineAreaData");
let M_ = V2;
const W2 = class W2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...DJ()
    };
  }
};
u(W2, "SphereAreaData");
let F_ = W2;
const K2 = class K2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...IJ()
    };
  }
};
u(K2, "SquareAreaData");
let R_ = K2;
const Y2 = class Y2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...PJ()
    };
  }
};
u(Y2, "WallAreaData");
let N_ = Y2;
const { fields: on } = foundry.data, id = /* @__PURE__ */ u(() => ({
  default: new on.BooleanField({ required: !0, nullable: !1, initial: !0 }),
  label: new on.StringField({ required: !0, nullable: !1, initial: "" }),
  type: new on.StringField({ required: !0, nullable: !1, initial: "" })
}), "baseSchema$3"), x9 = /* @__PURE__ */ u(() => ({
  quantity: new on.NumberField({ required: !0, nullable: !1, initial: 1 }),
  ...id()
}), "usesSchema"), eB = /* @__PURE__ */ u(() => ({
  itemId: new on.StringField({ required: !0, nullable: !1, initial: "" }),
  quantity: new on.NumberField({ required: !0, nullable: !1, initial: 0 }),
  deleteOnZero: new on.BooleanField({ required: !0, nullable: !1, initial: !1 }),
  ...id()
}), "quantitySchema"), MJ = /* @__PURE__ */ u(() => ({
  quantity: new on.NumberField({ required: !0, nullable: !1, initial: 0 }),
  ...id()
}), "hitDiceSchema"), FJ = /* @__PURE__ */ u(() => ({
  classIdentifier: new on.StringField({ required: !0, nullable: !1, initial: "" }),
  quantity: new on.NumberField({ required: !0, nullable: !1, initial: 0 }),
  resource: new on.StringField({ required: !0, nullable: !1, initial: "" }),
  restore: new on.BooleanField({ required: !0, nullable: !1, initial: !1 }),
  ...id()
}), "resourceSchema"), RJ = /* @__PURE__ */ u(() => ({
  mode: new on.StringField({
    required: !0,
    nullable: !1,
    initial: "variable",
    choices: [...CONFIG.A5E.SPELL_CONSUMER_MODES]
  }),
  charges: new on.NumberField({ required: !0, nullable: !1, initial: 0 }),
  points: new on.NumberField({ required: !0, nullable: !1, initial: 0 }),
  spellLevel: new on.NumberField({ required: !0, nullable: !1, initial: 0 }),
  ...id()
}), "spellSchema"), X2 = class X2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...x9()
    };
  }
};
u(X2, "ActionUsesConsumerData");
let j_ = X2;
const J2 = class J2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...eB()
    };
  }
};
u(J2, "AmmunitionConsumerData");
let L_ = J2;
const Z2 = class Z2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...MJ()
    };
  }
};
u(Z2, "HitDiceConsumerData");
let B_ = Z2;
const Q2 = class Q2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...x9()
    };
  }
};
u(Q2, "ItemUsesConsumerData");
let q_ = Q2;
const x2 = class x2 extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...eB()
    };
  }
};
u(x2, "QuantityConsumerData");
let G_ = x2;
const eA = class eA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...FJ()
    };
  }
};
u(eA, "ResourceConsumerData");
let z_ = eA;
const tA = class tA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...RJ()
    };
  }
};
u(tA, "SpellConsumerData");
let H_ = tA;
const { fields: ci } = foundry.data, fg = /* @__PURE__ */ u(() => ({
  default: new ci.BooleanField({ required: !0, nullable: !1, initial: !0 }),
  label: new ci.StringField({ required: !0, nullable: !1, initial: "" }),
  type: new ci.StringField({ required: !0, nullable: !1, initial: "" })
}), "baseSchema$2"), NJ = /* @__PURE__ */ u(() => ({
  ability: new ci.StringField({ required: !0, nullable: !1, initial: "str" }),
  ...fg()
}), "abilityCheckSchema$1"), jJ = /* @__PURE__ */ u(() => ({
  ability: new ci.StringField({ required: !0, nullable: !1, initial: "str" }),
  saveDC: new ci.SchemaField({
    bonus: new ci.StringField({ required: !0, nullable: !1, initial: "" }),
    type: new ci.StringField({ required: !0, nullable: !1, initial: "spellcasting" })
  }),
  onSave: new ci.StringField({ required: !0, nullable: !1, initial: "" }),
  ...fg()
}), "abilitySaveSchema"), LJ = /* @__PURE__ */ u(() => ({
  formula: new ci.StringField({ required: !0, nullable: !1, initial: "" }),
  ...fg()
}), "genericSchema"), BJ = /* @__PURE__ */ u(() => ({
  ability: new ci.StringField({ required: !0, nullable: !1, initial: "" }),
  skill: new ci.StringField({ required: !0, nullable: !1, initial: "acr" }),
  ...fg()
}), "skillCheckSchema"), sA = class sA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...NJ()
    };
  }
};
u(sA, "AbilityCheckPromptData");
let U_ = sA;
const nA = class nA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...LJ()
    };
  }
};
u(nA, "GenericPromptData");
let V_ = nA;
const iA = class iA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...BJ()
    };
  }
};
u(iA, "SkillCheckPromptData");
let W_ = iA;
const lA = class lA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...jJ()
    };
  }
};
u(lA, "SavingThrowPromptData");
let K_ = lA;
const { fields: xt } = foundry.data, Dr = /* @__PURE__ */ u(() => ({
  default: new xt.BooleanField({ required: !0, nullable: !1, initial: !0 }),
  label: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  type: new xt.StringField({ required: !0, nullable: !1, initial: "" })
}), "baseSchema$1"), qJ = /* @__PURE__ */ u(() => ({
  ability: new xt.StringField({ required: !0, nullable: !1, initial: "str" }),
  bonus: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  ...Dr()
}), "abilityCheckSchema"), GJ = /* @__PURE__ */ u(() => ({
  ability: new xt.StringField({ required: !0, nullable: !1, initial: "default" }),
  attackType: new xt.StringField({
    required: !0,
    nullable: !1,
    initial: "meleeWeaponAttack",
    choices: ["meleeWeaponAttack", "rangedWeaponAttack", "meleeSpellAttack", "rangedSpellAttack"]
  }),
  bonus: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  critThreshold: new xt.NumberField({ required: !0, nullable: !1, initial: 20 }),
  proficient: new xt.BooleanField({ required: !0, nullable: !1, initial: !0 }),
  ...Dr()
}), "attackRollSchema"), zJ = /* @__PURE__ */ u(() => ({
  canCrit: new xt.BooleanField({ required: !0, nullable: !1, initial: !0 }),
  critBonus: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  damageType: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  formula: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  scaling: new xt.ObjectField({ required: !0, nullable: !1 }),
  // TODO: Make this proper
  ...Dr()
}), "damageRollSchema"), HJ = /* @__PURE__ */ u(() => ({
  formula: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  scaling: new xt.ObjectField({ required: !0, nullable: !1 }),
  // TODO: Make this proper
  ...Dr()
}), "genericRollSchema"), UJ = /* @__PURE__ */ u(() => ({
  formula: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  healingType: new xt.StringField({ required: !0, nullable: !1, initial: "healing" }),
  scaling: new xt.ObjectField({ required: !0, nullable: !1 }),
  // TODO: Make this proper
  ...Dr()
}), "healingRollSchema"), VJ = /* @__PURE__ */ u(() => ({
  ability: new xt.StringField({ required: !0, nullable: !1, initial: "str" }),
  bonus: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  ...Dr()
}), "savingThrowSchema"), WJ = /* @__PURE__ */ u(() => ({
  ability: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  skill: new xt.StringField({ required: !0, nullable: !1, initial: "acr" }),
  bonus: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  ...Dr()
}), "skillCheckRollSchema"), KJ = /* @__PURE__ */ u(() => ({
  ability: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  tool: new xt.StringField({ required: !0, nullable: !1, initial: "airVehicles" }),
  bonus: new xt.StringField({ required: !0, nullable: !1, initial: "" }),
  ...Dr()
}), "toolCheckRollSchema"), rA = class rA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...qJ()
    };
  }
};
u(rA, "AbilityCheckRollData");
let Y_ = rA;
const oA = class oA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...GJ()
    };
  }
};
u(oA, "AttackRollData");
let X_ = oA;
const aA = class aA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...zJ()
    };
  }
};
u(aA, "DamageRollData");
let J_ = aA;
const cA = class cA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...HJ()
    };
  }
};
u(cA, "GenericRollData");
let Z_ = cA;
const uA = class uA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...UJ()
    };
  }
};
u(uA, "HealingRollData");
let Q_ = uA;
const fA = class fA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...VJ()
    };
  }
};
u(fA, "SavingThrowRollData");
let x_ = fA;
const dA = class dA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...WJ()
    };
  }
};
u(dA, "SkillCheckRollData");
let ey = dA;
const pA = class pA extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...KJ()
    };
  }
};
u(pA, "ToolCheckRollData");
let ty = pA;
const YJ = {
  circle: T_,
  cone: O_,
  cube: D_,
  cylinder: I_,
  emanation: P_,
  line: M_,
  sphere: F_,
  square: R_,
  wall: N_
}, mA = class mA extends foundry.data.fields.ObjectField {
  getModelForType(e) {
    return YJ[e];
  }
  _cleanType(e, t) {
    typeof e != "object" && (e = {});
    const s = this.getModelForType(e == null ? void 0 : e.type);
    return s ? s.cleanData(e, t) : e;
  }
  initialize(e, t, s = {}) {
    const n = this.getModelForType(e == null ? void 0 : e.type);
    return n ? new n(e, { parent: t, ...s }) : foundry.utils.deepClone(e);
  }
};
u(mA, "ActionAreaField");
let p4 = mA;
const XJ = {
  actionUses: j_,
  ammunition: L_,
  hitDice: B_,
  itemUses: q_,
  quantity: G_,
  resource: z_,
  spell: H_
}, hA = class hA extends foundry.data.fields.ObjectField {
  getModelForType(e) {
    return XJ[e];
  }
  _cleanType(e, t) {
    typeof e != "object" && (e = {});
    const s = this.getModelForType(e == null ? void 0 : e.type);
    return s ? s.cleanData(e, t) : e;
  }
  initialize(e, t, s = {}) {
    const n = this.getModelForType(e == null ? void 0 : e.type);
    return n ? new n(e, { parent: t, ...s }) : foundry.utils.deepClone(e);
  }
};
u(hA, "ActionConsumerField");
let sy = hA;
const JJ = {
  abilityCheck: U_,
  generic: V_,
  savingThrow: K_,
  skillCheck: W_
}, gA = class gA extends foundry.data.fields.ObjectField {
  getModelForType(e) {
    return JJ[e];
  }
  _cleanType(e, t) {
    typeof e != "object" && (e = {});
    const s = this.getModelForType(e == null ? void 0 : e.type);
    return s ? s.cleanData(e, t) : e;
  }
  initialize(e, t, s = {}) {
    const n = this.getModelForType(e == null ? void 0 : e.type);
    return n ? new n(e, { parent: t, ...s }) : foundry.utils.deepClone(e);
  }
};
u(gA, "ActionPromptField");
let ny = gA;
const ZJ = {
  abilityCheck: Y_,
  attack: X_,
  damage: J_,
  generic: Z_,
  healing: Q_,
  savingThrow: x_,
  skillCheck: ey,
  toolCheck: ty
}, bA = class bA extends foundry.data.fields.ObjectField {
  getModelForType(e) {
    return ZJ[e];
  }
  _cleanType(e, t) {
    typeof e != "object" && (e = {});
    const s = this.getModelForType(e == null ? void 0 : e.type);
    return s ? s.cleanData(e, t) : e;
  }
  initialize(e, t, s = {}) {
    const n = this.getModelForType(e == null ? void 0 : e.type);
    return n ? new n(e, { parent: t, ...s }) : foundry.utils.deepClone(e);
  }
};
u(bA, "ActionRollField");
let iy = bA;
const { fields: Pt } = foundry.data, QJ = /* @__PURE__ */ u(() => ({
  id: new Pt.StringField({ required: !0, nullable: !1, initial: "" }),
  name: new Pt.StringField({ required: !0, nullable: !1, initial: "New Action" }),
  default: new Pt.BooleanField({ required: !0, nullable: !1, initial: !1 }),
  description: new Pt.StringField({ required: !0, nullable: !1, initial: "" }),
  descriptionOutputs: new Pt.ArrayField(
    new Pt.StringField({ required: !0, nullable: !1, choices: ["action", "item"] }),
    { required: !0, nullable: !1, initial: ["item", "action"] }
  ),
  img: new Pt.StringField({ required: !0, initial: "" }),
  activation: new Pt.SchemaField({
    cost: new Pt.NumberField({ required: !0, nullable: !1, initial: 1 }),
    type: new Pt.StringField({ required: !0, nullable: !0, initial: "" }),
    reactionTrigger: new Pt.StringField({ required: !0, nullable: !1, initial: "" })
  }),
  area: new Pt.ObjectField({ required: !1, nullable: !0, initial: /* @__PURE__ */ u(() => {
  }, "initial") }),
  duration: new Pt.SchemaField({
    unit: new Pt.StringField({ required: !0, nullable: !1, initial: "" }),
    value: new Pt.NumberField({ required: !0, nullable: !1, initial: 0 })
  }),
  effects: new Pt.SetField(
    new Pt.StringField({ required: !0, nullable: !1, initial: "" }),
    { required: !0, nullable: !1 }
  ),
  // @ts-expect-error
  macro: new Pt.JavaScriptField({ required: !0, nullable: !1, initial: "", async: !0 }),
  consumers: new Vs(
    new Pt.DocumentIdField({
      required: !0,
      nullable: !1,
      initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial")
    }),
    new sy({ required: !0, nullable: !1 })
  ),
  prompts: new Vs(
    new Pt.DocumentIdField({
      required: !0,
      nullable: !1,
      initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial")
    }),
    new ny({ required: !0, nullable: !1 })
  ),
  ranges: new Pt.ObjectField({ required: !0, nullable: !1 }),
  rolls: new Vs(
    new Pt.DocumentIdField({
      required: !0,
      nullable: !1,
      initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial")
    }),
    new iy({ required: !0, nullable: !1 })
  ),
  target: new Pt.SchemaField({
    quantity: new Pt.NumberField({ required: !0, nullable: !1, initial: 0 }),
    scaling: new Pt.ObjectField({ required: !0, nullable: !1 }),
    type: new Pt.StringField({ required: !0, nullable: !1, initial: "" })
  }),
  uses: new Pt.SchemaField({
    value: new Pt.NumberField({ required: !0, nullable: !1, initial: 0 }),
    max: new Pt.StringField({ required: !0, nullable: !1, initial: "" }),
    per: new Pt.StringField({ required: !0, nullable: !1, initial: "" }),
    recharge: new Pt.SchemaField({
      formula: new Pt.StringField({ required: !0, nullable: !1 }),
      threshold: new Pt.NumberField({ required: !0, nullable: !1, initial: 0 })
    })
  })
}), "actionSchema"), _A = class _A extends foundry.abstract.DataModel {
  static defineSchema() {
    return {
      ...QJ()
    };
  }
  _initialize(e) {
    super._initialize(e), this.prepareBaseData(), this.prepareDerivedData();
  }
  /** -------------Helpers---------------- */
  rollsByType(e) {
    return Object.entries(this.rolls ?? {}).filter(([, s]) => s.type === e);
  }
  prepareBaseData() {
    this.img || (this.img = this.parent.parent.img || "");
  }
  prepareDerivedData() {
  }
};
u(_A, "A5EActionData");
let yp = _A;
const yA = class yA extends foundry.data.fields.ObjectField {
  _cleanType(e, t) {
    return typeof e != "object" && (e = {}), yp.cleanData(e, t);
  }
  initialize(e, t, s = {}) {
    return new yp(e, { parent: t, ...s });
  }
};
u(yA, "ActionField");
let ly = yA;
const { fields: ys } = foundry.data, dg = /* @__PURE__ */ u(() => ({
  // actions: new fields.ObjectField({ required: true, initial: {} })
  actions: new Vs(
    new ys.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
    new ly()
  )
}), "actions"), tB = /* @__PURE__ */ u(() => ({
  ac: new ys.SchemaField({
    baseFormula: new ys.StringField({ required: !0, initial: "" }),
    formula: new ys.StringField({ required: !0, initial: "" }),
    grantsDisadvantage: new ys.BooleanField({ required: !0, initial: !1 }),
    maxDex: new ys.NumberField({ required: !0, initial: 0, min: 0 }),
    minStr: new ys.NumberField({ required: !0, initial: 0, min: 0 }),
    mode: new ys.NumberField({ required: !0, initial: 2 }),
    requiresNoShield: new ys.BooleanField({ required: !0, initial: !1 }),
    requiresUnarmored: new ys.BooleanField({ required: !0, initial: !1 })
  })
}), "armor$1"), xJ = /* @__PURE__ */ u(() => ({
  description: new ys.HTMLField({ required: !0, initial: "" })
}), "description"), eZ = /* @__PURE__ */ u(() => ({
  secretDescription: new ys.HTMLField({ required: !0, initial: "" })
}), "secretDescription"), tZ = /* @__PURE__ */ u(() => ({
  favorite: new ys.BooleanField({ required: !0, initial: !1 })
}), "favorite"), sZ = /* @__PURE__ */ u(() => ({
  macro: new ys.JavaScriptField({ required: !0, nullable: !1, initial: "", async: !0 })
}), "macro"), nZ = /* @__PURE__ */ u(() => ({
  source: new ys.StringField({ required: !0, initial: "" })
}), "source$1"), pg = /* @__PURE__ */ u(() => ({
  uses: new ys.SchemaField({
    value: new ys.NumberField({
      required: !0,
      initial: 0,
      min: 0,
      integer: !0,
      nullable: !1
    }),
    max: new ys.StringField({ required: !0, initial: "", nullable: !1 }),
    per: new ys.StringField({ required: !0, initial: "" }),
    recharge: new ys.SchemaField({
      formula: new ys.StringField({ required: !0, initial: "" }),
      threshold: new ys.NumberField({ required: !0, initial: 0, integer: !0 })
    })
  })
}), "uses"), { fields: Xl } = foundry.data, mg = /* @__PURE__ */ u(() => ({
  migrationData: new Xl.SchemaField({
    version: new Xl.NumberField({
      required: !0,
      nullable: !0,
      initial: null
    }),
    type: new Xl.StringField({ required: !0, nullable: !1, initial: "" }),
    lastMigration: new Xl.SchemaField({
      schema: new Xl.NumberField({ nullable: !0 }),
      system: new Xl.StringField({ nullable: !0, required: !1 }),
      foundry: new Xl.StringField({ nullable: !0, required: !1 })
    })
  })
}), "migrationData"), sB = /* @__PURE__ */ u(() => ({
  source: new Xl.StringField({ required: !0, initial: "" })
}), "source"), vA = class vA extends foundry.abstract.TypeDataModel {
  /** @inheritDoc */
  static defineSchema() {
    return {
      ...xJ(),
      ...tZ(),
      ...sZ(),
      ...mg(),
      ...eZ(),
      ...nZ()
    };
  }
};
u(vA, "A5EBaseItemData");
let bi = vA;
const { fields: Ms } = foundry.data, iZ = {
  slug: new Ms.StringField({ nullable: !1, initial: "" }),
  class: new Ms.StringField({ nullable: !1, initial: "" }),
  grants: new Ms.ObjectField({ nullable: !1 }),
  resources: new Ms.ArrayField(
    new Ms.SchemaField({
      name: new Ms.StringField({ nullable: !1, initial: "New Resource" }),
      consumable: new Ms.BooleanField({ nullable: !1, required: !0, initial: !1 }),
      displayOnCore: new Ms.BooleanField({ nullable: !1, required: !0, initial: !0 }),
      reference: new Ms.SchemaField(
        Array.from({ length: 20 }, (i, e) => e + 1).reduce((i, e) => (i[e] = new Ms.StringField({ required: !0, initial: "" }), i), {})
      ),
      recovery: new Ms.StringField({ nullable: !1, initial: "longRest" }),
      slug: new Ms.StringField({ nullable: !1, initial: "" })
    }),
    { nullable: !1, initial: [] }
  ),
  spellcasting: new Ms.SchemaField({
    ability: new Ms.SchemaField({
      base: new Ms.StringField({ nullable: !1, initial: "none" }),
      options: new Ms.ArrayField(new Ms.StringField({ nullable: !1, initial: "none" }), {
        nullable: !1,
        initial: []
      }),
      value: new Ms.StringField({ nullable: !1, initial: "none" })
    }),
    casterType: new Ms.StringField({ nullable: !1, initial: "none" })
  })
}, kA = class kA extends bi {
  /** @inheritDoc */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      ...iZ
    };
  }
};
u(kA, "A5EArchetypeData");
let vp = kA;
const wA = class wA extends _r {
  get associatedLevels() {
    const { levels: e } = this.system.hp;
    return Object.entries(e ?? {}).reduce((t, [s, n]) => (n && t.push(s), t), []);
  }
  get averageHP() {
    return Math.floor(this.hitDice.size / 2) + 1;
  }
  get classLevels() {
    return this.system.classLevels;
  }
  get isStartingClass() {
    var e;
    return this.isEmbedded ? ((e = this.parent) == null ? void 0 : e.system.classes.startingClass) === this.slug : !1;
  }
  // TODO: Class documents - Cache this
  get maxHP() {
    return this.prepareMaxHitPoints();
  }
  get archetype() {
    var s;
    if (!this.isEmbedded) return null;
    const { slug: e } = this, t = (s = this.parent) == null ? void 0 : s.items.find(
      (n) => n.system instanceof vp && n.system.class === e
    );
    return t || null;
  }
  get slug() {
    return this.system.slug || this.name.slugify({ strict: !0 });
  }
  get totalHitDice() {
    return this.classLevels;
  }
  prepareBaseData() {
    super.prepareBaseData(), this.resources = new _p(this), this.hitDice = {
      current: this.totalHitDice - this.system.hp.hitDiceUsed,
      total: this.totalHitDice,
      size: this.system.hp.hitDiceSize
    }, this.casting = this.prepareCasterData();
  }
  prepareMaxHitPoints() {
    const { levels: e } = this.system.hp, t = this.isEmbedded ? this.parent : null, s = t ? t.levels.character : 20;
    return Object.entries(e ?? {}).reduce((n, [l, r]) => !r || l > s ? n : n + r, 0);
  }
  prepareCasterData() {
    var f;
    const { casterType: e } = this.system.spellcasting;
    if (!e || e === "none" || !this.classLevels)
      return ((f = this.archetype) == null ? void 0 : f.casting) ?? null;
    const t = CONFIG.A5E.casterProgression[e] ?? null;
    if (!t) return null;
    const { type: s, config: n, resource: l, multiplier: r, roundUp: o, multiclassMode: a } = t, c = { casterType: e, resource: l, progressionType: s };
    if (s === "multiplier" && l === "slots") {
      const d = Math.ceil, p = n[d(this.classLevels * (r ?? 1))] ?? [];
      c.slots = Object.fromEntries(
        p.map((m, g) => {
          const h = Math.round(1 / r) > this.classLevels;
          return r < 1 && h && !o ? [g + 1, 0] : [g + 1, m];
        })
      );
    }
    if (s === "reference") {
      const d = n[this.classLevels];
      c.multiclassMode = a, l === "slots" ? c.slots = { [d.level]: d.slots } : l === "points" ? (c.points = d.points, c.maxLevel = d.level) : l === "inventions" ? (c.inventions = d.count, c.maxLevel = d.level) : l === "artifactCharges" && (c.charges = d.charges, c.maxLevel = d.level);
    }
    return c;
  }
  getRollData() {
    var n, l;
    const e = { ...super.getRollData() }, t = ((n = this == null ? void 0 : this.resources) == null ? void 0 : n.rollData) ?? {}, { archetype: s } = this;
    if (s) {
      const r = ((l = s == null ? void 0 : s.resources) == null ? void 0 : l.rollData) ?? {};
      Object.assign(t, r);
    }
    return e.actorTransfer = {
      level: this.classLevels,
      hitDiceSize: this.system.hp.hitDiceSize,
      hitDiceUsed: this.system.hp.hitDiceUsed,
      resources: t,
      ...t
    }, e;
  }
  // eslint-disable-next-line consistent-return
  async _preCreate(e, t, s) {
    var n, l, r;
    if (foundry.utils.setProperty(e, "system.classLevels", 1), foundry.utils.setProperty(e, "system.hp.hitDiceUsed", 0), Array.from({ length: 19 }, (o, a) => a + 2).forEach((o) => {
      foundry.utils.setProperty(e, `system.hp.levels.${o}`, 0);
    }), ((n = this.parent) == null ? void 0 : n.documentName) === "Actor") {
      const o = this.parent, { classes: a } = o;
      if (Object.keys(a).length)
        foundry.utils.setProperty(e, "system.hp.levels.1", 0);
      else {
        await o.update({ "system.classes.startingClass": this.slug });
        const f = ((r = (l = this == null ? void 0 : this.system) == null ? void 0 : l.hp) == null ? void 0 : r.hitDiceSize) ?? 6;
        foundry.utils.setProperty(e, "system.hp.levels.1", f);
      }
      const c = a[this.slug];
      if (c)
        return c.update({ "system.classLevels": Math.min(c.system.classLevels + 1, 20) }), !1;
    }
    this.updateSource(e), await super._preCreate(e, t, s);
  }
  // eslint-disable-next-line consistent-return
  async _preUpdate(e, t, s) {
    var l, r;
    await super._preUpdate(e, t, s);
    const n = Object.keys(foundry.utils.flattenObject(e));
    if (n.includes("system.hp.hitDiceSize") && (this.isStartingClass || !this.parent)) {
      const o = foundry.utils.getProperty(e, "system.hp.hitDiceSize");
      await this.updateSource({ "system.hp.levels.1": o });
    }
    if (n.includes("system.slug") && this.isStartingClass && ((l = this.parent) == null ? void 0 : l.documentName) === "Actor") {
      const o = foundry.utils.getProperty(e, "system.slug");
      this.parent.update({ "system.classes.startingClass": o });
    }
    if (n.includes("system.hp.hitDiceUsed")) {
      const o = foundry.utils.getProperty(e, "system.hp.hitDiceUsed"), a = this.totalHitDice;
      await this.updateSource({ "system.hp.hitDiceUsed": Math.clamp(o, 0, a) });
    }
    if (((r = this.parent) == null ? void 0 : r.documentName) === "Actor" && n.includes("system.classLevels")) {
      const o = this.parent, a = this.system.classLevels, c = foundry.utils.getProperty(e, "system.classLevels");
      if (!await o.grants.createLeveledGrants(a, c, this)) return !1;
    }
  }
  async _onCreate(e, t, s) {
    var n;
    if (super._onCreate(e, t, s), this.isEmbedded) {
      const l = this.resources.level ?? 1, r = this.resources.consumableResources.reduce((o, a) => {
        var c;
        return o[a.slug] = mt(a.reference[l], (c = this.actor) == null ? void 0 : c.getRollData()) ?? 0, o;
      }, {});
      (n = this.actor) == null || n.update({
        "system.resources.classResources": r
      });
    }
  }
  _onUpdate(e, t, s) {
    super._onUpdate(e, t, s);
  }
  async _onDelete(e, t) {
    var s, n;
    if (await super._onDelete(e, t), this.isStartingClass && ((s = this.parent) == null ? void 0 : s.documentName) === "Actor" && this.parent.update({ "system.classes.startingClass": "" }), this.isEmbedded) {
      const { archetype: l } = this;
      l && l.delete();
      const r = this.resources.consumableResources.reduce((o, a) => (o[`-=${a.slug}`] = null, o), {});
      (n = this.actor) == null || n.update({ "system.resources.classResources": r });
    }
  }
};
u(wA, "ClassItemA5e");
let ry = wA;
function lZ(i) {
  let e, t, s, n, l, r, o;
  return t = new Ke({
    props: {
      heading: "Select an Action",
      options: (
        /*options*/
        i[2]
      ),
      selected: (
        /*selectedAction*/
        i[0]
      )
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[5]
  ), {
    c() {
      e = E("form"), j(t.$$.fragment), s = F(), n = E("button"), n.textContent = "Activate Action", b(e, "class", "svelte-12vq8l");
    },
    m(a, c) {
      T(a, e, c), R(t, e, null), A(e, s), A(e, n), l = !0, r || (o = W(n, "click", st(
        /*onSubmit*/
        i[1]
      )), r = !0);
    },
    p(a, [c]) {
      const f = {};
      c & /*selectedAction*/
      1 && (f.selected = /*selectedAction*/
      a[0]), t.$set(f);
    },
    i(a) {
      l || (w(t.$$.fragment, a), l = !0);
    },
    o(a) {
      O(t.$$.fragment, a), l = !1;
    },
    d(a) {
      a && C(e), N(t), r = !1, o();
    }
  };
}
u(lZ, "create_fragment$3D");
function rZ(i, e, t) {
  let { dialog: s, item: n } = de("#external").application, { dialog: l = s, item: r = n } = e;
  function o() {
    l.submit({ actionId: a });
  }
  u(o, "onSubmit");
  let a = r.actions.default.id, c = [...r.actions.entries()].map(([d, p]) => [d, p.name]).sort((d, p) => d[1].localeCompare(p[1]));
  const f = /* @__PURE__ */ u(({ detail: d }) => t(0, a = d), "updateSelection_handler");
  return i.$$set = (d) => {
    "dialog" in d && t(3, l = d.dialog), "item" in d && t(4, r = d.item);
  }, [a, o, c, l, r, f];
}
u(rZ, "instance$3u");
var La;
let oZ = (La = class extends re {
  constructor(e) {
    super(), oe(this, e, rZ, lZ, le, { dialog: 3, item: 4 });
  }
}, u(La, "ActionSelectionDialog"), La);
var Lf, ay;
const $A = class $A extends Un {
  constructor(t) {
    super(
      {
        title: `${t.name}: Select Action`,
        content: {
          class: oZ,
          props: { item: t }
        }
      },
      {
        classes: ["a5e-sheet"],
        width: 520
      }
    );
    x(this, Lf);
    this.data.content.props.dialog = this, this.promise = new Promise((s) => {
      this.resolve = s;
    });
  }
  /** @inheritdoc */
  close(t) {
    return X(this, Lf, ay).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return X(this, Lf, ay).call(this, t), super.close();
  }
};
Lf = new WeakSet(), ay = /* @__PURE__ */ u(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), u($A, "ActionSelectionDialog");
let oy = $A;
function kp(i, e, t, s, n = null, l = 1) {
  n && !n.includes(t) ? i.update({
    [e]: t,
    [s]: l
  }) : n ? te(i, e, t) : i.update({
    [e]: t,
    [s]: l
  });
}
u(kp, "updateAssociatedValues");
function m4(i, e, t) {
  const s = i.slice();
  return s[12] = e[t][0], s[13] = e[t][1], s;
}
u(m4, "get_each_context$1q");
function h4(i, e, t) {
  const s = i.slice();
  return s[12] = e[t][0], s[13] = e[t][1], s;
}
u(h4, "get_each_context_1$k");
function g4(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "class", "small-input"), G(e, "width", "5rem"), b(e, "id", `${/*actionId*/
      i[3]}-activation-cost`), b(e, "type", "number"), e.value = t = /*action*/
      ((l = i[1].activation) == null ? void 0 : l.cost) ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*action*/
      2 && t !== (t = /*action*/
      ((o = l[1].activation) == null ? void 0 : o.cost) ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(g4, "create_if_block_2$U");
function b4(i) {
  let e, t = K(
    /*label*/
    i[13]
  ) + "", s, n, l;
  return {
    c() {
      var r;
      e = E("option"), s = Q(t), n = F(), e.__value = /*value*/
      i[12], He(e, e.__value), e.selected = l = /*action*/
      ((r = i[1].activation) == null ? void 0 : r.type) === /*value*/
      i[12];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a;
      o & /*action*/
      2 && l !== (l = /*action*/
      ((a = r[1].activation) == null ? void 0 : a.type) === /*value*/
      r[12]) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(b4, "create_each_block_1$k");
function aZ(i) {
  var f, d;
  let e = (
    /*action*/
    ((f = i[1].activation) == null ? void 0 : f.type) && !/*specialActivationTypes*/
    i[5].includes(
      /*action*/
      (d = i[1].activation) == null ? void 0 : d.type
    )
  ), t, s, n, l, r, o = e && g4(i), a = ue(Object.entries(
    /*A5E*/
    i[4].abilityActivationTypes
  )), c = [];
  for (let p = 0; p < a.length; p += 1)
    c[p] = b4(h4(i, a, p));
  return {
    c() {
      o && o.c(), t = F(), s = E("select"), n = E("option");
      for (let p = 0; p < c.length; p += 1)
        c[p].c();
      n.__value = "", He(n, n.__value), b(s, "class", "u-w-fit");
    },
    m(p, m) {
      o && o.m(p, m), T(p, t, m), T(p, s, m), A(s, n);
      for (let g = 0; g < c.length; g += 1)
        c[g] && c[g].m(s, null);
      l || (r = W(
        s,
        "change",
        /*change_handler_1*/
        i[8]
      ), l = !0);
    },
    p(p, m) {
      var g, h;
      if (m & /*action*/
      2 && (e = /*action*/
      ((g = p[1].activation) == null ? void 0 : g.type) && !/*specialActivationTypes*/
      p[5].includes(
        /*action*/
        (h = p[1].activation) == null ? void 0 : h.type
      )), e ? o ? o.p(p, m) : (o = g4(p), o.c(), o.m(t.parentNode, t)) : o && (o.d(1), o = null), m & /*Object, A5E, action*/
      18) {
        a = ue(Object.entries(
          /*A5E*/
          p[4].abilityActivationTypes
        ));
        let _;
        for (_ = 0; _ < a.length; _ += 1) {
          const y = h4(p, a, _);
          c[_] ? c[_].p(y, m) : (c[_] = b4(y), c[_].c(), c[_].m(s, null));
        }
        for (; _ < c.length; _ += 1)
          c[_].d(1);
        c.length = a.length;
      }
    },
    d(p) {
      p && (C(t), C(s)), o && o.d(p), Le(c, p), l = !1, r();
    }
  };
}
u(aZ, "create_default_slot_3$y");
function _4(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.ActionActivationReactionTrigger",
      $$slots: { default: [cZ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, action, $item*/
      262147 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(_4, "create_if_block_1$1k");
function cZ(i) {
  let e, t, s, n, l;
  return {
    c() {
      var r;
      e = E("div"), t = E("input"), b(t, "class", "full-size-input"), b(t, "type", "text"), t.value = s = /*action*/
      ((r = i[1].activation) == null ? void 0 : r.reactionTrigger) ?? "", b(e, "class", "action-config__component");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = W(
        t,
        "change",
        /*change_handler_2*/
        i[9]
      ), n = !0);
    },
    p(r, o) {
      var a;
      o & /*action*/
      2 && s !== (s = /*action*/
      ((a = r[1].activation) == null ? void 0 : a.reactionTrigger) ?? "") && t.value !== s && (t.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(cZ, "create_default_slot_2$I");
function y4(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "class", "small-input"), G(e, "width", "5rem"), b(e, "id", `${/*actionId*/
      i[3]}-duration-value`), b(e, "type", "number"), e.value = t = /*action*/
      ((l = i[1].duration) == null ? void 0 : l.value) ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_3*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*action*/
      2 && t !== (t = /*action*/
      ((o = l[1].duration) == null ? void 0 : o.value) ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(y4, "create_if_block$1_");
function v4(i) {
  let e, t = K(
    /*label*/
    i[13]
  ) + "", s, n, l;
  return {
    c() {
      var r, o;
      e = E("option"), s = Q(t), n = F(), e.__value = /*value*/
      i[12], He(e, e.__value), e.selected = l = /*action*/
      ((o = (r = i[1]) == null ? void 0 : r.duration) == null ? void 0 : o.unit) === /*value*/
      i[12];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a, c;
      o & /*action*/
      2 && l !== (l = /*action*/
      ((c = (a = r[1]) == null ? void 0 : a.duration) == null ? void 0 : c.unit) === /*value*/
      r[12]) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(v4, "create_each_block$1q");
function uZ(i) {
  var d, p, m, g;
  let e, t = (
    /*action*/
    ((p = (d = i[1]) == null ? void 0 : d.duration) == null ? void 0 : p.unit) && !/*specialTimeTypes*/
    i[6].includes(
      /*action*/
      (g = (m = i[1]) == null ? void 0 : m.duration) == null ? void 0 : g.unit
    )
  ), s, n, l, r, o, a = t && y4(i), c = ue(Object.entries(
    /*A5E*/
    i[4].timePeriods
  )), f = [];
  for (let h = 0; h < c.length; h += 1)
    f[h] = v4(m4(i, c, h));
  return {
    c() {
      e = E("div"), a && a.c(), s = F(), n = E("select"), l = E("option");
      for (let h = 0; h < f.length; h += 1)
        f[h].c();
      l.__value = "", He(l, l.__value), b(n, "class", "u-w-fit"), b(e, "class", "action-config__component");
    },
    m(h, _) {
      T(h, e, _), a && a.m(e, null), A(e, s), A(e, n), A(n, l);
      for (let y = 0; y < f.length; y += 1)
        f[y] && f[y].m(n, null);
      r || (o = W(
        n,
        "change",
        /*change_handler_4*/
        i[11]
      ), r = !0);
    },
    p(h, _) {
      var y, v, k, S;
      if (_ & /*action*/
      2 && (t = /*action*/
      ((v = (y = h[1]) == null ? void 0 : y.duration) == null ? void 0 : v.unit) && !/*specialTimeTypes*/
      h[6].includes(
        /*action*/
        (S = (k = h[1]) == null ? void 0 : k.duration) == null ? void 0 : S.unit
      )), t ? a ? a.p(h, _) : (a = y4(h), a.c(), a.m(e, s)) : a && (a.d(1), a = null), _ & /*Object, A5E, action*/
      18) {
        c = ue(Object.entries(
          /*A5E*/
          h[4].timePeriods
        ));
        let D;
        for (D = 0; D < c.length; D += 1) {
          const I = m4(h, c, D);
          f[D] ? f[D].p(I, _) : (f[D] = v4(I), f[D].c(), f[D].m(n, null));
        }
        for (; D < f.length; D += 1)
          f[D].d(1);
        f.length = c.length;
      }
    },
    d(h) {
      h && C(e), a && a.d(), Le(f, h), r = !1, o();
    }
  };
}
u(uZ, "create_default_slot_1$W");
function fZ(i) {
  var a;
  let e, t, s, n, l, r;
  e = new ie({
    props: {
      heading: "A5E.ItemActivationCost",
      $$slots: { default: [aZ] },
      $$scope: { ctx: i }
    }
  });
  let o = (
    /*action*/
    ((a = i[1].activation) == null ? void 0 : a.type) === "reaction" && _4(i)
  );
  return l = new ie({
    props: {
      heading: "A5E.ItemDuration",
      $$slots: { default: [uZ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), o && o.c(), n = F(), j(l.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-direction", "row"), G(t, "--a5e-field-wrapper-header-width", "100%");
    },
    m(c, f) {
      T(c, t, f), R(e, t, null), T(c, s, f), o && o.m(c, f), T(c, n, f), R(l, c, f), r = !0;
    },
    p(c, f) {
      var m;
      const d = {};
      f & /*$$scope, $item, action*/
      262147 && (d.$$scope = { dirty: f, ctx: c }), e.$set(d), /*action*/
      ((m = c[1].activation) == null ? void 0 : m.type) === "reaction" ? o ? (o.p(c, f), f & /*action*/
      2 && w(o, 1)) : (o = _4(c), o.c(), w(o, 1), o.m(n.parentNode, n)) : o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce());
      const p = {};
      f & /*$$scope, $item, action*/
      262147 && (p.$$scope = { dirty: f, ctx: c }), l.$set(p);
    },
    i(c) {
      r || (w(e.$$.fragment, c), w(o), w(l.$$.fragment, c), r = !0);
    },
    o(c) {
      O(e.$$.fragment, c), O(o), O(l.$$.fragment, c), r = !1;
    },
    d(c) {
      c && (C(s), C(n)), c && e && C(t), N(e, c), o && o.d(c), N(l, c);
    }
  };
}
u(fZ, "create_default_slot$1I");
function dZ(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.ActivationConfiguration",
      $$slots: { default: [fZ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, $item, action*/
      262147 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(dZ, "create_fragment$3C");
function pZ(i, e, t) {
  let s, n;
  const l = de("item");
  pe(i, l, (h) => t(0, n = h));
  const r = de("actionId"), { A5E: o } = CONFIG, a = ["none", "special"], c = ["instantaneous", "permanent", "special"], f = /* @__PURE__ */ u(({ target: h }) => te(
    n,
    `system.actions.${r}.activation.cost`,
    // @ts-expect-error
    Number(h.value)
  ), "change_handler"), d = /* @__PURE__ */ u(({ target: h }) => kp(
    n,
    `system.actions.${r}.activation.type`,
    // @ts-expect-error
    h.value,
    `system.actions.${r}.activation.cost`,
    a
  ), "change_handler_1"), p = /* @__PURE__ */ u(({ target: h }) => te(
    n,
    `system.actions.${r}.activation.reactionTrigger`,
    // @ts-expect-error
    h.value
  ), "change_handler_2"), m = /* @__PURE__ */ u(({ target: h }) => te(
    n,
    `system.actions.${r}.duration.value`,
    // @ts-expect-error
    Number(h.value)
  ), "change_handler_3"), g = /* @__PURE__ */ u(({ target: h }) => kp(
    n,
    `system.actions.${r}.duration.unit`,
    // @ts-expect-error
    h.value,
    `system.actions.${r}.duration.value`,
    c
  ), "change_handler_4");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(1, s = n.actions.get(r));
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c,
    f,
    d,
    p,
    m,
    g
  ];
}
u(pZ, "instance$3t");
const AA = class AA extends re {
  constructor(e) {
    super(), oe(this, e, pZ, dZ, le, {});
  }
};
u(AA, "ActionsActivationTab");
let cy = AA;
var Kh;
const Yh = class Yh {
  /**
   * Returns true when Foundry is at least the specific major version number provided.
   *
   * Note: `game` must be initialized for correct comparison; use after Foundry `init` hook.
   *
   * @param {number}   version - Major version to check against.
   *
   * @returns {boolean} Foundry version is at least the major version specified.
   */
  static isAtLeast(e) {
    var t;
    if (((t = globalThis.game) == null ? void 0 : t.version) === void 0)
      throw new Error("FVTTVersion.isAtLeast error: Foundry VTT global 'game' object is not initialized.");
    if (!Number.isInteger(e) && e < 9)
      throw new TypeError("'version' is not a positive integer greater than or equals '9'.");
    return !globalThis.foundry.utils.isNewerVersion(e, globalThis.game.version);
  }
  /**
   * Returns true when Foundry is inclusively between the min / max major version numbers provided.
   *
   * @param {number}   min - Major minimum version to check against.
   *
   * @param {number}   max - Major maximum version to check against.
   *
   * @returns {boolean} Foundry version is at least the major version specified.
   */
  static isBetween(e, t) {
    var l;
    if (((l = globalThis.game) == null ? void 0 : l.version) === void 0)
      throw new Error("FVTTVersion.isBetween error: Foundry VTT global 'game' object is not initialized.");
    if (!Number.isInteger(e) && e < 9)
      throw new TypeError(
        "FVTTVersion.isBetween error: 'min' is not a positive integer greater than or equals '9'."
      );
    if (!Number.isInteger(t) && t < 9)
      throw new TypeError(
        "FVTTVersion.isBetween error: 'max' is not a positive integer greater than or equals '9'."
      );
    if (e > t)
      throw new TypeError("FVTTVersion.isBetween error: 'min' is greater than 'max'.");
    const s = P(this, Kh).exec(globalThis.game.version);
    if (!s)
      throw new Error("FVTTVersion.isBetween error: Could not parse 'globalThis.game.version'.");
    const n = parseInt(s[1], 10);
    return n >= e && n <= t;
  }
};
Kh = new WeakMap(), u(Yh, "FVTTVersion"), x(Yh, Kh, /(\d+)\./);
let wp = Yh;
var Xh, nB;
const ou = class ou {
  /**
   * Collect all the font definitions and combine them.
   *
   * @returns { {[key: string]: globalThis.FontFamilyDefinition}[] } Core font definitions.
   */
  static getCoreDefinitions() {
    var t, s;
    const e = [];
    if (wp.isAtLeast(11)) {
      he((t = globalThis.CONFIG) == null ? void 0 : t.fontDefinitions) && e.push(gr(globalThis.CONFIG.fontDefinitions));
      const n = (s = globalThis.game) == null ? void 0 : s.settings.get("core", "fonts");
      Array.isArray(n) && e.push(gr(n));
    }
    return ou.removeDuplicateDefinitions(e), e;
  }
  /**
   * Ensure that fonts have loaded and are ready for use.
   * Enforce a maximum timeout in milliseconds.
   * Proceed after that point even if fonts are not yet available.
   *
   * @param {object} [opts] - Optional parameters.
   *
   * @param {number} [opts.ms=4500] - The maximum time to spend loading fonts before proceeding.
   *
   * @param {Document} [opts.document] - The target document to load the fonts into.
   *
   * @param {boolean} [opts.editor=true] - When true verifies the `editor` field of {@link FontFamilyDefinition}.
   *
   * @param {(
   *    {[key: string]: globalThis.FontFamilyDefinition}[] |
   *    {[key: string]: globalThis.FontFamilyDefinition}
   * )} [opts.fonts] - A custom set of font family definitions to load. If not defined the core font family definitions
   *    are loaded.
   *
   * @returns {Promise<void>}
   */
  static async loadFonts({ ms: e = 4500, document: t = globalThis.document, editor: s = !0, fonts: n } = {}) {
    const l = n ? Array.isArray(n) ? n : [n] : this.getCoreDefinitions(), r = [];
    for (const c of l)
      if (he(c))
        for (const [f, d] of Object.entries(c)) {
          if (s && (typeof d.editor != "boolean" || !d.editor))
            continue;
          const p = `1rem "${f}"`;
          r.push(X(this, Xh, nB).call(this, p, f, d, t));
        }
    const o = new Promise((c) => setTimeout(c, e)), a = Promise.allSettled(r).then(() => t.fonts.ready);
    return Promise.race([a, o]);
  }
  /**
   * Removes duplicate font definitions.
   *
   * @param { {[key: string]: globalThis.FontFamilyDefinition}[] }  fonts - An array of FontFamilyDefinition objects
   *        to process.
   *
   * @returns { {[key: string]: globalThis.FontFamilyDefinition}[] } Filtered font definitions.
   */
  static removeDuplicateDefinitions(e) {
    if (!Array.isArray(e))
      throw new TypeError("FontManager.removeDuplicateDefinitions error: 'fonts' is not an array.");
    const t = /* @__PURE__ */ new Set();
    for (const s of e) {
      if (!he(s))
        throw new TypeError("FontManager.removeDuplicateDefinitions error: 'definitions' is not an object.");
      for (const n of Object.keys(s))
        t.has(n) ? delete s[n] : t.add(n);
    }
    return e;
  }
};
Xh = new WeakSet(), nB = /* @__PURE__ */ u(async function(e, t, s, n) {
  try {
    for (const l of s.fonts) {
      const r = l.urls.map((a) => `url("${a}")`).join(", "), o = new FontFace(t, r, l);
      await o.load(), n.fonts.add(o);
    }
    await n.fonts.load(e);
  } catch (l) {
    return console.warn(`Font family "${t}" failed to load: `, l), !1;
  }
  return n.fonts.check(e) ? !0 : (console.warn(`Font family "${t}" failed to load.`), !1);
}, "#loadFont"), x(ou, Xh), u(ou, "FontManager");
let wu = ou;
var Jh, li, Ba, Bf, uy;
const Br = class Br {
  /**
   * Gets the properties object associated with the selector. Try and use a direct match otherwise all keys
   * are iterated to find a selector string that includes the `selector`.
   *
   * @param {string}   selector - Selector to find.
   *
   * @returns { {[key: string]: string} } Properties object.
   */
  static getProperties(e) {
    if (P(this, Ba) || X(this, Bf, uy).call(this), P(this, li).has(e))
      return P(this, li).get(e);
    for (const t of P(this, li).keys())
      if (t.includes(e))
        return P(this, li).get(t);
  }
  /**
   * Gets a specific property value from the given `selector` and `property` key. Try and use a direct selector
   * match otherwise all keys are iterated to find a selector string that includes `selector`.
   *
   * @param {string}   selector - Selector to find.
   *
   * @param {string}   property - Specific property to locate.
   *
   * @returns {string|undefined} Property value.
   */
  static getProperty(e, t) {
    if (P(this, Ba) || X(this, Bf, uy).call(this), P(this, li).has(e)) {
      const s = P(this, li).get(e);
      return he(s) && t in s ? s[t] : void 0;
    }
    for (const s of P(this, li).keys())
      if (s.includes(e)) {
        const n = P(this, li).get(s);
        if (he(n) && t in n)
          return n[t];
      }
  }
};
Jh = new WeakMap(), li = new WeakMap(), Ba = new WeakMap(), Bf = new WeakSet(), uy = /* @__PURE__ */ u(function() {
  Ae(this, Ba, !0);
  const e = Array.from(document.styleSheets).filter((n) => n.href !== null);
  let t;
  const s = globalThis.foundry.utils.getRoute("/css/style.css");
  for (const n of e) {
    let l;
    try {
      l = new URL(n.href);
    } catch {
      continue;
    }
    if (typeof l.pathname == "string" && l.pathname === s) {
      Ae(this, Jh, t = n);
      break;
    }
  }
  if (t)
    for (const n of t.cssRules) {
      if (!(n instanceof CSSStyleRule))
        continue;
      const l = {};
      for (const r of n.style.cssText.split(";")) {
        const o = r.split(":");
        o.length < 2 || (l[o[0].trim()] = o[1].trim());
      }
      P(this, li).set(n.selectorText, l);
    }
}, "#initialize"), x(Br, Bf), u(Br, "FoundryStyles"), x(Br, Jh), /** @type {Map<string, {[key: string]: string}>} */
x(Br, li, /* @__PURE__ */ new Map()), x(Br, Ba, !1);
let Nr = Br;
var qf;
const Zh = class Zh {
  static initialize() {
    if (P(this, qf))
      return;
    const e = new sp({ docKey: "#__tjs-root-styles", version: 1.1 });
    Ae(this, qf, !0), e.setProperties({
      // For components w/ transparent background checkered pattern.
      "--tjs-checkerboard-background-dark": "rgb(205, 205, 205)",
      "--tjs-checkerboard-background-10": `url('data:image/svg+xml;utf8,<svg preserveAspectRatio="none"  viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="5" height="5" fill="transparent" /><rect x="5" y="5" width="5" height="5" fill="transparent" /><rect x="5" y="0" width="5" height="5" fill="white" /><rect x="0" y="5" width="5" height="5" fill="white" /></svg>') 0 0 / 10px 10px, var(--tjs-checkerboard-background-dark, rgb(205, 205, 205))`
    }, !1), e.setProperties({
      "--tjs-action-ripple-background": "rgba(0, 0, 0, 0.35)"
    }, !1), e.setProperties({
      "--tjs-icon-button-background-hover": "rgba(0, 0, 0, 0.10)",
      "--tjs-icon-button-background-selected": "rgba(0, 0, 0, 0.20)"
    }, !1);
    {
      const t = Nr.getProperties('input[type="text"], input[type="number"]');
      he(t) && e.setProperties({
        "--tjs-input-background": "background" in t ? t.background : "rgba(0, 0, 0, 0.05)",
        "--tjs-input-border": "border" in t ? t.border : "1px solid var(--color-border-light-tertiary)",
        "--tjs-input-border-radius": "border-radius" in t ? t["border-radius"] : "3px",
        "--tjs-input-height": "height" in t ? t.height : "var(--form-field-height)",
        "--tjs-input-min-width": "min-width" in t ? t["min-width"] : "20px",
        "--tjs-input-padding": "padding" in t ? t.padding : "1px 3px",
        "--tjs-input-width": "width" in t ? t.width : "calc(100% - 2px)",
        // Set default values that are only to be referenced and not set.
        "--_tjs-default-input-height": "height" in t ? t.height : "var(--form-field-height)",
        // Set directly / no lookup:
        "--tjs-input-border-color": "var(--color-border-light-tertiary)"
      }, !1);
    }
    {
      const t = Nr.getProperties('input[type="range"]::-webkit-slider-runnable-track'), s = Nr.getProperties('input[type="range"]:focus::-webkit-slider-runnable-track'), n = Nr.getProperties('input[type="range"]::-webkit-slider-thumb'), l = Nr.getProperties('input[type="range"]:focus::-webkit-slider-thumb');
      he(t) && e.setProperties({
        "--tjs-input-range-slider-track-box-shadow": "box-shadow" in t ? t["box-shadow"] : "1px 1px 1px #000000, 0px 0px 1px #0d0d0d"
      }, !1), he(s) && e.setProperties({
        "--tjs-input-range-slider-track-box-shadow-focus": "box-shadow" in s ? s["box-shadow"] : "1px 1px 1px #000000, 0px 0px 1px #0d0d0d"
      }, !1), he(n) && e.setProperties({
        "--tjs-input-range-slider-thumb-box-shadow": "box-shadow" in n ? n["box-shadow"] : "0 0 5px var(--color-shadow-primary)"
      }, !1), he(l) && e.setProperties({
        "--tjs-input-range-slider-thumb-box-shadow-focus": "box-shadow" in l ? l["box-shadow"] : "0 0 5px var(--color-shadow-primary)"
      }, !1);
    }
    e.setProperties({
      // `popup` is for components that are slightly elevated, but connected to an application;
      // see: TJSMenu / TJSContextMenu / TJSColordPicker
      "--tjs-default-popup-background": "var(--color-text-dark-header, #23221d)",
      "--tjs-default-popup-border": "1px solid var(--color-border-dark, #000)",
      "--tjs-default-popup-box-shadow": "0 0 2px var(--color-shadow-dark, #000)",
      "--tjs-default-popup-primary-color": "var(--color-text-light-primary, #b5b3a4)",
      "--tjs-default-popup-highlight-color": "var(--color-text-light-highlight, #f0f0e0)",
      // `popover` is for components that are elevated and independent; see: TJSContextMenu
      "--tjs-default-popover-border": "1px solid var(--color-border-dark, #000)",
      "--tjs-default-popover-box-shadow": "0 0 10px var(--color-shadow-dark, #000)"
    }, !1), Hooks.on("PopOut:loading", (t, s) => {
      t instanceof Gs && s.document.addEventListener("DOMContentLoaded", () => e.clone(s.document));
    });
  }
};
qf = new WeakMap(), u(Zh, "FVTTConfigure"), x(Zh, qf, !1);
let fy = Zh;
fy.initialize();
function k4(i) {
  return i == " " || i == `
` || i == "\r" || i == "	";
}
u(k4, "isSpace");
function mZ(i) {
  return i == '"' || i == "'";
}
u(mZ, "isQuote");
const Yo = "<", hg = ">", $p = "&lt;", iB = "&gt;", EA = class EA {
  constructor(e) {
    qe(this, "options");
    this.options = e;
  }
  consume(e, t) {
    return e == Yo ? (t(new dy(this.options)), "") : e == hg && this.options.encodePlaintextTagDelimiters ? iB : e;
  }
};
u(EA, "InPlaintextState");
let go = EA;
const SA = class SA {
  constructor(e) {
    qe(this, "options");
    qe(this, "nameBuffer", "");
    qe(this, "isClosingTag", !1);
    this.options = e;
  }
  consume(e, t) {
    if (this.nameBuffer.length == 0) {
      if (k4(e))
        return t(new go(this.options)), (this.options.encodePlaintextTagDelimiters ? $p : "<") + e;
      if (e == "/")
        return this.isClosingTag = !0, "";
    }
    return k4(e) ? this.isNameBufferAnAllowedTag() ? (t(new $u(0, this.options)), Yo + (this.isClosingTag ? "/" : "") + this.nameBuffer + e) : (t(new $u(1, this.options)), this.options.tagReplacementText) : e == Yo ? (this.nameBuffer += $p, "") : e == hg ? (t(new go(this.options)), this.isNameBufferAnAllowedTag() ? Yo + (this.isClosingTag ? "/" : "") + this.nameBuffer + e : this.options.tagReplacementText) : e == "-" && this.nameBuffer == "!-" ? (t(new my(this.options)), "") : (this.nameBuffer += e, "");
  }
  isNameBufferAnAllowedTag() {
    const e = this.nameBuffer.toLowerCase();
    return this.options.allowedTags ? this.options.allowedTags.has(e) : this.options.disallowedTags ? !this.options.disallowedTags.has(e) : !1;
  }
};
u(SA, "InTagNameState");
let dy = SA;
const CA = class CA {
  constructor(e, t) {
    qe(this, "mode");
    qe(this, "options");
    this.mode = e, this.options = t;
  }
  consume(e, t) {
    return e == hg ? t(new go(this.options)) : mZ(e) && t(new py(this.mode, e, this.options)), this.mode == 1 ? "" : e == Yo ? $p : e;
  }
};
u(CA, "InTagState");
let $u = CA;
const TA = class TA {
  constructor(e, t, s) {
    qe(this, "mode");
    qe(this, "quoteCharacter");
    qe(this, "options");
    this.mode = e, this.quoteCharacter = t, this.options = s;
  }
  consume(e, t) {
    return e == this.quoteCharacter && t(new $u(this.mode, this.options)), this.mode == 1 ? "" : e == Yo ? $p : e == hg ? iB : e;
  }
};
u(TA, "InQuotedStringInTagState");
let py = TA;
const OA = class OA {
  constructor(e) {
    qe(this, "options");
    qe(this, "consecutiveHyphens", 0);
    this.options = e;
  }
  consume(e, t) {
    return e == ">" && this.consecutiveHyphens >= 2 ? t(new go(this.options)) : e == "-" ? this.consecutiveHyphens++ : this.consecutiveHyphens = 0, "";
  }
};
u(OA, "InCommentState");
let my = OA;
const hZ = {
  tagReplacementText: "",
  encodePlaintextTagDelimiters: !0
}, DA = class DA {
  constructor(e = {}) {
    qe(this, "state");
    qe(this, "transitionFunction");
    this.state = new go({
      ...hZ,
      ...e
    }), this.transitionFunction = ((t) => {
      this.state = t;
    }).bind(this);
  }
  consume(e) {
    let t = "";
    for (const s of e)
      t += this.state.consume(s, this.transitionFunction);
    return t;
  }
};
u(DA, "StateMachine");
let hy = DA;
function gZ(i, e = {}) {
  return new hy(e).consume(i);
}
u(gZ, "striptags");
function bZ(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.textContent = `${K(`EDITOR.${/*revealed*/
      i[2] ? "Hide" : "Reveal"}`)}`, b(e, "type", "button"), b(e, "class", "reveal svelte-1e62bm0");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler*/
        i[3]
      ), t = !0);
    },
    p: se,
    i: se,
    o: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(bZ, "create_fragment$3B");
function _Z(i, e, t) {
  let { onUpdateRevealButtons: s = void 0 } = e, { sectionEl: n = void 0 } = e;
  const l = n.classList.contains("revealed"), r = /* @__PURE__ */ u(() => s(!l, n.id), "click_handler");
  return i.$$set = (o) => {
    "onUpdateRevealButtons" in o && t(0, s = o.onUpdateRevealButtons), "sectionEl" in o && t(1, n = o.sectionEl);
  }, [s, n, l, r];
}
u(_Z, "instance$3s");
const IA = class IA extends re {
  constructor(e) {
    super(), oe(this, e, _Z, bZ, le, { onUpdateRevealButtons: 0, sectionEl: 1 });
  }
};
u(IA, "RevealSecretButton");
let gy = IA;
function lB({ html: i, process: e, selector: t, containerElement: s = "div", firstMatchOnly: n = !1, namespaceURI: l }) {
  if (typeof i != "string")
    throw new TypeError("processHTML error: 'html' is not a string.");
  if (typeof e != "function")
    throw new TypeError("processHTML error: 'process' is not a function.");
  if (typeof t != "string")
    throw new TypeError("processHTML error: 'selector' is not a string.");
  if (typeof s != "string")
    throw new TypeError("processHTML error: 'containerElement' is not a string.");
  if (typeof n != "boolean")
    throw new TypeError("processHTML error: 'firstMatchOnly' is not a boolean.");
  if (l !== void 0 && typeof l != "string")
    throw new TypeError("processHTML error: 'namespaceURI' is not a string.");
  const r = l ? `${l}|${t}` : t, o = document.createElement(s);
  if (o.innerHTML = i, n) {
    const a = o.querySelector(r);
    a && e(a);
  } else {
    const a = o.querySelectorAll(r);
    if (a)
      for (const c of a)
        e(c);
  }
  return o.innerHTML;
}
u(lB, "processHTML");
function yZ(i, e) {
  function t(s, n) {
    const l = i.get();
    if (l && typeof (e == null ? void 0 : e.fieldName) == "string") {
      const r = cu(l, e == null ? void 0 : e.fieldName);
      if (typeof r == "string") {
        const o = lB({
          html: r,
          process: /* @__PURE__ */ u((a) => a.classList[`${s ? "add" : "remove"}`]("revealed"), "process"),
          selector: `section.secret[id=${n}]`,
          firstMatchOnly: !0
        });
        l.update({ [e == null ? void 0 : e.fieldName]: o });
      }
    }
  }
  return u(t, "onUpdateRevealButtons"), (s) => {
    const n = [];
    function l() {
      for (const o of n)
        o.$destroy();
      n.length = 0;
    }
    u(l, "destroyComponents");
    function r() {
      CL().then(() => {
        l();
        const o = s.querySelectorAll("section.secret[id]");
        for (const a of o)
          n.push(new gy({
            target: a,
            anchor: a.firstChild,
            props: {
              onUpdateRevealButtons: t,
              sectionEl: a
            }
          }));
      });
    }
    return u(r, "mountComponents"), {
      /**
       * On update if the external parameter `mountRevealButtons` is true and a document / fieldName is defined
       * mount the secret reveal buttons otherwise destroy any existing buttons.
       *
       * Note: In the editor components `enrichedContent` is also passed, but unused, but it will trigger an update
       * whenever the content changes.
       *
       * @param mountRevealButtons
       */
      update({ mountRevealButtons: o }) {
        o && i.get() && typeof (e == null ? void 0 : e.fieldName) == "string" ? r() : l();
      },
      destroy() {
        l();
      }
    };
  };
}
u(yZ, "createMountRevealSecretButtons");
globalThis.ProseMirror && globalThis.ProseMirror.ProseMirrorKeyMaps;
globalThis.ProseMirror && globalThis.ProseMirror.Plugin;
globalThis.ProseMirror && globalThis.ProseMirror.PluginKey;
var Qh, xh;
const zo = class zo {
  /**
   * Modifies editor content HTML to add random IDs to secret section blocks that don't presently have an ID
   * assigned. This is done on saving the content such that it interacts with the Foundry DocumentSheet and the
   * `mountRevealSecretsButton` action. TinyMCEs `style_formats` does not have a way to set an ID on the containing
   * block.
   *
   * @param {string}   html - Editor content to modify.
   */
  static addSecretIDs(e) {
    return lB({
      html: e,
      process: /* @__PURE__ */ u((t) => t.id = `secret-${foundry.utils.randomID()}`, "process"),
      selector: "section.secret:not([id])"
    });
  }
  static beforeInputHandler(e, t, s, n) {
    if (n === void 0 || e.plugins.wordcount === void 0 || !(t != null && t.isTrusted))
      return;
    const l = t.inputType;
    if (l === "deleteContentBackward" || l === "deleteContentForward" || e.plugins.wordcount.selection.getCharacterCount() > 0 && l === "insertText")
      return;
    if (e.plugins.wordcount.body.getCharacterCount() >= n)
      return t.preventDefault(), t.stopPropagation(), !1;
  }
  static hasEnterKeyHandler(e) {
    return typeof e.preventEnterKey == "boolean" && e.preventEnterKey || typeof e.saveOnEnterKey == "boolean" && e.saveOnEnterKey;
  }
  static get isV5() {
    var e;
    return ((e = globalThis.tinymce) == null ? void 0 : e.majorVersion) === "5";
  }
  static get isV6() {
    var e;
    return ((e = globalThis.tinymce) == null ? void 0 : e.majorVersion) === "6";
  }
  static keydownHandler(e, t, s, n, l) {
    switch (t.code) {
      case "Enter":
        if (zo.hasEnterKeyHandler(s))
          return t.preventDefault(), t.stopPropagation(), typeof s.saveOnEnterKey == "boolean" && s.saveOnEnterKey && n(), !1;
        break;
      case "Escape":
        e.resetContent(l), setTimeout(() => n(), 0);
        break;
    }
  }
  /**
   * Provides a mechanism to load core Foundry fonts and any additional font family definitions. The returned data
   * includes the parsed font family definitions and the configuration data TinyMCE needs for loading the font formats.
   *
   * @param { {[key: string]: globalThis.FontFamilyDefinition} }  [extraFonts] - Extra user defined fonts to load.
   *
   * @returns { {fonts: {[key: string]: globalThis.FontFamilyDefinition}[], fontFormats: string} } Font formats for
   *          MCE & all fonts to load.
   */
  static getFontData(e = {}) {
    if (!he(e))
      throw new TypeError("'extraFonts' is not an object.");
    const t = [
      ...wu.getCoreDefinitions(),
      e
    ], s = /* @__PURE__ */ new Set();
    for (const n of t)
      if (he(n))
        for (const l of Object.keys(n))
          s.add(`${l}=${l};`);
    return { fonts: t, fontFormats: [...s].sort().join("") };
  }
  /**
   * Handles paste preprocessing. Prevents pasting when `options.preventPaste` is true. Prevents pasting when
   * `options.maxContentLength` is set and only partially pastes text to fit within the max length.
   *
   *
   * For Foundry v10 and above when `options.maxContentLength` is not defined pasted text is examined for the shape
   * of a raw UUID and if detected attempts to retrieve the document and if found will generate a proper document link
   * from it. You can get the raw UUID by context-clicking the icon in the app header bar for various documents.
   *
   * @param {object}   editor -
   *
   * @param {object}   args -
   *
   * @param {object}   options -
   *
   * @param {number}   maxCharacterLength -
   */
  static pastePreprocess(e, t, s, n) {
    if ((typeof t.content != "string" || typeof s.preventPaste == "boolean" && s.preventPaste) && (t.stopImmediatePropagation(), t.stopPropagation(), t.preventDefault()), n >= 0) {
      let l = gZ(t.content);
      this.hasEnterKeyHandler(s) && (l = l.replace(/[\n\r]+/g, ""));
      const r = e.plugins.wordcount.body.getCharacterCount(), o = e.plugins.wordcount.selection.getCharacterCount();
      if (o > 0) {
        if (l.length > o) {
          const a = l.length + r - o;
          a > n && (l = l.substring(0, l.length - (a - n)));
        }
      } else if (l.length + r > n) {
        const a = n - r;
        l = l.substring(0, a);
      }
      t.content = l;
    } else {
      let l = t.content;
      if (wp.isAtLeast(10) && P(this, xh).test(l))
        try {
          const r = globalThis.fromUuidSync(l);
          r && (l = `@UUID[${l}]{${r.name}}`);
        } catch {
        }
      t.content = l;
    }
  }
  /**
   * Sets the initial selection based on `options.initialSelection`.
   *
   * @param {object}   editor - MCE editor.
   *
   * @param {string}   initialSelection - Initial selection option.
   *
   * @param {string}   defaultValue - Default value if initialSelection is invalid.
   */
  static setInitialSelection(e, t, s) {
    const n = t === "all" || t === "end" || t === "start" ? t : s, l = e.selection, r = e.getBody();
    if (r) {
      switch (n) {
        case "all":
          l.select(r, !0);
          break;
        case "end":
          l.select(r, !0), l.collapse(!1);
          break;
        case "start":
          l.select(r, !0), l.collapse(!0);
          break;
      }
      e.focus();
    }
  }
  /**
   * Copies over the CSS variable data that is inspected on the `.editor-content` div before the editor is active if
   * set or the default values to the body element of the TinyMCE IFrame.
   *
   * @param {HTMLElement} editorContentEl - Editor content element.
   *
   * @returns {string} TinyMCE config `content_style` parameter for .
   */
  static setMCEConfigContentStyle(e) {
    const t = {}, s = globalThis.getComputedStyle(e);
    for (const n of P(this, Qh)) {
      const l = s.getPropertyValue(n.variable);
      t[n.property] = l !== "" ? l : n.default;
    }
    return `body { ${Object.entries(t).map((n) => `${n[0]}: ${n[1]};`).join(";")} } p:first-of-type { margin-top: 0; } section.secret p:first-of-type { margin-top: 0.5em; }`;
  }
};
Qh = new WeakMap(), xh = new WeakMap(), u(zo, "MCEImpl"), /**
 * Stores the CSS variable data that is inspected on the `.editor-content` div before the editor is active and
 * copies these values if set or the default values to the body element of the TinyMCE IFrame.
 *
 * @type {object[]}
 */
x(zo, Qh, [
  { variable: "--tjs-editor-content-color", property: "color", default: "#000" },
  { variable: "--tjs-editor-content-font-family", property: "font-family", default: "Signika" },
  { variable: "--tjs-editor-content-font-size", property: "font-size", default: "10.5pt" },
  { variable: "--tjs-editor-content-line-height", property: "line-height", default: "1.2" },
  { variable: "--tjs-editor-content-padding", property: "padding", default: "3px 0 0 0" }
]), /**
 * Defines a regex to check for the shape of a raw Foundry document UUID.
 *
 * @type {RegExp}
 */
x(zo, xh, /(\.).*([a-zA-Z0-9]{16})/);
let ss = zo;
var qa, Rd, eg, tg, sg, Gf, Ga, ng, ig, za;
const Jn = class Jn {
  /**
   * Provides a very basic / limited TinyMCE config that limits the ability to apply many styles from the toolbar
   * or with key commands.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.basicFormats=true] - When true, only basic style formats are allowed.
   *
   * @param {string[]} [opts.contentCSS] - An array of CSS paths to load. `getRoute` will be applied to them.
   *
   * @param {string}   [opts.contentStyle=''] - The same content style string for TinyMCE options.
   *
   * @param {boolean}  [opts.fontFormat=true] - Includes font select box.
   *
   * @param {boolean}  [opts.fontSize=false] - Includes font size select box.
   *
   * @param {boolean}  [opts.help=false] - When true include help plugin / toolbar button.
   *
   * @param {boolean}  [opts.stripStyleFormat=true] - Strips any additional style formats added by other modules.
   *
   * @param {boolean}  [opts.styleFormat=true] - Includes style format select box.
   *
   * @param {boolean}  [opts.tjsStyles=false] - Includes extensive TJS styling options.
   *
   * @param {boolean}  [opts.toolbar=true] - Includes the editor toolbar.
   *
   * @returns {object} TinyMCE options
   */
  static configBasic({
    basicFormats: e = !0,
    contentCSS: t,
    contentStyle: s = "",
    fontFormat: n = !0,
    fontSize: l = !1,
    help: r = !1,
    stripStyleFormat: o = !0,
    styleFormat: a = !0,
    tjsStyles: c = !1,
    toolbar: f = !0
  } = {}) {
    const d = X(this, qa, Rd).call(this, e, o, c ? P(this, za) : []), p = `${a ? `${ss.isV6 ? "styles |" : "styleselect |"}` : ""} ${n ? `${ss.isV6 ? "fontfamily |" : "fontselect |"}` : ""} ${l ? `${ss.isV6 ? "fontsize |" : "fontsizeselect |"}` : ""} removeformat | save${r ? " | help" : ""}`, m = {
      content_css: Array.isArray(t) ? globalThis.CONFIG.TinyMCE.content_css.concat(t) : globalThis.CONFIG.TinyMCE.content_css,
      content_style: s,
      [`${ss.isV6 ? "font_size_formats" : "fontsize_formats"}`]: P(this, Ga),
      plugins: `${ss.isV6 ? "" : "hr paste"} save ${r ? "help" : ""} wordcount`,
      style_formats: d,
      style_formats_merge: !1,
      // This allows the manual addition of a style tag in the code editor.
      valid_children: "+body[style]",
      // Note we can include all internal tags as we prefilter the URL to make sure it is for YouTube then use the
      // oembed API to get the embed URL.
      extended_valid_elements: "iframe[allow|allowfullscreen|frameborder|scrolling|class|style|src|width|height]"
    };
    return e && (m.formats = P(this, tg)), m.toolbar = f ? p : !1, m;
  }
  /**
   * Provides the standard TinyMCE configuration options. This is similar to standard core configuration and the
   * ProseMirror editor.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.basicFormats=false] - When true, only basic style formats are allowed.
   *
   * @param {boolean}  [opts.code=true] - When true include source code editing option.
   *
   * @param {string[]} [opts.contentCSS] - An array of CSS paths to load. `getRoute` will be applied to them.
   *
   * @param {string}   [opts.contentStyle=''] - The same content style string for TinyMCE options.
   *
   * @param {boolean}  [opts.fontFormat=true] - Includes font select box.
   *
   * @param {boolean}  [opts.fontSize=false] - Includes font size select box.
   *
   * @param {boolean}  [opts.help=false] - When true include help plugin / toolbar button.
   *
   * @param {boolean}  [opts.stripStyleFormat=true] - Strips any additional style formats added by other modules.
   *
   * @param {boolean}  [opts.styleFormat=true] - Includes style format select box.
   *
   * @param {boolean}  [opts.tjsOembed=false] - Includes custom oEmbed plugin to include video from YouTube / Vimeo.
   *
   * @param {boolean}  [opts.tjsStyles=false] - Includes extensive TJS styling options.
   *
   * @param {boolean}  [opts.toolbar=true] - Includes the editor toolbar.
   *
   * @returns {object} TinyMCE options
   */
  static configStandard({
    basicFormats: e = !1,
    code: t = !0,
    contentCSS: s,
    contentStyle: n = "",
    fontFormat: l = !0,
    fontSize: r = !1,
    help: o = !1,
    stripStyleFormat: a = !0,
    styleFormat: c = !0,
    tjsOembed: f = !1,
    tjsStyles: d = !1,
    toolbar: p = !0
  } = {}) {
    const m = X(this, qa, Rd).call(this, e, a, d ? P(this, za) : []), g = `${c ? `${ss.isV6 ? "styles |" : "styleselect |"}` : ""} ${l ? `${ss.isV6 ? "fontfamily |" : "fontselect |"}` : ""} ${r ? `${ss.isV6 ? "fontsize |" : "fontsizeselect |"}` : ""} table | bullist | numlist | image ${f ? "| typhonjs-oembed" : ""} | hr | link | removeformat | save${t ? " | code" : ""}${o ? " | help" : ""}`, h = {
      content_css: Array.isArray(s) ? globalThis.CONFIG.TinyMCE.content_css.concat(s) : globalThis.CONFIG.TinyMCE.content_css,
      content_style: n,
      [`${ss.isV6 ? "font_size_formats" : "fontsize_formats"}`]: P(this, Ga),
      plugins: `${ss.isV6 ? "" : "hr paste"} emoticons image link lists charmap table ${f ? "typhonjs-oembed" : ""} ${t ? "code" : ""} save ${o ? "help" : ""} wordcount`,
      style_formats: m,
      style_formats_merge: !1,
      // For typhonjs-oembed plugin when loaded.
      oembed_live_embeds: !1,
      oembed_default_width: 424,
      oembed_default_height: 238,
      oembed_disable_file_source: !0,
      // This allows the manual addition of a style tag in the code editor.
      valid_children: "+body[style]",
      // Note we can include all internal tags as we prefilter the URL to make sure it is for YouTube then use the
      // oembed API to get the embed URL.
      extended_valid_elements: "iframe[allow|allowfullscreen|frameborder|scrolling|class|style|src|width|height]"
    };
    return h.toolbar = p ? g : !1, h;
  }
  /**
   * Provides the TJS super cool TinyMCE configuration options. These options are selected for increased media
   * embedding and styling flexibility.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.basicFormats=false] - When true, only basic style formats are allowed.
   *
   * @param {boolean}  [opts.code=true] - When true include source code editing option.
   *
   * @param {string[]} [opts.contentCSS] - An array of CSS paths to load. `getRoute` will be applied to them.
   *
   * @param {string}   [opts.contentStyle=''] - The same content style string for TinyMCE options.
   *
   * @param {boolean}  [opts.fontFormat=true] - Includes font formats, size, line spacing and color options.
   *
   * @param {boolean}  [opts.fontSize=true] - Includes font size options.
   *
   * @param {boolean}  [opts.help=false] - When true include help plugin / toolbar button.
   *
   * @param {boolean}  [opts.stripStyleFormat=true] - Strips any additional style formats added by other modules.
   *
   * @param {boolean}  [opts.styleFormat=true] - Includes style format select box.
   *
   * @param {boolean}  [opts.tjsOembed=true] - Includes custom oEmbed plugin to include video from YouTube / Vimeo.
   *
   * @param {boolean}  [opts.tjsStyles=true] - Includes extensive TJS styling options.
   *
   * @param {boolean}  [opts.toolbar=true] - Includes the editor toolbar.
   *
   * @returns {object} TinyMCE options
   */
  static configTJS({
    basicFormats: e = !1,
    code: t = !0,
    contentCSS: s,
    contentStyle: n = "",
    fontFormat: l = !0,
    fontSize: r = !0,
    help: o = !1,
    stripStyleFormat: a = !0,
    styleFormat: c = !0,
    tjsOembed: f = !0,
    tjsStyles: d = !0,
    toolbar: p = !0
  } = {}) {
    const m = X(this, qa, Rd).call(this, e, a, d ? P(this, za) : []), g = `${c ? `${ss.isV6 ? "styles |" : "styleselect |"}` : ""} table | ${l ? "formatgroup |" : ""} removeformat | insertgroup | bulletgroup | save${t ? " | code" : ""}${o ? " | help" : ""}`, h = {
      plugins: `${ss.isV6 ? "" : "hr paste"} emoticons image link lists ${f ? "typhonjs-oembed" : ""} charmap table ${t ? "code" : ""} save ${o ? "help" : ""} wordcount`,
      toolbar_groups: {
        bulletgroup: {
          icon: "unordered-list",
          tooltip: "Lists",
          items: "bullist | numlist"
        },
        formatgroup: {
          icon: "format",
          tooltip: "Fonts",
          items: `${ss.isV6 ? "fontfamily |" : "fontselect |"} ${r ? `${ss.isV6 ? "fontsize |" : "fontsizeselect |"}` : ""} lineheight | forecolor backcolor`
        },
        insertgroup: {
          icon: "plus",
          tooltip: "Insert",
          items: `link image ${f ? "typhonjs-oembed" : ""} emoticons charmap hr`
        }
      },
      content_css: Array.isArray(s) ? globalThis.CONFIG.TinyMCE.content_css.concat(s) : globalThis.CONFIG.TinyMCE.content_css,
      content_style: n,
      contextmenu: !1,
      // Prefer default browser context menu
      [`${ss.isV6 ? "font_size_formats" : "fontsize_formats"}`]: P(this, Ga),
      file_picker_types: "image media",
      image_advtab: !0,
      [`${ss.isV6 ? "line_height_formats" : "lineheight_formats"}`]: P(this, ng),
      // For typhonjs-oembed plugin when loaded.
      oembed_live_embeds: !1,
      oembed_default_width: 424,
      oembed_default_height: 238,
      oembed_disable_file_source: !0,
      style_formats: m,
      style_formats_merge: !1,
      table_class_list: P(this, ig),
      // This allows the manual addition of a style tag in the code editor.
      valid_children: "+body[style]",
      // Note we can include all internal tags as we prefilter the URL to make sure it is for YouTube then use the
      // oembed API to get the embed URL.
      extended_valid_elements: "iframe[allow|allowfullscreen|frameborder|scrolling|class|style|src|width|height]"
    };
    return h.toolbar = p ? g : !1, h;
  }
  /**
   * Provides a combined `mceConfig` and other default options to create a single line editor that prevents pasting,
   * prevents enter key / new lines, saves on editor blur, and doesn't show the toolbar. This is useful as a shortcut
   * to enable TJSTinyMCE to act as a content editable text entry for a single line text field.
   *
   * Note: Since this function returns an object w/ mceConfig and other options you must use it like in TJSTinyMCE
   * options; where `font-size` in contentStyleBody and any other styles match the editor CSS variables:
   *
   * ...TinyMCEHelper.configSingleLine({ contentStyleBody: { 'font-size': '22pt' }})
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {string[]} [opts.contentCSS] - An array of CSS paths to load. `getRoute` will be applied to them.
   *
   * @param {string}   [opts.contentStyle=''] - The same content style string for TinyMCE options.
   *
   * @returns {object} TinyMCE options
   */
  static optionsSingleLine({ contentCSS: e, contentStyle: t = "" } = {}) {
    return {
      mceConfig: {
        ...this.configBasic({ contentCSS: e, contentStyle: t, toolbar: !1 }),
        save_enablewhendirty: !1
      },
      preventEnterKey: !0,
      saveOnEnterKey: !0,
      saveOnBlur: !0
    };
  }
};
qa = new WeakSet(), Rd = /* @__PURE__ */ u(function(e = !1, t = !0, s = []) {
  const n = JSON.parse(JSON.stringify(e ? P(this, sg) : P(this, eg))), l = e ? 0 : 1;
  if (t)
    n[l].items.push(P(this, Gf));
  else {
    const r = globalThis.CONFIG.TinyMCE.style_formats.filter((o) => o.title !== "Custom");
    n.push(...r), n[l].items.push(P(this, Gf));
  }
  return n.concat(s);
}, "#getStyleFormats"), eg = new WeakMap(), tg = new WeakMap(), sg = new WeakMap(), Gf = new WeakMap(), Ga = new WeakMap(), ng = new WeakMap(), ig = new WeakMap(), za = new WeakMap(), x(Jn, qa), u(Jn, "TinyMCEHelper"), // Static data -----------------------------------------------------------------------------------------------------
/**
 * Defines the standard all style formats menu for style formats.
 *
 * @type {object[]}
 */
x(Jn, eg, [
  {
    title: "Headings",
    items: [
      { title: "Heading 1", format: "h1" },
      { title: "Heading 2", format: "h2" },
      { title: "Heading 3", format: "h3" },
      { title: "Heading 4", format: "h4" },
      { title: "Heading 5", format: "h5" },
      { title: "Heading 6", format: "h6" }
    ]
  },
  {
    title: "Blocks",
    items: [
      { title: "Paragraph", format: "p" },
      { title: "Blockquote", format: "blockquote" },
      { title: "Pre", format: "pre" }
    ]
  },
  {
    title: "Inline",
    items: [
      { title: "Bold", format: "bold" },
      { title: "Italic", format: "italic" },
      { title: "Code", format: "code" },
      { title: "Underline", format: "underline" },
      { title: "Strikethrough", format: "strikethrough" },
      { title: "Superscript", format: "superscript" },
      { title: "Subscript", format: "subscript" }
    ]
  },
  {
    title: "Align",
    items: [
      { title: "Left", format: "alignleft" },
      { title: "Center", format: "aligncenter" },
      { title: "Right", format: "alignright" },
      { title: "Justify", format: "alignjustify" }
    ]
  }
]), /**
 * Removes the TMCE core format options that are not considered basic / essential formats when `basicFormats`
 * is true.
 *
 * @type {object}
 */
x(Jn, tg, {
  blockquote: {},
  div: {},
  h1: {},
  h2: {},
  h3: {},
  h4: {},
  h5: {},
  h6: {},
  pre: {}
}), /**
 * Defines the limited style formats options when `basicFormats` is true.
 *
 * @type {object[]}
 */
x(Jn, sg, [
  {
    title: "Blocks",
    items: [
      { title: "Paragraph", format: "p" }
    ]
  },
  {
    title: "Inline",
    items: [
      { title: "Bold", format: "bold" },
      { title: "Italic", format: "italic" },
      { title: "Underline", format: "underline" },
      { title: "Strikethrough", format: "strikethrough" },
      { title: "Superscript", format: "superscript" },
      { title: "Subscript", format: "subscript" },
      { title: "Code", format: "code" }
    ]
  },
  {
    title: "Align",
    items: [
      { title: "Left", format: "alignleft" },
      { title: "Center", format: "aligncenter" },
      { title: "Right", format: "alignright" },
      { title: "Justify", format: "alignjustify" }
    ]
  }
]), /**
 * Defines the secret FVTT core format item.
 *
 * @type {object}
 */
x(Jn, Gf, {
  title: "Secret",
  block: "section",
  classes: "secret",
  wrapper: !0
}), /**
 * Defines the font sizes available in the toolbar options.
 *
 * @type {string}
 */
x(Jn, Ga, "10.5pt 12pt 13pt 14pt 15pt 16pt 18pt 22pt 28pt 32pt 36pt 42pt 48pt 64pt"), /**
 * Defines the line-height styles available in the toolbar options.
 *
 * @type {string}
 */
x(Jn, ng, "0.8 0.9 1 1.1 1.2 1.3 1.4 1.5 1.75 2"), /**
 * Provides a class list for the table dialog.
 *
 * @type {object}
 */
x(Jn, ig, [
  { title: "None", value: "" },
  { title: "No Colors / Border", value: "tmce-nocolors" }
]), /**
 * Provides extra CSS styles to configure text and various elements in TinyMCE.
 *
 * @type {object[]}
 */
x(Jn, za, [{
  title: "Styles",
  items: [
    {
      title: "Blend Mode",
      items: [
        {
          title: "BM Unset",
          selector: "*",
          styles: {
            "mix-blend-mode": "unset"
          }
        },
        {
          title: "BM Normal",
          selector: "*",
          styles: {
            "mix-blend-mode": "normal"
          }
        },
        {
          title: "BM Multiply",
          selector: "*",
          styles: {
            "mix-blend-mode": "multiply"
          }
        },
        {
          title: "BM Screen",
          selector: "*",
          styles: {
            "mix-blend-mode": "screen"
          }
        },
        {
          title: "BM Overlay",
          selector: "*",
          styles: {
            "mix-blend-mode": "overlay"
          }
        },
        {
          title: "BM Darken",
          selector: "*",
          styles: {
            "mix-blend-mode": "darken"
          }
        },
        {
          title: "BM Lighten",
          selector: "*",
          styles: {
            "mix-blend-mode": "lighten"
          }
        },
        {
          title: "BM Color Dodge",
          selector: "*",
          styles: {
            "mix-blend-mode": "color-dodge"
          }
        },
        {
          title: "BM Color Burn",
          selector: "*",
          styles: {
            "mix-blend-mode": "color-burn"
          }
        },
        {
          title: "BM Hard Light",
          selector: "*",
          styles: {
            "mix-blend-mode": "hard-light"
          }
        },
        {
          title: "BM Soft Light",
          selector: "*",
          styles: {
            "mix-blend-mode": "soft-light"
          }
        },
        {
          title: "BM Difference",
          selector: "*",
          styles: {
            "mix-blend-mode": "difference"
          }
        },
        {
          title: "BM Exclusion",
          selector: "*",
          styles: {
            "mix-blend-mode": "exclusion"
          }
        },
        {
          title: "BM Hue",
          selector: "*",
          styles: {
            "mix-blend-mode": "hue"
          }
        },
        {
          title: "BM Saturation",
          selector: "*",
          styles: {
            "mix-blend-mode": "saturation"
          }
        },
        {
          title: "BM Color",
          selector: "*",
          styles: {
            "mix-blend-mode": "color"
          }
        },
        {
          title: "BM Luminosity",
          selector: "*",
          styles: {
            "mix-blend-mode": "luminosity"
          }
        }
      ]
    },
    {
      title: "Border",
      items: [
        {
          title: "No Border",
          selector: "*",
          styles: {
            border: "none"
          }
        },
        {
          title: "Border Radius",
          items: [
            {
              title: "BR None",
              selector: "*",
              styles: {
                "border-radius": "unset"
              }
            },
            {
              title: "BR 4px",
              selector: "*",
              styles: {
                "border-radius": "4px"
              }
            },
            {
              title: "BR 8px",
              selector: "*",
              styles: {
                "border-radius": "8px"
              }
            },
            {
              title: "BR 16px",
              selector: "*",
              styles: {
                "border-radius": "16px"
              }
            }
          ]
        }
      ]
    },
    {
      title: "Filters",
      items: [
        {
          title: "No Filter",
          selector: "*",
          styles: {
            filter: "none"
          }
        },
        {
          title: "Blur",
          items: [
            {
              title: "Blur 1px",
              selector: "*",
              styles: {
                filter: "blur(1px)"
              }
            },
            {
              title: "Blur 2px",
              selector: "*",
              styles: {
                filter: "blur(2px)"
              }
            },
            {
              title: "Blur 3px",
              selector: "*",
              styles: {
                filter: "blur(3px)"
              }
            },
            {
              title: "Blur 4px",
              selector: "*",
              styles: {
                filter: "blur(4px)"
              }
            }
          ]
        },
        {
          title: "Drop Shadow",
          items: [
            {
              title: "DS 2px",
              selector: "*",
              styles: {
                filter: "drop-shadow(2px 2px 2px black)"
              }
            },
            {
              title: "DS 4px",
              selector: "*",
              styles: {
                filter: "drop-shadow(4px 4px 3px black)"
              }
            },
            {
              title: "DS 8px",
              selector: "*",
              styles: {
                filter: "drop-shadow(8px 8px 6px black)"
              }
            }
          ]
        },
        {
          title: "Grayscale",
          items: [
            {
              title: "GS 25%",
              selector: "*",
              styles: {
                filter: "grayscale(25%)"
              }
            },
            {
              title: "GS 50%",
              selector: "*",
              styles: {
                filter: "grayscale(50%)"
              }
            },
            {
              title: "GS 75%",
              selector: "*",
              styles: {
                filter: "grayscale(75%)"
              }
            },
            {
              title: "GS 100%",
              selector: "*",
              styles: {
                filter: "grayscale(100%)"
              }
            }
          ]
        }
      ]
    },
    {
      title: "Float",
      items: [
        {
          title: "Float Left",
          selector: "*",
          styles: {
            float: "left",
            margin: "0 10px 0 0"
          }
        },
        {
          title: "Float Right",
          selector: "*",
          styles: {
            float: "right",
            margin: "0 0 0 10px"
          }
        }
      ]
    },
    {
      title: "Fonts",
      items: [
        {
          title: "Neon",
          items: [
            {
              title: "Neon Blue",
              selector: "*",
              styles: {
                color: "#fff",
                "text-shadow": "0 0 5px #fff, 0 0 10px #fff, 0 0 15px #0073e6, 0 0 20px #0073e6, 0 0 25px #0073e6"
              }
            },
            {
              title: "Neon Green",
              selector: "*",
              styles: {
                color: "#fff",
                "text-shadow": "0 0 5px #fff, 0 0 10px #fff, 0 0 15px #00e704, 0 0 20px #00e704, 0 0 25px #00e704"
              }
            },
            {
              title: "Neon Red",
              selector: "*",
              styles: {
                color: "#fff",
                "text-shadow": "0 0 5px #fff, 0 0 10px #fff, 0 0 15px #e70000, 0 0 20px #e70000, 0 0 25px #e70000"
              }
            },
            {
              title: "Neon Purple",
              selector: "*",
              styles: {
                color: "#fff",
                "text-shadow": "0 0 5px #fff, 0 0 10px #fff, 0 0 15px #7900ea, 0 0 20px #7900ea, 0 0 25px #7900ea"
              }
            }
          ]
        }
      ]
    },
    {
      title: "Margin",
      items: [
        {
          title: "No Margin",
          selector: "*",
          styles: {
            margin: "unset"
          }
        },
        {
          title: "Top",
          items: [
            {
              title: "MT 5px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-top": "5px"
              }
            },
            {
              title: "MT 10px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-top": "10px"
              }
            },
            {
              title: "MT 15px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-top": "15px"
              }
            },
            {
              title: "MT 25px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-top": "25px"
              }
            }
          ]
        },
        {
          title: "Left",
          items: [
            {
              title: "ML 5px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "5px"
              }
            },
            {
              title: "ML 10px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "10px"
              }
            },
            {
              title: "ML 15px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "15px"
              }
            },
            {
              title: "ML 25px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "25px"
              }
            },
            {
              title: "ML 50px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "50px"
              }
            },
            {
              title: "ML 75px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "75px"
              }
            },
            {
              title: "ML 100px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "100px"
              }
            }
          ]
        },
        {
          title: "Bottom",
          items: [
            {
              title: "MB 5px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-bottom": "5px"
              }
            },
            {
              title: "MB 10px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-bottom": "10px"
              }
            },
            {
              title: "MB 15px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-bottom": "15px"
              }
            },
            {
              title: "MB 25px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-bottom": "25px"
              }
            }
          ]
        },
        {
          title: "Right",
          items: [
            {
              title: "MR 5px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "5px"
              }
            },
            {
              title: "MR 10px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "10px"
              }
            },
            {
              title: "MR 15px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "15px"
              }
            },
            {
              title: "MR 25px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "25px"
              }
            },
            {
              title: "MR 50px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "50px"
              }
            },
            {
              title: "MR 75px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "75px"
              }
            },
            {
              title: "MR 100px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "100px"
              }
            }
          ]
        }
      ]
    },
    {
      title: "Opacity",
      items: [
        {
          title: "OP 100%",
          selector: "*",
          styles: {
            opacity: "1"
          }
        },
        {
          title: "OP 90%",
          selector: "*",
          styles: {
            opacity: "0.9"
          }
        },
        {
          title: "OP 80%",
          selector: "*",
          styles: {
            opacity: "0.8"
          }
        },
        {
          title: "OP 70%",
          selector: "*",
          styles: {
            opacity: "0.7"
          }
        },
        {
          title: "OP 60%",
          selector: "*",
          styles: {
            opacity: "0.6"
          }
        },
        {
          title: "OP 50%",
          selector: "*",
          styles: {
            opacity: "0.5"
          }
        },
        {
          title: "OP 40%",
          selector: "*",
          styles: {
            opacity: "0.4"
          }
        },
        {
          title: "OP 30%",
          selector: "*",
          styles: {
            opacity: "0.3"
          }
        },
        {
          title: "OP 20%",
          selector: "*",
          styles: {
            opacity: "0.2"
          }
        },
        {
          title: "OP 10%",
          selector: "*",
          styles: {
            opacity: "0.1"
          }
        }
      ]
    }
  ]
}]);
let Ap = Jn;
function w4(i) {
  let e, t, s;
  return {
    c() {
      e = E("a"), e.innerHTML = '<i class="fas fa-edit"></i>', b(e, "class", "editor-edit svelte-1fiwjzl"), b(e, "role", "button"), b(e, "tabindex", "-1");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler*/
        i[21]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(w4, "create_if_block_1$1j");
function $4(i) {
  let e, t;
  return {
    c() {
      e = new bn(!1), t = $e(), e.a = t;
    },
    m(s, n) {
      e.m(
        /*enrichedContent*/
        i[1],
        s,
        n
      ), T(s, t, n);
    },
    p(s, n) {
      n[0] & /*enrichedContent*/
      2 && e.p(
        /*enrichedContent*/
        s[1]
      );
    },
    d(s) {
      s && (C(t), e.d());
    }
  };
}
u($4, "create_if_block$1Z");
function vZ(i) {
  let e, t, s, n, l, r, o, a, c = (
    /*editorButton*/
    i[6] && w4(i)
  ), f = !/*editorActive*/
  i[4] && $4(i);
  return {
    c() {
      var d;
      e = E("div"), c && c.c(), t = F(), s = E("div"), f && f.c(), b(s, "class", "editor-content tjs-editor-content svelte-1fiwjzl"), b(e, "class", l = "editor tinymce tjs-editor " + (Array.isArray(
        /*options*/
        (d = i[0]) == null ? void 0 : d.classes
      ) ? (
        /*options*/
        i[0].classes.join(" ")
      ) : "") + " svelte-1fiwjzl"), b(e, "role", "textbox"), b(e, "tabindex", "0"), Z(
        e,
        "click-to-edit",
        /*clickToEdit*/
        i[2]
      ), Z(
        e,
        "editor-active",
        /*editorActive*/
        i[4]
      );
    },
    m(d, p) {
      var m;
      T(d, e, p), c && c.m(e, null), A(e, t), A(e, s), f && f.m(s, null), i[22](s), i[23](e), o || (a = [
        Et(n = /*mountRevealSecretButtons*/
        i[11].call(null, s, {
          mountRevealButtons: !/*editorActive*/
          i[4] && /*editable*/
          i[3],
          enrichedContent: (
            /*enrichedContent*/
            i[1]
          )
        })),
        Et(r = Xs.call(
          null,
          e,
          /*options*/
          (m = i[0]) == null ? void 0 : m.styles
        )),
        W(
          e,
          "click",
          /*onClick*/
          i[13]
        ),
        W(
          e,
          "keydown",
          /*onKeydown*/
          i[14]
        ),
        W(
          e,
          "keyup",
          /*onKeyup*/
          i[15]
        )
      ], o = !0);
    },
    p(d, p) {
      var m, g;
      /*editorButton*/
      d[6] ? c ? c.p(d, p) : (c = w4(d), c.c(), c.m(e, t)) : c && (c.d(1), c = null), /*editorActive*/
      d[4] ? f && (f.d(1), f = null) : f ? f.p(d, p) : (f = $4(d), f.c(), f.m(s, null)), n && $t(n.update) && p[0] & /*editorActive, editable, enrichedContent*/
      26 && n.update.call(null, {
        mountRevealButtons: !/*editorActive*/
        d[4] && /*editable*/
        d[3],
        enrichedContent: (
          /*enrichedContent*/
          d[1]
        )
      }), p[0] & /*options*/
      1 && l !== (l = "editor tinymce tjs-editor " + (Array.isArray(
        /*options*/
        (m = d[0]) == null ? void 0 : m.classes
      ) ? (
        /*options*/
        d[0].classes.join(" ")
      ) : "") + " svelte-1fiwjzl") && b(e, "class", l), r && $t(r.update) && p[0] & /*options*/
      1 && r.update.call(
        null,
        /*options*/
        (g = d[0]) == null ? void 0 : g.styles
      ), p[0] & /*options, clickToEdit*/
      5 && Z(
        e,
        "click-to-edit",
        /*clickToEdit*/
        d[2]
      ), p[0] & /*options, editorActive*/
      17 && Z(
        e,
        "editor-active",
        /*editorActive*/
        d[4]
      );
    },
    i: se,
    o: se,
    d(d) {
      d && C(e), c && c.d(), f && f.d(), i[22](null), i[23](null), o = !1, Me(a);
    }
  };
}
u(vZ, "create_fragment$3A");
function kZ(i, e, t) {
  var Pe, ye, me;
  let s, n, l, { content: r = "" } = e, { enrichedContent: o = "" } = e, { options: a = {} } = e;
  const c = (Pe = de("#external")) == null ? void 0 : Pe.application, f = (c == null ? void 0 : c.position) ?? Mt(!1);
  pe(i, f, (Ce) => t(19, n = Ce));
  const d = ((me = (ye = c == null ? void 0 : c.reactive) == null ? void 0 : ye.storeUIState) == null ? void 0 : me.activeWindow) ?? Mt(globalThis);
  pe(i, d, (Ce) => t(20, l = Ce));
  const p = ft(), m = new Zt({ delete: Y });
  pe(i, m, (Ce) => t(18, s = Ce));
  const g = yZ(m, a);
  let h = l, _, y = !0, v, k = !1, S, D, I, M, L = !1, B;
  Qt(() => {
    k ? ke({
      remove: typeof (a == null ? void 0 : a.button) == "boolean" ? a.button : !0
    }) : z();
  }), $o(() => {
    y && !S && !_ && q();
  });
  function z(Ce = !0) {
    v && (setTimeout(
      () => {
        v == null || v.destroy(), D && t(7, D.innerText = "", D), v = void 0, setTimeout(() => t(4, k = !1), 0), L && (L = !1, setTimeout(
          () => {
            I instanceof HTMLElement && (I != null && I.isConnected) && I.focus();
          },
          100
        ));
      },
      0
    ), Ce && p("editor:cancel"));
  }
  u(z, "destroyEditor");
  async function q() {
    var je;
    const Ce = (je = a == null ? void 0 : a.mceConfig) == null ? void 0 : je.setup, { fonts: Je, fontFormats: Ne } = ss.getFontData(a == null ? void 0 : a.fonts), Re = {
      ...(a == null ? void 0 : a.mceConfig) ?? Ap.configStandard(),
      engine: "tinymce",
      [`${ss.isV6 ? "font_family_formats" : "font_formats"}`]: Ne,
      target: D,
      save_onsavecallback: /* @__PURE__ */ u(() => ke(), "save_onsavecallback"),
      height: "100%",
      paste_as_text: B >= 0
      // Pasted content must be text when limiting to a max length;
    };
    Re.setup = (Be) => {
      Be.on("beforeinput", (Ze) => ss.beforeInputHandler(Be, Ze, a, B)), Be.on("keydown", (Ze) => ss.keydownHandler(Be, Ze, a, ke, r)), typeof Ce == "function" && Ce(Be);
    }, Re.paste_preprocess = (Be, Ze) => ss.pastePreprocess(v, Ze, a, B), Re.content_style = `${ss.setMCEConfigContentStyle(D)} ${Re.content_style}`, t(4, k = !0), await I5(), v = await TextEditor.create(Re, r), ss.setInitialSelection(v, a == null ? void 0 : a.initialSelection, "start");
    const ge = I.querySelector(".tox-edit-area__iframe");
    ge && await wu.loadFonts({
      document: ge.contentDocument,
      fonts: Je
    }), v.on("blur", (Be) => U()), h === globalThis && v.on("click", () => {
      var Be;
      return (Be = c == null ? void 0 : c.bringToTop) == null ? void 0 : Be.call(c);
    }), p("editor:start");
  }
  u(q, "initEditor");
  function U() {
    k && typeof (a == null ? void 0 : a.saveOnBlur) == "boolean" && (a != null && a.saveOnBlur) && ke();
  }
  u(U, "onBlur");
  function H() {
    !k && _ && q();
  }
  u(H, "onClick");
  async function V(Ce, Je) {
    if (typeof Ce == "string")
      if (Je) {
        const Ne = (s == null ? void 0 : s.isOwner) ?? !1, Re = s ?? void 0, ge = he(a == null ? void 0 : a.enrichOptions) ? {
          secrets: globalThis.game.user.isGM || Ne,
          relativeTo: Re,
          ...a.enrichOptions,
          async: !0
        } : {
          async: !0,
          relativeTo: Re,
          secrets: globalThis.game.user.isGM || Ne
        };
        t(1, o = await TextEditor.enrichHTML(Ce, ge));
      } else
        t(1, o = Ce);
    else
      t(1, o = "");
    p("editor:enrichedContent", { enrichedContent: o });
  }
  u(V, "onContentChanged");
  function Y(Ce) {
    he(a) && t(0, a.document = void 0, a), z(), p("editor:document:deleted", { document: Ce }), t(16, r = ""), t(1, o = "");
  }
  u(Y, "onDocumentDeleted");
  function J(Ce) {
    k ? (Ce.code === "Escape" || Ce.code === "KeyS" && (Ce.ctrlKey || Ce.metaKey)) && (Ce.preventDefault(), Ce.stopPropagation()) : Ce.code === M && (Ce.preventDefault(), Ce.stopPropagation());
  }
  u(J, "onKeydown");
  function fe(Ce) {
    Ce.code === M && (k || (L = !0, q()), Ce.preventDefault(), Ce.stopPropagation());
  }
  u(fe, "onKeyup");
  function ke({ remove: Ce = typeof (a == null ? void 0 : a.button) == "boolean" ? a.button : !0 } = {}) {
    if (v) {
      let Je = ss.addSecretIDs(v.getContent());
      const Ne = Je !== r;
      Ne && (s && typeof (a == null ? void 0 : a.fieldName) == "string" ? s.update({ [a.fieldName]: Je }) : t(16, r = Je), p("editor:save", { content: Je })), Ce && z(!Ne);
    }
  }
  u(ke, "saveEditor");
  const ee = /* @__PURE__ */ u(() => q(), "click_handler");
  function ne(Ce) {
    rt[Ce ? "unshift" : "push"](() => {
      D = Ce, t(7, D);
    });
  }
  u(ne, "div0_binding");
  function Ee(Ce) {
    rt[Ce ? "unshift" : "push"](() => {
      I = Ce, t(5, I);
    });
  }
  return u(Ee, "div1_binding"), i.$$set = (Ce) => {
    "content" in Ce && t(16, r = Ce.content), "enrichedContent" in Ce && t(1, o = Ce.enrichedContent), "options" in Ce && t(0, a = Ce.options);
  }, i.$$.update = () => {
    var Ce;
    if (i.$$.dirty[0] & /*activeWindow, $applicationActiveWindow, editorActive*/
    1179664 && h !== l && (k && ke(), t(17, h = l)), i.$$.dirty[0] & /*editorActive, editorEl, $applicationPosition*/
    524336 && k && I && n) {
      const Je = ss.isV6 ? ".tox-tbtn[aria-controls^='aria-controls_']" : ".tox-tbtn[aria-owns^='aria-owns_']", Ne = I.querySelector(Je);
      Ne && Ne.click();
      const Re = document.querySelector(".tox.tox-tinymce-aux");
      if (Re) {
        let ge = Re.lastElementChild;
        for (; ge; )
          Re.removeChild(ge), ge = Re.lastElementChild;
      }
    }
    if (i.$$.dirty[0] & /*options, $doc, editable*/
    262153 && (typeof (a == null ? void 0 : a.editable) == "boolean" ? t(3, y = a.editable) : t(3, y = game.user.isGM || (((Ce = s ?? a.document) == null ? void 0 : Ce.isOwner) ?? !1)), y || z()), i.$$.dirty[0] & /*editorActive, editable, options*/
    25 && t(2, _ = !k && y && (typeof (a == null ? void 0 : a.clickToEdit) == "boolean" ? a.clickToEdit : !1)), i.$$.dirty[0] & /*editorActive, editable, options, clickToEdit*/
    29 && t(6, S = !k && y && (typeof (a == null ? void 0 : a.button) == "boolean" ? a.button : !0) && !_), i.$$.dirty[0] & /*options*/
    1 && (M = typeof (a == null ? void 0 : a.keyCode) == "string" ? a.keyCode : "Enter"), i.$$.dirty[0] & /*options*/
    1 && (B = Number.isInteger(a == null ? void 0 : a.maxCharacterLength) && (a == null ? void 0 : a.maxCharacterLength) >= 0 ? a.maxCharacterLength : void 0), i.$$.dirty[0] & /*options*/
    1 && a != null && a.fonts && wu.loadFonts({ fonts: a.fonts }), i.$$.dirty[0] & /*options, $doc*/
    262145)
      if ((a == null ? void 0 : a.document) !== void 0) {
        if (!(a.document instanceof globalThis.foundry.abstract.Document))
          throw new TypeError("TJSTinyMCE error: 'options.document' is not a Foundry document.");
        if (typeof (a == null ? void 0 : a.fieldName) != "string")
          throw new TypeError("TJSTinyMCE error: 'options.document' is defined, but 'options.fieldName' is not a string.");
        a.document !== s && (t(1, o = ""), t(16, r = ""), z(), m.set(a.document));
      } else
        s && (t(1, o = ""), t(16, r = ""), z(), m.set(void 0));
    i.$$.dirty[0] & /*$doc, options, content*/
    327681 && (t(16, r = s !== void 0 && typeof (a == null ? void 0 : a.fieldName) == "string" ? globalThis.foundry.utils.getProperty(s, a.fieldName) : typeof r == "string" ? r : ""), V(r, typeof (a == null ? void 0 : a.enrichContent) == "boolean" ? a == null ? void 0 : a.enrichContent : !0));
  }, [
    a,
    o,
    _,
    y,
    k,
    I,
    S,
    D,
    f,
    d,
    m,
    g,
    q,
    H,
    J,
    fe,
    r,
    h,
    s,
    n,
    l,
    ee,
    ne,
    Ee
  ];
}
u(kZ, "instance$3r");
const PA = class PA extends re {
  constructor(e) {
    super(), oe(
      this,
      e,
      kZ,
      vZ,
      le,
      {
        content: 16,
        enrichedContent: 1,
        options: 0
      },
      null,
      [-1, -1]
    );
  }
};
u(PA, "TJSTinyMCE");
let by = PA;
function wZ(i) {
  let e, t, s;
  return t = new by({
    props: {
      content: (
        /*content*/
        i[0]
      ),
      enrichedContent: (
        /*enrichedContent*/
        i[2]
      ),
      options: (
        /*options*/
        i[4]
      )
    }
  }), t.$on(
    "editor:save",
    /*updateEditorContent*/
    i[3]
  ), {
    c() {
      e = E("div"), j(t.$$.fragment), b(e, "class", "editor svelte-1dqah55");
    },
    m(n, l) {
      T(n, e, l), R(t, e, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*content*/
      1 && (r.content = /*content*/
      n[0]), l & /*enrichedContent*/
      4 && (r.enrichedContent = /*enrichedContent*/
      n[2]), t.$set(r);
    },
    i(n) {
      s || (w(t.$$.fragment, n), s = !0);
    },
    o(n) {
      O(t.$$.fragment, n), s = !1;
    },
    d(n) {
      n && C(e), N(t);
    }
  };
}
u(wZ, "create_fragment$3z");
function $Z(i, e, t) {
  var y;
  let s, n, l = se, r = /* @__PURE__ */ u(() => (l(), l = Xt(o, (v) => t(8, n = v)), o), "$$subscribe_document");
  i.$$.on_destroy.push(() => l());
  let { document: o } = e;
  r();
  let { content: a } = e, { updatePath: c } = e;
  const f = {
    secretDescription: "A5E.NoSecretDescription",
    unidentifiedDescription: "A5E.NoUnidentifiedDescription",
    description: "A5E.NoDescription"
  };
  function d(v) {
    const { content: k } = v.detail;
    n.update({
      [c]: k === "" ? "" : k
    });
  }
  u(d, "updateEditorContent");
  async function p() {
    return await TextEditor.enrichHTML(n[c], h);
  }
  u(p, "getEnrichedContent");
  let m;
  Object.entries(f).forEach(([v, k]) => {
    c.includes(v) && t(6, m = K(k));
  });
  const g = Ap.configStandard();
  g.toolbar = "styles | fontfamily | table | bullist | numlist | image | superscript | subscript | hr | save | link | removeformat | code ";
  const h = {
    secrets: n.isOwner,
    relativeTo: n,
    rollData: n.documentName === "Actor" ? n.getRollData() : ((y = n.actor) == null ? void 0 : y.getRollData(n)) ?? void 0
  }, _ = {
    editable: game.user.isGM || n.isOwner || !1,
    enrichOptions: h,
    mceConfig: g
  };
  return i.$$set = (v) => {
    "document" in v && r(t(1, o = v.document)), "content" in v && t(0, a = v.content), "updatePath" in v && t(5, c = v.updatePath);
  }, i.$$.update = () => {
    i.$$.dirty & /*content, newLabel*/
    65 && (t(0, a = a || m) || K("A5E.NoDescription"));
  }, t(2, s = Promise.resolve(p()).then((v) => v).catch(() => "Error Enriching Content")), [
    a,
    o,
    s,
    d,
    _,
    c,
    m
  ];
}
u($Z, "instance$3q");
const MA = class MA extends re {
  constructor(e) {
    super(), oe(this, e, $Z, wZ, le, { document: 1, content: 0, updatePath: 5 });
  }
};
u(MA, "Editor");
let wr = MA;
function A4(i, e, t) {
  const s = i.slice();
  return s[5] = e[t].field, s[6] = e[t].label, s;
}
u(A4, "get_each_context$1p");
function E4(i) {
  let e, t = (
    /*summaryData*/
    i[0].objectMechanics + ""
  ), s;
  return {
    c() {
      e = E("p"), s = Q(t), b(e, "class", "item-properties svelte-1lo5rdm");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*summaryData*/
      1 && t !== (t = /*summaryData*/
      n[0].objectMechanics + "") && be(s, t);
    },
    d(n) {
      n && C(e);
    }
  };
}
u(E4, "create_if_block_5$k");
function S4(i) {
  let e, t = (
    /*summaryData*/
    i[0].objectProperties + ""
  ), s;
  return {
    c() {
      e = E("p"), s = Q(t), b(e, "class", "item-properties svelte-1lo5rdm");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*summaryData*/
      1 && t !== (t = /*summaryData*/
      n[0].objectProperties + "") && be(s, t);
    },
    d(n) {
      n && C(e);
    }
  };
}
u(S4, "create_if_block_4$t");
function C4(i) {
  let e, t = (
    /*summaryData*/
    i[0].maneuverProperties + ""
  ), s;
  return {
    c() {
      e = E("p"), s = Q(t), b(e, "class", "item-properties svelte-1lo5rdm");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*summaryData*/
      1 && t !== (t = /*summaryData*/
      n[0].maneuverProperties + "") && be(s, t);
    },
    d(n) {
      n && C(e);
    }
  };
}
u(C4, "create_if_block_3$z");
function T4(i) {
  let e, t = (
    /*summaryData*/
    i[0].spellProperties + ""
  ), s;
  return {
    c() {
      e = E("p"), s = Q(t), b(e, "class", "item-properties svelte-1lo5rdm");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*summaryData*/
      1 && t !== (t = /*summaryData*/
      n[0].spellProperties + "") && be(s, t);
    },
    d(n) {
      n && C(e);
    }
  };
}
u(T4, "create_if_block_2$T");
function O4(i) {
  let e, t, s = ue(
    /*fields*/
    i[2]
  ), n = [];
  for (let l = 0; l < s.length; l += 1)
    n[l] = I4(A4(i, s, l));
  return {
    c() {
      e = E("ul");
      for (let l = 0; l < n.length; l += 1)
        n[l].c();
      b(e, "class", "summary-list svelte-1lo5rdm"), ks(() => (
        /*ul_elementresize_handler*/
        i[4].call(e)
      )), Z(
        e,
        "hide",
        /*listHeight*/
        i[1] === 0
      );
    },
    m(l, r) {
      T(l, e, r);
      for (let o = 0; o < n.length; o += 1)
        n[o] && n[o].m(e, null);
      t = hG(
        e,
        /*ul_elementresize_handler*/
        i[4].bind(e)
      );
    },
    p(l, r) {
      if (r & /*summaryData, fields*/
      5) {
        s = ue(
          /*fields*/
          l[2]
        );
        let o;
        for (o = 0; o < s.length; o += 1) {
          const a = A4(l, s, o);
          n[o] ? n[o].p(a, r) : (n[o] = I4(a), n[o].c(), n[o].m(e, null));
        }
        for (; o < n.length; o += 1)
          n[o].d(1);
        n.length = s.length;
      }
      r & /*listHeight*/
      2 && Z(
        e,
        "hide",
        /*listHeight*/
        l[1] === 0
      );
    },
    d(l) {
      l && C(e), Le(n, l), t();
    }
  };
}
u(O4, "create_if_block$1Y");
function D4(i) {
  let e, t, s, n = (
    /*summaryData*/
    i[0][
      /*field*/
      i[5]
    ] + ""
  ), l, r;
  return {
    c() {
      e = E("li"), t = E("span"), t.textContent = `${K(
        /*label*/
        i[6]
      )}:`, s = F(), l = Q(n), r = F(), b(t, "class", "field-header svelte-1lo5rdm");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(e, l), A(e, r);
    },
    p(o, a) {
      a & /*summaryData*/
      1 && n !== (n = /*summaryData*/
      o[0][
        /*field*/
        o[5]
      ] + "") && be(l, n);
    },
    d(o) {
      o && C(e);
    }
  };
}
u(D4, "create_if_block_1$1i");
function I4(i) {
  let e, t = (
    /*summaryData*/
    i[0][
      /*field*/
      i[5]
    ] && D4(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*summaryData*/
      s[0][
        /*field*/
        s[5]
      ] ? t ? t.p(s, n) : (t = D4(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(I4, "create_each_block$1p");
function AZ(i) {
  let e, t, s, n, l, r = (
    /*fields*/
    i[2].some(
      /*func*/
      i[3]
    )
  ), o = (
    /*summaryData*/
    i[0].objectMechanics && E4(i)
  ), a = (
    /*summaryData*/
    i[0].objectProperties && S4(i)
  ), c = (
    /*summaryData*/
    i[0].maneuverProperties && C4(i)
  ), f = (
    /*summaryData*/
    i[0].spellProperties && T4(i)
  ), d = r && O4(i);
  return {
    c() {
      e = E("div"), o && o.c(), t = F(), a && a.c(), s = F(), c && c.c(), n = F(), f && f.c(), l = F(), d && d.c(), b(e, "class", "summary-wrapper svelte-1lo5rdm");
    },
    m(p, m) {
      T(p, e, m), o && o.m(e, null), A(e, t), a && a.m(e, null), A(e, s), c && c.m(e, null), A(e, n), f && f.m(e, null), A(e, l), d && d.m(e, null);
    },
    p(p, [m]) {
      /*summaryData*/
      p[0].objectMechanics ? o ? o.p(p, m) : (o = E4(p), o.c(), o.m(e, t)) : o && (o.d(1), o = null), /*summaryData*/
      p[0].objectProperties ? a ? a.p(p, m) : (a = S4(p), a.c(), a.m(e, s)) : a && (a.d(1), a = null), /*summaryData*/
      p[0].maneuverProperties ? c ? c.p(p, m) : (c = C4(p), c.c(), c.m(e, n)) : c && (c.d(1), c = null), /*summaryData*/
      p[0].spellProperties ? f ? f.p(p, m) : (f = T4(p), f.c(), f.m(e, l)) : f && (f.d(1), f = null), m & /*summaryData*/
      1 && (r = /*fields*/
      p[2].some(
        /*func*/
        p[3]
      )), r ? d ? d.p(p, m) : (d = O4(p), d.c(), d.m(e, null)) : d && (d.d(1), d = null);
    },
    i: se,
    o: se,
    d(p) {
      p && C(e), o && o.d(), a && a.d(), c && c.d(), f && f.d(), d && d.d();
    }
  };
}
u(AZ, "create_fragment$3y");
function EZ(i, e, t) {
  const s = [
    {
      field: "craftingComponents",
      label: "A5E.CraftingComponents"
    },
    { field: "spellClasses", label: "Classes" },
    {
      field: "activationCost",
      label: "A5E.ActionActivationCost"
    },
    { field: "ranges", label: "A5E.ItemRange" },
    {
      field: "targets",
      label: "A5E.ItemTargetPlural"
    },
    { field: "area", label: "A5E.TargetArea" },
    {
      field: "spellComponents",
      label: "A5E.SpellComponents"
    },
    {
      field: "duration",
      label: "A5E.ItemDuration"
    },
    {
      field: "savingThrow",
      label: "A5E.ItemSavingThrow"
    }
  ];
  let { summaryData: n = {} } = e, l;
  const r = /* @__PURE__ */ u(({ field: a }) => n[a], "func");
  function o() {
    l = this.clientHeight, t(1, l);
  }
  return u(o, "ul_elementresize_handler"), i.$$set = (a) => {
    "summaryData" in a && t(0, n = a.summaryData);
  }, [n, l, s, r, o];
}
u(EZ, "instance$3p");
const FA = class FA extends re {
  constructor(e) {
    super(), oe(this, e, EZ, AZ, le, { summaryData: 0 });
  }
};
u(FA, "ItemSummary");
let pc = FA;
function P4(i) {
  let e, t, s, n, l;
  return e = new pc({
    props: { summaryData: (
      /*summaryData*/
      i[0]
    ) }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), n = E("hr"), G(t, "display", "contents"), G(t, "--inline-padding", "0.25rem"), b(n, "class", "a5e-rule a5e-rule--card");
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), T(r, s, o), T(r, n, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*summaryData*/
      1 && (a.summaryData = /*summaryData*/
      r[0]), e.$set(a);
    },
    i(r) {
      l || (w(e.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), l = !1;
    },
    d(r) {
      r && (C(s), C(n)), r && e && C(t), N(e, r);
    }
  };
}
u(P4, "create_if_block$1X");
function SZ(i) {
  let e = Object.values(
    /*summaryData*/
    i[0] ?? {}
  ).some(Boolean), t, s, n, l, r, o, a = e && P4(i);
  return n = new tt({
    props: {
      heading: "A5E.ActionDescriptionOptions",
      hint: "A5E.ActionDescriptionOptionsHint",
      options: (
        /*descriptionOutputOptions*/
        i[6]
      ),
      selected: (
        /*descriptionOutputs*/
        i[2]
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), r = new wr({
    props: {
      document: (
        /*item*/
        i[4]
      ),
      content: (
        /*content*/
        i[3]
      ),
      updatePath: `system.actions.${/*actionId*/
      i[5]}.description`
    }
  }), {
    c() {
      a && a.c(), t = F(), s = E("section"), j(n.$$.fragment), l = F(), j(r.$$.fragment), b(s, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(c, f) {
      a && a.m(c, f), T(c, t, f), T(c, s, f), R(n, s, null), A(s, l), R(r, s, null), o = !0;
    },
    p(c, [f]) {
      f & /*summaryData*/
      1 && (e = Object.values(
        /*summaryData*/
        c[0] ?? {}
      ).some(Boolean)), e ? a ? (a.p(c, f), f & /*summaryData*/
      1 && w(a, 1)) : (a = P4(c), a.c(), w(a, 1), a.m(t.parentNode, t)) : a && (ae(), O(a, 1, 1, () => {
        a = null;
      }), ce());
      const d = {};
      f & /*descriptionOutputs*/
      4 && (d.selected = /*descriptionOutputs*/
      c[2]), n.$set(d);
      const p = {};
      f & /*content*/
      8 && (p.content = /*content*/
      c[3]), r.$set(p);
    },
    i(c) {
      o || (w(a), w(n.$$.fragment, c), w(r.$$.fragment, c), o = !0);
    },
    o(c) {
      O(a), O(n.$$.fragment, c), O(r.$$.fragment, c), o = !1;
    },
    d(c) {
      c && (C(t), C(s)), a && a.d(c), N(n), N(r);
    }
  };
}
u(SZ, "create_fragment$3x");
function CZ(i, e, t) {
  let s, n, l, { summaryData: r = {} } = e;
  const o = de("item");
  pe(i, o, (d) => t(1, l = d));
  const a = de("actionId"), c = [["action", "A5E.ActionActivationAction"], ["item", "A5E.Item"]], f = /* @__PURE__ */ u(({ detail: d }) => te(l, `system.actions.${a}.descriptionOutputs`, d), "updateSelection_handler");
  return i.$$set = (d) => {
    "summaryData" in d && t(0, r = d.summaryData);
  }, i.$$.update = () => {
    var d, p;
    i.$$.dirty & /*$item*/
    2 && t(3, s = (d = l.system.actions[a]) == null ? void 0 : d.description), i.$$.dirty & /*$item*/
    2 && t(2, n = ((p = l.system.actions[a]) == null ? void 0 : p.descriptionOutputs) ?? ["item"]), i.$$.dirty & /*$item*/
    2 && t(0, r = nd(l, l.actions.get(a)));
  }, [
    r,
    l,
    n,
    s,
    o,
    a,
    c,
    f
  ];
}
u(CZ, "instance$3o");
const RA = class RA extends re {
  constructor(e) {
    super(), oe(this, e, CZ, SZ, le, { summaryData: 0 });
  }
};
u(RA, "ActionsDescriptionTab");
let _y = RA;
function TZ(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return {
    c() {
      e = E("div"), t = E("a"), s = E("i"), b(s, "class", n = di(
        /*icon*/
        i[1]
      ) + " svelte-f3qybu"), b(t, "role", "button"), b(t, "tabindex", l = /*disabled*/
      i[0] ? null : 0), b(t, "title", r = K(
        /*title*/
        i[2]
      )), b(t, "class", "svelte-f3qybu"), b(e, "class", "tjs-icon-button svelte-f3qybu"), Z(
        e,
        "disabled",
        /*disabled*/
        i[0]
      );
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, s), c || (f = [
        W(
          t,
          "click",
          /*onClick*/
          i[5]
        ),
        W(
          t,
          "contextmenu",
          /*onContextMenuPress*/
          i[6]
        ),
        W(
          t,
          "keydown",
          /*onKeydown*/
          i[7]
        ),
        W(
          t,
          "keyup",
          /*onKeyup*/
          i[8]
        ),
        W(
          t,
          "click",
          /*click_handler*/
          i[14]
        ),
        W(
          t,
          "contextmenu",
          /*contextmenu_handler*/
          i[15]
        ),
        Et(o = /*efx*/
        i[4].call(null, t, { disabled: (
          /*disabled*/
          i[0]
        ) })),
        Et(a = Xs.call(
          null,
          e,
          /*styles*/
          i[3]
        ))
      ], c = !0);
    },
    p(d, [p]) {
      p & /*icon*/
      2 && n !== (n = di(
        /*icon*/
        d[1]
      ) + " svelte-f3qybu") && b(s, "class", n), p & /*disabled*/
      1 && l !== (l = /*disabled*/
      d[0] ? null : 0) && b(t, "tabindex", l), p & /*title*/
      4 && r !== (r = K(
        /*title*/
        d[2]
      )) && b(t, "title", r), o && $t(o.update) && p & /*disabled*/
      1 && o.update.call(null, { disabled: (
        /*disabled*/
        d[0]
      ) }), a && $t(a.update) && p & /*styles*/
      8 && a.update.call(
        null,
        /*styles*/
        d[3]
      ), p & /*disabled*/
      1 && Z(
        e,
        "disabled",
        /*disabled*/
        d[0]
      );
    },
    i: se,
    o: se,
    d(d) {
      d && C(e), c = !1, Me(f);
    }
  };
}
u(TZ, "create_fragment$3w");
function OZ(i, e, t) {
  let { button: s = void 0 } = e, { disabled: n = void 0 } = e, { icon: l = void 0 } = e, { title: r = void 0 } = e, { styles: o = void 0 } = e, { efx: a = void 0 } = e, { keyCode: c = void 0 } = e, { onPress: f = void 0 } = e, { onContextMenu: d = void 0 } = e, { clickPropagate: p = void 0 } = e;
  const m = ft(), g = /* @__PURE__ */ u(() => {
  }, "s_EFX_DEFAULT");
  function h(D) {
    n || (typeof f == "function" && f({ event: D }), m("press", { event: D }), p || (D.preventDefault(), D.stopPropagation()));
  }
  u(h, "onClick");
  function _(D) {
    n || (typeof d == "function" && d({ event: D }), p || (D.preventDefault(), D.stopPropagation()));
  }
  u(_, "onContextMenuPress");
  function y(D) {
    n || D.code === c && (D.preventDefault(), D.stopPropagation());
  }
  u(y, "onKeydown");
  function v(D) {
    n || D.code === c && (typeof f == "function" && f({ event: D }), m("press", { event: D }), D.preventDefault(), D.stopPropagation());
  }
  u(v, "onKeyup");
  function k(D) {
    bt.call(this, i, D);
  }
  u(k, "click_handler");
  function S(D) {
    bt.call(this, i, D);
  }
  return u(S, "contextmenu_handler"), i.$$set = (D) => {
    "button" in D && t(13, s = D.button), "disabled" in D && t(0, n = D.disabled), "icon" in D && t(1, l = D.icon), "title" in D && t(2, r = D.title), "styles" in D && t(3, o = D.styles), "efx" in D && t(4, a = D.efx), "keyCode" in D && t(9, c = D.keyCode), "onPress" in D && t(10, f = D.onPress), "onContextMenu" in D && t(11, d = D.onContextMenu), "clickPropagate" in D && t(12, p = D.clickPropagate);
  }, i.$$.update = () => {
    i.$$.dirty & /*button, disabled*/
    8193 && t(0, n = he(s) && typeof s.disabled == "boolean" ? s.disabled : typeof n == "boolean" ? n : !1), i.$$.dirty & /*button, icon*/
    8194 && t(1, l = he(s) && typeof s.icon == "string" ? s.icon : typeof l == "string" ? l : ""), i.$$.dirty & /*button, title*/
    8196 && t(2, r = he(s) && typeof s.title == "string" ? s.title : typeof r == "string" ? r : ""), i.$$.dirty & /*button, styles*/
    8200 && t(3, o = he(s) && he(s.styles) ? s.styles : he(o) ? o : void 0), i.$$.dirty & /*button, efx*/
    8208 && t(4, a = he(s) && typeof s.efx == "function" ? s.efx : typeof a == "function" ? a : g), i.$$.dirty & /*button, keyCode*/
    8704 && t(9, c = he(s) && typeof s.keyCode == "string" ? s.keyCode : typeof c == "string" ? c : "Enter"), i.$$.dirty & /*button, onPress*/
    9216 && t(10, f = he(s) && typeof s.onPress == "function" ? s.onPress : typeof f == "function" ? f : void 0), i.$$.dirty & /*button, onContextMenu*/
    10240 && t(11, d = he(s) && typeof s.onContextMenu == "function" ? s.onContextMenu : typeof d == "function" ? d : void 0), i.$$.dirty & /*button, clickPropagate*/
    12288 && t(12, p = he(s) && typeof s.clickPropagate == "boolean" ? s.clickPropagate : typeof p == "boolean" ? p : !1);
  }, [
    n,
    l,
    r,
    o,
    a,
    h,
    _,
    y,
    v,
    c,
    f,
    d,
    p,
    s,
    k,
    S
  ];
}
u(OZ, "instance$3n");
const NA = class NA extends re {
  constructor(e) {
    super(), oe(this, e, OZ, TZ, le, {
      button: 13,
      disabled: 0,
      icon: 1,
      title: 2,
      styles: 3,
      efx: 4,
      keyCode: 9,
      onPress: 10,
      onContextMenu: 11,
      clickPropagate: 12
    });
  }
};
u(NA, "TJSIconButton");
let mc = NA;
function M4(i) {
  let e;
  const t = (
    /*#slots*/
    i[24].default
  ), s = Gt(
    t,
    i,
    /*$$scope*/
    i[23],
    null
  );
  return {
    c() {
      s && s.c();
    },
    m(n, l) {
      s && s.m(n, l), e = !0;
    },
    p(n, l) {
      s && s.p && (!e || l & /*$$scope*/
      8388608) && Ht(
        s,
        t,
        n,
        /*$$scope*/
        n[23],
        e ? zt(
          t,
          /*$$scope*/
          n[23],
          l,
          null
        ) : Ut(
          /*$$scope*/
          n[23]
        ),
        null
      );
    },
    i(n) {
      e || (w(s, n), e = !0);
    },
    o(n) {
      O(s, n), e = !1;
    },
    d(n) {
      s && s.d(n);
    }
  };
}
u(M4, "create_if_block$1W");
function DZ(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m = (
    /*selected*/
    i[5] && M4(i)
  );
  return {
    c() {
      e = E("div"), t = E("a"), s = E("i"), a = F(), m && m.c(), b(s, "class", n = di(
        /*icon*/
        i[1]
      ) + " svelte-v5are2"), Z(
        s,
        "selected",
        /*selected*/
        i[5]
      ), b(t, "role", "button"), b(t, "tabindex", l = /*disabled*/
      i[0] ? null : 0), b(t, "title", r = K(
        /*titleCurrent*/
        i[7]
      )), b(t, "class", "svelte-v5are2"), Z(
        t,
        "selected",
        /*selected*/
        i[5]
      ), b(e, "class", "tjs-toggle-icon-button svelte-v5are2"), b(e, "role", "button"), Z(
        e,
        "disabled",
        /*disabled*/
        i[0]
      );
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(t, s), i[27](t), A(e, a), m && m.m(e, null), f = !0, d || (p = [
        W(
          t,
          "click",
          /*onClick*/
          i[8]
        ),
        W(
          t,
          "contextmenu",
          /*onContextMenuPress*/
          i[9]
        ),
        W(
          t,
          "keydown",
          /*onKeydown*/
          i[12]
        ),
        W(
          t,
          "keyup",
          /*onKeyup*/
          i[13]
        ),
        W(
          t,
          "click",
          /*click_handler*/
          i[25]
        ),
        W(
          t,
          "contextmenu",
          /*contextmenu_handler*/
          i[26]
        ),
        Et(o = /*efx*/
        i[4].call(null, t, { disabled: (
          /*disabled*/
          i[0]
        ) })),
        W(
          e,
          "click",
          /*onClickDiv*/
          i[10]
        ),
        W(
          e,
          "close:popup",
          /*onClosePopup*/
          i[11]
        ),
        Et(c = Xs.call(
          null,
          e,
          /*styles*/
          i[3]
        ))
      ], d = !0);
    },
    p(g, [h]) {
      (!f || h & /*icon*/
      2 && n !== (n = di(
        /*icon*/
        g[1]
      ) + " svelte-v5are2")) && b(s, "class", n), (!f || h & /*icon, selected*/
      34) && Z(
        s,
        "selected",
        /*selected*/
        g[5]
      ), (!f || h & /*disabled*/
      1 && l !== (l = /*disabled*/
      g[0] ? null : 0)) && b(t, "tabindex", l), (!f || h & /*titleCurrent*/
      128 && r !== (r = K(
        /*titleCurrent*/
        g[7]
      ))) && b(t, "title", r), o && $t(o.update) && h & /*disabled*/
      1 && o.update.call(null, { disabled: (
        /*disabled*/
        g[0]
      ) }), (!f || h & /*selected*/
      32) && Z(
        t,
        "selected",
        /*selected*/
        g[5]
      ), /*selected*/
      g[5] ? m ? (m.p(g, h), h & /*selected*/
      32 && w(m, 1)) : (m = M4(g), m.c(), w(m, 1), m.m(e, null)) : m && (ae(), O(m, 1, 1, () => {
        m = null;
      }), ce()), c && $t(c.update) && h & /*styles*/
      8 && c.update.call(
        null,
        /*styles*/
        g[3]
      ), (!f || h & /*disabled*/
      1) && Z(
        e,
        "disabled",
        /*disabled*/
        g[0]
      );
    },
    i(g) {
      f || (w(m), f = !0);
    },
    o(g) {
      O(m), f = !1;
    },
    d(g) {
      g && C(e), i[27](null), m && m.d(), d = !1, Me(p);
    }
  };
}
u(DZ, "create_fragment$3v");
function IZ(i, e, t) {
  let s, n, l = se, r = /* @__PURE__ */ u(() => (l(), l = Xt(g, (ee) => t(22, n = ee)), g), "$$subscribe_store");
  i.$$.on_destroy.push(() => l());
  let { $$slots: o = {}, $$scope: a } = e, { button: c = void 0 } = e, { disabled: f = void 0 } = e, { icon: d = void 0 } = e, { title: p = void 0 } = e, { titleSelected: m = void 0 } = e, { store: g = void 0 } = e;
  r();
  let { styles: h = void 0 } = e, { efx: _ = void 0 } = e, { keyCode: y = void 0 } = e, { onPress: v = void 0 } = e, { onClose: k = void 0 } = e, { onContextMenu: S = void 0 } = e, { clickPropagate: D = void 0 } = e;
  const I = ft(), M = /* @__PURE__ */ u(() => {
  }, "s_EFX_DEFAULT");
  let L, B = !1;
  function z(ee) {
    f || (t(5, B = !B), g && g.set(B), typeof v == "function" && v({ event: ee, selected: B }), I("press", { event: ee, selected: B }), D || (ee.preventDefault(), ee.stopPropagation()));
  }
  u(z, "onClick");
  function q(ee) {
    f || (typeof S == "function" && S({ event: ee }), D || (ee.preventDefault(), ee.stopPropagation()));
  }
  u(q, "onContextMenuPress");
  function U(ee) {
    f || D || (ee.preventDefault(), ee.stopPropagation());
  }
  u(U, "onClickDiv");
  function H(ee) {
    var ne;
    t(5, B = !1), g && g.set(!1), typeof k == "function" && k({ event: ee, selected: B }), typeof ((ne = ee == null ? void 0 : ee.detail) == null ? void 0 : ne.keyboardFocus) == "boolean" && ee.detail.keyboardFocus && (L != null && L.isConnected) && (L.focus(), ee.stopPropagation(), ee.preventDefault());
  }
  u(H, "onClosePopup");
  function V(ee) {
    f || ee.code === y && (ee.preventDefault(), ee.stopPropagation());
  }
  u(V, "onKeydown");
  function Y(ee) {
    f || ee.code === y && (t(5, B = !B), g && g.set(B), typeof v == "function" && v({ event: ee, selected: B }), I("press", { event: ee, selected: B }), ee.preventDefault(), ee.stopPropagation());
  }
  u(Y, "onKeyup");
  function J(ee) {
    bt.call(this, i, ee);
  }
  u(J, "click_handler");
  function fe(ee) {
    bt.call(this, i, ee);
  }
  u(fe, "contextmenu_handler");
  function ke(ee) {
    rt[ee ? "unshift" : "push"](() => {
      L = ee, t(6, L);
    });
  }
  return u(ke, "a_binding"), i.$$set = (ee) => {
    "button" in ee && t(21, c = ee.button), "disabled" in ee && t(0, f = ee.disabled), "icon" in ee && t(1, d = ee.icon), "title" in ee && t(14, p = ee.title), "titleSelected" in ee && t(15, m = ee.titleSelected), "store" in ee && r(t(2, g = ee.store)), "styles" in ee && t(3, h = ee.styles), "efx" in ee && t(4, _ = ee.efx), "keyCode" in ee && t(16, y = ee.keyCode), "onPress" in ee && t(17, v = ee.onPress), "onClose" in ee && t(18, k = ee.onClose), "onContextMenu" in ee && t(19, S = ee.onContextMenu), "clickPropagate" in ee && t(20, D = ee.clickPropagate), "$$scope" in ee && t(23, a = ee.$$scope);
  }, i.$$.update = () => {
    i.$$.dirty & /*button, disabled*/
    2097153 && t(0, f = he(c) && typeof c.disabled == "boolean" ? c.disabled : typeof f == "boolean" ? f : !1), i.$$.dirty & /*button, icon*/
    2097154 && t(1, d = he(c) && typeof c.icon == "string" ? c.icon : typeof d == "string" ? d : ""), i.$$.dirty & /*button, title*/
    2113536 && t(14, p = he(c) && typeof c.title == "string" ? c.title : typeof p == "string" ? p : ""), i.$$.dirty & /*button, titleSelected*/
    2129920 && t(15, m = he(c) && typeof c.titleSelected == "string" ? c.titleSelected : typeof m == "string" ? m : ""), i.$$.dirty & /*button, store*/
    2097156 && r(t(2, g = he(c) && Cn(c.store) ? c.store : Cn(g) ? g : void 0)), i.$$.dirty & /*button, styles*/
    2097160 && t(3, h = he(c) && he(c.styles) ? c.styles : he(h) ? h : void 0), i.$$.dirty & /*button, efx*/
    2097168 && t(4, _ = he(c) && typeof c.efx == "function" ? c.efx : typeof _ == "function" ? _ : M), i.$$.dirty & /*button, keyCode*/
    2162688 && t(16, y = he(c) && typeof c.keyCode == "string" ? c.keyCode : typeof y == "string" ? y : "Enter"), i.$$.dirty & /*button, onPress*/
    2228224 && t(17, v = he(c) && typeof c.onPress == "function" ? c.onPress : typeof v == "function" ? v : void 0), i.$$.dirty & /*button, onClose*/
    2359296 && t(18, k = he(c) && typeof c.onClose == "function" ? c.onClose : typeof k == "function" ? k : void 0), i.$$.dirty & /*button, onContextMenu*/
    2621440 && t(19, S = he(c) && typeof c.onContextMenu == "function" ? c.onContextMenu : typeof S == "function" ? S : void 0), i.$$.dirty & /*button, clickPropagate*/
    3145728 && t(20, D = he(c) && typeof c.clickPropagate == "boolean" ? c.clickPropagate : typeof D == "boolean" ? D : !1), i.$$.dirty & /*store, disabled*/
    5 && g && f && wo(g, n = !1, n), i.$$.dirty & /*store, $store*/
    4194308 && g && t(5, B = n), i.$$.dirty & /*selected, titleSelected, title*/
    49184 && t(7, s = B && m !== "" ? m : p);
  }, [
    f,
    d,
    g,
    h,
    _,
    B,
    L,
    s,
    z,
    q,
    U,
    H,
    V,
    Y,
    p,
    m,
    y,
    v,
    k,
    S,
    D,
    c,
    n,
    a,
    o,
    J,
    fe,
    ke
  ];
}
u(IZ, "instance$3m");
const jA = class jA extends re {
  constructor(e) {
    super(), oe(this, e, IZ, DZ, le, {
      button: 21,
      disabled: 0,
      icon: 1,
      title: 14,
      titleSelected: 15,
      store: 2,
      styles: 3,
      efx: 4,
      keyCode: 16,
      onPress: 17,
      onClose: 18,
      onContextMenu: 19,
      clickPropagate: 20
    });
  }
};
u(jA, "TJSToggleIconButton");
let Ep = jA;
function yy(i, e = globalThis) {
  const t = e.document;
  if (!i || i.nodeName === "HTML")
    return { node: t.documentElement, reason: "root" };
  if (i.nodeName === "#document-fragment")
    return yy(i.host);
  const s = e.getComputedStyle(i);
  if (s.position === "fixed" || s.position === "sticky")
    return { node: i, reason: `position: ${s.position}` };
  if (s.zIndex !== "auto" && s.position !== "static")
    return { node: i, reason: `position: ${s.position}; z-index: ${s.zIndex}` };
  if (s.opacity !== "1")
    return { node: i, reason: `opacity: ${s.opacity}` };
  if (s.transform !== "none")
    return { node: i, reason: `transform: ${s.transform}` };
  if (s.mixBlendMode !== "normal")
    return { node: i, reason: `mixBlendMode: ${s.mixBlendMode}` };
  if (s.filter !== "none")
    return { node: i, reason: `filter: ${s.filter}` };
  if (s.perspective !== "none")
    return { node: i, reason: `perspective: ${s.perspective}` };
  if (s.clipPath !== "none")
    return { node: i, reason: `clip-path: ${s.clipPath} ` };
  const n = s.mask || s.webkitMask;
  if (n !== "none" && n !== void 0)
    return { node: i, reason: `mask:  ${n}` };
  const l = s.maskImage || s.webkitMaskImage;
  if (l !== "none" && l !== void 0)
    return { node: i, reason: `mask-image: ${l}` };
  const r = s.maskBorder || s.webkitMaskBorder;
  if (r !== "none" && r !== void 0)
    return { node: i, reason: `mask-border: ${r}` };
  if (s.isolation === "isolate")
    return { node: i, reason: `isolation: ${s.isolation}` };
  if (s.willChange === "transform" || s.willChange === "opacity")
    return { node: i, reason: `willChange: ${s.willChange}` };
  if (s.webkitOverflowScrolling === "touch")
    return { node: i, reason: "-webkit-overflow-scrolling: touch" };
  if (s.zIndex !== "auto") {
    const a = e.getComputedStyle(i.parentNode);
    if (a.display === "flex" || a.display === "inline-flex")
      return { node: i, reason: `flex-item; z-index: ${s.zIndex}` };
    if (a.grid !== "none / none / none / row / auto / auto")
      return { node: i, reason: `child of grid container; z-index: ${s.zIndex}` };
  }
  const o = s.contain;
  return ["layout", "paint", "strict", "content"].indexOf(o) > -1 || o.indexOf("paint") > -1 || o.indexOf("layout") > -1 ? { node: i, reason: `contain: ${o}` } : yy(i.parentNode);
}
u(yy, "getStackingContext");
function PZ(i) {
  let e, t, s;
  return {
    c() {
      e = E("div"), b(e, "class", "tjs-focus-wrap svelte-kjcljd"), b(e, "tabindex", "0");
    },
    m(n, l) {
      T(n, e, l), i[4](e), t || (s = W(
        e,
        "focus",
        /*onFocus*/
        i[1]
      ), t = !0);
    },
    p: se,
    i: se,
    o: se,
    d(n) {
      n && C(e), i[4](null), t = !1, s();
    }
  };
}
u(PZ, "create_fragment$3u");
function MZ(i, e, t) {
  let { elementRoot: s = void 0 } = e, { enabled: n = !0 } = e, l, r;
  function o() {
    if (n && ot.isFocusTarget(s)) {
      const c = ot.getFirstFocusableElement(s, l);
      ot.isFocusTarget(c) && c !== r ? c.focus() : s.focus();
    }
  }
  u(o, "onFocus");
  function a(c) {
    rt[c ? "unshift" : "push"](() => {
      r = c, t(0, r);
    });
  }
  return u(a, "div_binding"), i.$$set = (c) => {
    "elementRoot" in c && t(2, s = c.elementRoot), "enabled" in c && t(3, n = c.enabled);
  }, i.$$.update = () => {
    i.$$.dirty & /*wrapEl*/
    1 && r && (l = /* @__PURE__ */ new Set([r]));
  }, [r, o, s, n, a];
}
u(MZ, "instance$3l");
const LA = class LA extends re {
  constructor(e) {
    super(), oe(this, e, MZ, PZ, le, { elementRoot: 2, enabled: 3 });
  }
};
u(LA, "TJSFocusWrap");
let vy = LA;
const FZ = /* @__PURE__ */ u((i) => ({}), "get_after_slot_changes"), F4 = /* @__PURE__ */ u((i) => ({}), "get_after_slot_context");
function R4(i, e, t) {
  const s = i.slice();
  return s[39] = e[t], s;
}
u(R4, "get_each_context$1o");
const RZ = /* @__PURE__ */ u((i) => ({}), "get_before_slot_changes"), N4 = /* @__PURE__ */ u((i) => ({}), "get_before_slot_context");
function j4(i) {
  var o, a;
  let e, t, s;
  const n = [
    he(
      /*menu*/
      (a = (o = i[2]) == null ? void 0 : o.slotDefault) == null ? void 0 : a.props
    ) ? (
      /*menu*/
      i[2].slotDefault.props
    ) : {}
  ];
  var l = (
    /*menu*/
    i[2].slotDefault.class
  );
  function r(c, f) {
    var p, m;
    let d = {};
    for (let g = 0; g < n.length; g += 1)
      d = Dt(d, n[g]);
    return f !== void 0 && f[0] & /*menu*/
    4 && (d = Dt(d, Vt(n, [
      Jt(he(
        /*menu*/
        (m = (p = c[2]) == null ? void 0 : p.slotDefault) == null ? void 0 : m.props
      ) ? (
        /*menu*/
        c[2].slotDefault.props
      ) : {})
    ]))), { props: d };
  }
  return u(r, "switch_props"), l && (e = et(l, r(i))), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(c, f) {
      e && R(e, c, f), T(c, t, f), s = !0;
    },
    p(c, f) {
      var d, p;
      if (f[0] & /*menu*/
      4 && l !== (l = /*menu*/
      c[2].slotDefault.class)) {
        if (e) {
          ae();
          const m = e;
          O(m.$$.fragment, 1, 0, () => {
            N(m, 1);
          }), ce();
        }
        l ? (e = et(l, r(c, f)), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const m = f[0] & /*menu*/
        4 ? Vt(n, [
          Jt(he(
            /*menu*/
            (p = (d = c[2]) == null ? void 0 : d.slotDefault) == null ? void 0 : p.props
          ) ? (
            /*menu*/
            c[2].slotDefault.props
          ) : {})
        ]) : {};
        e.$set(m);
      }
    },
    i(c) {
      s || (e && w(e.$$.fragment, c), s = !0);
    },
    o(c) {
      e && O(e.$$.fragment, c), s = !1;
    },
    d(c) {
      c && C(t), e && N(e, c);
    }
  };
}
u(j4, "create_if_block_9$a");
function NZ(i) {
  var l, r;
  let e = Ws.isComponent(
    /*menu*/
    (r = (l = i[2]) == null ? void 0 : l.slotDefault) == null ? void 0 : r.class
  ), t, s, n = e && j4(i);
  return {
    c() {
      n && n.c(), t = $e();
    },
    m(o, a) {
      n && n.m(o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      var c, f;
      a[0] & /*menu*/
      4 && (e = Ws.isComponent(
        /*menu*/
        (f = (c = o[2]) == null ? void 0 : c.slotDefault) == null ? void 0 : f.class
      )), e ? n ? (n.p(o, a), a[0] & /*menu*/
      4 && w(n, 1)) : (n = j4(o), n.c(), w(n, 1), n.m(t.parentNode, t)) : n && (ae(), O(n, 1, 1, () => {
        n = null;
      }), ce());
    },
    i(o) {
      s || (w(n), s = !0);
    },
    o(o) {
      O(n), s = !1;
    },
    d(o) {
      o && C(t), n && n.d(o);
    }
  };
}
u(NZ, "fallback_block_2$1");
function L4(i) {
  let e, t, s, n, l, r;
  const o = (
    /*#slots*/
    i[17].before
  ), a = Gt(
    o,
    i,
    /*$$scope*/
    i[16],
    N4
  ), c = a || jZ(i);
  return {
    c() {
      e = E("li"), t = E("span"), s = F(), c && c.c(), b(t, "class", "tjs-menu-focus-indicator svelte-1evrp07"), b(e, "class", "tjs-menu-item svelte-1evrp07"), b(e, "role", "menuitem"), b(e, "tabindex", "0");
    },
    m(f, d) {
      T(f, e, d), A(e, t), A(e, s), c && c.m(e, null), n = !0, l || (r = [
        W(
          e,
          "click",
          /*click_handler*/
          i[18]
        ),
        W(
          e,
          "keyup",
          /*keyup_handler*/
          i[19]
        )
      ], l = !0);
    },
    p(f, d) {
      a ? a.p && (!n || d[0] & /*$$scope*/
      65536) && Ht(
        a,
        o,
        f,
        /*$$scope*/
        f[16],
        n ? zt(
          o,
          /*$$scope*/
          f[16],
          d,
          RZ
        ) : Ut(
          /*$$scope*/
          f[16]
        ),
        N4
      ) : c && c.p && (!n || d[0] & /*menu*/
      4) && c.p(f, n ? d : [-1, -1]);
    },
    i(f) {
      n || (w(c, f), n = !0);
    },
    o(f) {
      O(c, f), n = !1;
    },
    d(f) {
      f && C(e), c && c.d(f), l = !1, Me(r);
    }
  };
}
u(L4, "create_if_block_7$f");
function B4(i) {
  var o, a;
  let e, t, s;
  const n = [
    he(
      /*menu*/
      (a = (o = i[2]) == null ? void 0 : o.slotBefore) == null ? void 0 : a.props
    ) ? (
      /*menu*/
      i[2].slotBefore.props
    ) : {}
  ];
  var l = (
    /*menu*/
    i[2].slotBefore.class
  );
  function r(c, f) {
    var p, m;
    let d = {};
    for (let g = 0; g < n.length; g += 1)
      d = Dt(d, n[g]);
    return f !== void 0 && f[0] & /*menu*/
    4 && (d = Dt(d, Vt(n, [
      Jt(he(
        /*menu*/
        (m = (p = c[2]) == null ? void 0 : p.slotBefore) == null ? void 0 : m.props
      ) ? (
        /*menu*/
        c[2].slotBefore.props
      ) : {})
    ]))), { props: d };
  }
  return u(r, "switch_props"), l && (e = et(l, r(i))), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(c, f) {
      e && R(e, c, f), T(c, t, f), s = !0;
    },
    p(c, f) {
      var d, p;
      if (f[0] & /*menu*/
      4 && l !== (l = /*menu*/
      c[2].slotBefore.class)) {
        if (e) {
          ae();
          const m = e;
          O(m.$$.fragment, 1, 0, () => {
            N(m, 1);
          }), ce();
        }
        l ? (e = et(l, r(c, f)), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const m = f[0] & /*menu*/
        4 ? Vt(n, [
          Jt(he(
            /*menu*/
            (p = (d = c[2]) == null ? void 0 : d.slotBefore) == null ? void 0 : p.props
          ) ? (
            /*menu*/
            c[2].slotBefore.props
          ) : {})
        ]) : {};
        e.$set(m);
      }
    },
    i(c) {
      s || (e && w(e.$$.fragment, c), s = !0);
    },
    o(c) {
      e && O(e.$$.fragment, c), s = !1;
    },
    d(c) {
      c && C(t), e && N(e, c);
    }
  };
}
u(B4, "create_if_block_8$c");
function jZ(i) {
  var l, r;
  let e = Ws.isComponent(
    /*menu*/
    (r = (l = i[2]) == null ? void 0 : l.slotBefore) == null ? void 0 : r.class
  ), t, s, n = e && B4(i);
  return {
    c() {
      n && n.c(), t = $e();
    },
    m(o, a) {
      n && n.m(o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      var c, f;
      a[0] & /*menu*/
      4 && (e = Ws.isComponent(
        /*menu*/
        (f = (c = o[2]) == null ? void 0 : c.slotBefore) == null ? void 0 : f.class
      )), e ? n ? (n.p(o, a), a[0] & /*menu*/
      4 && w(n, 1)) : (n = B4(o), n.c(), w(n, 1), n.m(t.parentNode, t)) : n && (ae(), O(n, 1, 1, () => {
        n = null;
      }), ce());
    },
    i(o) {
      s || (w(n), s = !0);
    },
    o(o) {
      O(n), s = !1;
    },
    d(o) {
      o && C(t), n && n.d(o);
    }
  };
}
u(jZ, "fallback_block_1$1");
function LZ(i) {
  let e;
  return {
    c() {
      e = E("hr"), b(e, "class", "svelte-1evrp07");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    i: se,
    o: se,
    d(t) {
      t && C(e);
    }
  };
}
u(LZ, "create_if_block_6$i");
function BZ(i) {
  let e, t, s, n, l = K(
    /*item*/
    i[39].label
  ) + "", r, o, a;
  function c(...d) {
    return (
      /*click_handler_4*/
      i[26](
        /*item*/
        i[39],
        ...d
      )
    );
  }
  u(c, "click_handler_4");
  function f(...d) {
    return (
      /*keyup_handler_4*/
      i[27](
        /*item*/
        i[39],
        ...d
      )
    );
  }
  return u(f, "keyup_handler_4"), {
    c() {
      e = E("li"), t = E("span"), s = F(), n = E("span"), r = Q(l), b(t, "class", "tjs-menu-focus-indicator svelte-1evrp07"), b(n, "class", "tjs-menu-item-label svelte-1evrp07"), b(e, "class", "tjs-menu-item tjs-menu-item-button svelte-1evrp07"), b(e, "role", "menuitem"), b(e, "tabindex", "0");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(e, s), A(e, n), A(n, r), o || (a = [
        W(e, "click", c),
        W(e, "keyup", f)
      ], o = !0);
    },
    p(d, p) {
      i = d, p[0] & /*allItems*/
      8 && l !== (l = K(
        /*item*/
        i[39].label
      ) + "") && be(r, l);
    },
    i: se,
    o: se,
    d(d) {
      d && C(e), o = !1, Me(a);
    }
  };
}
u(BZ, "create_if_block_5$j");
function qZ(i) {
  let e, t, s, n, l, r, o, a, c = K(
    /*item*/
    i[39].label
  ) + "", f, d, p;
  function m(...h) {
    return (
      /*click_handler_3*/
      i[24](
        /*item*/
        i[39],
        ...h
      )
    );
  }
  u(m, "click_handler_3");
  function g(...h) {
    return (
      /*keyup_handler_3*/
      i[25](
        /*item*/
        i[39],
        ...h
      )
    );
  }
  return u(g, "keyup_handler_3"), {
    c() {
      e = E("li"), t = E("span"), s = F(), n = E("img"), o = F(), a = E("span"), f = Q(c), b(t, "class", "tjs-menu-focus-indicator svelte-1evrp07"), ze(n.src, l = /*item*/
      i[39].image) || b(n, "src", l), b(n, "alt", r = /*item*/
      i[39].imageAlt), b(n, "class", "svelte-1evrp07"), b(a, "class", "tjs-menu-item-label svelte-1evrp07"), b(e, "class", "tjs-menu-item tjs-menu-item-button svelte-1evrp07"), b(e, "role", "menuitem"), b(e, "tabindex", "0");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(e, s), A(e, n), A(e, o), A(e, a), A(a, f), d || (p = [
        W(e, "click", m),
        W(e, "keyup", g)
      ], d = !0);
    },
    p(h, _) {
      i = h, _[0] & /*allItems*/
      8 && !ze(n.src, l = /*item*/
      i[39].image) && b(n, "src", l), _[0] & /*allItems*/
      8 && r !== (r = /*item*/
      i[39].imageAlt) && b(n, "alt", r), _[0] & /*allItems*/
      8 && c !== (c = K(
        /*item*/
        i[39].label
      ) + "") && be(f, c);
    },
    i: se,
    o: se,
    d(h) {
      h && C(e), d = !1, Me(p);
    }
  };
}
u(qZ, "create_if_block_4$s");
function GZ(i) {
  let e, t, s, n, l, r, o, a = K(
    /*item*/
    i[39].label
  ) + "", c, f, d;
  function p(...g) {
    return (
      /*click_handler_2*/
      i[22](
        /*item*/
        i[39],
        ...g
      )
    );
  }
  u(p, "click_handler_2");
  function m(...g) {
    return (
      /*keyup_handler_2*/
      i[23](
        /*item*/
        i[39],
        ...g
      )
    );
  }
  return u(m, "keyup_handler_2"), {
    c() {
      e = E("li"), t = E("span"), s = F(), n = E("i"), r = F(), o = E("span"), c = Q(a), b(t, "class", "tjs-menu-focus-indicator svelte-1evrp07"), b(n, "class", l = di(
        /*item*/
        i[39].icon
      ) + " svelte-1evrp07"), b(o, "class", "tjs-menu-item-label svelte-1evrp07"), b(e, "class", "tjs-menu-item tjs-menu-item-button svelte-1evrp07"), b(e, "role", "menuitem"), b(e, "tabindex", "0");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), A(o, c), f || (d = [
        W(e, "click", p),
        W(e, "keyup", m)
      ], f = !0);
    },
    p(g, h) {
      i = g, h[0] & /*allItems*/
      8 && l !== (l = di(
        /*item*/
        i[39].icon
      ) + " svelte-1evrp07") && b(n, "class", l), h[0] & /*allItems*/
      8 && a !== (a = K(
        /*item*/
        i[39].label
      ) + "") && be(c, a);
    },
    i: se,
    o: se,
    d(g) {
      g && C(e), f = !1, Me(d);
    }
  };
}
u(GZ, "create_if_block_3$y");
function zZ(i) {
  let e, t, s, n, l, r, o;
  const a = [
    he(
      /*item*/
      i[39].props
    ) ? (
      /*item*/
      i[39].props
    ) : {}
  ];
  var c = (
    /*item*/
    i[39].class
  );
  function f(m, g) {
    let h = {};
    for (let _ = 0; _ < a.length; _ += 1)
      h = Dt(h, a[_]);
    return g !== void 0 && g[0] & /*allItems*/
    8 && (h = Dt(h, Vt(a, [
      Jt(he(
        /*item*/
        m[39].props
      ) ? (
        /*item*/
        m[39].props
      ) : {})
    ]))), { props: h };
  }
  u(f, "switch_props"), c && (n = et(c, f(i)));
  function d(...m) {
    return (
      /*click_handler_1*/
      i[20](
        /*item*/
        i[39],
        ...m
      )
    );
  }
  u(d, "click_handler_1");
  function p(...m) {
    return (
      /*keyup_handler_1*/
      i[21](
        /*item*/
        i[39],
        ...m
      )
    );
  }
  return u(p, "keyup_handler_1"), {
    c() {
      e = E("li"), t = E("span"), s = F(), n && j(n.$$.fragment), b(t, "class", "tjs-menu-focus-indicator svelte-1evrp07"), b(e, "class", "tjs-menu-item svelte-1evrp07"), b(e, "role", "menuitem"), b(e, "tabindex", "0");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(e, s), n && R(n, e, null), l = !0, r || (o = [
        W(e, "click", d),
        W(e, "keyup", p)
      ], r = !0);
    },
    p(m, g) {
      if (i = m, g[0] & /*allItems*/
      8 && c !== (c = /*item*/
      i[39].class)) {
        if (n) {
          ae();
          const h = n;
          O(h.$$.fragment, 1, 0, () => {
            N(h, 1);
          }), ce();
        }
        c ? (n = et(c, f(i, g)), j(n.$$.fragment), w(n.$$.fragment, 1), R(n, e, null)) : n = null;
      } else if (c) {
        const h = g[0] & /*allItems*/
        8 ? Vt(a, [
          Jt(he(
            /*item*/
            i[39].props
          ) ? (
            /*item*/
            i[39].props
          ) : {})
        ]) : {};
        n.$set(h);
      }
    },
    i(m) {
      l || (n && w(n.$$.fragment, m), l = !0);
    },
    o(m) {
      n && O(n.$$.fragment, m), l = !1;
    },
    d(m) {
      m && C(e), n && N(n), r = !1, Me(o);
    }
  };
}
u(zZ, "create_if_block_2$S");
function q4(i) {
  let e, t, s, n;
  const l = [
    zZ,
    GZ,
    qZ,
    BZ,
    LZ
  ], r = [];
  function o(a, c) {
    return (
      /*item*/
      a[39]["#type"] === "class" ? 0 : (
        /*item*/
        a[39]["#type"] === "icon" ? 1 : (
          /*item*/
          a[39]["#type"] === "image" ? 2 : (
            /*item*/
            a[39]["#type"] === "label" ? 3 : (
              /*item*/
              a[39]["#type"] === "separator-hr" ? 4 : -1
            )
          )
        )
      )
    );
  }
  return u(o, "select_block_type"), ~(e = o(i)) && (t = r[e] = l[e](i)), {
    c() {
      t && t.c(), s = $e();
    },
    m(a, c) {
      ~e && r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? ~e && r[e].p(a, c) : (t && (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce()), ~e ? (t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s)) : t = null);
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), ~e && r[e].d(a);
    }
  };
}
u(q4, "create_each_block$1o");
function G4(i) {
  let e, t, s, n, l, r;
  const o = (
    /*#slots*/
    i[17].after
  ), a = Gt(
    o,
    i,
    /*$$scope*/
    i[16],
    F4
  ), c = a || HZ(i);
  return {
    c() {
      e = E("li"), t = E("span"), s = F(), c && c.c(), b(t, "class", "tjs-menu-focus-indicator svelte-1evrp07"), b(e, "class", "tjs-menu-item svelte-1evrp07"), b(e, "role", "menuitem"), b(e, "tabindex", "0");
    },
    m(f, d) {
      T(f, e, d), A(e, t), A(e, s), c && c.m(e, null), n = !0, l || (r = [
        W(
          e,
          "click",
          /*click_handler_5*/
          i[28]
        ),
        W(
          e,
          "keyup",
          /*keyup_handler_5*/
          i[29]
        )
      ], l = !0);
    },
    p(f, d) {
      a ? a.p && (!n || d[0] & /*$$scope*/
      65536) && Ht(
        a,
        o,
        f,
        /*$$scope*/
        f[16],
        n ? zt(
          o,
          /*$$scope*/
          f[16],
          d,
          FZ
        ) : Ut(
          /*$$scope*/
          f[16]
        ),
        F4
      ) : c && c.p && (!n || d[0] & /*menu*/
      4) && c.p(f, n ? d : [-1, -1]);
    },
    i(f) {
      n || (w(c, f), n = !0);
    },
    o(f) {
      O(c, f), n = !1;
    },
    d(f) {
      f && C(e), c && c.d(f), l = !1, Me(r);
    }
  };
}
u(G4, "create_if_block$1V");
function z4(i) {
  var o, a;
  let e, t, s;
  const n = [
    he(
      /*menu*/
      (a = (o = i[2]) == null ? void 0 : o.slotAfter) == null ? void 0 : a.props
    ) ? (
      /*menu*/
      i[2].slotAfter.props
    ) : {}
  ];
  var l = (
    /*menu*/
    i[2].slotAfter.class
  );
  function r(c, f) {
    var p, m;
    let d = {};
    for (let g = 0; g < n.length; g += 1)
      d = Dt(d, n[g]);
    return f !== void 0 && f[0] & /*menu*/
    4 && (d = Dt(d, Vt(n, [
      Jt(he(
        /*menu*/
        (m = (p = c[2]) == null ? void 0 : p.slotAfter) == null ? void 0 : m.props
      ) ? (
        /*menu*/
        c[2].slotAfter.props
      ) : {})
    ]))), { props: d };
  }
  return u(r, "switch_props"), l && (e = et(l, r(i))), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(c, f) {
      e && R(e, c, f), T(c, t, f), s = !0;
    },
    p(c, f) {
      var d, p;
      if (f[0] & /*menu*/
      4 && l !== (l = /*menu*/
      c[2].slotAfter.class)) {
        if (e) {
          ae();
          const m = e;
          O(m.$$.fragment, 1, 0, () => {
            N(m, 1);
          }), ce();
        }
        l ? (e = et(l, r(c, f)), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const m = f[0] & /*menu*/
        4 ? Vt(n, [
          Jt(he(
            /*menu*/
            (p = (d = c[2]) == null ? void 0 : d.slotAfter) == null ? void 0 : p.props
          ) ? (
            /*menu*/
            c[2].slotAfter.props
          ) : {})
        ]) : {};
        e.$set(m);
      }
    },
    i(c) {
      s || (e && w(e.$$.fragment, c), s = !0);
    },
    o(c) {
      e && O(e.$$.fragment, c), s = !1;
    },
    d(c) {
      c && C(t), e && N(e, c);
    }
  };
}
u(z4, "create_if_block_1$1h");
function HZ(i) {
  var l, r;
  let e = Ws.isComponent(
    /*menu*/
    (r = (l = i[2]) == null ? void 0 : l.slotAfter) == null ? void 0 : r.class
  ), t, s, n = e && z4(i);
  return {
    c() {
      n && n.c(), t = $e();
    },
    m(o, a) {
      n && n.m(o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      var c, f;
      a[0] & /*menu*/
      4 && (e = Ws.isComponent(
        /*menu*/
        (f = (c = o[2]) == null ? void 0 : c.slotAfter) == null ? void 0 : f.class
      )), e ? n ? (n.p(o, a), a[0] & /*menu*/
      4 && w(n, 1)) : (n = z4(o), n.c(), w(n, 1), n.m(t.parentNode, t)) : n && (ae(), O(n, 1, 1, () => {
        n = null;
      }), ce());
    },
    i(o) {
      s || (w(n), s = !0);
    },
    o(o) {
      O(n), s = !1;
    },
    d(o) {
      o && C(t), n && n.d(o);
    }
  };
}
u(HZ, "fallback_block$1");
function UZ(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p;
  const m = (
    /*#slots*/
    i[17].default
  ), g = Gt(
    m,
    i,
    /*$$scope*/
    i[16],
    null
  ), h = g || NZ(i);
  let _ = (
    /*$$slots*/
    i[10].before && L4(i)
  ), y = ue(
    /*allItems*/
    i[3]
  ), v = [];
  for (let D = 0; D < y.length; D += 1)
    v[D] = q4(R4(i, y, D));
  const k = /* @__PURE__ */ u((D) => O(v[D], 1, 1, () => {
    v[D] = null;
  }), "out");
  let S = (
    /*$$slots*/
    i[10].after && G4(i)
  );
  return o = new vy({
    props: { elementRoot: (
      /*menuEl*/
      i[4]
    ) }
  }), {
    c() {
      e = E("nav"), t = E("ol"), h && h.c(), s = F(), _ && _.c(), n = F();
      for (let D = 0; D < v.length; D += 1)
        v[D].c();
      l = F(), S && S.c(), r = F(), j(o.$$.fragment), b(t, "class", "tjs-menu-items svelte-1evrp07"), b(t, "role", "menu"), b(e, "class", "tjs-menu svelte-1evrp07"), b(e, "tabindex", "-1");
    },
    m(D, I) {
      T(D, e, I), A(e, t), h && h.m(t, null), A(t, s), _ && _.m(t, null), A(t, n);
      for (let M = 0; M < v.length; M += 1)
        v[M] && v[M].m(t, null);
      A(t, l), S && S.m(t, null), A(e, r), R(o, e, null), i[30](e), f = !0, d || (p = [
        W(e, "click", Ve(st(VZ))),
        W(e, "keydown", Ve(
          /*onKeydownMenu*/
          i[7]
        )),
        W(e, "keyup", Ve(st(
          /*onKeyupMenu*/
          i[8]
        ))),
        W(e, "pointerdown", Ve(WZ)),
        W(e, "pointerup", Ve(KZ)),
        Et(a = Xs.call(
          null,
          e,
          /*styles*/
          i[0]
        )),
        Et(
          /*efx*/
          i[1].call(null, e)
        )
      ], d = !0);
    },
    p(D, I) {
      if (g ? g.p && (!f || I[0] & /*$$scope*/
      65536) && Ht(
        g,
        m,
        D,
        /*$$scope*/
        D[16],
        f ? zt(
          m,
          /*$$scope*/
          D[16],
          I,
          null
        ) : Ut(
          /*$$scope*/
          D[16]
        ),
        null
      ) : h && h.p && (!f || I[0] & /*menu*/
      4) && h.p(D, f ? I : [-1, -1]), /*$$slots*/
      D[10].before ? _ ? (_.p(D, I), I[0] & /*$$slots*/
      1024 && w(_, 1)) : (_ = L4(D), _.c(), w(_, 1), _.m(t, n)) : _ && (ae(), O(_, 1, 1, () => {
        _ = null;
      }), ce()), I[0] & /*onClick, allItems, onKeyupItem*/
      584) {
        y = ue(
          /*allItems*/
          D[3]
        );
        let L;
        for (L = 0; L < y.length; L += 1) {
          const B = R4(D, y, L);
          v[L] ? (v[L].p(B, I), w(v[L], 1)) : (v[L] = q4(B), v[L].c(), w(v[L], 1), v[L].m(t, l));
        }
        for (ae(), L = y.length; L < v.length; L += 1)
          k(L);
        ce();
      }
      /*$$slots*/
      D[10].after ? S ? (S.p(D, I), I[0] & /*$$slots*/
      1024 && w(S, 1)) : (S = G4(D), S.c(), w(S, 1), S.m(t, null)) : S && (ae(), O(S, 1, 1, () => {
        S = null;
      }), ce());
      const M = {};
      I[0] & /*menuEl*/
      16 && (M.elementRoot = /*menuEl*/
      D[4]), o.$set(M), a && $t(a.update) && I[0] & /*styles*/
      1 && a.update.call(
        null,
        /*styles*/
        D[0]
      );
    },
    i(D) {
      if (!f) {
        w(h, D), w(_);
        for (let I = 0; I < y.length; I += 1)
          w(v[I]);
        w(S), w(o.$$.fragment, D), ks(() => {
          f && (c || (c = yr(
            e,
            /*animate*/
            i[5],
            {},
            !0
          )), c.run(1));
        }), f = !0;
      }
    },
    o(D) {
      O(h, D), O(_), v = v.filter(Boolean);
      for (let I = 0; I < v.length; I += 1)
        O(v[I]);
      O(S), O(o.$$.fragment, D), c || (c = yr(
        e,
        /*animate*/
        i[5],
        {},
        !1
      )), c.run(0), f = !1;
    },
    d(D) {
      D && C(e), h && h.d(D), _ && _.d(), Le(v, D), S && S.d(), N(o), i[30](null), D && c && c.end(), d = !1, Me(p);
    }
  };
}
u(UZ, "create_fragment$3t");
const VZ = /* @__PURE__ */ u(() => null, "click_handler_6"), WZ = /* @__PURE__ */ u(() => null, "pointerdown_handler"), KZ = /* @__PURE__ */ u(() => null, "pointerup_handler");
function YZ(i, e, t) {
  var Je, Ne, Re;
  let { $$slots: s = {}, $$scope: n } = e;
  const l = O5(s);
  let { menu: r = void 0 } = e, { items: o = void 0 } = e, { focusEl: a = void 0 } = e, { offset: c = void 0 } = e, { styles: f = void 0 } = e, { efx: d = void 0 } = e, { keyCode: p = void 0 } = e, { transitionOptions: m = void 0 } = e;
  const g = { x: 0, y: 0 }, h = { ignoreClasses: ["tjs-focus-wrap"] }, _ = ((Re = (Ne = (Je = de("#external")) == null ? void 0 : Je.application) == null ? void 0 : Ne.reactive) == null ? void 0 : Re.activeWindow) ?? globalThis;
  let y, v, k = !1, S, D = !1;
  Qt(() => {
    _.document.body.removeEventListener("pointerdown", L), _.document.body.removeEventListener("wheel", L), _.removeEventListener("blur", U);
  }), $o(() => {
    _.document.body.addEventListener("pointerdown", L), _.document.body.addEventListener("wheel", L), _.addEventListener("blur", U);
    const ge = _.document.activeElement, je = v.parentElement;
    if (je instanceof HTMLElement && ge instanceof HTMLElement && je.contains(ge) && ge.matches(":focus-visible")) {
      const Be = ot.getFirstFocusableElement(v);
      Be instanceof HTMLElement && !Be.classList.contains("tjs-focus-wrap") ? (Be.focus(), D = !0) : v.focus(), S = { focusEl: [ge] }, a && S.focusEl.push(a);
    } else
      v.focus(), a && (S = { focusEl: [a] });
  });
  function I(ge) {
    const je = yy(ge.parentElement, _);
    if (!(je != null && je.node)) {
      console.warn("'TJSMenu.animate warning: Could not locate parent stacking context element.");
      return;
    }
    const Be = je == null ? void 0 : je.node.getBoundingClientRect(), Ze = Be.x + Be.width, Ge = ge.getBoundingClientRect(), Se = ge.parentElement.getBoundingClientRect(), _e = { ...g, ...c };
    return ge.style.top = `${_e.y + Se.height}px`, Se.x + Ge.width < Ze ? (ge.style.left = `${_e.x}px`, ge.style.removeProperty("right")) : (ge.style.right = `${_e.x}px`, ge.style.removeProperty("left")), _z(ge, m);
  }
  u(I, "animate");
  function M(ge, je) {
    typeof (je == null ? void 0 : je.onPress) == "function" && je.onPress({ event: ge, item: je, focusSource: S }), k || (k = !0, v.dispatchEvent(new CustomEvent("close:popup", { bubbles: !0, cancelable: !0 })));
  }
  u(M, "onClick");
  async function L(ge) {
    ge.target === v || v.contains(ge.target) || ge.target === v.parentElement || v.parentElement.contains(ge.target) || k || (k = !0, v.dispatchEvent(new CustomEvent(
      "close:popup",
      {
        bubbles: !0,
        cancelable: !0,
        detail: { target: ge.target }
      }
    )));
  }
  u(L, "onClose");
  function B(ge) {
    if (ge.code === p) {
      ge.stopPropagation();
      return;
    }
    switch (ge.code) {
      case "Tab":
        if (ge.stopPropagation(), ge.shiftKey) {
          const je = ot.getFocusableElements(v, h), Be = je.length > 0 ? je[0] : void 0, Ze = je.length > 0 ? je[je.length - 1] : void 0;
          (v === _.document.activeElement || Be === _.document.activeElement) && (Ze instanceof HTMLElement && Be !== Ze && Ze.focus(), ge.preventDefault());
        }
        break;
      default:
        ge.stopPropagation();
        break;
    }
  }
  u(B, "onKeydownMenu");
  function z(ge) {
    switch (ge.code) {
      case "Escape":
        k || (k = !0, v.dispatchEvent(new CustomEvent(
          "close:popup",
          {
            bubbles: !0,
            cancelable: !0,
            detail: { keyboardFocus: D }
          }
        ))), ge.preventDefault(), ge.stopPropagation();
        break;
    }
  }
  u(z, "onKeyupMenu");
  function q(ge, je) {
    ge.code === p && (typeof (je == null ? void 0 : je.onPress) == "function" && je.onPress({ event: ge, item: je, focusSource: S }), k || (k = !0, ge.preventDefault(), ge.stopPropagation(), v.dispatchEvent(new CustomEvent(
      "close:popup",
      {
        bubbles: !0,
        cancelable: !0,
        detail: { keyboardFocus: D }
      }
    ))));
  }
  u(q, "onKeyupItem");
  function U() {
    k || (k = !0, v.dispatchEvent(new CustomEvent("close:popup", { bubbles: !0, cancelable: !0 })));
  }
  u(U, "onWindowBlur");
  const H = /* @__PURE__ */ u((ge) => M(ge), "click_handler"), V = /* @__PURE__ */ u((ge) => q(ge), "keyup_handler"), Y = /* @__PURE__ */ u((ge, je) => M(je, ge), "click_handler_1"), J = /* @__PURE__ */ u((ge, je) => q(je, ge), "keyup_handler_1"), fe = /* @__PURE__ */ u((ge, je) => M(je, ge), "click_handler_2"), ke = /* @__PURE__ */ u((ge, je) => q(je, ge), "keyup_handler_2"), ee = /* @__PURE__ */ u((ge, je) => M(je, ge), "click_handler_3"), ne = /* @__PURE__ */ u((ge, je) => q(je, ge), "keyup_handler_3"), Ee = /* @__PURE__ */ u((ge, je) => M(je, ge), "click_handler_4"), Pe = /* @__PURE__ */ u((ge, je) => q(je, ge), "keyup_handler_4"), ye = /* @__PURE__ */ u((ge) => M(ge), "click_handler_5"), me = /* @__PURE__ */ u((ge) => q(ge), "keyup_handler_5");
  function Ce(ge) {
    rt[ge ? "unshift" : "push"](() => {
      v = ge, t(4, v);
    });
  }
  return u(Ce, "nav_binding"), i.$$set = (ge) => {
    "menu" in ge && t(2, r = ge.menu), "items" in ge && t(15, o = ge.items), "focusEl" in ge && t(11, a = ge.focusEl), "offset" in ge && t(12, c = ge.offset), "styles" in ge && t(0, f = ge.styles), "efx" in ge && t(1, d = ge.efx), "keyCode" in ge && t(13, p = ge.keyCode), "transitionOptions" in ge && t(14, m = ge.transitionOptions), "$$scope" in ge && t(16, n = ge.$$scope);
  }, i.$$.update = () => {
    if (i.$$.dirty[0] & /*menu, items*/
    32772) {
      const ge = he(r) && Nt(r.items) ? r.items : Nt(o) ? o : [], je = [];
      let Be = -1;
      for (const Ze of ge) {
        if (Be++, !he(Ze))
          throw new TypeError(`TJSMenu error: 'item[${Be}]' is not an object.`);
        if (typeof Ze.condition == "function" && !Ze.condition() || typeof Ze.condition == "boolean" && !Ze.condition)
          continue;
        let Ge;
        if (Ws.isComponent(Ze.class))
          Ge = "class";
        else if (typeof Ze.icon == "string")
          Ge = "icon";
        else if (typeof Ze.image == "string")
          Ge = "image";
        else if (Ze.icon === void 0 && Ze.image === void 0 && typeof Ze.label == "string")
          Ge = "label";
        else if (typeof Ze.separator == "string") {
          if (Ze.separator !== "hr")
            throw new Error(`TJSMenu error: 'item[${Be}]' has unknown separator type; only 'hr' is currently supported.`);
          Ge = "separator-hr";
        }
        if (Ge === void 0)
          throw new TypeError(`TJSMenu error: Unknown type for 'item[${Be}]'.`);
        je.push({ ...Ze, "#type": Ge });
      }
      t(3, y = je);
    }
    i.$$.dirty[0] & /*menu, focusEl*/
    2052 && t(11, a = he(r) && ot.isFocusSource(r.focusEl) ? r.focusEl : ot.isFocusSource(a) ? a : void 0), i.$$.dirty[0] & /*menu, offset*/
    4100 && t(12, c = he(r) && he(r.offset) ? r.offset : he(c) ? c : g), i.$$.dirty[0] & /*menu, styles*/
    5 && t(0, f = he(r) && he(r.styles) ? r.styles : he(f) ? f : void 0), i.$$.dirty[0] & /*menu, efx*/
    6 && t(1, d = he(r) && typeof r.efx == "function" ? r.efx : typeof d == "function" ? d : () => {
    }), i.$$.dirty[0] & /*menu, keyCode*/
    8196 && t(13, p = he(r) && typeof r.keyCode == "string" ? r.keyCode : typeof p == "string" ? p : "Enter"), i.$$.dirty[0] & /*menu, transitionOptions*/
    16388 && t(14, m = he(r) && he(r.transitionOptions) ? r.transitionOptions : he(m) ? m : { duration: 200, easing: "quintOut" });
  }, [
    f,
    d,
    r,
    y,
    v,
    I,
    M,
    B,
    z,
    q,
    l,
    a,
    c,
    p,
    m,
    o,
    n,
    s,
    H,
    V,
    Y,
    J,
    fe,
    ke,
    ee,
    ne,
    Ee,
    Pe,
    ye,
    me,
    Ce
  ];
}
u(YZ, "instance$3k");
const BA = class BA extends re {
  constructor(e) {
    super(), oe(
      this,
      e,
      YZ,
      UZ,
      le,
      {
        menu: 2,
        items: 15,
        focusEl: 11,
        offset: 12,
        styles: 0,
        efx: 1,
        keyCode: 13,
        transitionOptions: 14
      },
      null,
      [-1, -1]
    );
  }
};
u(BA, "TJSMenu");
let Sp = BA;
const al = Mt({});
function XZ(i, e) {
  if (i === "feature")
    return K(CONFIG.A5E.featureTypes[e]);
  if (i === "object")
    return K(CONFIG.A5E.objectTypes[e]);
  if (i === "spell") {
    const t = parseInt(e, 10);
    return K(t === 0 ? CONFIG.A5E.spellLevels[0] : "A5E.Spell");
  }
  return K(CONFIG.A5E.itemTypes[i]);
}
u(XZ, "getItemName");
function JZ(i) {
  return {
    featureType: i
  };
}
u(JZ, "createFeature");
function ZZ(i) {
  const e = {
    degree: Number(i)
  }, t = {
    [foundry.utils.randomID()]: {
      name: "Execute",
      consumers: {
        [foundry.utils.randomID()]: {
          resource: "exertion",
          quantity: 1,
          type: "resource"
        }
      }
    }
  };
  return e.actions = t, e;
}
u(ZZ, "createManuever");
function QZ(i) {
  return {
    objectType: i
  };
}
u(QZ, "createObject");
function xZ(i, e = {}) {
  var r, o, a, c;
  const { actor: t } = e, s = ((o = (r = Bn(al)) == null ? void 0 : r[t.uuid]) == null ? void 0 : o.currentSpellBook) || ((c = (a = t.spellBooks) == null ? void 0 : a.first()) == null ? void 0 : c._id), n = {
    level: Number(i),
    spellBook: s
  };
  if (n.level === 0) return n;
  const l = {
    [foundry.utils.randomID()]: {
      name: "Cast Spell",
      consumers: {
        [foundry.utils.randomID()]: {
          mode: "variable",
          spellLevel: Number(i),
          points: CONFIG.A5E.spellLevelCost[Number(i)],
          type: "spell"
        }
      }
    }
  };
  return n.actions = l, n;
}
u(xZ, "createSpell");
const eQ = {
  feature: JZ,
  maneuver: ZZ,
  object: QZ,
  spell: xZ
};
async function tQ(i, e, t) {
  const s = {
    name: K("A5E.NewItem", { type: K(XZ(e, t)) }),
    type: e,
    system: eQ[e](t, { actor: i })
  };
  (await i.createEmbeddedDocuments("Item", [s])).forEach((l) => {
    var r;
    return (r = l == null ? void 0 : l.sheet) == null ? void 0 : r.render(!0);
  });
}
u(tQ, "createItem");
async function sQ(i, { effectType: e, actionId: t }) {
  const s = (i == null ? void 0 : i.actions.get(t)) ?? {}, n = {
    label: K("A5E.effects.new"),
    icon: i.documentName === "Item" ? (s == null ? void 0 : s.img) ?? i.img : "icons/svg/aura.svg",
    origin: i.uuid
  };
  if (i.documentName === "Item")
    if (n.transfer = !1, e === "onUse") {
      if (!t) {
        ui.notifications.error(K("A5E.notifications.effects.noActionId"));
        return;
      }
      foundry.utils.setProperty(n, "system.effectType", "onUse");
    } else
      foundry.utils.setProperty(n, "system.effectType", "passive");
  e === "inactive" && (n.disabled = !0);
  const l = await i.createEmbeddedDocuments("ActiveEffect", [n]);
  if (l.forEach((r) => {
    var o;
    return (o = r == null ? void 0 : r.sheet) == null ? void 0 : o.render(!0);
  }), e === "onUse") {
    if (!s) return;
    cl.addEffect(i, t, l[0].id);
  }
}
u(sQ, "createEffect");
function H4(i, e, t) {
  const s = i.slice();
  return s[13] = e[t][0], s[14] = e[t][1], s;
}
u(H4, "get_each_context$1n");
function nQ(i) {
  let e, t, s;
  return e = new mc({
    props: {
      title: "Add " + /*documentName*/
      i[0],
      icon: "fas fa-plus",
      onPress: (
        /*func*/
        i[10]
      )
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--tjs-icon-button-background-hover", "none"), G(t, "--tjs-icon-button-background-focus", "none"), G(t, "--tjs-icon-button-background-focus-visible", "none"), G(t, "--tjs-icon-button-background-selected", "none"), G(t, "--tjs-icon-button-text-shadow-hover", "none"), G(t, "--tjs-icon-button-text-shadow-focus", "none"), G(t, "--tjs-icon-button-transition", "var(--a5e-transition-standard)"), G(t, "--tjs-icon-button-diameter", "1rem"), G(t, "--tjs-icon-button-border-radius", "0");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*documentName*/
      1 && (r.title = "Add " + /*documentName*/
      n[0]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(nQ, "create_else_block$D");
function iQ(i) {
  let e, t, s;
  return e = new Ep({
    props: {
      title: "Add " + /*documentName*/
      i[0],
      icon: "fas fa-plus",
      $$slots: { default: [rQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--tjs-icon-button-background-hover", "none"), G(t, "--tjs-icon-button-background-focus", "none"), G(t, "--tjs-icon-button-background-focus-visible", "none"), G(t, "--tjs-icon-button-background-selected", "none"), G(t, "--tjs-icon-button-text-shadow-hover", "none"), G(t, "--tjs-icon-button-text-shadow-focus", "none"), G(t, "--tjs-icon-button-transition", "var(--a5e-transition-standard)"), G(t, "--tjs-icon-button-diameter", "1.1rem"), G(t, "--tjs-icon-button-border-radius", "0");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*documentName*/
      1 && (r.title = "Add " + /*documentName*/
      n[0]), l & /*$$scope, offset, menuList*/
      131078 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(iQ, "create_if_block$1U");
function U4(i) {
  let e, t = K(
    /*heading*/
    i[14]
  ) + "", s, n, l, r;
  function o() {
    return (
      /*click_handler*/
      i[9](
        /*type*/
        i[13]
      )
    );
  }
  return u(o, "click_handler"), {
    c() {
      e = E("button"), s = Q(t), n = F(), b(e, "class", "svelte-1ku3pfp");
    },
    m(a, c) {
      T(a, e, c), A(e, s), A(e, n), l || (r = W(e, "click", st(o)), l = !0);
    },
    p(a, c) {
      i = a, c & /*menuList*/
      2 && t !== (t = K(
        /*heading*/
        i[14]
      ) + "") && be(s, t);
    },
    d(a) {
      a && C(e), l = !1, r();
    }
  };
}
u(U4, "create_each_block$1n");
function lQ(i) {
  let e, t = ue(
    /*menuList*/
    i[1]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = U4(H4(i, t, n));
  return {
    c() {
      e = E("article");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "svelte-1ku3pfp");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*createDocument, menuList*/
      10) {
        t = ue(
          /*menuList*/
          n[1]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = H4(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = U4(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(lQ, "create_default_slot_1$V");
function rQ(i) {
  let e, t;
  return e = new Sp({
    props: {
      offset: (
        /*offset*/
        i[2]
      ),
      $$slots: { default: [lQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*offset*/
      4 && (l.offset = /*offset*/
      s[2]), n & /*$$scope, menuList*/
      131074 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(rQ, "create_default_slot$1H");
function oQ(i) {
  let e, t, s, n;
  const l = [iQ, nQ], r = [];
  function o(a, c) {
    return (
      /*menuList*/
      a[1].length ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, [c]) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(oQ, "create_fragment$3s");
function aQ(i, e, t) {
  let s, { documentName: n = "Item" } = e, { menuList: l = [] } = e, { offset: r = { x: 0, y: 0 } } = e, { reducerType: o = null } = e, { reducer: a = null } = e, { options: c = {} } = e, { entityTypeOverride: f = null } = e;
  function d(_) {
    if (_ || (_ = f), !["Item", "ActiveEffect"].includes(n)) return m("press", _);
    if (n === "Item" && s.documentName === "Actor") return tQ(s, o.slice(0, -1), _);
    if (n === "ActiveEffect") return sQ(s, c);
  }
  u(d, "createDocument");
  const p = de("actor") ?? de("item");
  pe(i, p, (_) => t(11, s = _)), a || (a = p[o]);
  const m = ft(), g = /* @__PURE__ */ u((_) => d(_), "click_handler"), h = /* @__PURE__ */ u(() => d(), "func");
  return i.$$set = (_) => {
    "documentName" in _ && t(0, n = _.documentName), "menuList" in _ && t(1, l = _.menuList), "offset" in _ && t(2, r = _.offset), "reducerType" in _ && t(6, o = _.reducerType), "reducer" in _ && t(5, a = _.reducer), "options" in _ && t(7, c = _.options), "entityTypeOverride" in _ && t(8, f = _.entityTypeOverride);
  }, [
    n,
    l,
    r,
    d,
    p,
    a,
    o,
    c,
    f,
    g,
    h
  ];
}
u(aQ, "instance$3j");
const qA = class qA extends re {
  constructor(e) {
    super(), oe(this, e, aQ, oQ, le, {
      documentName: 0,
      menuList: 1,
      offset: 2,
      reducerType: 6,
      reducer: 5,
      options: 7,
      entityTypeOverride: 8
    });
  }
};
u(qA, "CreateMenu");
let Tn = qA;
function V4(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "You can reenable this dialog at any time by turning off the 'Hide Deletion Confirmation Dialog' system setting.",
      $$slots: { default: [cQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, hideDeleteConfirmation*/
      516 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(V4, "create_if_block$1T");
function cQ(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Don't show this dialog again",
      checked: (
        /*hideDeleteConfirmation*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*hideDeleteConfirmation*/
      4 && (l.checked = /*hideDeleteConfirmation*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(cQ, "create_default_slot$1G");
function uQ(i) {
  let e, t, s, n, l, r, o = `Delete ${/*itemDocument*/
  i[0].type.capitalize()}`, a, c, f, d, p, m, g = !/*hideDeleteSection*/
  i[1] && V4(i);
  return {
    c() {
      e = E("form"), g && g.c(), t = F(), s = E("div"), n = E("button"), l = E("i"), r = F(), a = Q(o), c = F(), f = E("button"), f.innerHTML = `<i class="fa-solid fa-ban"></i>
            Cancel Deletion`, b(l, "class", "fa-solid fa-trash"), b(s, "class", "button-container svelte-1osm0n1"), b(e, "class", "svelte-1osm0n1");
    },
    m(h, _) {
      T(h, e, _), g && g.m(e, null), A(e, t), A(e, s), A(s, n), A(n, l), A(n, r), A(n, a), A(s, c), A(s, f), d = !0, p || (m = [
        W(n, "click", st(
          /*click_handler*/
          i[7]
        )),
        W(f, "click", st(
          /*click_handler_1*/
          i[8]
        ))
      ], p = !0);
    },
    p(h, [_]) {
      /*hideDeleteSection*/
      h[1] ? g && (ae(), O(g, 1, 1, () => {
        g = null;
      }), ce()) : g ? (g.p(h, _), _ & /*hideDeleteSection*/
      2 && w(g, 1)) : (g = V4(h), g.c(), w(g, 1), g.m(e, t)), (!d || _ & /*itemDocument*/
      1) && o !== (o = `Delete ${/*itemDocument*/
      h[0].type.capitalize()}`) && be(a, o);
    },
    i(h) {
      d || (w(g), d = !0);
    },
    o(h) {
      O(g), d = !1;
    },
    d(h) {
      h && C(e), g && g.d(), p = !1, Me(m);
    }
  };
}
u(uQ, "create_fragment$3r");
function fQ(i, e, t) {
  let { dialog: s, itemDocument: n, hideDeleteSection: l } = de("#external").application, { dialog: r = s, itemDocument: o = n, hideDeleteSection: a = l } = e;
  function c() {
    r.submit({
      confirmDeletion: !0,
      hideDeleteConfirmation: d
    });
  }
  u(c, "onSubmit");
  function f() {
    r.submit({ confirmDeletion: !1 });
  }
  u(f, "onCancelDeletion");
  let d = game.settings.get("a5e", "hideDeleteConfirmation");
  const p = /* @__PURE__ */ u(({ detail: h }) => {
    t(2, d = h);
  }, "updateSelection_handler"), m = /* @__PURE__ */ u(() => c(), "click_handler"), g = /* @__PURE__ */ u(() => f(), "click_handler_1");
  return i.$$set = (h) => {
    "dialog" in h && t(5, r = h.dialog), "itemDocument" in h && t(0, o = h.itemDocument), "hideDeleteSection" in h && t(1, a = h.hideDeleteSection);
  }, [
    o,
    a,
    d,
    c,
    f,
    r,
    p,
    m,
    g
  ];
}
u(fQ, "instance$3i");
var Ha;
let dQ = (Ha = class extends re {
  constructor(e) {
    super(), oe(this, e, fQ, uQ, le, {
      dialog: 5,
      itemDocument: 0,
      hideDeleteSection: 1
    });
  }
}, u(Ha, "DeletionConfirmationDialog"), Ha);
var zf, ky;
const GA = class GA extends Un {
  constructor(t, s = !1) {
    super(
      {
        title: `${t == null ? void 0 : t.name}: Confirm Deletion`,
        content: {
          class: dQ,
          props: { itemDocument: t, hideDeleteSection: s }
        }
      },
      {
        classes: ["a5e-sheet"],
        width: 420
      }
    );
    x(this, zf);
    this.data.content.props.dialog = this, this.promise = new Promise((n) => {
      this.resolve = n;
    });
  }
  /** @inheritdoc */
  close(t) {
    return X(this, zf, ky).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return X(this, zf, ky).call(this, t), super.close();
  }
};
zf = new WeakSet(), ky = /* @__PURE__ */ u(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), u(GA, "DeletionConfirmationDialog");
let Au = GA;
function W4(i) {
  let e;
  return {
    c() {
      e = E("div"), e.innerHTML = '<div class="component svelte-nve8ug" data-tooltip="A5E.effects.types.singular.temporary" data-tooltip-direction="UP"><i class="fa-solid fa-hourglass-half"></i></div>', b(e, "class", "component-wrapper svelte-nve8ug");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(W4, "create_if_block_4$r");
function K4(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "effect-button fa-regular fa-circle-down svelte-nve8ug"), b(e, "data-tooltip", "A5E.effects.applyToActor"), b(e, "data-tooltip-direction", "UP");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler_2*/
        i[12]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(K4, "create_if_block_3$x");
function Y4(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "effect-button effect-button--active-toggle fas svelte-nve8ug"), b(e, "data-tooltip", t = /*effect*/
      i[0].isLocked ? "Originating item is not equipped." : "A5E.effects.toggleActiveState"), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "fa-toggle-off",
        /*effect*/
        i[0].isSuppressed
      ), Z(e, "fa-toggle-on", !/*effect*/
      i[0].isSuppressed), Z(e, "active", !/*effect*/
      i[0].isSuppressed), Z(
        e,
        "locked",
        /*effect*/
        i[0].isLocked
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "click",
        /*click_handler_3*/
        i[13]
      ), s = !0);
    },
    p(l, r) {
      r & /*effect*/
      1 && t !== (t = /*effect*/
      l[0].isLocked ? "Originating item is not equipped." : "A5E.effects.toggleActiveState") && b(e, "data-tooltip", t), r & /*effect*/
      1 && Z(
        e,
        "fa-toggle-off",
        /*effect*/
        l[0].isSuppressed
      ), r & /*effect*/
      1 && Z(e, "fa-toggle-on", !/*effect*/
      l[0].isSuppressed), r & /*effect*/
      1 && Z(e, "active", !/*effect*/
      l[0].isSuppressed), r & /*effect*/
      1 && Z(
        e,
        "locked",
        /*effect*/
        l[0].isLocked
      );
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Y4, "create_if_block_2$R");
function X4(i) {
  let e, t = !/*sheetIsLocked*/
  i[2] && J4(i);
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*sheetIsLocked*/
      s[2] ? t && (t.d(1), t = null) : t ? t.p(s, n) : (t = J4(s), t.c(), t.m(e.parentNode, e));
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(X4, "create_if_block$1S");
function J4(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g;
  return {
    c() {
      e = E("div"), t = E("i"), s = F(), n = E("ul"), l = E("li"), r = E("button"), o = F(), a = E("li"), c = E("button"), f = F(), d = E("li"), p = E("button"), b(t, "class", "track-icon fa-solid fa-ellipsis-vertical svelte-nve8ug"), b(r, "class", "action-button fas fa-cog svelte-nve8ug"), b(r, "data-tooltip", "A5E.ButtonToolTipConfigure"), b(r, "data-tooltip-direction", "UP"), b(c, "class", "action-button fa-solid fa-clone svelte-nve8ug"), b(c, "data-tooltip", "A5E.ButtonToolTipDuplicate"), b(c, "data-tooltip-direction", "UP"), b(p, "class", "action-button delete-button fas fa-trash svelte-nve8ug"), b(p, "data-tooltip", "A5E.ButtonToolTipDelete"), b(p, "data-tooltip-direction", "UP"), b(n, "class", "track-items svelte-nve8ug"), b(e, "class", "track svelte-nve8ug");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(e, s), A(e, n), A(n, l), A(l, r), A(n, o), A(n, a), A(a, c), A(n, f), A(n, d), A(d, p), m || (g = [
        W(r, "click", Ve(
          /*onConfigure*/
          i[4]
        )),
        W(c, "click", Ve(
          /*onDuplicate*/
          i[5]
        )),
        W(p, "click", Ve(
          /*onDelete*/
          i[6]
        )),
        W(e, "click", Ve(
          /*click_handler*/
          i[10]
        ))
      ], m = !0);
    },
    p: se,
    d(h) {
      h && C(e), m = !1, Me(g);
    }
  };
}
u(J4, "create_if_block_1$1g");
function pQ(i) {
  let e, t, s, n, l, r, o, a, c = (
    /*effect*/
    i[0].name + ""
  ), f, d, p, m, g, h, _, y, v, k = (
    /*effect*/
    i[0].isTemporary && W4()
  ), S = (
    /*allowTransfer*/
    i[3] && K4(i)
  ), D = (
    /*$doc*/
    i[1].documentName === "Actor" && Y4(i)
  ), I = (
    /*$doc*/
    i[1].isOwner && X4(i)
  );
  return {
    c() {
      var M, L;
      e = E("li"), t = E("button"), s = E("img"), r = F(), o = E("div"), a = E("div"), f = Q(c), d = F(), p = E("div"), k && k.c(), m = F(), g = E("div"), S && S.c(), h = F(), D && D.c(), _ = F(), I && I.c(), b(s, "class", "effect-image svelte-nve8ug"), ze(s.src, n = /*effect*/
      ((M = i[0]) == null ? void 0 : M.img) ?? /*doc*/
      i[8].img ?? "icons/svg/aura.svg") || b(s, "src", n), b(s, "alt", l = /*effect*/
      ((L = i[0]) == null ? void 0 : L.name) ?? K("A5E.effects.new")), b(t, "class", "effect-activate-button svelte-nve8ug"), t.disabled = !0, Z(t, "disable-pointer-events", !/*$doc*/
      i[1].isOwner), b(a, "class", "name svelte-nve8ug"), b(o, "class", "name-wrapper svelte-nve8ug"), b(g, "class", "button-wrapper svelte-nve8ug"), b(p, "class", "indicator-wrapper svelte-nve8ug"), b(e, "class", "a5e-item a5e-item--effect"), b(e, "draggable", "true");
    },
    m(M, L) {
      T(M, e, L), A(e, t), A(t, s), A(e, r), A(e, o), A(o, a), A(a, f), A(e, d), A(e, p), k && k.m(p, null), A(p, m), A(p, g), S && S.m(g, null), A(g, h), D && D.m(g, null), A(e, _), I && I.m(e, null), y || (v = [
        W(t, "click", Ve(
          /*click_handler_1*/
          i[11]
        )),
        W(
          e,
          "dragstart",
          /*onDragStart*/
          i[7]
        ),
        W(e, "auxclick", st(
          /*auxclick_handler*/
          i[14]
        ))
      ], y = !0);
    },
    p(M, [L]) {
      var B, z;
      L & /*effect*/
      1 && !ze(s.src, n = /*effect*/
      ((B = M[0]) == null ? void 0 : B.img) ?? /*doc*/
      M[8].img ?? "icons/svg/aura.svg") && b(s, "src", n), L & /*effect*/
      1 && l !== (l = /*effect*/
      ((z = M[0]) == null ? void 0 : z.name) ?? K("A5E.effects.new")) && b(s, "alt", l), L & /*$doc*/
      2 && Z(t, "disable-pointer-events", !/*$doc*/
      M[1].isOwner), L & /*effect*/
      1 && c !== (c = /*effect*/
      M[0].name + "") && be(f, c), /*effect*/
      M[0].isTemporary ? k || (k = W4(), k.c(), k.m(p, m)) : k && (k.d(1), k = null), /*allowTransfer*/
      M[3] ? S ? S.p(M, L) : (S = K4(M), S.c(), S.m(g, h)) : S && (S.d(1), S = null), /*$doc*/
      M[1].documentName === "Actor" ? D ? D.p(M, L) : (D = Y4(M), D.c(), D.m(g, null)) : D && (D.d(1), D = null), /*$doc*/
      M[1].isOwner ? I ? I.p(M, L) : (I = X4(M), I.c(), I.m(e, null)) : I && (I.d(1), I = null);
    },
    i: se,
    o: se,
    d(M) {
      M && C(e), k && k.d(), S && S.d(), D && D.d(), I && I.d(), y = !1, Me(v);
    }
  };
}
u(pQ, "create_fragment$3q");
function mQ(i, e, t) {
  let s, n, l, { effect: r } = e;
  function o() {
    var k;
    (k = r.sheet) == null || k.render(!0);
  }
  u(o, "onConfigure");
  function a() {
    r.duplicateEffect(p);
  }
  u(a, "onDuplicate");
  async function c() {
    let k;
    if (!game.settings.get("a5e", "hideDeleteConfirmation")) {
      const M = { name: r.name, type: "Active Effect" }, L = new Au(M);
      if (await L.render(!0), k = await L.promise, !k || !k.confirmDeletion) return;
    }
    await game.settings.set("a5e", "hideDeleteConfirmation", (k == null ? void 0 : k.hideDeleteConfirmation) ?? game.settings.get("a5e", "hideDeleteConfirmation"));
    const S = r.id;
    if (r.delete(), !p || l.documentName !== "Item") return;
    const I = [...l.actions.get(p).effects].filter((M) => M !== S);
    l.update({
      [`system.actions.${p}.effects`]: I
    });
  }
  u(c, "onDelete");
  function f(k) {
    var D;
    const S = r.toDragData();
    if (S)
      return S.parentId = (D = r == null ? void 0 : r.parent) == null ? void 0 : D.id, k.dataTransfer.setData("text/plain", JSON.stringify(S));
  }
  u(f, "onDragStart");
  const d = de("actor") ?? de("item");
  pe(i, d, (k) => t(1, l = k));
  const p = de("actionId") ?? null;
  let m = game.settings.get("a5e", "itemRightClickConfigure") ?? !1;
  function g(k) {
    bt.call(this, i, k);
  }
  u(g, "click_handler");
  const h = /* @__PURE__ */ u(({ target: k }) => {
    k.blur();
  }, "click_handler_1"), _ = /* @__PURE__ */ u(() => r.transferEffect(l.parent), "click_handler_2"), y = /* @__PURE__ */ u(() => r.toggleActiveState(), "click_handler_3"), v = /* @__PURE__ */ u(() => {
    m && o();
  }, "auxclick_handler");
  return i.$$set = (k) => {
    "effect" in k && t(0, r = k.effect);
  }, i.$$.update = () => {
    var k, S, D;
    i.$$.dirty & /*effect, $doc*/
    3 && t(3, s = r.system.effectType === "passive" && l.documentName === "Item" && ["Actor", "ActorDelta"].includes((k = l.parent) == null ? void 0 : k.documentName)), i.$$.dirty & /*$doc*/
    2 && t(2, n = l.isOwner ? l.documentName === "Item" ? !1 : ((D = (S = l.flags) == null ? void 0 : S.a5e) == null ? void 0 : D.sheetIsLocked) ?? !0 : !0);
  }, [
    r,
    l,
    n,
    s,
    o,
    a,
    c,
    f,
    d,
    m,
    g,
    h,
    _,
    y,
    v
  ];
}
u(mQ, "instance$3h");
const zA = class zA extends re {
  constructor(e) {
    super(), oe(this, e, mQ, pQ, le, { effect: 0 });
  }
};
u(zA, "Effect");
let wy = zA;
function Z4(i, e, t) {
  const s = i.slice();
  return s[7] = e[t], s;
}
u(Z4, "get_each_context$1m");
function Q4(i, e) {
  let t, s, n, l, r, o;
  return s = new wy({ props: { effect: (
    /*effect*/
    e[7]
  ) } }), {
    key: i,
    first: null,
    c() {
      t = $e(), n = E("div"), j(s.$$.fragment), G(n, "display", "contents"), G(n, "--effectTemplateAreas", l = /*effectTemplateConfiguration*/
      e[2].areas), G(n, "--effectTemplateColumns", r = /*effectTemplateConfiguration*/
      e[2].columns), this.first = t;
    },
    m(a, c) {
      T(a, t, c), T(a, n, c), R(s, n, null), o = !0;
    },
    p(a, c) {
      e = a, c & /*effectTemplateConfiguration*/
      4 && l !== (l = /*effectTemplateConfiguration*/
      e[2].areas) && G(n, "--effectTemplateAreas", l), c & /*effectTemplateConfiguration*/
      4 && r !== (r = /*effectTemplateConfiguration*/
      e[2].columns) && G(n, "--effectTemplateColumns", r);
      const f = {};
      c & /*effects*/
      2 && (f.effect = /*effect*/
      e[7]), s.$set(f);
    },
    i(a) {
      o || (w(s.$$.fragment, a), o = !0);
    },
    o(a) {
      O(s.$$.fragment, a), o = !1;
    },
    d(a) {
      a && C(t), a && s && C(n), N(s, a);
    }
  };
}
u(Q4, "create_each_block$1m");
function hQ(i) {
  let e, t, s, n = K(
    /*label*/
    i[0]
  ) + "", l, r, o, a = [], c = /* @__PURE__ */ new Map(), f, d = ue([.../*effects*/
  i[1]]);
  const p = /* @__PURE__ */ u((m) => (
    /*effect*/
    m[7].id
  ), "get_key");
  for (let m = 0; m < d.length; m += 1) {
    let g = Z4(i, d, m), h = p(g);
    c.set(h, a[m] = Q4(h, g));
  }
  return {
    c() {
      e = E("section"), t = E("header"), s = E("h3"), l = Q(n), r = F(), o = E("ul");
      for (let m = 0; m < a.length; m += 1)
        a[m].c();
      b(s, "class", "a5e-section-header__heading"), b(t, "class", "a5e-section-header a5e-section-header--item-list"), Z(t, "a5e-section-header--flat-bottom", [.../*effects*/
      i[1]].length), b(o, "class", "a5e-item-list");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, s), A(s, l), A(e, r), A(e, o);
      for (let h = 0; h < a.length; h += 1)
        a[h] && a[h].m(o, null);
      f = !0;
    },
    p(m, [g]) {
      (!f || g & /*label*/
      1) && n !== (n = K(
        /*label*/
        m[0]
      ) + "") && be(l, n), (!f || g & /*effects*/
      2) && Z(t, "a5e-section-header--flat-bottom", [.../*effects*/
      m[1]].length), g & /*effects, effectTemplateConfiguration*/
      6 && (d = ue([.../*effects*/
      m[1]]), ae(), a = Lt(a, g, p, 1, m, d, c, o, cn, Q4, null, Z4), ce());
    },
    i(m) {
      if (!f) {
        for (let g = 0; g < d.length; g += 1)
          w(a[g]);
        f = !0;
      }
    },
    o(m) {
      for (let g = 0; g < a.length; g += 1)
        O(a[g]);
      f = !1;
    },
    d(m) {
      m && C(e);
      for (let g = 0; g < a.length; g += 1)
        a[g].d();
    }
  };
}
u(hQ, "create_fragment$3p");
function gQ(i, e, t) {
  let s, n, l, { label: r } = e, { effects: o } = e;
  function a(f) {
    let d = "icon name indicators", p = "min-content 1fr min-content";
    return (l.documentName === "Item" || !f) && (d += " menu", p += " 2rem"), { areas: `"${d}"`, columns: p };
  }
  u(a, "getEffectTemplateConfiguration");
  const c = de("actor") ?? de("item");
  return pe(i, c, (f) => t(5, l = f)), i.$$set = (f) => {
    "label" in f && t(0, r = f.label), "effects" in f && t(1, o = f.effects);
  }, i.$$.update = () => {
    var f, d;
    i.$$.dirty & /*$doc*/
    32 && t(4, s = l.isOwner ? l.documentName === "Item" ? !1 : ((d = (f = l.flags) == null ? void 0 : f.a5e) == null ? void 0 : d.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*sheetIsLocked*/
    16 && t(2, n = a(s));
  }, [r, o, n, c, s, l];
}
u(gQ, "instance$3g");
const HA = class HA extends re {
  constructor(e) {
    super(), oe(this, e, gQ, hQ, le, { label: 0, effects: 1 });
  }
};
u(HA, "EffectCategory");
let Eu = HA;
function x4(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", t = di(
        /*icon*/
        i[1]
      ) + " svelte-jq7vi1");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*icon*/
      2 && t !== (t = di(
        /*icon*/
        s[1]
      ) + " svelte-jq7vi1") && b(e, "class", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(x4, "create_if_block_3$w");
function bQ(i) {
  let e, t, s;
  const n = [
    he(
      /*label*/
      i[2].props
    ) ? (
      /*label*/
      i[2].props
    ) : {}
  ];
  var l = (
    /*label*/
    i[2].class
  );
  function r(o, a) {
    let c = {};
    for (let f = 0; f < n.length; f += 1)
      c = Dt(c, n[f]);
    return a !== void 0 && a & /*label*/
    4 && (c = Dt(c, Vt(n, [
      Jt(he(
        /*label*/
        o[2].props
      ) ? (
        /*label*/
        o[2].props
      ) : {})
    ]))), { props: c };
  }
  return u(r, "switch_props"), l && (e = et(l, r(i))), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(o, a) {
      e && R(e, o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a & /*label*/
      4 && l !== (l = /*label*/
      o[2].class)) {
        if (e) {
          ae();
          const c = e;
          O(c.$$.fragment, 1, 0, () => {
            N(c, 1);
          }), ce();
        }
        l ? (e = et(l, r(o, a)), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const c = a & /*label*/
        4 ? Vt(n, [
          Jt(he(
            /*label*/
            o[2].props
          ) ? (
            /*label*/
            o[2].props
          ) : {})
        ]) : {};
        e.$set(c);
      }
    },
    i(o) {
      s || (e && w(e.$$.fragment, o), s = !0);
    },
    o(o) {
      e && O(e.$$.fragment, o), s = !1;
    },
    d(o) {
      o && C(t), e && N(e, o);
    }
  };
}
u(bQ, "create_if_block_2$Q");
function _Q(i) {
  let e = K(
    /*label*/
    i[2]
  ) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*label*/
      4 && e !== (e = K(
        /*label*/
        s[2]
      ) + "") && be(t, e);
    },
    i: se,
    o: se,
    d(s) {
      s && C(t);
    }
  };
}
u(_Q, "create_if_block_1$1f");
function yQ(i) {
  let e;
  const t = (
    /*#slots*/
    i[18].default
  ), s = Gt(
    t,
    i,
    /*$$scope*/
    i[17],
    null
  );
  return {
    c() {
      s && s.c();
    },
    m(n, l) {
      s && s.m(n, l), e = !0;
    },
    p(n, l) {
      s && s.p && (!e || l & /*$$scope*/
      131072) && Ht(
        s,
        t,
        n,
        /*$$scope*/
        n[17],
        e ? zt(
          t,
          /*$$scope*/
          n[17],
          l,
          null
        ) : Ut(
          /*$$scope*/
          n[17]
        ),
        null
      );
    },
    i(n) {
      e || (w(s, n), e = !0);
    },
    o(n) {
      O(s, n), e = !1;
    },
    d(n) {
      s && s.d(n);
    }
  };
}
u(yQ, "create_if_block$1R");
function vQ(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g = (
    /*icon*/
    i[1] && x4(i)
  );
  const h = [yQ, _Q, bQ], _ = [];
  function y(v, k) {
    return k & /*label*/
    4 && (l = null), /*$$slots*/
    v[11].default ? 0 : typeof /*label*/
    v[2] == "string" ? 1 : (l == null && (l = !!mi.isConfig(
      /*label*/
      v[2]
    )), l ? 2 : -1);
  }
  return u(y, "select_block_type"), ~(r = y(i, -1)) && (o = _[r] = h[r](i)), {
    c() {
      e = E("button"), t = E("span"), s = E("span"), g && g.c(), n = F(), o && o.c(), b(s, "class", "tjs-form-button-span svelte-jq7vi1"), b(t, "class", "tjs-form-button-efx svelte-jq7vi1"), b(e, "class", "tjs-form-button svelte-jq7vi1"), e.disabled = /*disabled*/
      i[0], b(e, "title", c = K(
        /*title*/
        i[3]
      ));
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(t, s), g && g.m(s, null), A(s, n), ~r && _[r].m(s, null), i[22](t), d = !0, p || (m = [
        Et(a = /*efx*/
        i[5].call(null, t, { disabled: (
          /*disabled*/
          i[0]
        ) })),
        W(
          e,
          "click",
          /*onClick*/
          i[7]
        ),
        W(
          e,
          "contextmenu",
          /*onContextMenuPress*/
          i[8]
        ),
        W(
          e,
          "keydown",
          /*onKeydown*/
          i[9]
        ),
        W(
          e,
          "keyup",
          /*onKeyup*/
          i[10]
        ),
        W(
          e,
          "click",
          /*click_handler*/
          i[19]
        ),
        W(
          e,
          "contextmenu",
          /*contextmenu_handler*/
          i[20]
        ),
        W(
          e,
          "press",
          /*press_handler*/
          i[21]
        ),
        Et(f = Xs.call(
          null,
          e,
          /*styles*/
          i[4]
        ))
      ], p = !0);
    },
    p(v, [k]) {
      /*icon*/
      v[1] ? g ? g.p(v, k) : (g = x4(v), g.c(), g.m(s, n)) : g && (g.d(1), g = null);
      let S = r;
      r = y(v, k), r === S ? ~r && _[r].p(v, k) : (o && (ae(), O(_[S], 1, 1, () => {
        _[S] = null;
      }), ce()), ~r ? (o = _[r], o ? o.p(v, k) : (o = _[r] = h[r](v), o.c()), w(o, 1), o.m(s, null)) : o = null), a && $t(a.update) && k & /*disabled*/
      1 && a.update.call(null, { disabled: (
        /*disabled*/
        v[0]
      ) }), (!d || k & /*disabled*/
      1) && (e.disabled = /*disabled*/
      v[0]), (!d || k & /*title*/
      8 && c !== (c = K(
        /*title*/
        v[3]
      ))) && b(e, "title", c), f && $t(f.update) && k & /*styles*/
      16 && f.update.call(
        null,
        /*styles*/
        v[4]
      );
    },
    i(v) {
      d || (w(o), d = !0);
    },
    o(v) {
      O(o), d = !1;
    },
    d(v) {
      v && C(e), g && g.d(), ~r && _[r].d(), i[22](null), p = !1, Me(m);
    }
  };
}
u(vQ, "create_fragment$3o");
function kQ(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e;
  const l = O5(s);
  let { button: r = void 0 } = e, { disabled: o = void 0 } = e, { icon: a = void 0 } = e, { label: c = void 0 } = e, { title: f = void 0 } = e, { styles: d = void 0 } = e, { keyCode: p = void 0 } = e, { efx: m = void 0 } = e, { onPress: g = void 0 } = e, { onContextMenu: h = void 0 } = e, { clickPropagate: _ = void 0 } = e;
  const y = ft(), v = /* @__PURE__ */ u(() => {
  }, "s_EFX_DEFAULT");
  let k;
  function S(U) {
    typeof g == "function" && g({ event: U }), y("press", { event: U }), _ || (U.preventDefault(), U.stopPropagation());
  }
  u(S, "onClick");
  function D(U) {
    typeof h == "function" && (k && k.dispatchEvent(new MouseEvent("contextmenu")), h({ event: U })), _ || (U.preventDefault(), U.stopPropagation());
  }
  u(D, "onContextMenuPress");
  function I(U) {
    U.code === p && (U.preventDefault(), U.stopPropagation()), (U.code === "Enter" || U.code === "Space") && U.preventDefault();
  }
  u(I, "onKeydown");
  function M(U) {
    U.code === p && (k && k.dispatchEvent(new KeyboardEvent(U.type, { key: U.key, code: U.code })), typeof g == "function" && g({ event: U }), y("press", { event: U }), U.preventDefault(), U.stopPropagation());
  }
  u(M, "onKeyup");
  function L(U) {
    bt.call(this, i, U);
  }
  u(L, "click_handler");
  function B(U) {
    bt.call(this, i, U);
  }
  u(B, "contextmenu_handler");
  function z(U) {
    bt.call(this, i, U);
  }
  u(z, "press_handler");
  function q(U) {
    rt[U ? "unshift" : "push"](() => {
      k = U, t(6, k);
    });
  }
  return u(q, "span1_binding"), i.$$set = (U) => {
    "button" in U && t(16, r = U.button), "disabled" in U && t(0, o = U.disabled), "icon" in U && t(1, a = U.icon), "label" in U && t(2, c = U.label), "title" in U && t(3, f = U.title), "styles" in U && t(4, d = U.styles), "keyCode" in U && t(12, p = U.keyCode), "efx" in U && t(5, m = U.efx), "onPress" in U && t(13, g = U.onPress), "onContextMenu" in U && t(14, h = U.onContextMenu), "clickPropagate" in U && t(15, _ = U.clickPropagate), "$$scope" in U && t(17, n = U.$$scope);
  }, i.$$.update = () => {
    i.$$.dirty & /*button, disabled*/
    65537 && t(0, o = he(r) && typeof r.disabled == "boolean" ? r.disabled : typeof o == "boolean" ? o : !1), i.$$.dirty & /*button, icon*/
    65538 && t(1, a = he(r) && typeof r.icon == "string" ? r.icon : typeof a == "string" ? a : void 0), i.$$.dirty & /*button, label*/
    65540 && t(2, c = he(r) && (typeof r.label == "string" || mi.isConfig(r.label)) ? r.label : typeof c == "string" || mi.isConfig(c) ? c : void 0), i.$$.dirty & /*button, title*/
    65544 && t(3, f = he(r) && typeof r.title == "string" ? r.title : typeof f == "string" ? f : void 0), i.$$.dirty & /*button, styles*/
    65552 && t(4, d = he(r) && he(r.styles) ? r.styles : he(d) ? d : void 0), i.$$.dirty & /*button, keyCode*/
    69632 && t(12, p = he(r) && typeof r.keyCode == "string" ? r.keyCode : typeof p == "string" ? p : "Enter"), i.$$.dirty & /*button, efx*/
    65568 && t(5, m = he(r) && typeof r.efx == "function" ? r.efx : typeof m == "function" ? m : v), i.$$.dirty & /*button, onPress*/
    73728 && t(13, g = he(r) && typeof r.onPress == "function" ? r.onPress : typeof g == "function" ? g : void 0), i.$$.dirty & /*button, onContextMenu*/
    81920 && t(14, h = he(r) && typeof r.onContextMenu == "function" ? r.onContextMenu : typeof h == "function" ? h : void 0), i.$$.dirty & /*button, clickPropagate*/
    98304 && t(15, _ = he(r) && typeof r.clickPropagate == "boolean" ? r.clickPropagate : typeof _ == "boolean" ? _ : !1);
  }, [
    o,
    a,
    c,
    f,
    d,
    m,
    k,
    S,
    D,
    I,
    M,
    l,
    p,
    g,
    h,
    _,
    r,
    n,
    s,
    L,
    B,
    z,
    q
  ];
}
u(kQ, "instance$3f");
const UA = class UA extends re {
  constructor(e) {
    super(), oe(this, e, kQ, vQ, le, {
      button: 16,
      disabled: 0,
      icon: 1,
      label: 2,
      title: 3,
      styles: 4,
      keyCode: 12,
      efx: 5,
      onPress: 13,
      onContextMenu: 14,
      clickPropagate: 15
    });
  }
};
u(UA, "TJSButton");
let $y = UA;
const VA = class VA {
  /**
   * Test if the given label is valid data / prop for the TJSSlotLabel component.
   */
  static isValid(e) {
    return typeof e == "string" || mi.isConfig(e);
  }
};
u(VA, "TJSSlotLabelUtil");
let Vn = VA;
function wQ(i) {
  let e;
  const t = (
    /*#slots*/
    i[3].default
  ), s = Gt(
    t,
    i,
    /*$$scope*/
    i[2],
    null
  );
  return {
    c() {
      s && s.c();
    },
    m(n, l) {
      s && s.m(n, l), e = !0;
    },
    p(n, l) {
      s && s.p && (!e || l & /*$$scope*/
      4) && Ht(
        s,
        t,
        n,
        /*$$scope*/
        n[2],
        e ? zt(
          t,
          /*$$scope*/
          n[2],
          l,
          null
        ) : Ut(
          /*$$scope*/
          n[2]
        ),
        null
      );
    },
    i(n) {
      e || (w(s, n), e = !0);
    },
    o(n) {
      O(s, n), e = !1;
    },
    d(n) {
      s && s.d(n);
    }
  };
}
u(wQ, "create_else_block$C");
function $Q(i) {
  let e, t, s, n, l, r;
  const o = [EQ, AQ], a = [];
  function c(p, m) {
    return m & /*label*/
    1 && (t = null), typeof /*label*/
    p[0] == "string" ? 0 : (t == null && (t = !!mi.isConfig(
      /*label*/
      p[0]
    )), t ? 1 : -1);
  }
  u(c, "select_block_type_1"), ~(s = c(i, -1)) && (n = a[s] = o[s](i));
  const f = (
    /*#slots*/
    i[3].default
  ), d = Gt(
    f,
    i,
    /*$$scope*/
    i[2],
    null
  );
  return {
    c() {
      e = E("label"), n && n.c(), l = F(), d && d.c(), b(e, "class", "tjs-slot-label svelte-1c8p0p4");
    },
    m(p, m) {
      T(p, e, m), ~s && a[s].m(e, null), A(e, l), d && d.m(e, null), r = !0;
    },
    p(p, m) {
      let g = s;
      s = c(p, m), s === g ? ~s && a[s].p(p, m) : (n && (ae(), O(a[g], 1, 1, () => {
        a[g] = null;
      }), ce()), ~s ? (n = a[s], n ? n.p(p, m) : (n = a[s] = o[s](p), n.c()), w(n, 1), n.m(e, l)) : n = null), d && d.p && (!r || m & /*$$scope*/
      4) && Ht(
        d,
        f,
        p,
        /*$$scope*/
        p[2],
        r ? zt(
          f,
          /*$$scope*/
          p[2],
          m,
          null
        ) : Ut(
          /*$$scope*/
          p[2]
        ),
        null
      );
    },
    i(p) {
      r || (w(n), w(d, p), r = !0);
    },
    o(p) {
      O(n), O(d, p), r = !1;
    },
    d(p) {
      p && C(e), ~s && a[s].d(), d && d.d(p);
    }
  };
}
u($Q, "create_if_block$1Q");
function AQ(i) {
  let e, t, s;
  const n = [
    he(
      /*label*/
      i[0].props
    ) ? (
      /*label*/
      i[0].props
    ) : {},
    { disabled: (
      /*disabled*/
      i[1]
    ) }
  ];
  var l = (
    /*label*/
    i[0].class
  );
  function r(o, a) {
    let c = {};
    for (let f = 0; f < n.length; f += 1)
      c = Dt(c, n[f]);
    return a !== void 0 && a & /*label, disabled*/
    3 && (c = Dt(c, Vt(n, [
      a & /*label*/
      1 && Jt(he(
        /*label*/
        o[0].props
      ) ? (
        /*label*/
        o[0].props
      ) : {}),
      a & /*disabled*/
      2 && { disabled: (
        /*disabled*/
        o[1]
      ) }
    ]))), { props: c };
  }
  return u(r, "switch_props"), l && (e = et(l, r(i))), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(o, a) {
      e && R(e, o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a & /*label*/
      1 && l !== (l = /*label*/
      o[0].class)) {
        if (e) {
          ae();
          const c = e;
          O(c.$$.fragment, 1, 0, () => {
            N(c, 1);
          }), ce();
        }
        l ? (e = et(l, r(o, a)), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const c = a & /*label, disabled*/
        3 ? Vt(n, [
          a & /*label*/
          1 && Jt(he(
            /*label*/
            o[0].props
          ) ? (
            /*label*/
            o[0].props
          ) : {}),
          a & /*disabled*/
          2 && { disabled: (
            /*disabled*/
            o[1]
          ) }
        ]) : {};
        e.$set(c);
      }
    },
    i(o) {
      s || (e && w(e.$$.fragment, o), s = !0);
    },
    o(o) {
      e && O(e.$$.fragment, o), s = !1;
    },
    d(o) {
      o && C(t), e && N(e, o);
    }
  };
}
u(AQ, "create_if_block_2$P");
function EQ(i) {
  let e, t = K(
    /*label*/
    i[0]
  ) + "", s;
  return {
    c() {
      e = E("span"), s = Q(t), b(e, "class", "tjs-slot-label-span svelte-1c8p0p4"), Z(
        e,
        "disabled",
        /*disabled*/
        i[1]
      );
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*label*/
      1 && t !== (t = K(
        /*label*/
        n[0]
      ) + "") && be(s, t), l & /*disabled*/
      2 && Z(
        e,
        "disabled",
        /*disabled*/
        n[1]
      );
    },
    i: se,
    o: se,
    d(n) {
      n && C(e);
    }
  };
}
u(EQ, "create_if_block_1$1e");
function SQ(i) {
  let e, t, s, n;
  const l = [$Q, wQ], r = [];
  function o(a, c) {
    return (
      /*label*/
      a[0] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, [c]) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(SQ, "create_fragment$3n");
function CQ(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e, { label: l = void 0 } = e, { disabled: r = void 0 } = e;
  return i.$$set = (o) => {
    "label" in o && t(0, l = o.label), "disabled" in o && t(1, r = o.disabled), "$$scope" in o && t(2, n = o.$$scope);
  }, i.$$.update = () => {
    i.$$.dirty & /*label*/
    1 && t(0, l = Vn.isValid(l) ? l : void 0), i.$$.dirty & /*label, disabled*/
    3 && t(1, r = he(l) && typeof l.disabled == "boolean" ? l.disabled : typeof r == "boolean" ? r : !1);
  }, [l, r, n, s];
}
u(CQ, "instance$3e");
const WA = class WA extends re {
  constructor(e) {
    super(), oe(this, e, CQ, SQ, le, { label: 0, disabled: 1 });
  }
};
u(WA, "TJSSlotLabel");
let bo = WA;
function TQ(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "tjs-input svelte-ebn87w"), b(e, "type", "checkbox"), e.disabled = /*disabled*/
      i[0], e.readOnly = /*readonly*/
      i[2];
    },
    m(l, r) {
      T(l, e, r), e.checked = /*$store*/
      i[5], s || (n = [
        W(
          e,
          "change",
          /*input_1_change_handler*/
          i[9]
        ),
        W(
          e,
          "pointerdown",
          /*pointerdown_handler*/
          i[8]
        ),
        Et(t = Xs.call(
          null,
          e,
          /*styles*/
          i[4]
        ))
      ], s = !0);
    },
    p(l, r) {
      r & /*disabled*/
      1 && (e.disabled = /*disabled*/
      l[0]), r & /*readonly*/
      4 && (e.readOnly = /*readonly*/
      l[2]), r & /*$store*/
      32 && (e.checked = /*$store*/
      l[5]), t && $t(t.update) && r & /*styles*/
      16 && t.update.call(
        null,
        /*styles*/
        l[4]
      );
    },
    d(l) {
      l && C(e), s = !1, Me(n);
    }
  };
}
u(TQ, "create_default_slot$1F");
function OQ(i) {
  let e, t;
  return e = new bo({
    props: {
      label: (
        /*label*/
        i[1]
      ),
      disabled: (
        /*disabled*/
        i[0]
      ),
      $$slots: { default: [TQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*label*/
      2 && (l.label = /*label*/
      s[1]), n & /*disabled*/
      1 && (l.disabled = /*disabled*/
      s[0]), n & /*$$scope, disabled, readonly, $store, styles*/
      1077 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(OQ, "create_fragment$3m");
function DQ(i, e, t) {
  let s, n = se, l = /* @__PURE__ */ u(() => (n(), n = Xt(f, (h) => t(5, s = h)), f), "$$subscribe_store");
  i.$$.on_destroy.push(() => n());
  let { input: r = void 0 } = e, { disabled: o = void 0 } = e, { label: a = void 0 } = e, { readonly: c = void 0 } = e, { store: f = void 0 } = e;
  l();
  let { styles: d = void 0 } = e, { efx: p = void 0 } = e;
  function m(h) {
    bt.call(this, i, h);
  }
  u(m, "pointerdown_handler");
  function g() {
    s = this.checked, f.set(s);
  }
  return u(g, "input_1_change_handler"), i.$$set = (h) => {
    "input" in h && t(7, r = h.input), "disabled" in h && t(0, o = h.disabled), "label" in h && t(1, a = h.label), "readonly" in h && t(2, c = h.readonly), "store" in h && l(t(3, f = h.store)), "styles" in h && t(4, d = h.styles), "efx" in h && t(6, p = h.efx);
  }, i.$$.update = () => {
    i.$$.dirty & /*input, disabled*/
    129 && t(0, o = he(r) && typeof r.disabled == "boolean" ? r.disabled : typeof o == "boolean" ? o : !1), i.$$.dirty & /*input, label*/
    130 && t(1, a = he(r) && Vn.isValid(r.label) ? r.label : Vn.isValid(a) ? a : void 0), i.$$.dirty & /*input, readonly*/
    132 && t(2, c = he(r) && typeof r.readonly == "boolean" ? r.readonly : typeof c == "boolean" ? c : !1), i.$$.dirty & /*input, store*/
    136 && l(t(3, f = he(r) && Cn(r.store) ? r.store : Cn(f) ? f : Mt(void 0))), i.$$.dirty & /*input, styles*/
    144 && t(4, d = he(r) && he(r.styles) ? r.styles : he(d) ? d : void 0), i.$$.dirty & /*input, efx*/
    192 && t(6, p = he(r) && typeof r.efx == "function" ? r.efx : typeof p == "function" ? p : () => {
    });
  }, [
    o,
    a,
    c,
    f,
    d,
    s,
    p,
    r,
    m,
    g
  ];
}
u(DQ, "instance$3d");
const KA = class KA extends re {
  constructor(e) {
    super(), oe(this, e, DQ, OQ, le, {
      input: 7,
      disabled: 0,
      label: 1,
      readonly: 2,
      store: 3,
      styles: 4,
      efx: 6
    });
  }
};
u(KA, "TJSInputCheckbox");
let Ay = KA;
function IQ(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "tjs-input svelte-mb4yj5"), b(t, "type", "number"), b(
        t,
        "max",
        /*max*/
        i[2]
      ), b(
        t,
        "min",
        /*min*/
        i[3]
      ), b(
        t,
        "step",
        /*step*/
        i[6]
      ), b(
        t,
        "placeholder",
        /*placeholder*/
        i[4]
      ), t.disabled = /*disabled*/
      i[0], t.readOnly = /*readonly*/
      i[5], Z(t, "is-value-invalid", !/*$storeIsValid*/
      i[12]), b(e, "class", "tjs-input-container svelte-mb4yj5");
    },
    m(r, o) {
      T(r, e, o), A(e, t), i[19](t), He(
        t,
        /*$store*/
        i[13]
      ), n || (l = [
        W(
          t,
          "input",
          /*input_1_input_handler*/
          i[20]
        ),
        W(
          t,
          "focusin",
          /*onFocusIn*/
          i[14]
        ),
        W(
          t,
          "keydown",
          /*onKeyDown*/
          i[15]
        ),
        Et(
          /*efx*/
          i[10].call(null, e)
        ),
        Et(s = Xs.call(
          null,
          e,
          /*styles*/
          i[9]
        )),
        W(
          e,
          "pointerdown",
          /*pointerdown_handler*/
          i[18]
        )
      ], n = !0);
    },
    p(r, o) {
      o & /*max*/
      4 && b(
        t,
        "max",
        /*max*/
        r[2]
      ), o & /*min*/
      8 && b(
        t,
        "min",
        /*min*/
        r[3]
      ), o & /*step*/
      64 && b(
        t,
        "step",
        /*step*/
        r[6]
      ), o & /*placeholder*/
      16 && b(
        t,
        "placeholder",
        /*placeholder*/
        r[4]
      ), o & /*disabled*/
      1 && (t.disabled = /*disabled*/
      r[0]), o & /*readonly*/
      32 && (t.readOnly = /*readonly*/
      r[5]), o & /*$store*/
      8192 && Hn(t.value) !== /*$store*/
      r[13] && He(
        t,
        /*$store*/
        r[13]
      ), o & /*$storeIsValid*/
      4096 && Z(t, "is-value-invalid", !/*$storeIsValid*/
      r[12]), s && $t(s.update) && o & /*styles*/
      512 && s.update.call(
        null,
        /*styles*/
        r[9]
      );
    },
    d(r) {
      r && C(e), i[19](null), n = !1, Me(l);
    }
  };
}
u(IQ, "create_default_slot$1E");
function PQ(i) {
  let e, t;
  return e = new bo({
    props: {
      label: (
        /*label*/
        i[1]
      ),
      disabled: (
        /*disabled*/
        i[0]
      ),
      $$slots: { default: [IQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*label*/
      2 && (l.label = /*label*/
      s[1]), n & /*disabled*/
      1 && (l.disabled = /*disabled*/
      s[0]), n & /*$$scope, styles, max, min, step, placeholder, disabled, readonly, inputEl, $store, $storeIsValid*/
      8403581 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(PQ, "create_fragment$3l");
function MQ(i, e, t) {
  let s, n = se, l = /* @__PURE__ */ u(() => (n(), n = Xt(k, (V) => t(12, s = V)), k), "$$subscribe_storeIsValid"), r, o = se, a = /* @__PURE__ */ u(() => (o(), o = Xt(v, (V) => t(13, r = V)), v), "$$subscribe_store");
  i.$$.on_destroy.push(() => n()), i.$$.on_destroy.push(() => o());
  let { input: c = void 0 } = e, { disabled: f = void 0 } = e, { label: d = void 0 } = e, { options: p = void 0 } = e, { max: m = void 0 } = e, { min: g = void 0 } = e, { placeholder: h = void 0 } = e, { readonly: _ = void 0 } = e, { step: y = void 0 } = e, { store: v = void 0 } = e;
  a();
  let { storeIsValid: k = void 0 } = e;
  l();
  let { styles: S = void 0 } = e, { efx: D = void 0 } = e;
  const I = {
    blurOnEnterKey: !0,
    cancelOnEscKey: !1
  };
  let M, L;
  function B() {
    I.cancelOnEscKey && (L = M.value === "" ? null : globalThis.parseFloat(M.value));
  }
  u(B, "onFocusIn");
  function z(V) {
    if (I.blurOnEnterKey && V.code === "Enter") {
      V.preventDefault(), V.stopPropagation(), M.blur();
      return;
    }
    V.code === "Escape" && I.cancelOnEscKey && (L === null || typeof L == "number") && (V.preventDefault(), V.stopPropagation(), v.set(L), L = void 0, M.blur());
  }
  u(z, "onKeyDown");
  function q(V) {
    bt.call(this, i, V);
  }
  u(q, "pointerdown_handler");
  function U(V) {
    rt[V ? "unshift" : "push"](() => {
      M = V, t(11, M);
    });
  }
  u(U, "input_1_binding");
  function H() {
    r = Hn(this.value), v.set(r);
  }
  return u(H, "input_1_input_handler"), i.$$set = (V) => {
    "input" in V && t(17, c = V.input), "disabled" in V && t(0, f = V.disabled), "label" in V && t(1, d = V.label), "options" in V && t(16, p = V.options), "max" in V && t(2, m = V.max), "min" in V && t(3, g = V.min), "placeholder" in V && t(4, h = V.placeholder), "readonly" in V && t(5, _ = V.readonly), "step" in V && t(6, y = V.step), "store" in V && a(t(7, v = V.store)), "storeIsValid" in V && l(t(8, k = V.storeIsValid)), "styles" in V && t(9, S = V.styles), "efx" in V && t(10, D = V.efx);
  }, i.$$.update = () => {
    i.$$.dirty & /*input, disabled*/
    131073 && t(0, f = he(c) && typeof c.disabled == "boolean" ? c.disabled : typeof f == "boolean" ? f : !1), i.$$.dirty & /*input, label*/
    131074 && t(1, d = he(c) && Vn.isValid(c.label) ? c.label : Vn.isValid(d) ? d : void 0), i.$$.dirty & /*input, options*/
    196608 && (t(16, p = he(c) && he(c.options) ? c.options : he(p) ? p : {}), typeof (p == null ? void 0 : p.blurOnEnterKey) == "boolean" && (I.blurOnEnterKey = p.blurOnEnterKey), typeof (p == null ? void 0 : p.cancelOnEscKey) == "boolean" && (I.cancelOnEscKey = p.cancelOnEscKey)), i.$$.dirty & /*input, max*/
    131076 && t(2, m = he(c) && typeof c.max == "number" ? c.max : typeof m == "number" ? m : void 0), i.$$.dirty & /*input, min*/
    131080 && t(3, g = he(c) && typeof c.min == "number" ? c.min : typeof g == "number" ? g : void 0), i.$$.dirty & /*input, placeholder*/
    131088 && t(4, h = he(c) && typeof c.placeholder == "string" ? K(c.placeholder) : typeof h == "string" ? K(h) : void 0), i.$$.dirty & /*input, readonly*/
    131104 && t(5, _ = he(c) && typeof c.readonly == "boolean" ? c.readonly : typeof _ == "boolean" ? _ : !1), i.$$.dirty & /*input, step*/
    131136 && t(6, y = he(c) && typeof c.step == "number" ? c.step : typeof y == "number" ? y : void 0), i.$$.dirty & /*input, store*/
    131200 && a(t(7, v = he(c) && Cn(c.store) ? c.store : Cn(v) ? v : Mt(void 0))), i.$$.dirty & /*input, storeIsValid*/
    131328 && l(t(8, k = he(c) && Ud(c.storeIsValid) ? c.storeIsValid : Ud(k) ? k : Mt(!0))), i.$$.dirty & /*input, styles*/
    131584 && t(9, S = he(c) && he(c.styles) ? c.styles : he(S) ? S : void 0), i.$$.dirty & /*input, efx*/
    132096 && t(10, D = he(c) && typeof c.efx == "function" ? c.efx : typeof D == "function" ? D : () => {
    });
  }, [
    f,
    d,
    m,
    g,
    h,
    _,
    y,
    v,
    k,
    S,
    D,
    M,
    s,
    r,
    B,
    z,
    p,
    c,
    q,
    U,
    H
  ];
}
u(MQ, "instance$3c");
const YA = class YA extends re {
  constructor(e) {
    super(), oe(this, e, MQ, PQ, le, {
      input: 17,
      disabled: 0,
      label: 1,
      options: 16,
      max: 2,
      min: 3,
      placeholder: 4,
      readonly: 5,
      step: 6,
      store: 7,
      storeIsValid: 8,
      styles: 9,
      efx: 10
    });
  }
};
u(YA, "TJSInputNumber");
let Ey = YA;
function FQ(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "tjs-input svelte-2xxdp1"), b(t, "type", "range"), t.disabled = /*disabled*/
      i[0], b(
        t,
        "min",
        /*min*/
        i[3]
      ), b(
        t,
        "max",
        /*max*/
        i[2]
      ), t.readOnly = /*readonly*/
      i[4], b(
        t,
        "step",
        /*step*/
        i[5]
      ), b(e, "class", "tjs-input-container svelte-2xxdp1");
    },
    m(r, o) {
      T(r, e, o), A(e, t), i[16](t), He(
        t,
        /*$store*/
        i[10]
      ), n || (l = [
        W(
          t,
          "change",
          /*input_1_change_input_handler*/
          i[17]
        ),
        W(
          t,
          "input",
          /*input_1_change_input_handler*/
          i[17]
        ),
        W(
          t,
          "focusin",
          /*onFocusIn*/
          i[11]
        ),
        W(
          t,
          "keydown",
          /*onKeyDown*/
          i[12]
        ),
        Et(
          /*efx*/
          i[8].call(null, e)
        ),
        Et(s = Xs.call(
          null,
          e,
          /*styles*/
          i[7]
        )),
        W(
          e,
          "pointerdown",
          /*pointerdown_handler*/
          i[15]
        )
      ], n = !0);
    },
    p(r, o) {
      o & /*disabled*/
      1 && (t.disabled = /*disabled*/
      r[0]), o & /*min*/
      8 && b(
        t,
        "min",
        /*min*/
        r[3]
      ), o & /*max*/
      4 && b(
        t,
        "max",
        /*max*/
        r[2]
      ), o & /*readonly*/
      16 && (t.readOnly = /*readonly*/
      r[4]), o & /*step*/
      32 && b(
        t,
        "step",
        /*step*/
        r[5]
      ), o & /*$store*/
      1024 && He(
        t,
        /*$store*/
        r[10]
      ), s && $t(s.update) && o & /*styles*/
      128 && s.update.call(
        null,
        /*styles*/
        r[7]
      );
    },
    d(r) {
      r && C(e), i[16](null), n = !1, Me(l);
    }
  };
}
u(FQ, "create_default_slot$1D");
function RQ(i) {
  let e, t;
  return e = new bo({
    props: {
      label: (
        /*label*/
        i[1]
      ),
      disabled: (
        /*disabled*/
        i[0]
      ),
      $$slots: { default: [FQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*label*/
      2 && (l.label = /*label*/
      s[1]), n & /*disabled*/
      1 && (l.disabled = /*disabled*/
      s[0]), n & /*$$scope, styles, disabled, min, max, readonly, step, inputEl, $store*/
      1050301 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(RQ, "create_fragment$3k");
function NQ(i, e, t) {
  let s, n = se, l = /* @__PURE__ */ u(() => (n(), n = Xt(g, (B) => t(10, s = B)), g), "$$subscribe_store");
  i.$$.on_destroy.push(() => n());
  let { input: r = void 0 } = e, { disabled: o = void 0 } = e, { label: a = void 0 } = e, { options: c = void 0 } = e, { max: f = void 0 } = e, { min: d = void 0 } = e, { readonly: p = void 0 } = e, { step: m = void 0 } = e, { store: g = void 0 } = e;
  l();
  let { styles: h = void 0 } = e, { efx: _ = void 0 } = e;
  const y = {
    blurOnEnterKey: !0,
    cancelOnEscKey: !1
  };
  let v, k;
  function S() {
    k = y.cancelOnEscKey ? v.value : void 0;
  }
  u(S, "onFocusIn");
  function D(B) {
    if (y.blurOnEnterKey && B.code === "Enter") {
      B.preventDefault(), B.stopPropagation(), v.blur();
      return;
    }
    B.code === "Escape" && y.cancelOnEscKey && typeof k == "string" && (B.preventDefault(), B.stopPropagation(), g.set(k), k = void 0, v.blur());
  }
  u(D, "onKeyDown");
  function I(B) {
    bt.call(this, i, B);
  }
  u(I, "pointerdown_handler");
  function M(B) {
    rt[B ? "unshift" : "push"](() => {
      v = B, t(9, v);
    });
  }
  u(M, "input_1_binding");
  function L() {
    s = Hn(this.value), g.set(s);
  }
  return u(L, "input_1_change_input_handler"), i.$$set = (B) => {
    "input" in B && t(14, r = B.input), "disabled" in B && t(0, o = B.disabled), "label" in B && t(1, a = B.label), "options" in B && t(13, c = B.options), "max" in B && t(2, f = B.max), "min" in B && t(3, d = B.min), "readonly" in B && t(4, p = B.readonly), "step" in B && t(5, m = B.step), "store" in B && l(t(6, g = B.store)), "styles" in B && t(7, h = B.styles), "efx" in B && t(8, _ = B.efx);
  }, i.$$.update = () => {
    i.$$.dirty & /*input, disabled*/
    16385 && t(0, o = he(r) && typeof r.disabled == "boolean" ? r.disabled : typeof o == "boolean" ? o : !1), i.$$.dirty & /*input, label*/
    16386 && t(1, a = he(r) && Vn.isValid(r.label) ? r.label : Vn.isValid(a) ? a : void 0), i.$$.dirty & /*input, max*/
    16388 && t(2, f = he(r) && typeof r.max == "number" ? r.max : typeof f == "number" ? f : 100), i.$$.dirty & /*input, min*/
    16392 && t(3, d = he(r) && typeof r.min == "number" ? r.min : typeof d == "number" ? d : 0), i.$$.dirty & /*input, options*/
    24576 && (t(13, c = he(r) && he(r.options) ? r.options : he(c) ? c : {}), typeof (c == null ? void 0 : c.blurOnEnterKey) == "boolean" && (y.blurOnEnterKey = c.blurOnEnterKey), typeof (c == null ? void 0 : c.cancelOnEscKey) == "boolean" && (y.cancelOnEscKey = c.cancelOnEscKey)), i.$$.dirty & /*input, readonly*/
    16400 && t(4, p = he(r) && typeof r.readonly == "boolean" ? r.readonly : typeof p == "boolean" ? p : !1), i.$$.dirty & /*input, step*/
    16416 && t(5, m = he(r) && typeof r.step == "number" ? r.step : typeof m == "number" ? m : 1), i.$$.dirty & /*input, store*/
    16448 && l(t(6, g = he(r) && Cn(r.store) ? r.store : Cn(g) ? g : Mt(void 0))), i.$$.dirty & /*input, styles*/
    16512 && t(7, h = he(r) && he(r.styles) ? r.styles : he(h) ? h : void 0), i.$$.dirty & /*input, efx*/
    16640 && t(8, _ = he(r) && typeof r.efx == "function" ? r.efx : typeof _ == "function" ? _ : () => {
    });
  }, [
    o,
    a,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    v,
    s,
    S,
    D,
    c,
    r,
    I,
    M,
    L
  ];
}
u(NQ, "instance$3b");
const XA = class XA extends re {
  constructor(e) {
    super(), oe(this, e, NQ, RQ, le, {
      input: 14,
      disabled: 0,
      label: 1,
      options: 13,
      max: 2,
      min: 3,
      readonly: 4,
      step: 5,
      store: 6,
      styles: 7,
      efx: 8
    });
  }
};
u(XA, "TJSInputRange");
let Sy = XA;
function jQ(i) {
  let e, t, s, n, l, r = [
    { class: "tjs-input" },
    { type: (
      /*type*/
      i[7]
    ) },
    { placeholder: (
      /*placeholder*/
      i[2]
    ) },
    { disabled: (
      /*disabled*/
      i[0]
    ) },
    { readOnly: (
      /*readonly*/
      i[3]
    ) }
  ], o = {};
  for (let a = 0; a < r.length; a += 1)
    o = Dt(o, r[a]);
  return {
    c() {
      e = E("div"), t = E("input"), Bd(t, o), Z(t, "is-value-invalid", !/*$storeIsValid*/
      i[10]), Z(t, "svelte-k7qury", !0), b(e, "class", "tjs-input-container svelte-k7qury");
    },
    m(a, c) {
      T(a, e, c), A(e, t), t.autofocus && t.focus(), i[17](t), He(
        t,
        /*$store*/
        i[11]
      ), n || (l = [
        W(
          t,
          "input",
          /*input_1_input_handler*/
          i[18]
        ),
        W(
          t,
          "focusin",
          /*onFocusIn*/
          i[12]
        ),
        W(
          t,
          "keydown",
          /*onKeyDown*/
          i[13]
        ),
        Et(
          /*efx*/
          i[8].call(null, e)
        ),
        Et(s = Xs.call(
          null,
          e,
          /*styles*/
          i[6]
        )),
        W(
          e,
          "pointerdown",
          /*pointerdown_handler*/
          i[16]
        )
      ], n = !0);
    },
    p(a, c) {
      Bd(t, o = Vt(r, [
        { class: "tjs-input" },
        c & /*type*/
        128 && { type: (
          /*type*/
          a[7]
        ) },
        c & /*placeholder*/
        4 && { placeholder: (
          /*placeholder*/
          a[2]
        ) },
        c & /*disabled*/
        1 && { disabled: (
          /*disabled*/
          a[0]
        ) },
        c & /*readonly*/
        8 && { readOnly: (
          /*readonly*/
          a[3]
        ) }
      ])), c & /*$store*/
      2048 && t.value !== /*$store*/
      a[11] && He(
        t,
        /*$store*/
        a[11]
      ), Z(t, "is-value-invalid", !/*$storeIsValid*/
      a[10]), Z(t, "svelte-k7qury", !0), s && $t(s.update) && c & /*styles*/
      64 && s.update.call(
        null,
        /*styles*/
        a[6]
      );
    },
    d(a) {
      a && C(e), i[17](null), n = !1, Me(l);
    }
  };
}
u(jQ, "create_default_slot$1C");
function LQ(i) {
  let e, t;
  return e = new bo({
    props: {
      label: (
        /*label*/
        i[1]
      ),
      disabled: (
        /*disabled*/
        i[0]
      ),
      $$slots: { default: [jQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*label*/
      2 && (l.label = /*label*/
      s[1]), n & /*disabled*/
      1 && (l.disabled = /*disabled*/
      s[0]), n & /*$$scope, styles, type, placeholder, disabled, readonly, inputEl, $store, $storeIsValid*/
      2100941 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(LQ, "create_fragment$3j");
function BQ(i, e, t) {
  let s, n = se, l = /* @__PURE__ */ u(() => (n(), n = Xt(_, (U) => t(10, s = U)), _), "$$subscribe_storeIsValid"), r, o = se, a = /* @__PURE__ */ u(() => (o(), o = Xt(h, (U) => t(11, r = U)), h), "$$subscribe_store");
  i.$$.on_destroy.push(() => n()), i.$$.on_destroy.push(() => o());
  let { input: c = void 0 } = e, { disabled: f = void 0 } = e, { label: d = void 0 } = e, { options: p = void 0 } = e, { placeholder: m = void 0 } = e, { readonly: g = void 0 } = e, { store: h = void 0 } = e;
  a();
  let { storeIsValid: _ = void 0 } = e;
  l();
  let { styles: y = void 0 } = e, { type: v = void 0 } = e, { efx: k = void 0 } = e;
  const S = {
    blurOnEnterKey: !0,
    cancelOnEscKey: !1,
    clearOnEscKey: !1
  };
  let D, I;
  function M(U) {
    I = S.cancelOnEscKey ? D.value : void 0;
  }
  u(M, "onFocusIn");
  function L(U) {
    if (S.blurOnEnterKey && U.code === "Enter") {
      U.preventDefault(), U.stopPropagation(), D.blur();
      return;
    }
    U.code === "Escape" && (S.cancelOnEscKey && typeof I == "string" ? (U.preventDefault(), U.stopPropagation(), h.set(I), I = void 0, D.blur()) : S.clearOnEscKey && (U.preventDefault(), U.stopPropagation(), h.set(""), D.blur()));
  }
  u(L, "onKeyDown");
  function B(U) {
    bt.call(this, i, U);
  }
  u(B, "pointerdown_handler");
  function z(U) {
    rt[U ? "unshift" : "push"](() => {
      D = U, t(9, D);
    });
  }
  u(z, "input_1_binding");
  function q() {
    r = this.value, h.set(r);
  }
  return u(q, "input_1_input_handler"), i.$$set = (U) => {
    "input" in U && t(15, c = U.input), "disabled" in U && t(0, f = U.disabled), "label" in U && t(1, d = U.label), "options" in U && t(14, p = U.options), "placeholder" in U && t(2, m = U.placeholder), "readonly" in U && t(3, g = U.readonly), "store" in U && a(t(4, h = U.store)), "storeIsValid" in U && l(t(5, _ = U.storeIsValid)), "styles" in U && t(6, y = U.styles), "type" in U && t(7, v = U.type), "efx" in U && t(8, k = U.efx);
  }, i.$$.update = () => {
    if (i.$$.dirty & /*input, type*/
    32896)
      switch (t(7, v = he(c) && typeof c.type == "string" ? c.type : typeof v == "string" ? v : "text"), v) {
        case "email":
        case "password":
        case "search":
        case "text":
        case "url":
          break;
        default:
          throw new Error("'TJSInputText only supports text input types: 'email', 'password', 'search', 'text', 'url'.");
      }
    i.$$.dirty & /*input, disabled*/
    32769 && t(0, f = he(c) && typeof c.disabled == "boolean" ? c.disabled : typeof f == "boolean" ? f : !1), i.$$.dirty & /*input, label*/
    32770 && t(1, d = he(c) && Vn.isValid(c.label) ? c.label : Vn.isValid(d) ? d : void 0), i.$$.dirty & /*input, options*/
    49152 && (t(14, p = he(c) && he(c.options) ? c.options : he(p) ? p : {}), typeof (p == null ? void 0 : p.blurOnEnterKey) == "boolean" && (S.blurOnEnterKey = p.blurOnEnterKey), typeof (p == null ? void 0 : p.cancelOnEscKey) == "boolean" && (S.cancelOnEscKey = p.cancelOnEscKey), typeof (p == null ? void 0 : p.clearOnEscKey) == "boolean" && (S.clearOnEscKey = p.clearOnEscKey)), i.$$.dirty & /*input, placeholder*/
    32772 && t(2, m = he(c) && typeof c.placeholder == "string" ? K(c.placeholder) : typeof m == "string" ? K(m) : void 0), i.$$.dirty & /*input, readonly*/
    32776 && t(3, g = he(c) && typeof c.readonly == "boolean" ? c.readonly : typeof g == "boolean" ? g : !1), i.$$.dirty & /*input, store*/
    32784 && a(t(4, h = he(c) && Cn(c.store) ? c.store : Cn(h) ? h : Mt(void 0))), i.$$.dirty & /*input, storeIsValid*/
    32800 && l(t(5, _ = he(c) && Ud(c.storeIsValid) ? c.storeIsValid : Ud(_) ? _ : Mt(!0))), i.$$.dirty & /*input, styles*/
    32832 && t(6, y = he(c) && he(c.styles) ? c.styles : he(y) ? y : void 0), i.$$.dirty & /*input, efx*/
    33024 && t(8, k = he(c) && typeof c.efx == "function" ? c.efx : typeof k == "function" ? k : () => {
    });
  }, [
    f,
    d,
    m,
    g,
    h,
    _,
    y,
    v,
    k,
    D,
    s,
    r,
    M,
    L,
    p,
    c,
    B,
    z,
    q
  ];
}
u(BQ, "instance$3a");
const JA = class JA extends re {
  constructor(e) {
    super(), oe(this, e, BQ, LQ, le, {
      input: 15,
      disabled: 0,
      label: 1,
      options: 14,
      placeholder: 2,
      readonly: 3,
      store: 4,
      storeIsValid: 5,
      styles: 6,
      type: 7,
      efx: 8
    });
  }
};
u(JA, "TJSInputText");
let Cy = JA;
function eI(i, e, t) {
  const s = i.slice();
  return s[14] = e[t], s;
}
u(eI, "get_each_context$1l");
function tI(i) {
  let e, t = (
    /*option*/
    i[14].label + ""
  ), s, n, l;
  return {
    c() {
      e = E("option"), s = Q(t), n = F(), b(e, "class", "tjs-select-option svelte-1uux9av"), e.__value = l = /*option*/
      i[14].value, He(e, e.__value);
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*options*/
      4 && t !== (t = /*option*/
      r[14].label + "") && be(s, t), o & /*options*/
      4 && l !== (l = /*option*/
      r[14].value) && (e.__value = l, He(e, e.__value));
    },
    d(r) {
      r && C(e);
    }
  };
}
u(tI, "create_each_block$1l");
function qQ(i) {
  let e, t, s, n, l, r = ue(
    /*options*/
    i[2]
  ), o = [];
  for (let a = 0; a < r.length; a += 1)
    o[a] = tI(eI(i, r, a));
  return {
    c() {
      e = E("div"), t = E("select");
      for (let a = 0; a < o.length; a += 1)
        o[a].c();
      b(t, "class", "tjs-select svelte-1uux9av"), t.disabled = /*disabled*/
      i[0], /*$store*/
      i[6] === void 0 && ks(() => (
        /*select_1_change_handler*/
        i[13].call(t)
      )), Z(
        t,
        "has-efx",
        /*efx*/
        i[5] !== /*s_DEFAULT_EFX*/
        i[7]
      ), b(e, "class", "tjs-select-container svelte-1uux9av");
    },
    m(a, c) {
      T(a, e, c), A(e, t);
      for (let f = 0; f < o.length; f += 1)
        o[f] && o[f].m(t, null);
      Ys(
        t,
        /*$store*/
        i[6],
        !0
      ), n || (l = [
        W(
          t,
          "change",
          /*change_handler_1*/
          i[12]
        ),
        W(
          t,
          "change",
          /*select_1_change_handler*/
          i[13]
        ),
        W(
          e,
          "change",
          /*change_handler*/
          i[10]
        ),
        Et(
          /*efx*/
          i[5].call(null, e)
        ),
        Et(s = Xs.call(
          null,
          e,
          /*styles*/
          i[4]
        )),
        W(
          e,
          "pointerdown",
          /*pointerdown_handler*/
          i[11]
        )
      ], n = !0);
    },
    p(a, c) {
      if (c & /*options*/
      4) {
        r = ue(
          /*options*/
          a[2]
        );
        let f;
        for (f = 0; f < r.length; f += 1) {
          const d = eI(a, r, f);
          o[f] ? o[f].p(d, c) : (o[f] = tI(d), o[f].c(), o[f].m(t, null));
        }
        for (; f < o.length; f += 1)
          o[f].d(1);
        o.length = r.length;
      }
      c & /*disabled*/
      1 && (t.disabled = /*disabled*/
      a[0]), c & /*$store, options*/
      68 && Ys(
        t,
        /*$store*/
        a[6]
      ), c & /*efx, s_DEFAULT_EFX*/
      160 && Z(
        t,
        "has-efx",
        /*efx*/
        a[5] !== /*s_DEFAULT_EFX*/
        a[7]
      ), s && $t(s.update) && c & /*styles*/
      16 && s.update.call(
        null,
        /*styles*/
        a[4]
      );
    },
    d(a) {
      a && C(e), Le(o, a), n = !1, Me(l);
    }
  };
}
u(qQ, "create_default_slot$1B");
function GQ(i) {
  let e, t;
  return e = new bo({
    props: {
      label: (
        /*label*/
        i[1]
      ),
      disabled: (
        /*disabled*/
        i[0]
      ),
      $$slots: { default: [qQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*label*/
      2 && (l.label = /*label*/
      s[1]), n & /*disabled*/
      1 && (l.disabled = /*disabled*/
      s[0]), n & /*$$scope, styles, disabled, $store, efx, options*/
      131189 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(GQ, "create_fragment$3i");
function zQ(i, e, t) {
  let s, n = se, l = /* @__PURE__ */ u(() => (n(), n = Xt(d, (k) => t(6, s = k)), d), "$$subscribe_store");
  i.$$.on_destroy.push(() => n());
  let { select: r = void 0 } = e, { disabled: o = void 0 } = e, { label: a = void 0 } = e, { selected: c = void 0 } = e, { options: f = void 0 } = e, { store: d = void 0 } = e;
  l();
  let { styles: p = void 0 } = e, { efx: m = void 0 } = e;
  const g = /* @__PURE__ */ u(() => {
  }, "s_DEFAULT_EFX");
  $o(() => {
    c && d && !f.includes(s) && f.includes(c) && d.set(c);
  });
  function h(k) {
    bt.call(this, i, k);
  }
  u(h, "change_handler");
  function _(k) {
    bt.call(this, i, k);
  }
  u(_, "pointerdown_handler");
  function y(k) {
    bt.call(this, i, k);
  }
  u(y, "change_handler_1");
  function v() {
    s = fo(this), d.set(s), t(2, f), t(9, r);
  }
  return u(v, "select_1_change_handler"), i.$$set = (k) => {
    "select" in k && t(9, r = k.select), "disabled" in k && t(0, o = k.disabled), "label" in k && t(1, a = k.label), "selected" in k && t(8, c = k.selected), "options" in k && t(2, f = k.options), "store" in k && l(t(3, d = k.store)), "styles" in k && t(4, p = k.styles), "efx" in k && t(5, m = k.efx);
  }, i.$$.update = () => {
    i.$$.dirty & /*select, disabled*/
    513 && t(0, o = he(r) && typeof r.disabled == "boolean" ? r.disabled : typeof o == "boolean" ? o : !1), i.$$.dirty & /*select, label*/
    514 && t(1, a = he(r) && Vn.isValid(r.label) ? r.label : Vn.isValid(a) ? a : void 0), i.$$.dirty & /*select, selected*/
    768 && t(8, c = he(r) && typeof r.selected == "string" ? r.selected : typeof c == "string" ? c : void 0), i.$$.dirty & /*select, options*/
    516 && t(2, f = he(r) && Array.isArray(r.options) ? r.options : Array.isArray(f) ? f : []), i.$$.dirty & /*select, store*/
    520 && l(t(3, d = he(r) && Cn(r.store) ? r.store : Cn(d) ? d : Mt(void 0))), i.$$.dirty & /*select, styles*/
    528 && t(4, p = he(r) && he(r.styles) ? r.styles : he(p) ? p : void 0), i.$$.dirty & /*select, efx*/
    544 && t(5, m = he(r) && typeof r.efx == "function" ? r.efx : typeof m == "function" ? m : g);
  }, [
    o,
    a,
    f,
    d,
    p,
    m,
    s,
    g,
    c,
    r,
    h,
    _,
    y,
    v
  ];
}
u(zQ, "instance$39");
const ZA = class ZA extends re {
  constructor(e) {
    super(), oe(this, e, zQ, GQ, le, {
      select: 9,
      disabled: 0,
      label: 1,
      selected: 8,
      options: 2,
      store: 3,
      styles: 4,
      efx: 5
    });
  }
};
u(ZA, "TJSSelect");
let Ty = ZA;
function HQ(i) {
  let e, t, s;
  const n = [
    /*passedProps*/
    i[1]
  ];
  var l = (
    /*component*/
    i[2]
  );
  function r(o, a) {
    let c = {};
    for (let f = 0; f < n.length; f += 1)
      c = Dt(c, n[f]);
    return a !== void 0 && a & /*passedProps*/
    2 && (c = Dt(c, Vt(n, [Jt(
      /*passedProps*/
      o[1]
    )]))), { props: c };
  }
  return u(r, "switch_props"), l && (e = et(l, r(i))), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(o, a) {
      e && R(e, o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a & /*component*/
      4 && l !== (l = /*component*/
      o[2])) {
        if (e) {
          ae();
          const c = e;
          O(c.$$.fragment, 1, 0, () => {
            N(c, 1);
          }), ce();
        }
        l ? (e = et(l, r(o, a)), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const c = a & /*passedProps*/
        2 ? Vt(n, [Jt(
          /*passedProps*/
          o[1]
        )]) : {};
        e.$set(c);
      }
    },
    i(o) {
      s || (e && w(e.$$.fragment, o), s = !0);
    },
    o(o) {
      e && O(e.$$.fragment, o), s = !1;
    },
    d(o) {
      o && C(t), e && N(e, o);
    }
  };
}
u(HQ, "create_else_block$B");
function UQ(i) {
  let e, t, s;
  const n = [
    /*passedProps*/
    i[1]
  ];
  var l = (
    /*component*/
    i[2]
  );
  function r(o, a) {
    let c = {};
    for (let f = 0; f < n.length; f += 1)
      c = Dt(c, n[f]);
    return a !== void 0 && a & /*passedProps*/
    2 && (c = Dt(c, Vt(n, [Jt(
      /*passedProps*/
      o[1]
    )]))), { props: c };
  }
  return u(r, "switch_props"), l && (e = et(l, r(i))), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(o, a) {
      e && R(e, o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a & /*component*/
      4 && l !== (l = /*component*/
      o[2])) {
        if (e) {
          ae();
          const c = e;
          O(c.$$.fragment, 1, 0, () => {
            N(c, 1);
          }), ce();
        }
        l ? (e = et(l, r(o, a)), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const c = a & /*passedProps*/
        2 ? Vt(n, [Jt(
          /*passedProps*/
          o[1]
        )]) : {};
        e.$set(c);
      }
    },
    i(o) {
      s || (e && w(e.$$.fragment, o), s = !0);
    },
    o(o) {
      e && O(e.$$.fragment, o), s = !1;
    },
    d(o) {
      o && C(t), e && N(e, o);
    }
  };
}
u(UQ, "create_if_block_1$1d");
function VQ(i) {
  let e, t, s;
  const n = [
    /*passedProps*/
    i[1]
  ];
  var l = (
    /*component*/
    i[2]
  );
  function r(o, a) {
    let c = {};
    for (let f = 0; f < n.length; f += 1)
      c = Dt(c, n[f]);
    return a !== void 0 && a & /*passedProps*/
    2 && (c = Dt(c, Vt(n, [Jt(
      /*passedProps*/
      o[1]
    )]))), { props: c };
  }
  return u(r, "switch_props"), l && (e = et(l, r(i)), e.$on(
    "click",
    /*click_handler*/
    i[4]
  ), e.$on(
    "press",
    /*press_handler*/
    i[5]
  ), e.$on(
    "contextmenu",
    /*contextmenu_handler*/
    i[6]
  )), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(o, a) {
      e && R(e, o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a & /*component*/
      4 && l !== (l = /*component*/
      o[2])) {
        if (e) {
          ae();
          const c = e;
          O(c.$$.fragment, 1, 0, () => {
            N(c, 1);
          }), ce();
        }
        l ? (e = et(l, r(o, a)), e.$on(
          "click",
          /*click_handler*/
          o[4]
        ), e.$on(
          "press",
          /*press_handler*/
          o[5]
        ), e.$on(
          "contextmenu",
          /*contextmenu_handler*/
          o[6]
        ), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const c = a & /*passedProps*/
        2 ? Vt(n, [Jt(
          /*passedProps*/
          o[1]
        )]) : {};
        e.$set(c);
      }
    },
    i(o) {
      s || (e && w(e.$$.fragment, o), s = !0);
    },
    o(o) {
      e && O(e.$$.fragment, o), s = !1;
    },
    d(o) {
      o && C(t), e && N(e, o);
    }
  };
}
u(VQ, "create_if_block$1P");
function WQ(i) {
  let e, t, s, n;
  const l = [VQ, UQ, HQ], r = [];
  function o(a, c) {
    return (
      /*type*/
      a[0] === "button" ? 0 : (
        /*type*/
        a[0] === "select" ? 1 : 2
      )
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, [c]) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(WQ, "create_fragment$3h");
function KQ(i, e, t) {
  let { input: s = void 0 } = e, { type: n = void 0 } = e, l, r = Object.assign({}, e);
  delete r.type;
  function o(f) {
    bt.call(this, i, f);
  }
  u(o, "click_handler");
  function a(f) {
    bt.call(this, i, f);
  }
  u(a, "press_handler");
  function c(f) {
    bt.call(this, i, f);
  }
  return u(c, "contextmenu_handler"), i.$$set = (f) => {
    t(7, e = Dt(Dt({}, e), K3(f))), "input" in f && t(3, s = f.input), "type" in f && t(0, n = f.type);
  }, i.$$.update = () => {
    if (i.$$.dirty & /*input, type, passedProps*/
    11)
      switch (t(0, n = he(s) && typeof s.type == "string" ? s.type : typeof n == "string" ? n : "text"), n) {
        case "button":
          t(1, r.button = s, r), delete r.input, t(2, l = $y);
          break;
        case "checkbox":
          t(2, l = Ay);
          break;
        case "number":
          t(2, l = Ey);
          break;
        case "range":
          t(2, l = Sy);
          break;
        case "email":
        case "password":
        case "search":
        case "text":
        case "url":
          t(2, l = Cy);
          break;
        case "select":
          t(1, r.select = s, r), delete r.input, t(2, l = Ty);
          break;
        default:
          throw new Error("'TJSInput' currently only supports the following input types: 'button', 'checkbox', 'email', 'number', 'password', 'range, 'search', 'select', 'text', and 'url'.");
      }
  }, e = K3(e), [
    n,
    r,
    l,
    s,
    o,
    a,
    c
  ];
}
u(KQ, "instance$38");
const QA = class QA extends re {
  constructor(e) {
    super(), oe(this, e, KQ, WQ, le, { input: 3, type: 0 });
  }
};
u(QA, "TJSInput");
let Cp = QA;
function rB(i) {
  const e = e1.filters.regexObjectQuery(["name", "containerItemNames"]), t = {
    store: e,
    placeholder: "Search",
    type: "search"
  };
  return i.filters.add({ id: "searchFilter", filter: e }), t;
}
u(rB, "addSearchFilter");
function oB(i) {
  i.filters.removeById("searchFilter");
}
u(oB, "removeSearchFilter");
function YQ(i) {
  let e, t, s, n;
  return t = new Cp({ props: { input: (
    /*input*/
    i[0]
  ) } }), {
    c() {
      e = E("div"), s = E("div"), j(t.$$.fragment), G(s, "display", "contents"), G(s, "--tjs-input-placeholder-color", "#555"), G(s, "--tjs-input-text-margin", "0"), G(s, "--tjs-input-text-width", "100%"), b(e, "class", "search-container svelte-1nl30e7");
    },
    m(l, r) {
      T(l, e, r), A(e, s), R(t, s, null), n = !0;
    },
    p: se,
    i(l) {
      n || (w(t.$$.fragment, l), n = !0);
    },
    o(l) {
      O(t.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(e), N(t);
    }
  };
}
u(YQ, "create_fragment$3g");
function XQ(i, e, t) {
  let { reducerType: s } = e, { reducer: n = null } = e;
  const l = de("actor") ?? de("item");
  n || (n = l[s]);
  const r = rB(n);
  return Qt(() => oB(n)), i.$$set = (o) => {
    "reducerType" in o && t(2, s = o.reducerType), "reducer" in o && t(1, n = o.reducer);
  }, [r, n, s];
}
u(XQ, "instance$37");
const xA = class xA extends re {
  constructor(e) {
    super(), oe(this, e, XQ, YQ, le, { reducerType: 2, reducer: 1 });
  }
};
u(xA, "Search");
let Nl = xA;
async function sI(i, e, t) {
  const s = [...e];
  s.sort((l, r) => l.name.toLowerCase().localeCompare(r.name.toLowerCase()));
  const n = s.map(
    (l, r) => t === "ActiveEffect" ? { _id: l.id, flags: { a5e: { sort: r } } } : { _id: l.id, sort: r }
  );
  await i.updateEmbeddedDocuments(t, n);
}
u(sI, "sortAscending");
async function JQ(i, e, t) {
  const s = [...e];
  s.sort((l, r) => l.name.toLowerCase().localeCompare(r.name.toLowerCase())).reverse();
  const n = s.map(
    (l, r) => t === "ActiveEffect" ? { _id: l.id, flags: { a5e: { sort: r } } } : { _id: l.id, sort: r }
  );
  await i.updateEmbeddedDocuments(t, n);
}
u(JQ, "sortDescending");
function ZQ(i) {
  let e, t, s;
  return e = new mc({
    props: {
      title: "Sort",
      icon: `fas ${/*sortIcons*/
      i[3][
        /*sortMode*/
        i[1]
      ]}`,
      onPress: (
        /*onSortReducer*/
        i[4]
      )
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--tjs-icon-button-background-hover", "none"), G(t, "--tjs-icon-button-background-focus", "none"), G(t, "--tjs-icon-button-background-focus-visible", "none"), G(t, "--tjs-icon-button-background-selected", "none"), G(t, "--tjs-icon-button-text-shadow-hover", "none"), G(t, "--tjs-icon-button-text-shadow-focus", "none"), G(t, "--tjs-icon-button-transition", "var(--a5e-transition-standard)"), G(t, "--tjs-icon-button-diameter", "1.1rem"), G(t, "--tjs-icon-button-border-radius", "0");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*sortMode*/
      2 && (r.icon = `fas ${/*sortIcons*/
      n[3][
        /*sortMode*/
        n[1]
      ]}`), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(ZQ, "create_fragment$3f");
function QQ(i, e, t) {
  let s, n, l, r = se, o = /* @__PURE__ */ u(() => (r(), r = Xt(f, (y) => t(9, l = y)), f), "$$subscribe_reducer");
  i.$$.on_destroy.push(() => r());
  let { reducerType: a } = e, { reducerId: c = null } = e, { reducer: f = null } = e;
  o();
  let { documentName: d = "Item" } = e;
  const p = de("actor") ?? de("item");
  pe(i, p, (y) => t(8, n = y)), f || o(f = p[a]);
  const m = {
    0: "fa-sort",
    1: "fa-arrow-down-a-z",
    2: "fa-arrow-down-z-a"
  }, g = {
    0: sI,
    1: JQ,
    2: sI
  };
  async function h() {
    await g[s](n, l, d);
    let y = (s + 1) % 3;
    y = y === 0 ? 1 : y, await n.setFlag("a5e", _, y);
  }
  u(h, "onSortReducer");
  let _ = c ? `sortMode.${a}.${c}` : `sortMode.${a}`;
  return i.$$set = (y) => {
    "reducerType" in y && t(5, a = y.reducerType), "reducerId" in y && t(6, c = y.reducerId), "reducer" in y && o(t(0, f = y.reducer)), "documentName" in y && t(7, d = y.documentName);
  }, i.$$.update = () => {
    i.$$.dirty & /*$document*/
    256 && t(1, s = n.getFlag("a5e", _) || 0);
  }, [
    f,
    s,
    p,
    m,
    h,
    a,
    c,
    d,
    n
  ];
}
u(QQ, "instance$36");
const eE = class eE extends re {
  constructor(e) {
    super(), oe(this, e, QQ, ZQ, le, {
      reducerType: 5,
      reducerId: 6,
      reducer: 0,
      documentName: 7
    });
  }
};
u(eE, "Sort");
let jl = eE;
function xQ(i) {
  let e, t;
  const s = (
    /*#slots*/
    i[1].default
  ), n = Gt(
    s,
    i,
    /*$$scope*/
    i[0],
    null
  );
  return {
    c() {
      e = E("section"), n && n.c(), b(e, "class", "utility-bar svelte-18w60b6");
    },
    m(l, r) {
      T(l, e, r), n && n.m(e, null), t = !0;
    },
    p(l, [r]) {
      n && n.p && (!t || r & /*$$scope*/
      1) && Ht(
        n,
        s,
        l,
        /*$$scope*/
        l[0],
        t ? zt(
          s,
          /*$$scope*/
          l[0],
          r,
          null
        ) : Ut(
          /*$$scope*/
          l[0]
        ),
        null
      );
    },
    i(l) {
      t || (w(n, l), t = !0);
    },
    o(l) {
      O(n, l), t = !1;
    },
    d(l) {
      l && C(e), n && n.d(l);
    }
  };
}
u(xQ, "create_fragment$3e");
function ex(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e;
  return i.$$set = (l) => {
    "$$scope" in l && t(0, n = l.$$scope);
  }, [n, s];
}
u(ex, "instance$35");
const tE = class tE extends re {
  constructor(e) {
    super(), oe(this, e, ex, xQ, le, {});
  }
};
u(tE, "UtilityBar");
let Ll = tE;
function nI(i, e, t) {
  const s = i.slice();
  return s[6] = e[t][0], s[7] = e[t][1], s;
}
u(nI, "get_each_context$1k");
function iI(i) {
  let e, t;
  return e = new Ll({
    props: {
      $$slots: { default: [tx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope*/
      1024 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(iI, "create_if_block_1$1c");
function tx(i) {
  let e, t, s, n, l, r;
  return e = new Nl({ props: { reducerType: Rg } }), s = new jl({
    props: {
      reducerType: Rg,
      documentName: "ActiveEffect"
    }
  }), l = new Tn({
    props: {
      reducerType: Rg,
      documentName: "ActiveEffect",
      options: {
        actionId: (
          /*actionId*/
          i[3]
        ),
        effectType: "onUse"
      }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), R(s, o, a), T(o, n, a), R(l, o, a), r = !0;
    },
    p: se,
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(s.$$.fragment, o), O(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (C(t), C(n)), N(e, o), N(s, o), N(l, o);
    }
  };
}
u(tx, "create_default_slot$1A");
function lI(i) {
  let e, t;
  return e = new Eu({
    props: {
      label: (
        /*subTypes*/
        i[5][
          /*label*/
          i[6]
        ]
      ),
      effects: (
        /*effects*/
        i[7]
      )
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$activeEffects*/
      2 && (l.label = /*subTypes*/
      s[5][
        /*label*/
        s[6]
      ]), n & /*$activeEffects*/
      2 && (l.effects = /*effects*/
      s[7]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(lI, "create_if_block$1O");
function rI(i) {
  let e, t, s = (
    /*effects*/
    i[7].length && /*label*/
    i[6] === "onUse" && lI(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*effects*/
      n[7].length && /*label*/
      n[6] === "onUse" ? s ? (s.p(n, l), l & /*$activeEffects*/
      2 && w(s, 1)) : (s = lI(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(rI, "create_each_block$1k");
function sx(i) {
  let e, t, s, n = (
    /*$item*/
    i[0].isOwner && iI(i)
  ), l = ue(Object.entries(
    /*$activeEffects*/
    i[1]._types
  )), r = [];
  for (let a = 0; a < l.length; a += 1)
    r[a] = rI(nI(i, l, a));
  const o = /* @__PURE__ */ u((a) => O(r[a], 1, 1, () => {
    r[a] = null;
  }), "out");
  return {
    c() {
      n && n.c(), e = F(), t = E("section");
      for (let a = 0; a < r.length; a += 1)
        r[a].c();
      b(t, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(a, c) {
      n && n.m(a, c), T(a, e, c), T(a, t, c);
      for (let f = 0; f < r.length; f += 1)
        r[f] && r[f].m(t, null);
      s = !0;
    },
    p(a, [c]) {
      if (/*$item*/
      a[0].isOwner ? n ? (n.p(a, c), c & /*$item*/
      1 && w(n, 1)) : (n = iI(a), n.c(), w(n, 1), n.m(e.parentNode, e)) : n && (ae(), O(n, 1, 1, () => {
        n = null;
      }), ce()), c & /*subTypes, Object, $activeEffects*/
      34) {
        l = ue(Object.entries(
          /*$activeEffects*/
          a[1]._types
        ));
        let f;
        for (f = 0; f < l.length; f += 1) {
          const d = nI(a, l, f);
          r[f] ? (r[f].p(d, c), w(r[f], 1)) : (r[f] = rI(d), r[f].c(), w(r[f], 1), r[f].m(t, null));
        }
        for (ae(), f = l.length; f < r.length; f += 1)
          o(f);
        ce();
      }
    },
    i(a) {
      if (!s) {
        w(n);
        for (let c = 0; c < l.length; c += 1)
          w(r[c]);
        s = !0;
      }
    },
    o(a) {
      O(n), r = r.filter(Boolean);
      for (let c = 0; c < r.length; c += 1)
        O(r[c]);
      s = !1;
    },
    d(a) {
      a && (C(e), C(t)), n && n.d(a), Le(r, a);
    }
  };
}
u(sx, "create_fragment$3d");
const Rg = "activeEffects";
function nx(i, e, t) {
  let s, n;
  const l = de("item");
  pe(i, l, (c) => t(0, s = c));
  const r = de("actionId"), { activeEffects: o } = l;
  pe(i, o, (c) => t(1, n = c));
  const a = CONFIG.A5E.actionActiveEffectTypesPlural;
  return o == null || o.filters.add({
    id: "onUse-filter",
    filter: /* @__PURE__ */ u((c) => s.actions.get(r).effects.has(c.id), "filter")
  }), Qt(() => {
    o == null || o.filters.clear();
  }), [s, n, l, r, o, a];
}
u(nx, "instance$34");
const sE = class sE extends re {
  constructor(e) {
    super(), oe(this, e, nx, sx, le, {});
  }
};
u(sE, "ActionsEffectsTab");
let Oy = sE;
function ix(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*prompt*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*prompt*/
      4 && t !== (t = /*prompt*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(ix, "create_default_slot$1z");
function lx(i) {
  let e, t, s, n, l, r, o;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[11]
          )
        }
      ],
      $$slots: { default: [ix] },
      $$scope: { ctx: i }
    }
  }), n = new Ke({
    props: {
      allowDeselect: !1,
      heading: "A5E.ItemAbilityCheckType",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: fl(),
      selected: (
        /*selectedAbility*/
        i[4]
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), r = new Te({
    props: {
      label: "A5E.PromptDefaultSelection",
      checked: (
        /*prompt*/
        i[2].default ?? !0
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "#bebdb5"), G(t, "--a5e-header-button-color-hover", "#555"), G(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(a, c) {
      T(a, t, c), R(e, t, null), T(a, s, c), R(n, a, c), T(a, l, c), R(r, a, c), o = !0;
    },
    p(a, [c]) {
      const f = {};
      c & /*duplicatePrompt, prompt, deletePrompt, promptId*/
      15 && (f.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            a[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            a[11]
          )
        }
      ]), c & /*$$scope, prompt, $item, promptId*/
      16428 && (f.$$scope = { dirty: c, ctx: a }), e.$set(f);
      const d = {};
      c & /*selectedAbility*/
      16 && (d.selected = /*selectedAbility*/
      a[4]), n.$set(d);
      const p = {};
      c & /*prompt*/
      4 && (p.checked = /*prompt*/
      a[2].default ?? !0), r.$set(p);
    },
    i(a) {
      o || (w(e.$$.fragment, a), w(n.$$.fragment, a), w(r.$$.fragment, a), o = !0);
    },
    o(a) {
      O(e.$$.fragment, a), O(n.$$.fragment, a), O(r.$$.fragment, a), o = !1;
    },
    d(a) {
      a && (C(s), C(l)), a && e && C(t), N(e, a), N(n, a), N(r, a);
    }
  };
}
u(lx, "create_fragment$3c");
function rx(i, e, t) {
  let s, n, { deletePrompt: l } = e, { duplicatePrompt: r } = e, { prompt: o } = e, { promptId: a } = e;
  const c = de("item");
  pe(i, c, (y) => t(5, n = y));
  const f = de("actionId");
  function d(y) {
    t(4, s = y), te(n, `system.actions.${f}.prompts.${a}.ability`, s);
  }
  u(d, "updateAbility");
  const p = /* @__PURE__ */ u(({ target: y }) => te(n, `system.actions.${f}.prompts.${a}.label`, y.value), "change_handler"), m = /* @__PURE__ */ u(() => r(f, o), "func"), g = /* @__PURE__ */ u(() => l(f, a), "func_1"), h = /* @__PURE__ */ u(({ detail: y }) => d(y), "updateSelection_handler"), _ = /* @__PURE__ */ u(({ detail: y }) => {
    te(n, `system.actions.${f}.prompts.${a}.default`, y);
  }, "updateSelection_handler_1");
  return i.$$set = (y) => {
    "deletePrompt" in y && t(0, l = y.deletePrompt), "duplicatePrompt" in y && t(1, r = y.duplicatePrompt), "prompt" in y && t(2, o = y.prompt), "promptId" in y && t(3, a = y.promptId);
  }, i.$$.update = () => {
    i.$$.dirty & /*prompt*/
    4 && t(4, s = o.ability ?? "none");
  }, [
    l,
    r,
    o,
    a,
    s,
    n,
    c,
    f,
    d,
    p,
    m,
    g,
    h,
    _
  ];
}
u(rx, "instance$33");
const nE = class nE extends re {
  constructor(e) {
    super(), oe(this, e, rx, lx, le, {
      deletePrompt: 0,
      duplicatePrompt: 1,
      prompt: 2,
      promptId: 3
    });
  }
};
u(nE, "AbilityCheckPromptConfig");
let Dy = nE;
function ox(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*prompt*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      r & /*prompt*/
      4 && t !== (t = /*prompt*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(ox, "create_default_slot_1$U");
function ax(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("input"), b(e, "id", t = /*actionId*/
      i[6] + "-" + /*promptId*/
      i[3] + "-roll-formula"), b(e, "type", "text"), e.value = s = /*prompt*/
      i[2].formula ?? "";
    },
    m(r, o) {
      T(r, e, o), n || (l = W(
        e,
        "change",
        /*change_handler_1*/
        i[10]
      ), n = !0);
    },
    p(r, o) {
      o & /*promptId*/
      8 && t !== (t = /*actionId*/
      r[6] + "-" + /*promptId*/
      r[3] + "-roll-formula") && b(e, "id", t), o & /*prompt*/
      4 && s !== (s = /*prompt*/
      r[2].formula ?? "") && e.value !== s && (e.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(ax, "create_default_slot$1y");
function cx(i) {
  let e, t, s, n, l, r, o;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[8]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[9]
          )
        }
      ],
      $$slots: { default: [ox] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.RollFormula",
      $$slots: { default: [ax] },
      $$scope: { ctx: i }
    }
  }), r = new Te({
    props: {
      label: "A5E.PromptDefaultSelection",
      checked: (
        /*prompt*/
        i[2].default ?? !0
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[11]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "#bebdb5"), G(t, "--a5e-header-button-color-hover", "#555"), G(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(a, c) {
      T(a, t, c), R(e, t, null), T(a, s, c), R(n, a, c), T(a, l, c), R(r, a, c), o = !0;
    },
    p(a, [c]) {
      const f = {};
      c & /*duplicatePrompt, prompt, deletePrompt, promptId*/
      15 && (f.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            a[8]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            a[9]
          )
        }
      ]), c & /*$$scope, prompt, $item, promptId*/
      4124 && (f.$$scope = { dirty: c, ctx: a }), e.$set(f);
      const d = {};
      c & /*$$scope, promptId, prompt, $item*/
      4124 && (d.$$scope = { dirty: c, ctx: a }), n.$set(d);
      const p = {};
      c & /*prompt*/
      4 && (p.checked = /*prompt*/
      a[2].default ?? !0), r.$set(p);
    },
    i(a) {
      o || (w(e.$$.fragment, a), w(n.$$.fragment, a), w(r.$$.fragment, a), o = !0);
    },
    o(a) {
      O(e.$$.fragment, a), O(n.$$.fragment, a), O(r.$$.fragment, a), o = !1;
    },
    d(a) {
      a && (C(s), C(l)), a && e && C(t), N(e, a), N(n, a), N(r, a);
    }
  };
}
u(cx, "create_fragment$3b");
function ux(i, e, t) {
  let s;
  const n = de("item");
  pe(i, n, (h) => t(4, s = h));
  const l = de("actionId");
  let { deletePrompt: r } = e, { duplicatePrompt: o } = e, { prompt: a } = e, { promptId: c } = e;
  const f = /* @__PURE__ */ u(({ target: h }) => te(s, `system.actions.${l}.prompts.${c}.label`, h.value), "change_handler"), d = /* @__PURE__ */ u(() => o(l, a), "func"), p = /* @__PURE__ */ u(() => r(l, c), "func_1"), m = /* @__PURE__ */ u(({ target: h }) => te(s, `system.actions.${l}.prompts.${c}.formula`, h.value), "change_handler_1"), g = /* @__PURE__ */ u(({ detail: h }) => {
    te(s, `system.actions.${l}.prompts.${c}.default`, h);
  }, "updateSelection_handler");
  return i.$$set = (h) => {
    "deletePrompt" in h && t(0, r = h.deletePrompt), "duplicatePrompt" in h && t(1, o = h.duplicatePrompt), "prompt" in h && t(2, a = h.prompt), "promptId" in h && t(3, c = h.promptId);
  }, [
    r,
    o,
    a,
    c,
    s,
    n,
    l,
    f,
    d,
    p,
    m,
    g
  ];
}
u(ux, "instance$32");
const iE = class iE extends re {
  constructor(e) {
    super(), oe(this, e, ux, cx, le, {
      deletePrompt: 0,
      duplicatePrompt: 1,
      prompt: 2,
      promptId: 3
    });
  }
};
u(iE, "GenericPromptConfig");
let Iy = iE;
function oI(i, e, t) {
  const s = i.slice();
  return s[25] = e[t][0], s[26] = e[t][1], s;
}
u(oI, "get_each_context$1j");
function fx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*prompt*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[16]
      ), s = !0);
    },
    p(l, r) {
      r & /*prompt*/
      4 && t !== (t = /*prompt*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(fx, "create_default_slot_4$n");
function aI(i) {
  let e, t = K(
    /*label*/
    i[26]
  ) + "", s, n, l;
  return {
    c() {
      var r, o;
      e = E("option"), s = Q(t), n = F(), e.__value = /*type*/
      i[25], He(e, e.__value), e.selected = l = /*type*/
      i[25] === /*prompt*/
      ((o = (r = i[2]) == null ? void 0 : r.saveDC) == null ? void 0 : o.type);
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a, c;
      o & /*prompt*/
      4 && l !== (l = /*type*/
      r[25] === /*prompt*/
      ((c = (a = r[2]) == null ? void 0 : a.saveDC) == null ? void 0 : c.type)) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(aI, "create_each_block$1j");
function dx(i) {
  let e, t, s, n = ue(Object.entries(
    /*saveDCOptions*/
    i[14]
  )), l = [];
  for (let r = 0; r < n.length; r += 1)
    l[r] = aI(oI(i, n, r));
  return {
    c() {
      e = E("select");
      for (let r = 0; r < l.length; r += 1)
        l[r].c();
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < l.length; a += 1)
        l[a] && l[a].m(e, null);
      t || (s = W(
        e,
        "change",
        /*selectSaveDCCalculationType*/
        i[10]
      ), t = !0);
    },
    p(r, o) {
      if (o & /*Object, saveDCOptions, prompt*/
      16388) {
        n = ue(Object.entries(
          /*saveDCOptions*/
          r[14]
        ));
        let a;
        for (a = 0; a < n.length; a += 1) {
          const c = oI(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = aI(c), l[a].c(), l[a].m(e, null));
        }
        for (; a < l.length; a += 1)
          l[a].d(1);
        l.length = n.length;
      }
    },
    d(r) {
      r && C(e), Le(l, r), t = !1, s();
    }
  };
}
u(dx, "create_default_slot_3$x");
function cI(i) {
  let e;
  function t(l, r) {
    return (
      /*saveDCIsValid*/
      l[5] ? mx : px
    );
  }
  u(t, "select_block_type");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("span"), n.c(), b(e, "class", "save-dc-preview svelte-u5kzqe"), b(e, "type", "number"), Z(e, "save-dc-preview--invalid", !/*saveDCIsValid*/
      i[5]);
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null))), r & /*saveDCIsValid*/
      32 && Z(e, "save-dc-preview--invalid", !/*saveDCIsValid*/
      l[5]);
    },
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(cI, "create_if_block$1N");
function px(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fa-solid fa-circle-exclamation");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    d(t) {
      t && C(e);
    }
  };
}
u(px, "create_else_block$A");
function mx(i) {
  let e;
  return {
    c() {
      e = Q(
        /*saveDC*/
        i[7]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*saveDC*/
      128 && be(
        e,
        /*saveDC*/
        t[7]
      );
    },
    d(t) {
      t && C(e);
    }
  };
}
u(mx, "create_if_block_1$1b");
function hx(i) {
  let e, t, s, n, l, r = (
    /*saveDC*/
    (i[7] || !/*saveDCIsValid*/
    i[5]) && cI(i)
  );
  return {
    c() {
      e = E("div"), t = E("input"), s = F(), r && r.c(), b(t, "type", "text"), b(t, "autocomplete", "off"), b(e, "class", "u-flex u-gap-sm");
    },
    m(o, a) {
      T(o, e, a), A(e, t), He(
        t,
        /*saveDCBonus*/
        i[4]
      ), A(e, s), r && r.m(e, null), n || (l = [
        W(
          t,
          "input",
          /*input_input_handler*/
          i[20]
        ),
        W(
          t,
          "change",
          /*change_handler_1*/
          i[21]
        )
      ], n = !0);
    },
    p(o, a) {
      a & /*saveDCBonus*/
      16 && t.value !== /*saveDCBonus*/
      o[4] && He(
        t,
        /*saveDCBonus*/
        o[4]
      ), /*saveDC*/
      o[7] || !/*saveDCIsValid*/
      o[5] ? r ? r.p(o, a) : (r = cI(o), r.c(), r.m(e, null)) : r && (r.d(1), r = null);
    },
    d(o) {
      o && C(e), r && r.d(), n = !1, Me(l);
    }
  };
}
u(hx, "create_default_slot_2$H");
function gx(i) {
  var o, a;
  let e, t, s, n, l, r;
  return e = new ie({
    props: {
      heading: "A5E.ItemSavingThrowDC",
      $$slots: { default: [dx] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: (
        /*prompt*/
        ((a = (o = i[2]) == null ? void 0 : o.saveDC) == null ? void 0 : a.type) === "custom" ? "A5E.ItemSavingThrowDCCustom" : "A5E.ItemSavingThrowDCBonus"
      ),
      $$slots: { default: [hx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-label-width", "9rem"), G(l, "display", "contents"), G(l, "--a5e-field-wrapper-grow", "1");
    },
    m(c, f) {
      T(c, t, f), R(e, t, null), T(c, s, f), T(c, l, f), R(n, l, null), r = !0;
    },
    p(c, f) {
      var m, g;
      const d = {};
      f & /*$$scope, prompt*/
      536870916 && (d.$$scope = { dirty: f, ctx: c }), e.$set(d);
      const p = {};
      f & /*prompt*/
      4 && (p.heading = /*prompt*/
      ((g = (m = c[2]) == null ? void 0 : m.saveDC) == null ? void 0 : g.type) === "custom" ? "A5E.ItemSavingThrowDCCustom" : "A5E.ItemSavingThrowDCBonus"), f & /*$$scope, saveDCIsValid, saveDC, saveDCBonus, $item, promptId*/
      536871352 && (p.$$scope = { dirty: f, ctx: c }), n.$set(p);
    },
    i(c) {
      r || (w(e.$$.fragment, c), w(n.$$.fragment, c), r = !0);
    },
    o(c) {
      O(e.$$.fragment, c), O(n.$$.fragment, c), r = !1;
    },
    d(c) {
      c && C(s), c && e && C(t), N(e, c), c && n && C(l), N(n, c);
    }
  };
}
u(gx, "create_default_slot_1$T");
function bx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*prompt*/
      i[2].onSave ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_2*/
        i[22]
      ), s = !0);
    },
    p(l, r) {
      r & /*prompt*/
      4 && t !== (t = /*prompt*/
      l[2].onSave ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(bx, "create_default_slot$1x");
function _x(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[17]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[18]
          )
        }
      ],
      $$slots: { default: [fx] },
      $$scope: { ctx: i }
    }
  }), n = new Ke({
    props: {
      heading: "A5E.ItemSavingThrowType",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: fl(),
      selected: (
        /*selectedAbility*/
        i[6]
      ),
      allowDeselect: !1
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[19]
  ), r = new De({
    props: {
      $$slots: { default: [gx] },
      $$scope: { ctx: i }
    }
  }), c = new ie({
    props: {
      heading: "A5E.ItemEffectOnSave",
      $$slots: { default: [bx] },
      $$scope: { ctx: i }
    }
  }), d = new Te({
    props: {
      label: "A5E.PromptDefaultSelection",
      checked: (
        /*prompt*/
        i[2].default ?? !0
      )
    }
  }), d.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[23]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), o = E("div"), j(r.$$.fragment), a = F(), j(c.$$.fragment), f = F(), j(d.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "#bebdb5"), G(t, "--a5e-header-button-color-hover", "#555"), G(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem"), G(o, "display", "contents"), G(o, "--a5e-section-body-direction", "row"), G(o, "--a5e-section-body-wrap", "nowrap"), G(o, "--a5e-section-body-padding", "0");
    },
    m(m, g) {
      T(m, t, g), R(e, t, null), T(m, s, g), R(n, m, g), T(m, l, g), T(m, o, g), R(r, o, null), T(m, a, g), R(c, m, g), T(m, f, g), R(d, m, g), p = !0;
    },
    p(m, [g]) {
      const h = {};
      g & /*duplicatePrompt, prompt, deletePrompt, promptId*/
      15 && (h.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            m[17]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            m[18]
          )
        }
      ]), g & /*$$scope, prompt, $item, promptId*/
      536871180 && (h.$$scope = { dirty: g, ctx: m }), e.$set(h);
      const _ = {};
      g & /*selectedAbility*/
      64 && (_.selected = /*selectedAbility*/
      m[6]), n.$set(_);
      const y = {};
      g & /*$$scope, prompt, saveDCIsValid, saveDC, saveDCBonus, $item, promptId*/
      536871356 && (y.$$scope = { dirty: g, ctx: m }), r.$set(y);
      const v = {};
      g & /*$$scope, prompt, $item, promptId*/
      536871180 && (v.$$scope = { dirty: g, ctx: m }), c.$set(v);
      const k = {};
      g & /*prompt*/
      4 && (k.checked = /*prompt*/
      m[2].default ?? !0), d.$set(k);
    },
    i(m) {
      p || (w(e.$$.fragment, m), w(n.$$.fragment, m), w(r.$$.fragment, m), w(c.$$.fragment, m), w(d.$$.fragment, m), p = !0);
    },
    o(m) {
      O(e.$$.fragment, m), O(n.$$.fragment, m), O(r.$$.fragment, m), O(c.$$.fragment, m), O(d.$$.fragment, m), p = !1;
    },
    d(m) {
      m && (C(s), C(l), C(a), C(f)), m && e && C(t), N(e, m), N(n, m), m && r && C(o), N(r, m), N(c, m), N(d, m);
    }
  };
}
u(_x, "create_fragment$3a");
function yx(i, e, t) {
  var U;
  let s, n, l, r;
  function o(H) {
    t(6, n = H), te(r, `system.actions.${_}.prompts.${m}.ability`, n);
  }
  u(o, "updateAbility");
  function a(H) {
    var Y, J;
    const V = (J = (Y = H.target) == null ? void 0 : Y.selectedOptions[0]) == null ? void 0 : J.value;
    r.update({
      [`system.actions.${_}.prompts.${m}.saveDC.type`]: V
    });
  }
  u(a, "selectSaveDCCalculationType");
  function c(H) {
    var V;
    try {
      const Y = R5(H, r, {
        type: (V = p == null ? void 0 : p.saveDC) == null ? void 0 : V.type,
        bonus: k
      });
      return t(5, v = !0), Y;
    } catch {
      t(5, v = !1);
    }
  }
  u(c, "onSaveDCUpdate");
  let { deletePrompt: f } = e, { duplicatePrompt: d } = e, { prompt: p } = e, { promptId: m } = e;
  const g = de("item");
  pe(i, g, (H) => t(8, r = H));
  const h = r.actor && new Zt(r.actor);
  pe(i, h, (H) => t(15, l = H));
  const _ = de("actionId"), { saveDCOptions: y } = CONFIG.A5E;
  let v = !0, k = (U = p == null ? void 0 : p.saveDC) == null ? void 0 : U.bonus;
  const S = /* @__PURE__ */ u(({ target: H }) => te(r, `system.actions.${_}.prompts.${m}.label`, H.value), "change_handler"), D = /* @__PURE__ */ u(() => d(_, p), "func"), I = /* @__PURE__ */ u(() => f(_, m), "func_1"), M = /* @__PURE__ */ u(({ detail: H }) => o(H), "updateSelection_handler");
  function L() {
    k = this.value, t(4, k);
  }
  u(L, "input_input_handler");
  const B = /* @__PURE__ */ u(({ target: H }) => te(r, `system.actions.${_}.prompts.${m}.saveDC.bonus`, H.value), "change_handler_1"), z = /* @__PURE__ */ u(({ target: H }) => te(r, `system.actions.${_}.prompts.${m}.onSave`, H.value), "change_handler_2"), q = /* @__PURE__ */ u(({ detail: H }) => {
    te(r, `system.actions.${_}.prompts.${m}.default`, H);
  }, "updateSelection_handler_1");
  return i.$$set = (H) => {
    "deletePrompt" in H && t(0, f = H.deletePrompt), "duplicatePrompt" in H && t(1, d = H.duplicatePrompt), "prompt" in H && t(2, p = H.prompt), "promptId" in H && t(3, m = H.promptId);
  }, i.$$.update = () => {
    var H;
    i.$$.dirty & /*$actor, prompt, saveDCBonus*/
    32788 && t(7, s = c(l, (H = p == null ? void 0 : p.saveDC) == null ? void 0 : H.type)), i.$$.dirty & /*prompt*/
    4 && t(6, n = p.ability ?? "none");
  }, [
    f,
    d,
    p,
    m,
    k,
    v,
    n,
    s,
    r,
    o,
    a,
    g,
    h,
    _,
    y,
    l,
    S,
    D,
    I,
    M,
    L,
    B,
    z,
    q
  ];
}
u(yx, "instance$31");
const lE = class lE extends re {
  constructor(e) {
    super(), oe(this, e, yx, _x, le, {
      deletePrompt: 0,
      duplicatePrompt: 1,
      prompt: 2,
      promptId: 3
    });
  }
};
u(lE, "SavePromptConfig");
let Py = lE;
function uI(i, e, t) {
  const s = i.slice();
  return s[16] = e[t][0], s[17] = e[t][1], s;
}
u(uI, "get_each_context$1i");
function vx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*prompt*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*prompt*/
      1 && t !== (t = /*prompt*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(vx, "create_default_slot_1$S");
function fI(i) {
  let e, t = K(
    /*label*/
    i[17]
  ) + "", s, n, l;
  return {
    c() {
      var r;
      e = E("option"), s = Q(t), n = F(), e.__value = /*skill*/
      i[16], He(e, e.__value), e.selected = l = /*prompt*/
      ((r = i[0]) == null ? void 0 : r.skill) === /*skill*/
      i[16];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a;
      o & /*prompt*/
      1 && l !== (l = /*prompt*/
      ((a = r[0]) == null ? void 0 : a.skill) === /*skill*/
      r[16]) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(fI, "create_each_block$1i");
function kx(i) {
  let e, t, s, n = ue(Object.entries(
    /*skills*/
    i[8]
  )), l = [];
  for (let r = 0; r < n.length; r += 1)
    l[r] = fI(uI(i, n, r));
  return {
    c() {
      e = E("select");
      for (let r = 0; r < l.length; r += 1)
        l[r].c();
      b(e, "class", "u-w-fit");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < l.length; a += 1)
        l[a] && l[a].m(e, null);
      t || (s = W(
        e,
        "change",
        /*change_handler_1*/
        i[13]
      ), t = !0);
    },
    p(r, o) {
      if (o & /*Object, skills, prompt*/
      257) {
        n = ue(Object.entries(
          /*skills*/
          r[8]
        ));
        let a;
        for (a = 0; a < n.length; a += 1) {
          const c = uI(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = fI(c), l[a].c(), l[a].m(e, null));
        }
        for (; a < l.length; a += 1)
          l[a].d(1);
        l.length = n.length;
      }
    },
    d(r) {
      r && C(e), Le(l, r), t = !1, s();
    }
  };
}
u(kx, "create_default_slot$1w");
function wx(i) {
  let e, t, s, n, l, r, o, a, c;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[11]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[12]
          )
        }
      ],
      $$slots: { default: [vx] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.Skill",
      $$slots: { default: [kx] },
      $$scope: { ctx: i }
    }
  }), r = new Ke({
    props: {
      heading: "A5E.ItemAbilityCheckType",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: fl(!1, !0),
      selected: (
        /*selectedAbility*/
        i[4]
      ),
      allowDeselect: !1
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  ), a = new Te({
    props: {
      label: "A5E.PromptDefaultSelection",
      checked: (
        /*prompt*/
        i[0].default ?? !0
      )
    }
  }), a.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[15]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), o = F(), j(a.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "#bebdb5"), G(t, "--a5e-header-button-color-hover", "#555"), G(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(f, d) {
      T(f, t, d), R(e, t, null), T(f, s, d), R(n, f, d), T(f, l, d), R(r, f, d), T(f, o, d), R(a, f, d), c = !0;
    },
    p(f, [d]) {
      const p = {};
      d & /*duplicatePrompt, prompt, deletePrompt, promptId*/
      15 && (p.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            f[11]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            f[12]
          )
        }
      ]), d & /*$$scope, prompt, $item, promptId*/
      1048617 && (p.$$scope = { dirty: d, ctx: f }), e.$set(p);
      const m = {};
      d & /*$$scope, $item, promptId, prompt*/
      1048617 && (m.$$scope = { dirty: d, ctx: f }), n.$set(m);
      const g = {};
      d & /*selectedAbility*/
      16 && (g.selected = /*selectedAbility*/
      f[4]), r.$set(g);
      const h = {};
      d & /*prompt*/
      1 && (h.checked = /*prompt*/
      f[0].default ?? !0), a.$set(h);
    },
    i(f) {
      c || (w(e.$$.fragment, f), w(n.$$.fragment, f), w(r.$$.fragment, f), w(a.$$.fragment, f), c = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(n.$$.fragment, f), O(r.$$.fragment, f), O(a.$$.fragment, f), c = !1;
    },
    d(f) {
      f && (C(s), C(l), C(o)), f && e && C(t), N(e, f), N(n, f), N(r, f), N(a, f);
    }
  };
}
u(wx, "create_fragment$39");
function $x(i, e, t) {
  let s, n, { deletePrompt: l } = e, { duplicatePrompt: r } = e, { prompt: o } = e, { promptId: a } = e;
  const c = de("item");
  pe(i, c, (k) => t(5, n = k));
  const f = de("actionId"), d = { ...CONFIG.A5E.skills };
  game.settings.get("a5e", "hideA5eSkills") && (delete d.cul, delete d.eng);
  function p(k) {
    t(4, s = k), te(n, `system.actions.${f}.prompts.${a}.ability`, s);
  }
  u(p, "updateAbility");
  const m = /* @__PURE__ */ u(({ target: k }) => te(n, `system.actions.${f}.prompts.${a}.label`, k.value), "change_handler"), g = /* @__PURE__ */ u(() => r(f, o), "func"), h = /* @__PURE__ */ u(() => l(f, a), "func_1"), _ = /* @__PURE__ */ u(({ target: k }) => te(n, `system.actions.${f}.prompts.${a}.skill`, k.value), "change_handler_1"), y = /* @__PURE__ */ u(({ detail: k }) => p(k), "updateSelection_handler"), v = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, `system.actions.${f}.prompts.${a}.default`, k);
  }, "updateSelection_handler_1");
  return i.$$set = (k) => {
    "deletePrompt" in k && t(1, l = k.deletePrompt), "duplicatePrompt" in k && t(2, r = k.duplicatePrompt), "prompt" in k && t(0, o = k.prompt), "promptId" in k && t(3, a = k.promptId);
  }, i.$$.update = () => {
    i.$$.dirty & /*prompt*/
    1 && t(0, o), i.$$.dirty & /*prompt*/
    1 && t(4, s = o.ability ?? "none");
  }, [
    o,
    l,
    r,
    a,
    s,
    n,
    c,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    v
  ];
}
u($x, "instance$30");
const rE = class rE extends re {
  constructor(e) {
    super(), oe(this, e, $x, wx, le, {
      deletePrompt: 1,
      duplicatePrompt: 2,
      prompt: 0,
      promptId: 3
    });
  }
};
u(rE, "SkillCheckPromptConfig");
let My = rE;
function dI(i, e, t) {
  const s = i.slice();
  return s[13] = e[t][0], s[14] = e[t][1].heading, s[15] = e[t][1].singleLabel, s[16] = e[t][1].component, s;
}
u(dI, "get_each_context$1h");
function pI(i, e, t) {
  const s = i.slice();
  return s[19] = e[t][0], s[20] = e[t][1], s;
}
u(pI, "get_each_context_1$j");
function mI(i) {
  let e, t, s, n, l;
  function r() {
    return (
      /*func_2*/
      i[11](
        /*promptType*/
        i[13]
      )
    );
  }
  return u(r, "func_2"), t = new De({
    props: {
      heading: (
        /*heading*/
        i[14]
      ),
      headerButtons: [
        {
          classes: "add-button",
          handler: r,
          label: K("A5E.ButtonAddPrompt", { type: K(
            /*singleLabel*/
            i[15]
          ) })
        }
      ],
      $$slots: { default: [Ax] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("li"), s = E("div"), j(t.$$.fragment), n = F(), G(s, "display", "contents"), G(s, "--a5e-section-gap", "0"), b(e, "class", "prompts-config-list__item svelte-tp228x");
    },
    m(o, a) {
      T(o, e, a), A(e, s), R(t, s, null), A(e, n), l = !0;
    },
    p(o, a) {
      i = o;
      const c = {};
      a & /*$item, action*/
      3 && (c.headerButtons = [
        {
          classes: "add-button",
          handler: r,
          label: K("A5E.ButtonAddPrompt", { type: K(
            /*singleLabel*/
            i[15]
          ) })
        }
      ]), a & /*$$scope, prompts*/
      8388616 && (c.$$scope = { dirty: a, ctx: i }), t.$set(c);
    },
    i(o) {
      l || (w(t.$$.fragment, o), l = !0);
    },
    o(o) {
      O(t.$$.fragment, o), l = !1;
    },
    d(o) {
      o && C(e), N(t);
    }
  };
}
u(mI, "create_if_block$1M");
function hI(i, e) {
  let t, s, n, l;
  var r = (
    /*component*/
    e[16]
  );
  function o(a, c) {
    return {
      props: {
        prompt: (
          /*prompt*/
          a[20]
        ),
        promptId: (
          /*promptId*/
          a[19]
        ),
        deletePrompt: (
          /*deletePrompt*/
          a[4]
        ),
        duplicatePrompt: (
          /*duplicatePrompt*/
          a[5]
        )
      }
    };
  }
  return u(o, "switch_props"), r && (s = et(r, o(e))), {
    key: i,
    first: null,
    c() {
      t = E("li"), s && j(s.$$.fragment), n = F(), b(t, "class", "a5e-item a5e-item--action-config"), this.first = t;
    },
    m(a, c) {
      T(a, t, c), s && R(s, t, null), A(t, n), l = !0;
    },
    p(a, c) {
      if (e = a, r !== (r = /*component*/
      e[16])) {
        if (s) {
          ae();
          const f = s;
          O(f.$$.fragment, 1, 0, () => {
            N(f, 1);
          }), ce();
        }
        r ? (s = et(r, o(e)), j(s.$$.fragment), w(s.$$.fragment, 1), R(s, t, n)) : s = null;
      } else if (r) {
        const f = {};
        c & /*prompts*/
        8 && (f.prompt = /*prompt*/
        e[20]), c & /*prompts*/
        8 && (f.promptId = /*promptId*/
        e[19]), s.$set(f);
      }
    },
    i(a) {
      l || (s && w(s.$$.fragment, a), l = !0);
    },
    o(a) {
      s && O(s.$$.fragment, a), l = !1;
    },
    d(a) {
      a && C(t), s && N(s);
    }
  };
}
u(hI, "create_each_block_1$j");
function Ax(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n;
  function l(...a) {
    return (
      /*func_1*/
      i[10](
        /*promptType*/
        i[13],
        ...a
      )
    );
  }
  u(l, "func_1");
  let r = ue(Object.entries(
    /*prompts*/
    i[3]
  ).filter(l));
  const o = /* @__PURE__ */ u((a) => (
    /*promptId*/
    a[19]
  ), "get_key");
  for (let a = 0; a < r.length; a += 1) {
    let c = pI(i, r, a), f = o(c);
    s.set(f, t[a] = hI(f, c));
  }
  return {
    c() {
      e = E("ul");
      for (let a = 0; a < t.length; a += 1)
        t[a].c();
      b(e, "class", "a5e-item-list");
    },
    m(a, c) {
      T(a, e, c);
      for (let f = 0; f < t.length; f += 1)
        t[f] && t[f].m(e, null);
      n = !0;
    },
    p(a, c) {
      i = a, c & /*Object, promptTypes, prompts, deletePrompt, duplicatePrompt*/
      312 && (r = ue(Object.entries(
        /*prompts*/
        i[3]
      ).filter(l)), ae(), t = Lt(t, c, o, 1, i, r, s, e, cn, hI, null, pI), ce());
    },
    i(a) {
      if (!n) {
        for (let c = 0; c < r.length; c += 1)
          w(t[c]);
        n = !0;
      }
    },
    o(a) {
      for (let c = 0; c < t.length; c += 1)
        O(t[c]);
      n = !1;
    },
    d(a) {
      a && C(e);
      for (let c = 0; c < t.length; c += 1)
        t[c].d();
    }
  };
}
u(Ax, "create_default_slot$1v");
function gI(i, e) {
  let t, s = Object.values(
    /*prompts*/
    e[3]
  ).filter(r).length, n, l;
  function r(...a) {
    return (
      /*func*/
      e[9](
        /*promptType*/
        e[13],
        ...a
      )
    );
  }
  u(r, "func");
  let o = s && mI(e);
  return {
    key: i,
    first: null,
    c() {
      t = $e(), o && o.c(), n = $e(), this.first = t;
    },
    m(a, c) {
      T(a, t, c), o && o.m(a, c), T(a, n, c), l = !0;
    },
    p(a, c) {
      e = a, c & /*prompts*/
      8 && (s = Object.values(
        /*prompts*/
        e[3]
      ).filter(r).length), s ? o ? (o.p(e, c), c & /*prompts*/
      8 && w(o, 1)) : (o = mI(e), o.c(), w(o, 1), o.m(n.parentNode, n)) : o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce());
    },
    i(a) {
      l || (w(o), l = !0);
    },
    o(a) {
      O(o), l = !1;
    },
    d(a) {
      a && (C(t), C(n)), o && o.d(a);
    }
  };
}
u(gI, "create_each_block$1h");
function Ex(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r, o, a, c = ue(Object.entries(
    /*promptTypes*/
    i[8]
  ));
  const f = /* @__PURE__ */ u((d) => (
    /*promptType*/
    d[13]
  ), "get_key");
  for (let d = 0; d < c.length; d += 1) {
    let p = dI(i, c, d), m = f(p);
    n.set(m, s[d] = gI(m, p));
  }
  return o = new Tn({
    props: {
      menuList: (
        /*menuList*/
        i[2]
      ),
      offset: { x: -110, y: -105 },
      documentName: "Prompt"
    }
  }), o.$on(
    "press",
    /*press_handler*/
    i[12]
  ), {
    c() {
      e = E("div"), t = E("ul");
      for (let d = 0; d < s.length; d += 1)
        s[d].c();
      l = F(), r = E("div"), j(o.$$.fragment), b(t, "class", "prompts-config-list svelte-tp228x"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(r, "class", "sticky-add-button svelte-tp228x");
    },
    m(d, p) {
      T(d, e, p), A(e, t);
      for (let m = 0; m < s.length; m += 1)
        s[m] && s[m].m(t, null);
      T(d, l, p), T(d, r, p), R(o, r, null), a = !0;
    },
    p(d, [p]) {
      p & /*Object, promptTypes, $item, actionId, action, prompts, deletePrompt, duplicatePrompt*/
      443 && (c = ue(Object.entries(
        /*promptTypes*/
        d[8]
      )), ae(), s = Lt(s, p, f, 1, d, c, n, t, cn, gI, null, dI), ce());
      const m = {};
      p & /*menuList*/
      4 && (m.menuList = /*menuList*/
      d[2]), o.$set(m);
    },
    i(d) {
      if (!a) {
        for (let p = 0; p < c.length; p += 1)
          w(s[p]);
        w(o.$$.fragment, d), a = !0;
      }
    },
    o(d) {
      for (let p = 0; p < s.length; p += 1)
        O(s[p]);
      O(o.$$.fragment, d), a = !1;
    },
    d(d) {
      d && (C(e), C(l), C(r));
      for (let p = 0; p < s.length; p += 1)
        s[p].d();
      N(o);
    }
  };
}
u(Ex, "create_fragment$38");
function Sx(i, e, t) {
  let s, n, l, r;
  function o(_, y) {
    r.update({
      [`system.actions.${_}.prompts`]: { [`-=${y}`]: null }
    });
  }
  u(o, "deletePrompt");
  function a(_, y) {
    const v = foundry.utils.duplicate(y);
    r.update({
      [`system.actions.${_}.prompts`]: { [foundry.utils.randomID()]: v }
    });
  }
  u(a, "duplicatePrompt");
  const c = de("item");
  pe(i, c, (_) => t(1, r = _));
  const f = de("actionId"), d = {
    savingThrow: {
      heading: "A5E.SavingThrowPlural",
      singleLabel: "A5E.SavingThrow",
      component: Py
    },
    abilityCheck: {
      heading: "A5E.AbilityCheckPlural",
      singleLabel: "A5E.AbilityCheck",
      component: Dy
    },
    skillCheck: {
      heading: "A5E.SkillCheckPlural",
      singleLabel: "A5E.SkillCheckSingular",
      component: My
    },
    generic: {
      heading: "A5E.OtherPlural",
      singleLabel: "A5E.Other",
      component: Iy
    }
  }, p = /* @__PURE__ */ u((_, y) => y.type === _, "func"), m = /* @__PURE__ */ u((_, [y, v]) => v.type === _, "func_1"), g = /* @__PURE__ */ u((_) => cl.addPrompt(r, [f, s], _), "func_2"), h = /* @__PURE__ */ u(({ detail: _ }) => cl.addPrompt(r, [f, s], _), "press_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    2 && t(0, s = r.actions.get(f)), i.$$.dirty & /*action*/
    1 && t(3, n = s.prompts ?? {});
  }, t(2, l = Object.entries(d).map(([_, { heading: y }]) => [_, y])), [
    s,
    r,
    l,
    n,
    o,
    a,
    c,
    f,
    d,
    p,
    m,
    g,
    h
  ];
}
u(Sx, "instance$2$");
const oE = class oE extends re {
  constructor(e) {
    super(), oe(this, e, Sx, Ex, le, {});
  }
};
u(oE, "ActionsPromptsTab");
let Fy = oE;
function Cx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Cx, "create_default_slot_1$R");
function Tx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].bonus ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].bonus ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Tx, "create_default_slot$1u");
function Ox(i) {
  let e, t, s, n, l, r, o, a, c;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[11]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[12]
          )
        }
      ],
      $$slots: { default: [Cx] },
      $$scope: { ctx: i }
    }
  }), n = new Ke({
    props: {
      heading: "A5E.ItemAbilityCheckType",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: Object.entries(
        /*abilities*/
        i[8]
      ),
      selected: (
        /*selectedAbility*/
        i[4]
      ),
      allowDeselect: !1
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[13]
  ), r = new ie({
    props: {
      heading: "A5E.CheckBonus",
      $$slots: { default: [Tx] },
      $$scope: { ctx: i }
    }
  }), a = new Te({
    props: {
      label: "A5E.AbilityCheckDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), a.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[15]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), o = F(), j(a.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "#bebdb5"), G(t, "--a5e-header-button-color-hover", "#555"), G(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(f, d) {
      T(f, t, d), R(e, t, null), T(f, s, d), R(n, f, d), T(f, l, d), R(r, f, d), T(f, o, d), R(a, f, d), c = !0;
    },
    p(f, [d]) {
      const p = {};
      d & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (p.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            f[11]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            f[12]
          )
        }
      ]), d & /*$$scope, roll, $item, rollId*/
      65580 && (p.$$scope = { dirty: d, ctx: f }), e.$set(p);
      const m = {};
      d & /*selectedAbility*/
      16 && (m.selected = /*selectedAbility*/
      f[4]), n.$set(m);
      const g = {};
      d & /*$$scope, roll, $item, rollId*/
      65580 && (g.$$scope = { dirty: d, ctx: f }), r.$set(g);
      const h = {};
      d & /*roll*/
      4 && (h.checked = /*roll*/
      f[2].default ?? !0), a.$set(h);
    },
    i(f) {
      c || (w(e.$$.fragment, f), w(n.$$.fragment, f), w(r.$$.fragment, f), w(a.$$.fragment, f), c = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(n.$$.fragment, f), O(r.$$.fragment, f), O(a.$$.fragment, f), c = !1;
    },
    d(f) {
      f && (C(s), C(l), C(o)), f && e && C(t), N(e, f), N(n, f), N(r, f), N(a, f);
    }
  };
}
u(Ox, "create_fragment$37");
function Dx(i, e, t) {
  let s, n, { deleteRoll: l } = e, { duplicateRoll: r } = e, { roll: o } = e, { rollId: a } = e;
  const c = de("item");
  pe(i, c, (k) => t(5, n = k));
  const f = de("actionId"), { abilities: d } = CONFIG.A5E;
  function p(k) {
    t(4, s = k), te(n, `system.actions.${f}.rolls.${a}.ability`, s);
  }
  u(p, "updateAbility");
  const m = /* @__PURE__ */ u(({ target: k }) => te(n, `system.actions.${f}.rolls.${a}.label`, k.value), "change_handler"), g = /* @__PURE__ */ u(() => r(f, o), "func"), h = /* @__PURE__ */ u(() => l(f, a), "func_1"), _ = /* @__PURE__ */ u(({ detail: k }) => p(k), "updateSelection_handler"), y = /* @__PURE__ */ u(({ target: k }) => te(n, `system.actions.${f}.rolls.${a}.bonus`, k.value), "change_handler_1"), v = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, `system.actions.${f}.rolls.${a}.default`, k);
  }, "updateSelection_handler_1");
  return i.$$set = (k) => {
    "deleteRoll" in k && t(0, l = k.deleteRoll), "duplicateRoll" in k && t(1, r = k.duplicateRoll), "roll" in k && t(2, o = k.roll), "rollId" in k && t(3, a = k.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && t(4, s = o.ability ?? "none");
  }, [
    l,
    r,
    o,
    a,
    s,
    n,
    c,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    v
  ];
}
u(Dx, "instance$2_");
const aE = class aE extends re {
  constructor(e) {
    super(), oe(this, e, Dx, Ox, le, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
u(aE, "AbilityCheckRollConfig");
let Ry = aE;
function bI(i, e, t) {
  const s = i.slice();
  return s[19] = e[t][0], s[20] = e[t][1], s;
}
u(bI, "get_each_context$1g");
function Ix(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[11]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Ix, "create_default_slot_4$m");
function _I(i, e) {
  let t, s = K(
    /*name*/
    e[20]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = Q(s), l = F(), t.__value = /*key*/
      e[19], He(t, t.__value), t.selected = r = /*roll*/
      e[2].attackType === /*key*/
      e[19], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*roll*/
      4 && r !== (r = /*roll*/
      e[2].attackType === /*key*/
      e[19]) && (t.selected = r);
    },
    d(o) {
      o && C(t);
    }
  };
}
u(_I, "create_each_block$1g");
function Px(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l, r = ue(Object.entries(
    /*A5E*/
    i[9].attackTypes
  ));
  const o = /* @__PURE__ */ u((a) => (
    /*key*/
    a[19]
  ), "get_key");
  for (let a = 0; a < r.length; a += 1) {
    let c = bI(i, r, a), f = o(c);
    s.set(f, t[a] = _I(f, c));
  }
  return {
    c() {
      e = E("select");
      for (let a = 0; a < t.length; a += 1)
        t[a].c();
      b(e, "class", "u-w-full");
    },
    m(a, c) {
      T(a, e, c);
      for (let f = 0; f < t.length; f += 1)
        t[f] && t[f].m(e, null);
      n || (l = W(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), n = !0);
    },
    p(a, c) {
      c & /*Object, A5E, roll*/
      516 && (r = ue(Object.entries(
        /*A5E*/
        a[9].attackTypes
      )), t = Lt(t, c, o, 1, a, r, s, e, an, _I, null, bI));
    },
    d(a) {
      a && C(e);
      for (let c = 0; c < t.length; c += 1)
        t[c].d();
      n = !1, l();
    }
  };
}
u(Px, "create_default_slot_3$w");
function Mx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].bonus || "0";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_2*/
        i[16]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].bonus || "0") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Mx, "create_default_slot_2$G");
function Fx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), e.value = t = /*roll*/
      i[2].critThreshold ?? 20;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_3*/
        i[17]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].critThreshold ?? 20) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Fx, "create_default_slot_1$Q");
function Rx(i) {
  let e, t, s, n, l, r, o;
  return e = new ie({
    props: {
      heading: "A5E.AttackType",
      $$slots: { default: [Px] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      heading: "A5E.AttackBonus",
      $$slots: { default: [Mx] },
      $$scope: { ctx: i }
    }
  }), r = new ie({
    props: {
      heading: "A5E.CriticalHitThreshold",
      $$slots: { default: [Fx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), n = E("div"), j(s.$$.fragment), l = F(), j(r.$$.fragment), G(n, "display", "contents"), G(n, "--a5e-field-wrapper-grow", "1");
    },
    m(a, c) {
      R(e, a, c), T(a, t, c), T(a, n, c), R(s, n, null), T(a, l, c), R(r, a, c), o = !0;
    },
    p(a, c) {
      const f = {};
      c & /*$$scope, $item, rollId, roll*/
      8388652 && (f.$$scope = { dirty: c, ctx: a }), e.$set(f);
      const d = {};
      c & /*$$scope, roll, $item, rollId*/
      8388652 && (d.$$scope = { dirty: c, ctx: a }), s.$set(d);
      const p = {};
      c & /*$$scope, roll, $item, rollId*/
      8388652 && (p.$$scope = { dirty: c, ctx: a }), r.$set(p);
    },
    i(a) {
      o || (w(e.$$.fragment, a), w(s.$$.fragment, a), w(r.$$.fragment, a), o = !0);
    },
    o(a) {
      O(e.$$.fragment, a), O(s.$$.fragment, a), O(r.$$.fragment, a), o = !1;
    },
    d(a) {
      a && (C(t), C(l)), N(e, a), a && s && C(n), N(s, a), N(r, a);
    }
  };
}
u(Rx, "create_default_slot$1t");
function Nx(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[12]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[13]
          )
        }
      ],
      $$slots: { default: [Ix] },
      $$scope: { ctx: i }
    }
  }), n = new Ke({
    props: {
      heading: "A5E.AbilityScore",
      hint: "The ability score modifier to add to the attack roll.",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: (
        /*abilityOptions*/
        i[10]
      ),
      selected: (
        /*selectedAbility*/
        i[4]
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  ), r = new De({
    props: {
      $$slots: { default: [Rx] },
      $$scope: { ctx: i }
    }
  }), c = new Te({
    props: {
      label: "A5E.AddProficiency",
      checked: (
        /*roll*/
        i[2].proficient ?? !0
      )
    }
  }), c.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[18]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), o = E("div"), j(r.$$.fragment), a = F(), j(c.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "#bebdb5"), G(t, "--a5e-header-button-color-hover", "#555"), G(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem"), G(o, "display", "contents"), G(o, "--a5e-section-body-direction", "row"), G(o, "--a5e-section-body-padding", "0"), G(o, "--a5e-section-body-wrap", "nowrap");
    },
    m(d, p) {
      T(d, t, p), R(e, t, null), T(d, s, p), R(n, d, p), T(d, l, p), T(d, o, p), R(r, o, null), T(d, a, p), R(c, d, p), f = !0;
    },
    p(d, [p]) {
      const m = {};
      p & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (m.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            d[12]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            d[13]
          )
        }
      ]), p & /*$$scope, roll, $item, rollId*/
      8388652 && (m.$$scope = { dirty: p, ctx: d }), e.$set(m);
      const g = {};
      p & /*selectedAbility*/
      16 && (g.selected = /*selectedAbility*/
      d[4]), n.$set(g);
      const h = {};
      p & /*$$scope, roll, $item, rollId*/
      8388652 && (h.$$scope = { dirty: p, ctx: d }), r.$set(h);
      const _ = {};
      p & /*roll*/
      4 && (_.checked = /*roll*/
      d[2].proficient ?? !0), c.$set(_);
    },
    i(d) {
      f || (w(e.$$.fragment, d), w(n.$$.fragment, d), w(r.$$.fragment, d), w(c.$$.fragment, d), f = !0);
    },
    o(d) {
      O(e.$$.fragment, d), O(n.$$.fragment, d), O(r.$$.fragment, d), O(c.$$.fragment, d), f = !1;
    },
    d(d) {
      d && (C(s), C(l), C(a)), d && e && C(t), N(e, d), N(n, d), d && r && C(o), N(r, d), N(c, d);
    }
  };
}
u(Nx, "create_fragment$36");
function jx(i, e, t) {
  let s, n, { deleteRoll: l } = e, { duplicateRoll: r } = e, { roll: o } = e, { rollId: a } = e;
  const c = de("item");
  pe(i, c, (I) => t(5, n = I));
  const f = de("actionId");
  function d(I) {
    t(4, s = I), te(n, `system.actions.${f}.rolls.${a}.ability`, s);
  }
  u(d, "updateAbility");
  const p = CONFIG.A5E, m = [
    ["none", "A5E.None"],
    ["default", "A5E.abilities.default"],
    ["spellcasting", "A5E.abilities.spellcasting"],
    ...fl()
  ], g = /* @__PURE__ */ u(({ target: I }) => te(n, `system.actions.${f}.rolls.${a}.label`, I.value), "change_handler"), h = /* @__PURE__ */ u(() => r(f, o), "func"), _ = /* @__PURE__ */ u(() => l(f, a), "func_1"), y = /* @__PURE__ */ u(({ detail: I }) => d(I), "updateSelection_handler"), v = /* @__PURE__ */ u(({ target: I }) => te(n, `system.actions.${f}.rolls.${a}.attackType`, I.value), "change_handler_1"), k = /* @__PURE__ */ u(({ target: I }) => te(n, `system.actions.${f}.rolls.${a}.bonus`, I.value), "change_handler_2"), S = /* @__PURE__ */ u(({ target: I }) => te(n, `system.actions.${f}.rolls.${a}.critThreshold`, Number(I.value)), "change_handler_3"), D = /* @__PURE__ */ u(({ detail: I }) => {
    te(n, `system.actions.${f}.rolls.${a}.proficient`, I);
  }, "updateSelection_handler_1");
  return i.$$set = (I) => {
    "deleteRoll" in I && t(0, l = I.deleteRoll), "duplicateRoll" in I && t(1, r = I.duplicateRoll), "roll" in I && t(2, o = I.roll), "rollId" in I && t(3, a = I.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && t(4, s = o.ability ?? "none");
  }, [
    l,
    r,
    o,
    a,
    s,
    n,
    c,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    v,
    k,
    S,
    D
  ];
}
u(jx, "instance$2Z");
const cE = class cE extends re {
  constructor(e) {
    super(), oe(this, e, jx, Nx, le, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
u(cE, "AttackRollConfig");
let Ny = cE;
function Lx(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [Gx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, scalingMode, actionId, rollId, roll, $item*/
      8223 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Lx, "create_if_block_2$O");
function Bx(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [zx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, actionId, rollId, roll, $item*/
      8207 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Bx, "create_if_block_1$1a");
function qx(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "Roll Increment",
      hint: "This increment will be applied automatically to your roll based on your caster level.",
      $$slots: { default: [Hx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, actionId, rollId, roll, $item*/
      8207 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(qx, "create_if_block$1L");
function Gx(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S, D, I, M, L, B = (
    /*scalingMode*/
    i[4] === "spellPoints" ? "Points" : "Uses"
  ), z, q, U;
  return {
    c() {
      var H, V;
      e = E("section"), t = E("div"), s = E("label"), n = Q("Roll Increment"), r = F(), o = E("input"), d = F(), p = E("div"), m = E("label"), g = Q("Per"), _ = F(), y = E("input"), D = F(), I = E("div"), M = E("span"), L = Q("Additional "), z = Q(B), b(s, "for", l = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-formula"), b(s, "class", "svelte-ch1xwr"), b(o, "id", a = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-formula"), b(o, "type", "text"), b(o, "name", c = "system.actions." + /*actionId*/
      i[0] + ".rolls." + /*rollId*/
      i[1] + ".scaling.formula"), o.value = f = /*roll*/
      ((H = i[2].scaling) == null ? void 0 : H.formula) ?? 0, b(o, "class", "svelte-ch1xwr"), b(t, "class", "a5e-field-group a5e-field-group--formula"), b(m, "for", h = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-step"), b(m, "class", "svelte-ch1xwr"), b(y, "id", v = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-step"), G(y, "text-align", "center"), b(y, "type", "number"), b(y, "name", k = "system.actions." + /*actionId*/
      i[0] + ".rolls." + /*rollId*/
      i[1] + ".scaling.step"), y.value = S = /*roll*/
      ((V = i[2].scaling) == null ? void 0 : V.step) ?? 1, b(y, "class", "svelte-ch1xwr"), b(p, "class", "a5e-field-group u-w-12"), b(M, "class", "levels svelte-ch1xwr"), b(I, "class", "a5e-field-group levels-wrapper svelte-ch1xwr"), b(e, "class", "row u-flex-wrap svelte-ch1xwr");
    },
    m(H, V) {
      T(H, e, V), A(e, t), A(t, s), A(s, n), A(t, r), A(t, o), A(e, d), A(e, p), A(p, m), A(m, g), A(p, _), A(p, y), A(e, D), A(e, I), A(I, M), A(M, L), A(M, z), q || (U = [
        W(
          o,
          "change",
          /*change_handler_3*/
          i[11]
        ),
        W(
          y,
          "change",
          /*change_handler_4*/
          i[12]
        )
      ], q = !0);
    },
    p(H, V) {
      var Y, J;
      V & /*actionId, rollId*/
      3 && l !== (l = /*actionId*/
      H[0] + "-" + /*rollId*/
      H[1] + "-roll-scaling-formula") && b(s, "for", l), V & /*actionId, rollId*/
      3 && a !== (a = /*actionId*/
      H[0] + "-" + /*rollId*/
      H[1] + "-roll-scaling-formula") && b(o, "id", a), V & /*actionId, rollId*/
      3 && c !== (c = "system.actions." + /*actionId*/
      H[0] + ".rolls." + /*rollId*/
      H[1] + ".scaling.formula") && b(o, "name", c), V & /*roll*/
      4 && f !== (f = /*roll*/
      ((Y = H[2].scaling) == null ? void 0 : Y.formula) ?? 0) && o.value !== f && (o.value = f), V & /*actionId, rollId*/
      3 && h !== (h = /*actionId*/
      H[0] + "-" + /*rollId*/
      H[1] + "-roll-scaling-step") && b(m, "for", h), V & /*actionId, rollId*/
      3 && v !== (v = /*actionId*/
      H[0] + "-" + /*rollId*/
      H[1] + "-roll-scaling-step") && b(y, "id", v), V & /*actionId, rollId*/
      3 && k !== (k = "system.actions." + /*actionId*/
      H[0] + ".rolls." + /*rollId*/
      H[1] + ".scaling.step") && b(y, "name", k), V & /*roll*/
      4 && S !== (S = /*roll*/
      ((J = H[2].scaling) == null ? void 0 : J.step) ?? 1) && y.value !== S && (y.value = S), V & /*scalingMode*/
      16 && B !== (B = /*scalingMode*/
      H[4] === "spellPoints" ? "Points" : "Uses") && be(z, B);
    },
    d(H) {
      H && C(e), q = !1, Me(U);
    }
  };
}
u(Gx, "create_default_slot_2$F");
function zx(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S, D, I, M, L, B, z;
  return {
    c() {
      var q, U;
      e = E("section"), t = E("div"), s = E("label"), n = Q("Roll Increment"), r = F(), o = E("input"), d = F(), p = E("div"), m = E("label"), g = Q("Per"), _ = F(), y = E("input"), D = F(), I = E("div"), I.innerHTML = '<span class="levels svelte-ch1xwr">Levels</span>', M = F(), L = E("small"), L.textContent = `This increment will be applied automatically to your roll based the
                    spell slot used during activation.`, b(s, "for", l = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-formula"), b(s, "class", "svelte-ch1xwr"), b(o, "id", a = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-formula"), b(o, "type", "text"), b(o, "name", c = "system.actions." + /*actionId*/
      i[0] + ".rolls." + /*rollId*/
      i[1] + ".scaling.formula"), o.value = f = /*roll*/
      ((q = i[2].scaling) == null ? void 0 : q.formula) ?? 0, b(o, "class", "svelte-ch1xwr"), b(t, "class", "a5e-field-group a5e-field-group--formula a5e-field-group--spell-level svelte-ch1xwr"), b(m, "for", h = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-step"), b(m, "class", "svelte-ch1xwr"), b(y, "id", v = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-step"), b(y, "type", "number"), b(y, "name", k = "system.actions." + /*actionId*/
      i[0] + ".rolls." + /*rollId*/
      i[1] + ".scaling.step"), y.value = S = /*roll*/
      ((U = i[2].scaling) == null ? void 0 : U.step) ?? 1, b(y, "class", "svelte-ch1xwr"), b(p, "class", "a5e-field-group u-w-12 a5e-field-group--spell-level svelte-ch1xwr"), b(I, "class", "a5e-field-group levels-wrapper svelte-ch1xwr"), b(L, "class", "svelte-ch1xwr"), b(e, "class", "row u-flex-wrap svelte-ch1xwr");
    },
    m(q, U) {
      T(q, e, U), A(e, t), A(t, s), A(s, n), A(t, r), A(t, o), A(e, d), A(e, p), A(p, m), A(m, g), A(p, _), A(p, y), A(e, D), A(e, I), A(e, M), A(e, L), B || (z = [
        W(
          o,
          "change",
          /*change_handler_1*/
          i[9]
        ),
        W(
          y,
          "change",
          /*change_handler_2*/
          i[10]
        )
      ], B = !0);
    },
    p(q, U) {
      var H, V;
      U & /*actionId, rollId*/
      3 && l !== (l = /*actionId*/
      q[0] + "-" + /*rollId*/
      q[1] + "-roll-scaling-formula") && b(s, "for", l), U & /*actionId, rollId*/
      3 && a !== (a = /*actionId*/
      q[0] + "-" + /*rollId*/
      q[1] + "-roll-scaling-formula") && b(o, "id", a), U & /*actionId, rollId*/
      3 && c !== (c = "system.actions." + /*actionId*/
      q[0] + ".rolls." + /*rollId*/
      q[1] + ".scaling.formula") && b(o, "name", c), U & /*roll*/
      4 && f !== (f = /*roll*/
      ((H = q[2].scaling) == null ? void 0 : H.formula) ?? 0) && o.value !== f && (o.value = f), U & /*actionId, rollId*/
      3 && h !== (h = /*actionId*/
      q[0] + "-" + /*rollId*/
      q[1] + "-roll-scaling-step") && b(m, "for", h), U & /*actionId, rollId*/
      3 && v !== (v = /*actionId*/
      q[0] + "-" + /*rollId*/
      q[1] + "-roll-scaling-step") && b(y, "id", v), U & /*actionId, rollId*/
      3 && k !== (k = "system.actions." + /*actionId*/
      q[0] + ".rolls." + /*rollId*/
      q[1] + ".scaling.step") && b(y, "name", k), U & /*roll*/
      4 && S !== (S = /*roll*/
      ((V = q[2].scaling) == null ? void 0 : V.step) ?? 1) && y.value !== S && (y.value = S);
    },
    d(q) {
      q && C(e), B = !1, Me(z);
    }
  };
}
u(zx, "create_default_slot_1$P");
function Hx(i) {
  let e, t, s, n, l;
  return {
    c() {
      var r;
      e = E("input"), b(e, "class", "a5e-input svelte-ch1xwr"), b(e, "type", "text"), b(e, "name", t = "system.actions." + /*actionId*/
      i[0] + ".rolls." + /*rollId*/
      i[1] + ".scaling.formula"), e.value = s = /*roll*/
      ((r = i[2].scaling) == null ? void 0 : r.formula) ?? 0;
    },
    m(r, o) {
      T(r, e, o), n || (l = W(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), n = !0);
    },
    p(r, o) {
      var a;
      o & /*actionId, rollId*/
      3 && t !== (t = "system.actions." + /*actionId*/
      r[0] + ".rolls." + /*rollId*/
      r[1] + ".scaling.formula") && b(e, "name", t), o & /*roll*/
      4 && s !== (s = /*roll*/
      ((a = r[2].scaling) == null ? void 0 : a.formula) ?? 0) && e.value !== s && (e.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Hx, "create_default_slot$1s");
function Ux(i) {
  let e, t, s, n, l, r, o;
  t = new Ke({
    props: {
      heading: "Scaling Mode",
      options: Vx(),
      selected: (
        /*scalingMode*/
        i[4]
      ),
      allowDeselect: !1
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  );
  const a = [qx, Bx, Lx], c = [];
  function f(d, p) {
    return p & /*scalingMode*/
    16 && (n = null), /*scalingMode*/
    d[4] === "cantrip" ? 0 : (
      /*scalingMode*/
      d[4] === "spellLevel" ? 1 : (n == null && (n = !!["artifactCharges", "spellPoints", "actionUses", "itemUses"].includes(
        /*scalingMode*/
        d[4]
      )), n ? 2 : -1)
    );
  }
  return u(f, "select_block_type"), ~(l = f(i, -1)) && (r = c[l] = a[l](i)), {
    c() {
      e = E("form"), j(t.$$.fragment), s = F(), r && r.c(), b(e, "class", "svelte-ch1xwr");
    },
    m(d, p) {
      T(d, e, p), R(t, e, null), A(e, s), ~l && c[l].m(e, null), o = !0;
    },
    p(d, [p]) {
      const m = {};
      p & /*scalingMode*/
      16 && (m.selected = /*scalingMode*/
      d[4]), t.$set(m);
      let g = l;
      l = f(d, p), l === g ? ~l && c[l].p(d, p) : (r && (ae(), O(c[g], 1, 1, () => {
        c[g] = null;
      }), ce()), ~l ? (r = c[l], r ? r.p(d, p) : (r = c[l] = a[l](d), r.c()), w(r, 1), r.m(e, null)) : r = null);
    },
    i(d) {
      o || (w(t.$$.fragment, d), w(r), o = !0);
    },
    o(d) {
      O(t.$$.fragment, d), O(r), o = !1;
    },
    d(d) {
      d && C(e), N(t), ~l && c[l].d();
    }
  };
}
u(Ux, "create_fragment$35");
function Vx() {
  return [[null, "A5E.None"], ...Object.entries(CONFIG.A5E.baseScalingModes)];
}
u(Vx, "getScalingOptions$1");
function Wx(i, e, t) {
  let s, n, l, { document: r, actionId: o, rollId: a } = de("#external").application, { document: c = r, actionId: f = o, rollId: d = a } = e;
  const p = c;
  pe(i, p, (k) => t(3, l = k));
  const m = /* @__PURE__ */ u((k) => {
    te(l, `system.actions.${f}.rolls.${d}.scaling.mode`, k.detail);
  }, "updateSelection_handler"), g = /* @__PURE__ */ u(({ target: k }) => te(l, k.name, k.value), "change_handler"), h = /* @__PURE__ */ u(({ target: k }) => te(l, k.name, k.value), "change_handler_1"), _ = /* @__PURE__ */ u(({ target: k }) => te(l, k.name, parseInt(k.value, 10)), "change_handler_2"), y = /* @__PURE__ */ u(({ target: k }) => te(l, k.name, k.value), "change_handler_3"), v = /* @__PURE__ */ u(({ target: k }) => te(l, k.name, parseInt(k.value, 10)), "change_handler_4");
  return i.$$set = (k) => {
    "document" in k && t(6, c = k.document), "actionId" in k && t(0, f = k.actionId), "rollId" in k && t(1, d = k.rollId);
  }, i.$$.update = () => {
    var k, S;
    i.$$.dirty & /*$item, actionId, rollId*/
    11 && t(2, s = (k = l.actions.get(f)) == null ? void 0 : k.rolls[d]), i.$$.dirty & /*roll*/
    4 && t(4, n = ((S = s.scaling) == null ? void 0 : S.mode) ?? null);
  }, [
    f,
    d,
    s,
    l,
    n,
    p,
    c,
    m,
    g,
    h,
    _,
    y,
    v
  ];
}
u(Wx, "instance$2Y");
const uE = class uE extends re {
  constructor(e) {
    super(), oe(this, e, Wx, Ux, le, { document: 6, actionId: 0, rollId: 1 });
  }
};
u(uE, "RollScalingDialog");
let Su = uE;
function Bl(i) {
  const e = parseInt((i == null ? void 0 : i.toString()) ?? 0, 10) % 10, t = parseInt((i == null ? void 0 : i.toString()) ?? 0, 10) % 100;
  return e === 1 && t !== 11 ? `${i}st` : e === 2 && t !== 12 ? `${i}nd` : e === 3 && t !== 13 ? `${i}rd` : `${i}th`;
}
u(Bl, "getOrdinalNumber");
function yI(i, e, t) {
  const s = i.slice();
  return s[19] = e[t][0], s[20] = e[t][1], s;
}
u(yI, "get_each_context$1f");
function Kx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Kx, "create_default_slot_4$l");
function Yx(i) {
  let e, t, s, n, l, r, o, a;
  return {
    c() {
      e = E("div"), t = E("input"), l = F(), r = E("button"), r.innerHTML = '<i class="fa-solid fa-arrow-up-right-dots svelte-imwkd8" data-tooltip="A5E.ConfigureDamageScaling" data-tooltip-direction="UP"></i>', b(t, "id", s = /*actionId*/
      i[7] + "-" + /*rollId*/
      i[3] + "-damage-formula"), b(t, "type", "text"), t.value = n = /*roll*/
      i[2].formula ?? "", b(r, "class", "scaling-button svelte-imwkd8"), b(e, "class", "u-flex u-gap-sm u-w-full");
    },
    m(c, f) {
      T(c, e, f), A(e, t), A(e, l), A(e, r), o || (a = [
        W(
          t,
          "change",
          /*change_handler_1*/
          i[12]
        ),
        W(r, "click", st(
          /*onClickScalingButton*/
          i[5]
        ))
      ], o = !0);
    },
    p(c, f) {
      f & /*rollId*/
      8 && s !== (s = /*actionId*/
      c[7] + "-" + /*rollId*/
      c[3] + "-damage-formula") && b(t, "id", s), f & /*roll*/
      4 && n !== (n = /*roll*/
      c[2].formula ?? "") && t.value !== n && (t.value = n);
    },
    d(c) {
      c && C(e), o = !1, Me(a);
    }
  };
}
u(Yx, "create_default_slot_3$v");
function vI(i, e) {
  let t, s = K(
    /*name*/
    e[20]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = Q(s), l = F(), t.__value = /*key*/
      e[19], He(t, t.__value), t.selected = r = /*roll*/
      e[2].damageType === /*key*/
      e[19], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*roll*/
      4 && r !== (r = /*roll*/
      e[2].damageType === /*key*/
      e[19]) && (t.selected = r);
    },
    d(o) {
      o && C(t);
    }
  };
}
u(vI, "create_each_block$1f");
function Xx(i) {
  let e, t, s = K("A5E.None") + "", n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, f, d, p = ue(Object.entries(
    /*damageTypes*/
    i[8]
  ));
  const m = /* @__PURE__ */ u((g) => (
    /*key*/
    g[19]
  ), "get_key");
  for (let g = 0; g < p.length; g += 1) {
    let h = yI(i, p, g), _ = m(h);
    a.set(_, o[g] = vI(_, h));
  }
  return {
    c() {
      e = E("select"), t = E("option"), n = Q(s), l = F();
      for (let g = 0; g < o.length; g += 1)
        o[g].c();
      t.__value = null, He(t, t.__value), t.selected = r = /*roll*/
      i[2].damageType === "null", b(e, "id", c = /*actionId*/
      i[7] + "-" + /*rollId*/
      i[3] + "-damage-type"), b(e, "class", "u-w-fit damage-type-select svelte-imwkd8");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(t, n), A(t, l);
      for (let _ = 0; _ < o.length; _ += 1)
        o[_] && o[_].m(e, null);
      f || (d = W(
        e,
        "change",
        /*change_handler_2*/
        i[13]
      ), f = !0);
    },
    p(g, h) {
      h & /*roll*/
      4 && r !== (r = /*roll*/
      g[2].damageType === "null") && (t.selected = r), h & /*Object, damageTypes, roll*/
      260 && (p = ue(Object.entries(
        /*damageTypes*/
        g[8]
      )), o = Lt(o, h, m, 1, g, p, a, e, an, vI, null, yI)), h & /*rollId*/
      8 && c !== (c = /*actionId*/
      g[7] + "-" + /*rollId*/
      g[3] + "-damage-type") && b(e, "id", c);
    },
    d(g) {
      g && C(e);
      for (let h = 0; h < o.length; h += 1)
        o[h].d();
      f = !1, d();
    }
  };
}
u(Xx, "create_default_slot_2$E");
function Jx(i) {
  let e, t, s, n, l;
  return e = new ie({
    props: {
      heading: "A5E.DamageFormula",
      $$slots: { default: [Yx] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.DamageType",
      $$slots: { default: [Xx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-grow", "1");
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), T(r, s, o), R(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$$scope, rollId, roll, $item*/
      8388636 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, rollId, $item, roll*/
      8388636 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(s), r && e && C(t), N(e, r), N(n, r);
    }
  };
}
u(Jx, "create_default_slot_1$O");
function kI(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.DamageBonusOnCrit",
      hint: `When you score a critical hit, this damage is added after doubling
    the attack's damage.`,
      $$slots: { default: [Zx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, rollId, roll, $item*/
      8388636 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(kI, "create_if_block$1K");
function Zx(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("input"), b(e, "id", t = /*actionId*/
      i[7] + "-" + /*rollId*/
      i[3] + "-crit-bonus"), b(e, "type", "text"), e.value = s = /*roll*/
      i[2].critBonus ?? "";
    },
    m(r, o) {
      T(r, e, o), n || (l = W(
        e,
        "change",
        /*change_handler_3*/
        i[15]
      ), n = !0);
    },
    p(r, o) {
      o & /*rollId*/
      8 && t !== (t = /*actionId*/
      r[7] + "-" + /*rollId*/
      r[3] + "-crit-bonus") && b(e, "id", t), o & /*roll*/
      4 && s !== (s = /*roll*/
      r[2].critBonus ?? "") && e.value !== s && (e.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Zx, "create_default_slot$1r");
function Qx(i) {
  let e, t, s, n, l, r, o, a, c, f, d;
  e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[11]
          )
        }
      ],
      $$slots: { default: [Kx] },
      $$scope: { ctx: i }
    }
  }), n = new De({
    props: {
      $$slots: { default: [Jx] },
      $$scope: { ctx: i }
    }
  }), o = new Te({
    props: {
      label: "A5E.DamageDoubleOnCrit",
      checked: (
        /*roll*/
        i[2].canCrit ?? !0
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  );
  let p = (
    /*roll*/
    (i[2].canCrit ?? !0) && kI(i)
  );
  return f = new Te({
    props: {
      label: "A5E.DamageDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), f.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[16]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), r = F(), j(o.$$.fragment), a = F(), p && p.c(), c = F(), j(f.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "#bebdb5"), G(t, "--a5e-header-button-color-hover", "#555"), G(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem"), G(l, "display", "contents"), G(l, "--a5e-section-body-direction", "row"), G(l, "--a5e-section-body-wrap", "nowrap"), G(l, "--a5e-section-body-padding", "0");
    },
    m(m, g) {
      T(m, t, g), R(e, t, null), T(m, s, g), T(m, l, g), R(n, l, null), T(m, r, g), R(o, m, g), T(m, a, g), p && p.m(m, g), T(m, c, g), R(f, m, g), d = !0;
    },
    p(m, [g]) {
      const h = {};
      g & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (h.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            m[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            m[11]
          )
        }
      ]), g & /*$$scope, roll, $item, rollId*/
      8388636 && (h.$$scope = { dirty: g, ctx: m }), e.$set(h);
      const _ = {};
      g & /*$$scope, rollId, $item, roll*/
      8388636 && (_.$$scope = { dirty: g, ctx: m }), n.$set(_);
      const y = {};
      g & /*roll*/
      4 && (y.checked = /*roll*/
      m[2].canCrit ?? !0), o.$set(y), /*roll*/
      m[2].canCrit ?? !0 ? p ? (p.p(m, g), g & /*roll*/
      4 && w(p, 1)) : (p = kI(m), p.c(), w(p, 1), p.m(c.parentNode, c)) : p && (ae(), O(p, 1, 1, () => {
        p = null;
      }), ce());
      const v = {};
      g & /*roll*/
      4 && (v.checked = /*roll*/
      m[2].default ?? !0), f.$set(v);
    },
    i(m) {
      d || (w(e.$$.fragment, m), w(n.$$.fragment, m), w(o.$$.fragment, m), w(p), w(f.$$.fragment, m), d = !0);
    },
    o(m) {
      O(e.$$.fragment, m), O(n.$$.fragment, m), O(o.$$.fragment, m), O(p), O(f.$$.fragment, m), d = !1;
    },
    d(m) {
      m && (C(s), C(r), C(a), C(c)), m && e && C(t), N(e, m), m && n && C(l), N(n, m), N(o, m), p && p.d(m), N(f, m);
    }
  };
}
u(Qx, "create_fragment$34");
function xx(i, e, t) {
  let s;
  function n(D) {
    var q, U, H, V, Y, J, fe;
    const I = (q = D.scaling) == null ? void 0 : q.mode, M = ((U = D.scaling) == null ? void 0 : U.formula) ?? 0, L = a[D.damageType], B = Bl(s.system.level ?? 1), z = (H = D.scaling) == null ? void 0 : H.step;
    return I === "cantrip" ? K("A5E.scaling.summaries.cantrip.damage", { formula: M, damageType: L }) : I === "spellLevel" ? !z || z === 1 ? K("A5E.scaling.summaries.spellLevel.damage", { formula: M, level: B, damageType: L }) : K("A5E.scaling.summaries.steppedSpellLevel.damage", { formula: M, step: z, level: B, damageType: L }) : I === "spellPoints" ? !((V = D.scaling) != null && V.step) || ((Y = D.scaling) == null ? void 0 : Y.step) === 1 ? K("A5E.scaling.summaries.spellPoint.damage", { formula: M }) : K("A5E.scaling.summaries.steppedSpellPoint.damage", { formula: M, step: z }) : ["actionUses", "itemUses"].includes(I) ? !((J = D.scaling) != null && J.step) || ((fe = D.scaling) == null ? void 0 : fe.step) === 1 ? K("A5E.scaling.summaries.uses.damage", { formula: M }) : K("A5E.scaling.summaries.steppedUses.damage", { formula: M, step: z }) : null;
  }
  u(n, "getScalingSummary");
  function l() {
    let D = s.dialogs.rollScaling[p];
    D || (wo(r, s.dialogs.rollScaling[p] = new gi(s, `${s.name} Damage Scaling Configuration`, Su, { actionId: o, rollId: p }, { width: 432 }), s), D = s.dialogs.rollScaling[p]), D.render(!0);
  }
  u(l, "onClickScalingButton");
  const r = de("item");
  pe(i, r, (D) => t(4, s = D));
  const o = de("actionId"), { damageTypes: a } = CONFIG.A5E;
  let { deleteRoll: c } = e, { duplicateRoll: f } = e, { roll: d } = e, { rollId: p } = e;
  const m = /* @__PURE__ */ u(({ target: D }) => te(s, `system.actions.${o}.rolls.${p}.label`, D.value), "change_handler"), g = /* @__PURE__ */ u(() => f(o, d), "func"), h = /* @__PURE__ */ u(() => c(o, p), "func_1"), _ = /* @__PURE__ */ u(({ target: D }) => te(s, `system.actions.${o}.rolls.${p}.formula`, D.value), "change_handler_1"), y = /* @__PURE__ */ u(({ target: D }) => te(s, `system.actions.${o}.rolls.${p}.damageType`, D.value), "change_handler_2"), v = /* @__PURE__ */ u(({ detail: D }) => {
    te(s, `system.actions.${o}.rolls.${p}.canCrit`, D);
  }, "updateSelection_handler"), k = /* @__PURE__ */ u(({ target: D }) => te(s, `system.actions.${o}.rolls.${p}.critBonus`, D.value), "change_handler_3"), S = /* @__PURE__ */ u(({ detail: D }) => {
    te(s, `system.actions.${o}.rolls.${p}.default`, D);
  }, "updateSelection_handler_1");
  return i.$$set = (D) => {
    "deleteRoll" in D && t(0, c = D.deleteRoll), "duplicateRoll" in D && t(1, f = D.duplicateRoll), "roll" in D && t(2, d = D.roll), "rollId" in D && t(3, p = D.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && n(d);
  }, [
    c,
    f,
    d,
    p,
    s,
    l,
    r,
    o,
    a,
    m,
    g,
    h,
    _,
    y,
    v,
    k,
    S
  ];
}
u(xx, "instance$2X");
const fE = class fE extends re {
  constructor(e) {
    super(), oe(this, e, xx, Qx, le, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
u(fE, "DamageRollConfig");
let jy = fE;
function eee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(eee, "create_default_slot_1$N");
function tee(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("div"), t = E("input"), n = F(), l = E("button"), l.innerHTML = '<i class="fa-solid fa-arrow-up-right-dots svelte-rl2ai7" data-tooltip="A5E.ConfigureDamageScaling" data-tooltip-direction="UP"></i>', b(t, "type", "text"), t.value = s = /*roll*/
      i[2].formula ?? "", b(l, "class", "scaling-button svelte-rl2ai7"), b(e, "class", "u-flex u-gap-sm u-w-full");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, n), A(e, l), r || (o = [
        W(
          t,
          "change",
          /*change_handler_1*/
          i[11]
        ),
        W(l, "click", st(
          /*onClickScalingButton*/
          i[5]
        ))
      ], r = !0);
    },
    p(a, c) {
      c & /*roll*/
      4 && s !== (s = /*roll*/
      a[2].formula ?? "") && t.value !== s && (t.value = s);
    },
    d(a) {
      a && C(e), r = !1, Me(o);
    }
  };
}
u(tee, "create_default_slot$1q");
function see(i) {
  let e, t, s, n, l, r, o, a;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[9]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[10]
          )
        }
      ],
      $$slots: { default: [eee] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.RollFormula",
      $$slots: { default: [tee] },
      $$scope: { ctx: i }
    }
  }), o = new Te({
    props: {
      label: "A5E.GenericDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), r = F(), j(o.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "#bebdb5"), G(t, "--a5e-header-button-color-hover", "#555"), G(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem"), G(l, "display", "contents"), G(l, "--a5e-field-wrapper-grow", "1");
    },
    m(c, f) {
      T(c, t, f), R(e, t, null), T(c, s, f), T(c, l, f), R(n, l, null), T(c, r, f), R(o, c, f), a = !0;
    },
    p(c, [f]) {
      const d = {};
      f & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (d.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            c[9]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            c[10]
          )
        }
      ]), f & /*$$scope, roll, $item, rollId*/
      8220 && (d.$$scope = { dirty: f, ctx: c }), e.$set(d);
      const p = {};
      f & /*$$scope, roll, $item, rollId*/
      8220 && (p.$$scope = { dirty: f, ctx: c }), n.$set(p);
      const m = {};
      f & /*roll*/
      4 && (m.checked = /*roll*/
      c[2].default ?? !0), o.$set(m);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(n.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      O(e.$$.fragment, c), O(n.$$.fragment, c), O(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (C(s), C(r)), c && e && C(t), N(e, c), c && n && C(l), N(n, c), N(o, c);
    }
  };
}
u(see, "create_fragment$33");
function nee(i, e, t) {
  let s;
  function n() {
    let _ = s.dialogs.rollScaling[f];
    _ || (wo(l, s.dialogs.rollScaling[f] = new gi(s, `${s.name} Roll Scaling Configuration`, Su, { actionId: r, rollId: f }, { width: 432 }), s), _ = s.dialogs.rollScaling[f]), _.render(!0);
  }
  u(n, "onClickScalingButton");
  const l = de("item");
  pe(i, l, (_) => t(4, s = _));
  const r = de("actionId");
  let { deleteRoll: o } = e, { duplicateRoll: a } = e, { roll: c } = e, { rollId: f } = e;
  const d = /* @__PURE__ */ u(({ target: _ }) => te(s, `system.actions.${r}.rolls.${f}.label`, _.value), "change_handler"), p = /* @__PURE__ */ u(() => a(r, c), "func"), m = /* @__PURE__ */ u(() => o(r, f), "func_1"), g = /* @__PURE__ */ u(({ target: _ }) => te(s, `system.actions.${r}.rolls.${f}.formula`, _.value), "change_handler_1"), h = /* @__PURE__ */ u(({ detail: _ }) => {
    te(s, `system.actions.${r}.rolls.${f}.default`, _);
  }, "updateSelection_handler");
  return i.$$set = (_) => {
    "deleteRoll" in _ && t(0, o = _.deleteRoll), "duplicateRoll" in _ && t(1, a = _.duplicateRoll), "roll" in _ && t(2, c = _.roll), "rollId" in _ && t(3, f = _.rollId);
  }, [
    o,
    a,
    c,
    f,
    s,
    n,
    l,
    r,
    d,
    p,
    m,
    g,
    h
  ];
}
u(nee, "instance$2W");
const dE = class dE extends re {
  constructor(e) {
    super(), oe(this, e, nee, see, le, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
u(dE, "GenericRollConfig");
let Ly = dE;
function wI(i, e, t) {
  const s = i.slice();
  return s[18] = e[t][0], s[19] = e[t][1], s;
}
u(wI, "get_each_context$1e");
function iee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(iee, "create_default_slot_3$u");
function lee(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("div"), t = E("input"), n = F(), l = E("button"), l.innerHTML = '<i class="fa-solid fa-arrow-up-right-dots svelte-rl2ai7" data-tooltip="A5E.ConfigureDamageScaling" data-tooltip-direction="UP"></i>', b(t, "type", "text"), t.value = s = /*roll*/
      i[2].formula ?? "", b(l, "class", "scaling-button svelte-rl2ai7"), b(e, "class", "u-flex u-gap-sm u-w-full");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, n), A(e, l), r || (o = [
        W(
          t,
          "change",
          /*change_handler_1*/
          i[12]
        ),
        W(l, "click", st(
          /*onClickScalingButton*/
          i[5]
        ))
      ], r = !0);
    },
    p(a, c) {
      c & /*roll*/
      4 && s !== (s = /*roll*/
      a[2].formula ?? "") && t.value !== s && (t.value = s);
    },
    d(a) {
      a && C(e), r = !1, Me(o);
    }
  };
}
u(lee, "create_default_slot_2$D");
function $I(i, e) {
  let t, s = K(
    /*name*/
    e[19]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = Q(s), l = F(), t.__value = /*key*/
      e[18], He(t, t.__value), t.selected = r = /*roll*/
      e[2].healingType === /*key*/
      e[18], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*roll*/
      4 && r !== (r = /*roll*/
      e[2].healingType === /*key*/
      e[18]) && (t.selected = r);
    },
    d(o) {
      o && C(t);
    }
  };
}
u($I, "create_each_block$1e");
function ree(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l, r, o = ue(Object.entries(
    /*healingTypes*/
    i[8]
  ));
  const a = /* @__PURE__ */ u((c) => (
    /*key*/
    c[18]
  ), "get_key");
  for (let c = 0; c < o.length; c += 1) {
    let f = wI(i, o, c), d = a(f);
    s.set(d, t[c] = $I(d, f));
  }
  return {
    c() {
      e = E("select");
      for (let c = 0; c < t.length; c += 1)
        t[c].c();
      b(e, "id", n = /*actionId*/
      i[7] + "-" + /*rollId*/
      i[3] + "-healing-type"), b(e, "class", "u-w-fit");
    },
    m(c, f) {
      T(c, e, f);
      for (let d = 0; d < t.length; d += 1)
        t[d] && t[d].m(e, null);
      l || (r = W(
        e,
        "change",
        /*change_handler_2*/
        i[13]
      ), l = !0);
    },
    p(c, f) {
      f & /*Object, healingTypes, roll*/
      260 && (o = ue(Object.entries(
        /*healingTypes*/
        c[8]
      )), t = Lt(t, f, a, 1, c, o, s, e, an, $I, null, wI)), f & /*rollId*/
      8 && n !== (n = /*actionId*/
      c[7] + "-" + /*rollId*/
      c[3] + "-healing-type") && b(e, "id", n);
    },
    d(c) {
      c && C(e);
      for (let f = 0; f < t.length; f += 1)
        t[f].d();
      l = !1, r();
    }
  };
}
u(ree, "create_default_slot_1$M");
function oee(i) {
  let e, t, s, n, l;
  return e = new ie({
    props: {
      heading: "A5E.HealingFormula",
      $$slots: { default: [lee] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.HealingType",
      $$slots: { default: [ree] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-grow", "1");
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), T(r, s, o), R(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$$scope, roll, $item, rollId*/
      4194332 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, rollId, $item, roll*/
      4194332 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(s), r && e && C(t), N(e, r), N(n, r);
    }
  };
}
u(oee, "create_default_slot$1p");
function aee(i) {
  let e, t, s, n, l, r, o, a;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[11]
          )
        }
      ],
      $$slots: { default: [iee] },
      $$scope: { ctx: i }
    }
  }), n = new De({
    props: {
      $$slots: { default: [oee] },
      $$scope: { ctx: i }
    }
  }), o = new Te({
    props: {
      label: "A5E.HealingDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), r = F(), j(o.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "#bebdb5"), G(t, "--a5e-header-button-color-hover", "#555"), G(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem"), G(l, "display", "contents"), G(l, "--a5e-section-body-direction", "row"), G(l, "--a5e-section-body-wrap", "nowrap"), G(l, "--a5e-section-body-padding", "0");
    },
    m(c, f) {
      T(c, t, f), R(e, t, null), T(c, s, f), T(c, l, f), R(n, l, null), T(c, r, f), R(o, c, f), a = !0;
    },
    p(c, [f]) {
      const d = {};
      f & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (d.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            c[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            c[11]
          )
        }
      ]), f & /*$$scope, roll, $item, rollId*/
      4194332 && (d.$$scope = { dirty: f, ctx: c }), e.$set(d);
      const p = {};
      f & /*$$scope, rollId, $item, roll*/
      4194332 && (p.$$scope = { dirty: f, ctx: c }), n.$set(p);
      const m = {};
      f & /*roll*/
      4 && (m.checked = /*roll*/
      c[2].default ?? !0), o.$set(m);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(n.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      O(e.$$.fragment, c), O(n.$$.fragment, c), O(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (C(s), C(r)), c && e && C(t), N(e, c), c && n && C(l), N(n, c), N(o, c);
    }
  };
}
u(aee, "create_fragment$32");
function cee(i, e, t) {
  let s;
  function n(S) {
    var z, q, U, H, V, Y, J;
    const D = (z = S.scaling) == null ? void 0 : z.mode, I = ((q = S.scaling) == null ? void 0 : q.formula) ?? 0, M = (c[S.healingType] ?? c.healing).toLocaleLowerCase(), L = Bl(s.system.level ?? 1), B = (U = S.scaling) == null ? void 0 : U.step;
    return D === "cantrip" ? K("A5E.scaling.summaries.cantrip.healing", { formula: I, healingType: M }) : D === "spellLevel" ? !B || B === 1 ? K("A5E.scaling.summaries.spellLevel.healing", { formula: I, level: L, healingType: M }) : K("A5E.scaling.summaries.steppedSpellLevel.healing", { formula: I, step: B, level: L, healingType: M }) : D === "spellPoints" ? !((H = S.scaling) != null && H.step) || ((V = S.scaling) == null ? void 0 : V.step) === 1 ? K("A5E.scaling.summaries.spellPoint.healing", { formula: I, healingType: M }) : K("A5E.scaling.summaries.steppedSpellPoint.healing", { formula: I, step: B, healingType: M }) : ["actionUses", "itemUses"].includes(D) ? !((Y = S.scaling) != null && Y.step) || ((J = S.scaling) == null ? void 0 : J.step) === 1 ? K("A5E.scaling.summaries.uses.healing", { formula: I, healingType: M }) : K("A5E.scaling.summaries.steppedUses.healing", { formula: I, step: B, healingType: M }) : null;
  }
  u(n, "getScalingSummary");
  function l() {
    let S = s.dialogs.rollScaling[m];
    S || (wo(r, s.dialogs.rollScaling[m] = new gi(s, `${s.name} Healing Scaling Configuration`, Su, { actionId: o, rollId: m }, { width: 432 }), s), S = s.dialogs.rollScaling[m]), S.render(!0);
  }
  u(l, "onClickScalingButton");
  const r = de("item");
  pe(i, r, (S) => t(4, s = S));
  const o = de("actionId"), { A5E: a } = CONFIG, { healingTypes: c } = a;
  let { deleteRoll: f } = e, { duplicateRoll: d } = e, { roll: p } = e, { rollId: m } = e;
  const g = /* @__PURE__ */ u(({ target: S }) => te(s, `system.actions.${o}.rolls.${m}.label`, S.value), "change_handler"), h = /* @__PURE__ */ u(() => d(o, p), "func"), _ = /* @__PURE__ */ u(() => f(o, m), "func_1"), y = /* @__PURE__ */ u(({ target: S }) => te(s, `system.actions.${o}.rolls.${m}.formula`, S.value), "change_handler_1"), v = /* @__PURE__ */ u(({ target: S }) => te(s, `system.actions.${o}.rolls.${m}.healingType`, S.value), "change_handler_2"), k = /* @__PURE__ */ u(({ detail: S }) => {
    te(s, `system.actions.${o}.rolls.${m}.default`, S);
  }, "updateSelection_handler");
  return i.$$set = (S) => {
    "deleteRoll" in S && t(0, f = S.deleteRoll), "duplicateRoll" in S && t(1, d = S.duplicateRoll), "roll" in S && t(2, p = S.roll), "rollId" in S && t(3, m = S.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && n(p);
  }, [
    f,
    d,
    p,
    m,
    s,
    l,
    r,
    o,
    c,
    g,
    h,
    _,
    y,
    v,
    k
  ];
}
u(cee, "instance$2V");
const pE = class pE extends re {
  constructor(e) {
    super(), oe(this, e, cee, aee, le, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
u(pE, "HealingRollConfig");
let By = pE;
function uee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(uee, "create_default_slot_1$L");
function fee(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("input"), b(e, "id", t = /*actionId*/
      i[7] + "-" + /*rollId*/
      i[3] + "-bonus"), b(e, "type", "text"), e.value = s = /*roll*/
      i[2].bonus ?? "";
    },
    m(r, o) {
      T(r, e, o), n || (l = W(
        e,
        "change",
        /*change_handler_1*/
        i[13]
      ), n = !0);
    },
    p(r, o) {
      o & /*rollId*/
      8 && t !== (t = /*actionId*/
      r[7] + "-" + /*rollId*/
      r[3] + "-bonus") && b(e, "id", t), o & /*roll*/
      4 && s !== (s = /*roll*/
      r[2].bonus ?? "") && e.value !== s && (e.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(fee, "create_default_slot$1o");
function dee(i) {
  let e, t, s, n, l, r, o, a, c;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[11]
          )
        }
      ],
      $$slots: { default: [uee] },
      $$scope: { ctx: i }
    }
  }), n = new Ke({
    props: {
      heading: "A5E.ItemSavingThrowType",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: fl(),
      selected: (
        /*selectedAbility*/
        i[4]
      ),
      allowDeselect: !1
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), r = new ie({
    props: {
      heading: "A5E.SaveBonus",
      $$slots: { default: [fee] },
      $$scope: { ctx: i }
    }
  }), a = new Te({
    props: {
      label: "A5E.SavingThrowDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), a.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[14]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), o = F(), j(a.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "#bebdb5"), G(t, "--a5e-header-button-color-hover", "#555"), G(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(f, d) {
      T(f, t, d), R(e, t, null), T(f, s, d), R(n, f, d), T(f, l, d), R(r, f, d), T(f, o, d), R(a, f, d), c = !0;
    },
    p(f, [d]) {
      const p = {};
      d & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (p.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            f[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            f[11]
          )
        }
      ]), d & /*$$scope, roll, $item, rollId*/
      32812 && (p.$$scope = { dirty: d, ctx: f }), e.$set(p);
      const m = {};
      d & /*selectedAbility*/
      16 && (m.selected = /*selectedAbility*/
      f[4]), n.$set(m);
      const g = {};
      d & /*$$scope, rollId, roll, $item*/
      32812 && (g.$$scope = { dirty: d, ctx: f }), r.$set(g);
      const h = {};
      d & /*roll*/
      4 && (h.checked = /*roll*/
      f[2].default ?? !0), a.$set(h);
    },
    i(f) {
      c || (w(e.$$.fragment, f), w(n.$$.fragment, f), w(r.$$.fragment, f), w(a.$$.fragment, f), c = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(n.$$.fragment, f), O(r.$$.fragment, f), O(a.$$.fragment, f), c = !1;
    },
    d(f) {
      f && (C(s), C(l), C(o)), f && e && C(t), N(e, f), N(n, f), N(r, f), N(a, f);
    }
  };
}
u(dee, "create_fragment$31");
function pee(i, e, t) {
  let s, n, { deleteRoll: l } = e, { duplicateRoll: r } = e, { roll: o } = e, { rollId: a } = e;
  const c = de("item");
  pe(i, c, (v) => t(5, n = v));
  const f = de("actionId");
  function d(v) {
    t(4, s = v), te(n, `system.actions.${f}.rolls.${a}.ability`, s);
  }
  u(d, "updateAbility");
  const p = /* @__PURE__ */ u(({ target: v }) => te(n, `system.actions.${f}.rolls.${a}.label`, v.value), "change_handler"), m = /* @__PURE__ */ u(() => r(f, o), "func"), g = /* @__PURE__ */ u(() => l(f, a), "func_1"), h = /* @__PURE__ */ u(({ detail: v }) => d(v), "updateSelection_handler"), _ = /* @__PURE__ */ u(({ target: v }) => te(n, `system.actions.${f}.rolls.${a}.bonus`, v.value), "change_handler_1"), y = /* @__PURE__ */ u(({ detail: v }) => {
    te(n, `system.actions.${f}.rolls.${a}.default`, v);
  }, "updateSelection_handler_1");
  return i.$$set = (v) => {
    "deleteRoll" in v && t(0, l = v.deleteRoll), "duplicateRoll" in v && t(1, r = v.duplicateRoll), "roll" in v && t(2, o = v.roll), "rollId" in v && t(3, a = v.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && t(4, s = o.ability ?? "none");
  }, [
    l,
    r,
    o,
    a,
    s,
    n,
    c,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
u(pee, "instance$2U");
const mE = class mE extends re {
  constructor(e) {
    super(), oe(this, e, pee, dee, le, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
u(mE, "SavingThrowRollConfig");
let qy = mE;
function AI(i, e, t) {
  const s = i.slice();
  return s[17] = e[t][0], s[18] = e[t][1], s;
}
u(AI, "get_each_context$1d");
function mee(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      ((l = i[2]) == null ? void 0 : l.label) ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*roll*/
      4 && t !== (t = /*roll*/
      ((o = l[2]) == null ? void 0 : o.label) ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(mee, "create_default_slot_2$C");
function EI(i) {
  let e, t = K(
    /*label*/
    i[18]
  ) + "", s, n, l;
  return {
    c() {
      var r;
      e = E("option"), s = Q(t), n = F(), e.__value = /*skill*/
      i[17], He(e, e.__value), e.selected = l = /*roll*/
      ((r = i[2]) == null ? void 0 : r.skill) === /*skill*/
      i[17];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a;
      o & /*roll*/
      4 && l !== (l = /*roll*/
      ((a = r[2]) == null ? void 0 : a.skill) === /*skill*/
      r[17]) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(EI, "create_each_block$1d");
function hee(i) {
  let e, t, s, n = ue(Object.entries(
    /*skills*/
    i[8]
  )), l = [];
  for (let r = 0; r < n.length; r += 1)
    l[r] = EI(AI(i, n, r));
  return {
    c() {
      e = E("select");
      for (let r = 0; r < l.length; r += 1)
        l[r].c();
      b(e, "class", "u-w-fit");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < l.length; a += 1)
        l[a] && l[a].m(e, null);
      t || (s = W(
        e,
        "change",
        /*change_handler_1*/
        i[13]
      ), t = !0);
    },
    p(r, o) {
      if (o & /*Object, skills, roll*/
      260) {
        n = ue(Object.entries(
          /*skills*/
          r[8]
        ));
        let a;
        for (a = 0; a < n.length; a += 1) {
          const c = AI(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = EI(c), l[a].c(), l[a].m(e, null));
        }
        for (; a < l.length; a += 1)
          l[a].d(1);
        l.length = n.length;
      }
    },
    d(r) {
      r && C(e), Le(l, r), t = !1, s();
    }
  };
}
u(hee, "create_default_slot_1$K");
function gee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].bonus ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_2*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].bonus ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(gee, "create_default_slot$1n");
function bee(i) {
  let e, t, s, n, l, r, o, a, c, f, d;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[11]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[12]
          )
        }
      ],
      $$slots: { default: [mee] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.Skill",
      $$slots: { default: [hee] },
      $$scope: { ctx: i }
    }
  }), r = new Ke({
    props: {
      allowDeselect: !1,
      heading: "A5E.DefaultAbilityScore",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: fl(!1, !0),
      selected: (
        /*selectedAbility*/
        i[4]
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  ), a = new ie({
    props: {
      heading: "A5E.CheckBonus",
      $$slots: { default: [gee] },
      $$scope: { ctx: i }
    }
  }), f = new Te({
    props: {
      label: "A5E.SkillCheckDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), f.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[16]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), o = F(), j(a.$$.fragment), c = F(), j(f.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "#bebdb5"), G(t, "--a5e-header-button-color-hover", "#555"), G(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(p, m) {
      T(p, t, m), R(e, t, null), T(p, s, m), R(n, p, m), T(p, l, m), R(r, p, m), T(p, o, m), R(a, p, m), T(p, c, m), R(f, p, m), d = !0;
    },
    p(p, [m]) {
      const g = {};
      m & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (g.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            p[11]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            p[12]
          )
        }
      ]), m & /*$$scope, roll, $item, rollId*/
      2097196 && (g.$$scope = { dirty: m, ctx: p }), e.$set(g);
      const h = {};
      m & /*$$scope, $item, rollId, roll*/
      2097196 && (h.$$scope = { dirty: m, ctx: p }), n.$set(h);
      const _ = {};
      m & /*selectedAbility*/
      16 && (_.selected = /*selectedAbility*/
      p[4]), r.$set(_);
      const y = {};
      m & /*$$scope, roll, $item, rollId*/
      2097196 && (y.$$scope = { dirty: m, ctx: p }), a.$set(y);
      const v = {};
      m & /*roll*/
      4 && (v.checked = /*roll*/
      p[2].default ?? !0), f.$set(v);
    },
    i(p) {
      d || (w(e.$$.fragment, p), w(n.$$.fragment, p), w(r.$$.fragment, p), w(a.$$.fragment, p), w(f.$$.fragment, p), d = !0);
    },
    o(p) {
      O(e.$$.fragment, p), O(n.$$.fragment, p), O(r.$$.fragment, p), O(a.$$.fragment, p), O(f.$$.fragment, p), d = !1;
    },
    d(p) {
      p && (C(s), C(l), C(o), C(c)), p && e && C(t), N(e, p), N(n, p), N(r, p), N(a, p), N(f, p);
    }
  };
}
u(bee, "create_fragment$30");
function _ee(i, e, t) {
  let s, n, { deleteRoll: l } = e, { duplicateRoll: r } = e, { roll: o } = e, { rollId: a } = e;
  const c = de("item");
  pe(i, c, (S) => t(5, n = S));
  const f = de("actionId"), d = { ...CONFIG.A5E.skills };
  game.settings.get("a5e", "hideA5eSkills") && (delete d.cul, delete d.eng);
  function p(S) {
    t(4, s = S), te(n, `system.actions.${f}.rolls.${a}.ability`, s);
  }
  u(p, "updateAbility");
  const m = /* @__PURE__ */ u(({ target: S }) => te(n, `system.actions.${f}.rolls.${a}.label`, S.value), "change_handler"), g = /* @__PURE__ */ u(() => r(f, o), "func"), h = /* @__PURE__ */ u(() => l(f, a), "func_1"), _ = /* @__PURE__ */ u(({ target: S }) => te(n, `system.actions.${f}.rolls.${a}.skill`, S.value), "change_handler_1"), y = /* @__PURE__ */ u(({ detail: S }) => p(S), "updateSelection_handler"), v = /* @__PURE__ */ u(({ target: S }) => te(n, `system.actions.${f}.rolls.${a}.bonus`, S.value), "change_handler_2"), k = /* @__PURE__ */ u(({ detail: S }) => {
    te(n, `system.actions.${f}.rolls.${a}.default`, S);
  }, "updateSelection_handler_1");
  return i.$$set = (S) => {
    "deleteRoll" in S && t(0, l = S.deleteRoll), "duplicateRoll" in S && t(1, r = S.duplicateRoll), "roll" in S && t(2, o = S.roll), "rollId" in S && t(3, a = S.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && t(4, s = (o == null ? void 0 : o.ability) ?? "none");
  }, [
    l,
    r,
    o,
    a,
    s,
    n,
    c,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    v,
    k
  ];
}
u(_ee, "instance$2T");
const hE = class hE extends re {
  constructor(e) {
    super(), oe(this, e, _ee, bee, le, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
u(hE, "SkillCheckRollConfig");
let Gy = hE;
function SI(i, e, t) {
  const s = i.slice();
  return s[17] = e[t][0], s[18] = e[t][1], s;
}
u(SI, "get_each_context$1c");
function yee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(yee, "create_default_slot_2$B");
function CI(i) {
  let e, t = K(
    /*label*/
    i[18]
  ) + "", s, n, l;
  return {
    c() {
      var r;
      e = E("option"), s = Q(t), n = F(), e.__value = /*tool*/
      i[17], He(e, e.__value), e.selected = l = /*roll*/
      ((r = i[2]) == null ? void 0 : r.tool) === /*tool*/
      i[17];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a;
      o & /*roll*/
      4 && l !== (l = /*roll*/
      ((a = r[2]) == null ? void 0 : a.tool) === /*tool*/
      r[17]) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(CI, "create_each_block$1c");
function vee(i) {
  let e, t, s, n = ue(
    /*tools*/
    i[9]
  ), l = [];
  for (let r = 0; r < n.length; r += 1)
    l[r] = CI(SI(i, n, r));
  return {
    c() {
      e = E("select");
      for (let r = 0; r < l.length; r += 1)
        l[r].c();
      b(e, "class", "u-w-fit");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < l.length; a += 1)
        l[a] && l[a].m(e, null);
      t || (s = W(
        e,
        "change",
        /*change_handler_1*/
        i[13]
      ), t = !0);
    },
    p(r, o) {
      if (o & /*tools, roll*/
      516) {
        n = ue(
          /*tools*/
          r[9]
        );
        let a;
        for (a = 0; a < n.length; a += 1) {
          const c = SI(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = CI(c), l[a].c(), l[a].m(e, null));
        }
        for (; a < l.length; a += 1)
          l[a].d(1);
        l.length = n.length;
      }
    },
    d(r) {
      r && C(e), Le(l, r), t = !1, s();
    }
  };
}
u(vee, "create_default_slot_1$J");
function kee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].bonus ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_2*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].bonus ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(kee, "create_default_slot$1m");
function wee(i) {
  let e, t, s, n, l, r, o, a, c, f, d;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[11]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[12]
          )
        }
      ],
      $$slots: { default: [yee] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.Tool",
      $$slots: { default: [vee] },
      $$scope: { ctx: i }
    }
  }), r = new Ke({
    props: {
      heading: "A5E.DefaultAbilityScore",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: fl(!1, !0),
      selected: (
        /*selectedAbility*/
        i[4]
      ),
      allowDeselect: !1
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  ), a = new ie({
    props: {
      heading: "A5E.CheckBonus",
      $$slots: { default: [kee] },
      $$scope: { ctx: i }
    }
  }), f = new Te({
    props: {
      label: "A5E.ToolCheckDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), f.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[16]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), o = F(), j(a.$$.fragment), c = F(), j(f.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "#bebdb5"), G(t, "--a5e-header-button-color-hover", "#555"), G(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(p, m) {
      T(p, t, m), R(e, t, null), T(p, s, m), R(n, p, m), T(p, l, m), R(r, p, m), T(p, o, m), R(a, p, m), T(p, c, m), R(f, p, m), d = !0;
    },
    p(p, [m]) {
      const g = {};
      m & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (g.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            p[11]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            p[12]
          )
        }
      ]), m & /*$$scope, roll, $item, rollId*/
      2097196 && (g.$$scope = { dirty: m, ctx: p }), e.$set(g);
      const h = {};
      m & /*$$scope, $item, rollId, roll*/
      2097196 && (h.$$scope = { dirty: m, ctx: p }), n.$set(h);
      const _ = {};
      m & /*selectedAbility*/
      16 && (_.selected = /*selectedAbility*/
      p[4]), r.$set(_);
      const y = {};
      m & /*$$scope, roll, $item, rollId*/
      2097196 && (y.$$scope = { dirty: m, ctx: p }), a.$set(y);
      const v = {};
      m & /*roll*/
      4 && (v.checked = /*roll*/
      p[2].default ?? !0), f.$set(v);
    },
    i(p) {
      d || (w(e.$$.fragment, p), w(n.$$.fragment, p), w(r.$$.fragment, p), w(a.$$.fragment, p), w(f.$$.fragment, p), d = !0);
    },
    o(p) {
      O(e.$$.fragment, p), O(n.$$.fragment, p), O(r.$$.fragment, p), O(a.$$.fragment, p), O(f.$$.fragment, p), d = !1;
    },
    d(p) {
      p && (C(s), C(l), C(o), C(c)), p && e && C(t), N(e, p), N(n, p), N(r, p), N(a, p), N(f, p);
    }
  };
}
u(wee, "create_fragment$2$");
function $ee(i, e, t) {
  let s, n;
  function l(S) {
    t(4, s = S), te(n, `system.actions.${d}.rolls.${c}.ability`, s);
  }
  u(l, "updateAbility");
  let { deleteRoll: r } = e, { duplicateRoll: o } = e, { roll: a } = e, { rollId: c } = e;
  const f = de("item");
  pe(i, f, (S) => t(5, n = S));
  const d = de("actionId"), p = Object.entries(CONFIG.A5E.tools).map(([S, D]) => Object.entries(D)).flat().sort((S, D) => S[0].toLowerCase().localeCompare(D[0].toLowerCase())), m = /* @__PURE__ */ u(({ target: S }) => te(n, `system.actions.${d}.rolls.${c}.label`, S.value), "change_handler"), g = /* @__PURE__ */ u(() => o(d, a), "func"), h = /* @__PURE__ */ u(() => r(d, c), "func_1"), _ = /* @__PURE__ */ u(({ target: S }) => te(n, `system.actions.${d}.rolls.${c}.tool`, S.value), "change_handler_1"), y = /* @__PURE__ */ u(({ detail: S }) => l(S), "updateSelection_handler"), v = /* @__PURE__ */ u(({ target: S }) => te(n, `system.actions.${d}.rolls.${c}.bonus`, S.value), "change_handler_2"), k = /* @__PURE__ */ u(({ detail: S }) => {
    te(n, `system.actions.${d}.rolls.${c}.default`, S);
  }, "updateSelection_handler_1");
  return i.$$set = (S) => {
    "deleteRoll" in S && t(0, r = S.deleteRoll), "duplicateRoll" in S && t(1, o = S.duplicateRoll), "roll" in S && t(2, a = S.roll), "rollId" in S && t(3, c = S.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && t(4, s = a.ability ?? "none");
  }, [
    r,
    o,
    a,
    c,
    s,
    n,
    l,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    v,
    k
  ];
}
u($ee, "instance$2S");
const gE = class gE extends re {
  constructor(e) {
    super(), oe(this, e, $ee, wee, le, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
u(gE, "ToolCheckRollConfig");
let zy = gE;
function TI(i, e, t) {
  const s = i.slice();
  return s[14] = e[t][0], s[15] = e[t][1].heading, s[16] = e[t][1].singleLabel, s[17] = e[t][1].buttonLabel, s[18] = e[t][1].component, s;
}
u(TI, "get_each_context$1b");
function OI(i, e, t) {
  const s = i.slice();
  return s[21] = e[t][0], s[22] = e[t][1], s;
}
u(OI, "get_each_context_1$i");
function DI(i) {
  let e, t, s, n, l;
  function r() {
    return (
      /*func_2*/
      i[12](
        /*rollType*/
        i[14]
      )
    );
  }
  return u(r, "func_2"), t = new De({
    props: {
      heading: (
        /*heading*/
        i[15]
      ),
      headerButtons: (
        /*rollType*/
        i[14] === "attack" ? [] : [
          {
            classes: "add-button",
            handler: r,
            label: K("A5E.ButtonAddRoll", {
              type: K(
                /*rollType*/
                i[14] === "damage" ? (
                  /*buttonLabel*/
                  i[17]
                ) : (
                  /*singleLabel*/
                  i[16]
                )
              )
            })
          }
        ]
      ),
      $$slots: { default: [Aee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("li"), s = E("div"), j(t.$$.fragment), n = F(), G(s, "display", "contents"), G(s, "--a5e-section-gap", "0"), b(e, "class", "roll-config-list__item svelte-kn00p3");
    },
    m(o, a) {
      T(o, e, a), A(e, s), R(t, s, null), A(e, n), l = !0;
    },
    p(o, a) {
      i = o;
      const c = {};
      a & /*$item, action*/
      3 && (c.headerButtons = /*rollType*/
      i[14] === "attack" ? [] : [
        {
          classes: "add-button",
          handler: r,
          label: K("A5E.ButtonAddRoll", {
            type: K(
              /*rollType*/
              i[14] === "damage" ? (
                /*buttonLabel*/
                i[17]
              ) : (
                /*singleLabel*/
                i[16]
              )
            )
          })
        }
      ]), a & /*$$scope, rolls*/
      33554440 && (c.$$scope = { dirty: a, ctx: i }), t.$set(c);
    },
    i(o) {
      l || (w(t.$$.fragment, o), l = !0);
    },
    o(o) {
      O(t.$$.fragment, o), l = !1;
    },
    d(o) {
      o && C(e), N(t);
    }
  };
}
u(DI, "create_if_block$1J");
function II(i, e) {
  let t, s, n, l;
  var r = (
    /*component*/
    e[18]
  );
  function o(a, c) {
    return {
      props: {
        deleteRoll: (
          /*deleteRoll*/
          a[4]
        ),
        duplicateRoll: (
          /*duplicateRoll*/
          a[5]
        ),
        roll: (
          /*roll*/
          a[22]
        ),
        rollId: (
          /*rollId*/
          a[21]
        )
      }
    };
  }
  return u(o, "switch_props"), r && (s = et(r, o(e))), {
    key: i,
    first: null,
    c() {
      t = E("li"), s && j(s.$$.fragment), n = F(), b(t, "class", "a5e-item a5e-item--action-config"), this.first = t;
    },
    m(a, c) {
      T(a, t, c), s && R(s, t, null), A(t, n), l = !0;
    },
    p(a, c) {
      if (e = a, r !== (r = /*component*/
      e[18])) {
        if (s) {
          ae();
          const f = s;
          O(f.$$.fragment, 1, 0, () => {
            N(f, 1);
          }), ce();
        }
        r ? (s = et(r, o(e)), j(s.$$.fragment), w(s.$$.fragment, 1), R(s, t, n)) : s = null;
      } else if (r) {
        const f = {};
        c & /*rolls*/
        8 && (f.roll = /*roll*/
        e[22]), c & /*rolls*/
        8 && (f.rollId = /*rollId*/
        e[21]), s.$set(f);
      }
    },
    i(a) {
      l || (s && w(s.$$.fragment, a), l = !0);
    },
    o(a) {
      s && O(s.$$.fragment, a), l = !1;
    },
    d(a) {
      a && C(t), s && N(s);
    }
  };
}
u(II, "create_each_block_1$i");
function Aee(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n;
  function l(...a) {
    return (
      /*func_1*/
      i[11](
        /*rollType*/
        i[14],
        ...a
      )
    );
  }
  u(l, "func_1");
  let r = ue(Object.entries(
    /*rolls*/
    i[3]
  ).filter(l));
  const o = /* @__PURE__ */ u((a) => (
    /*rollId*/
    a[21]
  ), "get_key");
  for (let a = 0; a < r.length; a += 1) {
    let c = OI(i, r, a), f = o(c);
    s.set(f, t[a] = II(f, c));
  }
  return {
    c() {
      e = E("ul");
      for (let a = 0; a < t.length; a += 1)
        t[a].c();
      b(e, "class", "a5e-item-list");
    },
    m(a, c) {
      T(a, e, c);
      for (let f = 0; f < t.length; f += 1)
        t[f] && t[f].m(e, null);
      n = !0;
    },
    p(a, c) {
      i = a, c & /*Object, rollTypes, deleteRoll, duplicateRoll, rolls*/
      312 && (r = ue(Object.entries(
        /*rolls*/
        i[3]
      ).filter(l)), ae(), t = Lt(t, c, o, 1, i, r, s, e, cn, II, null, OI), ce());
    },
    i(a) {
      if (!n) {
        for (let c = 0; c < r.length; c += 1)
          w(t[c]);
        n = !0;
      }
    },
    o(a) {
      for (let c = 0; c < t.length; c += 1)
        O(t[c]);
      n = !1;
    },
    d(a) {
      a && C(e);
      for (let c = 0; c < t.length; c += 1)
        t[c].d();
    }
  };
}
u(Aee, "create_default_slot$1l");
function PI(i, e) {
  let t, s = Object.values(
    /*rolls*/
    e[3]
  ).filter(r).length, n, l;
  function r(...a) {
    return (
      /*func*/
      e[10](
        /*rollType*/
        e[14],
        ...a
      )
    );
  }
  u(r, "func");
  let o = s && DI(e);
  return {
    key: i,
    first: null,
    c() {
      t = $e(), o && o.c(), n = $e(), this.first = t;
    },
    m(a, c) {
      T(a, t, c), o && o.m(a, c), T(a, n, c), l = !0;
    },
    p(a, c) {
      e = a, c & /*rolls*/
      8 && (s = Object.values(
        /*rolls*/
        e[3]
      ).filter(r).length), s ? o ? (o.p(e, c), c & /*rolls*/
      8 && w(o, 1)) : (o = DI(e), o.c(), w(o, 1), o.m(n.parentNode, n)) : o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce());
    },
    i(a) {
      l || (w(o), l = !0);
    },
    o(a) {
      O(o), l = !1;
    },
    d(a) {
      a && (C(t), C(n)), o && o.d(a);
    }
  };
}
u(PI, "create_each_block$1b");
function Eee(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r, o, a, c = ue(Object.entries(
    /*rollTypes*/
    i[8]
  ));
  const f = /* @__PURE__ */ u((d) => (
    /*rollType*/
    d[14]
  ), "get_key");
  for (let d = 0; d < c.length; d += 1) {
    let p = TI(i, c, d), m = f(p);
    n.set(m, s[d] = PI(m, p));
  }
  return o = new Tn({
    props: {
      menuList: (
        /*menuList*/
        i[2]
      ),
      offset: { x: -110, y: -140 },
      documentName: "Roll"
    }
  }), o.$on(
    "press",
    /*press_handler*/
    i[13]
  ), {
    c() {
      e = E("div"), t = E("ul");
      for (let d = 0; d < s.length; d += 1)
        s[d].c();
      l = F(), r = E("div"), j(o.$$.fragment), b(t, "class", "roll-config-list svelte-kn00p3"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(r, "class", "sticky-add-button svelte-kn00p3");
    },
    m(d, p) {
      T(d, e, p), A(e, t);
      for (let m = 0; m < s.length; m += 1)
        s[m] && s[m].m(t, null);
      T(d, l, p), T(d, r, p), R(o, r, null), a = !0;
    },
    p(d, [p]) {
      p & /*Object, rollTypes, $item, actionId, action, rolls, deleteRoll, duplicateRoll*/
      443 && (c = ue(Object.entries(
        /*rollTypes*/
        d[8]
      )), ae(), s = Lt(s, p, f, 1, d, c, n, t, cn, PI, null, TI), ce());
      const m = {};
      p & /*menuList*/
      4 && (m.menuList = /*menuList*/
      d[2]), o.$set(m);
    },
    i(d) {
      if (!a) {
        for (let p = 0; p < c.length; p += 1)
          w(s[p]);
        w(o.$$.fragment, d), a = !0;
      }
    },
    o(d) {
      for (let p = 0; p < s.length; p += 1)
        O(s[p]);
      O(o.$$.fragment, d), a = !1;
    },
    d(d) {
      d && (C(e), C(l), C(r));
      for (let p = 0; p < s.length; p += 1)
        s[p].d();
      N(o);
    }
  };
}
u(Eee, "create_fragment$2_");
function See(i, e, t) {
  let s, n, l, r, o;
  async function a(y, v) {
    const k = o.dialogs.rollScaling[v];
    await (k == null ? void 0 : k.close()), delete o.dialogs.rollScaling[v], o.update({
      [`system.actions.${y}.rolls`]: { [`-=${v}`]: null }
    });
  }
  u(a, "deleteRoll");
  function c(y, v) {
    const k = foundry.utils.duplicate(v);
    o.update({
      [`system.actions.${y}.rolls`]: { [foundry.utils.randomID()]: k }
    });
  }
  u(c, "duplicateRoll");
  const f = de("item");
  pe(i, f, (y) => t(1, o = y));
  const d = de("actionId"), p = {
    attack: {
      heading: "A5E.ItemAttackRoll",
      singleLabel: "A5E.ItemAttackRoll",
      component: Ny
    },
    damage: {
      heading: "A5E.ItemDamageRollPlural",
      buttonLabel: "A5E.Damage",
      singleLabel: "A5E.ItemDamageRoll",
      component: jy
    },
    healing: {
      heading: "A5E.ItemHealingRollPlural",
      singleLabel: "A5E.Healing",
      component: By
    },
    abilityCheck: {
      heading: "A5E.AbilityCheckPlural",
      singleLabel: "A5E.AbilityCheck",
      component: Ry
    },
    skillCheck: {
      heading: "A5E.SkillCheckPlural",
      singleLabel: "A5E.SkillCheckSingular",
      component: Gy
    },
    toolCheck: {
      heading: "A5E.ToolCheckPlural",
      singleLabel: "A5E.ToolCheck",
      component: zy
    },
    savingThrow: {
      heading: "A5E.SavingThrowPlural",
      singleLabel: "A5E.SavingThrow",
      component: qy
    },
    generic: {
      heading: "A5E.OtherPlural",
      singleLabel: "A5E.Other",
      component: Ly
    }
  }, m = /* @__PURE__ */ u((y, v) => v.type === y, "func"), g = /* @__PURE__ */ u((y, [v, k]) => k.type === y, "func_1"), h = /* @__PURE__ */ u((y) => cl.addRoll(o, [d, s], y), "func_2"), _ = /* @__PURE__ */ u(({ detail: y }) => cl.addRoll(o, [d, s], y), "press_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    2 && t(0, s = o.actions.get(d)), i.$$.dirty & /*action*/
    1 && t(3, n = s.rolls ?? {}), i.$$.dirty & /*action*/
    1 && t(9, l = Object.entries(s.rolls ?? {}).filter(([y, v]) => v.type === "attack")), i.$$.dirty & /*attackRolls*/
    512 && t(2, r = Object.entries(p).reduce(
      (y, [v, { singleLabel: k }]) => (v === "attack" && l.length > 0 || y.push([v, k]), y),
      []
    ));
  }, [
    s,
    o,
    r,
    n,
    a,
    c,
    f,
    d,
    p,
    l,
    m,
    g,
    h,
    _
  ];
}
u(See, "instance$2R");
const bE = class bE extends re {
  constructor(e) {
    super(), oe(this, e, See, Eee, le, {});
  }
};
u(bE, "ActionsRollsTab");
let Hy = bE;
function MI(i, e, t) {
  const s = i.slice();
  return s[15] = e[t].name, s[16] = e[t].id, s;
}
u(MI, "get_each_context$1a");
function Cee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Cee, "create_default_slot_5$i");
function Tee(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Select Consumer Automatically in Roll Prompt",
      checked: (
        /*consumer*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[10]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*consumer*/
      1 && (l.checked = /*consumer*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Tee, "create_default_slot_4$k");
function FI(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r, o, a = ue(
    /*ammunitionItems*/
    i[5]
  );
  const c = /* @__PURE__ */ u((f) => (
    /*id*/
    f[16]
  ), "get_key");
  for (let f = 0; f < a.length; f += 1) {
    let d = MI(i, a, f), p = c(d);
    n.set(p, s[f] = RI(p, d));
  }
  return {
    c() {
      e = E("select"), t = E("option");
      for (let f = 0; f < s.length; f += 1)
        s[f].c();
      t.__value = "", He(t, t.__value), b(e, "id", l = /*actionId*/
      i[7] + "-" + /*consumerId*/
      i[1] + "-item-id"), b(e, "class", "u-w-fit"), /*selectedItem*/
      i[3] === void 0 && ks(() => (
        /*select_change_handler*/
        i[11].call(e)
      ));
    },
    m(f, d) {
      T(f, e, d), A(e, t);
      for (let p = 0; p < s.length; p += 1)
        s[p] && s[p].m(e, null);
      Ys(
        e,
        /*selectedItem*/
        i[3],
        !0
      ), r || (o = W(
        e,
        "change",
        /*select_change_handler*/
        i[11]
      ), r = !0);
    },
    p(f, d) {
      d & /*ammunitionItems, consumer*/
      33 && (a = ue(
        /*ammunitionItems*/
        f[5]
      ), s = Lt(s, d, c, 1, f, a, n, e, an, RI, null, MI)), d & /*consumerId*/
      2 && l !== (l = /*actionId*/
      f[7] + "-" + /*consumerId*/
      f[1] + "-item-id") && b(e, "id", l), d & /*selectedItem, ammunitionItems*/
      40 && Ys(
        e,
        /*selectedItem*/
        f[3]
      );
    },
    d(f) {
      f && C(e);
      for (let d = 0; d < s.length; d += 1)
        s[d].d();
      r = !1, o();
    }
  };
}
u(FI, "create_if_block_1$19");
function RI(i, e) {
  let t, s = (
    /*name*/
    e[15] + ""
  ), n, l, r, o;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = Q(s), l = F(), t.__value = r = /*id*/
      e[16], He(t, t.__value), t.selected = o = /*consumer*/
      e[0].itemId === /*id*/
      e[16], this.first = t;
    },
    m(a, c) {
      T(a, t, c), A(t, n), A(t, l);
    },
    p(a, c) {
      e = a, c & /*ammunitionItems*/
      32 && s !== (s = /*name*/
      e[15] + "") && be(n, s), c & /*ammunitionItems*/
      32 && r !== (r = /*id*/
      e[16]) && (t.__value = r, He(t, t.__value)), c & /*consumer, ammunitionItems*/
      33 && o !== (o = /*consumer*/
      e[0].itemId === /*id*/
      e[16]) && (t.selected = o);
    },
    d(a) {
      a && C(t);
    }
  };
}
u(RI, "create_each_block$1a");
function Oee(i) {
  let e, t = (
    /*$item*/
    i[4].actor && FI(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*$item*/
      s[4].actor ? t ? t.p(s, n) : (t = FI(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(Oee, "create_default_slot_3$t");
function NI(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "A5E.ItemQuantity",
      $$slots: { default: [Dee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, consumer, $item, consumerId*/
      524307 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(NI, "create_if_block$1I");
function Dee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), e.value = t = /*consumer*/
      i[0].quantity ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[12]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].quantity ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Dee, "create_default_slot_2$A");
function Iee(i) {
  let e, t, s, n;
  e = new ie({
    props: {
      heading: "A5E.Item",
      warning: "Item selection will be available when item is on an actor.",
      showWarning: !/*$item*/
      i[4].actor,
      $$slots: { default: [Oee] },
      $$scope: { ctx: i }
    }
  });
  let l = (
    /*$item*/
    i[4].actor && NI(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), l && l.c(), s = $e();
    },
    m(r, o) {
      R(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$item*/
      16 && (a.showWarning = !/*$item*/
      r[4].actor), o & /*$$scope, consumerId, selectedItem, ammunitionItems, consumer, $item*/
      524347 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a), /*$item*/
      r[4].actor ? l ? (l.p(r, o), o & /*$item*/
      16 && w(l, 1)) : (l = NI(r), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ae(), O(l, 1, 1, () => {
        l = null;
      }), ce());
    },
    i(r) {
      n || (w(e.$$.fragment, r), w(l), n = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(l), n = !1;
    },
    d(r) {
      r && (C(t), C(s)), N(e, r), l && l.d(r);
    }
  };
}
u(Iee, "create_default_slot_1$I");
function Pee(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Delete item when quantity reaches zero",
      checked: (
        /*consumer*/
        i[0].deleteOnZero ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*consumer*/
      1 && (l.checked = /*consumer*/
      s[0].deleteOnZero ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Pee, "create_default_slot$1k");
function Mee(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            i[9]
          )
        }
      ],
      $$slots: { default: [Cee] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      $$slots: { default: [Tee] },
      $$scope: { ctx: i }
    }
  }), r = new De({
    props: {
      $$slots: { default: [Iee] },
      $$scope: { ctx: i }
    }
  }), c = new ie({
    props: {
      $$slots: { default: [Pee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), o = E("div"), j(r.$$.fragment), a = F(), j(c.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), G(t, "--a5e-header-button-color-hover", "#555"), G(o, "display", "contents"), G(o, "--a5e-section-body-direction", "row"), G(o, "--a5e-section-body-padding", "0"), G(o, "--a5e-section-body-gap", "0.5rem");
    },
    m(d, p) {
      T(d, t, p), R(e, t, null), T(d, s, p), R(n, d, p), T(d, l, p), T(d, o, p), R(r, o, null), T(d, a, p), R(c, d, p), f = !0;
    },
    p(d, [p]) {
      const m = {};
      p & /*deleteConsumer, consumerId*/
      6 && (m.buttons = [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            d[9]
          )
        }
      ]), p & /*$$scope, consumer, $item, consumerId*/
      524307 && (m.$$scope = { dirty: p, ctx: d }), e.$set(m);
      const g = {};
      p & /*$$scope, consumer, $item, consumerId*/
      524307 && (g.$$scope = { dirty: p, ctx: d }), n.$set(g);
      const h = {};
      p & /*$$scope, consumer, $item, consumerId, selectedItem, ammunitionItems*/
      524347 && (h.$$scope = { dirty: p, ctx: d }), r.$set(h);
      const _ = {};
      p & /*$$scope, consumer, $item, consumerId*/
      524307 && (_.$$scope = { dirty: p, ctx: d }), c.$set(_);
    },
    i(d) {
      f || (w(e.$$.fragment, d), w(n.$$.fragment, d), w(r.$$.fragment, d), w(c.$$.fragment, d), f = !0);
    },
    o(d) {
      O(e.$$.fragment, d), O(n.$$.fragment, d), O(r.$$.fragment, d), O(c.$$.fragment, d), f = !1;
    },
    d(d) {
      d && (C(s), C(l), C(a)), d && e && C(t), N(e, d), N(n, d), d && r && C(o), N(r, d), N(c, d);
    }
  };
}
u(Mee, "create_fragment$2Z");
function Fee(i, e, t) {
  let s, n, { consumer: l } = e, { consumerId: r } = e, { deleteConsumer: o } = e;
  const a = de("item");
  pe(i, a, (v) => t(4, n = v));
  const c = de("actionId");
  function f() {
    te(n, `system.actions.${c}.consumers.${r}.itemId`, d);
  }
  u(f, "updateItemSelection");
  let d = l.itemId;
  const p = /* @__PURE__ */ u(() => te(n, `system.actions.${c}.consumers.${r}.label`), "change_handler"), m = /* @__PURE__ */ u(() => o(c, r), "func"), g = /* @__PURE__ */ u(({ detail: v }) => te(n, `system.actions.${c}.consumers.${r}.default`, v), "updateSelection_handler");
  function h() {
    d = fo(this), t(3, d), t(5, s), t(4, n);
  }
  u(h, "select_change_handler");
  const _ = /* @__PURE__ */ u(({ target: v }) => te(n, `system.actions.${c}.consumers.${r}.quantity`, Number(v.value)), "change_handler_1"), y = /* @__PURE__ */ u(({ detail: v }) => te(n, `system.actions.${c}.consumers.${r}.deleteOnZero`, v), "updateSelection_handler_1");
  return i.$$set = (v) => {
    "consumer" in v && t(0, l = v.consumer), "consumerId" in v && t(1, r = v.consumerId), "deleteConsumer" in v && t(2, o = v.deleteConsumer);
  }, i.$$.update = () => {
    i.$$.dirty & /*selectedItem*/
    8 && f(), i.$$.dirty & /*$item*/
    16 && t(5, s = n.actor ? n.actor.items.filter((v) => v.type === "object" && v.system.objectType === "ammunition").map((v) => ({ name: v.name, id: v.id })).sort((v, k) => v.name.toLowerCase().localeCompare(k.name.toLowerCase())) : []);
  }, [
    l,
    r,
    o,
    d,
    n,
    s,
    a,
    c,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
u(Fee, "instance$2Q");
const _E = class _E extends re {
  constructor(e) {
    super(), oe(this, e, Fee, Mee, le, {
      consumer: 0,
      consumerId: 1,
      deleteConsumer: 2
    });
  }
};
u(_E, "AmmoConsumer");
let Uy = _E;
function Ree(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Ree, "create_default_slot$1j");
function Nee(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            i[8]
          )
        }
      ],
      $$slots: { default: [Ree] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), G(t, "--a5e-header-button-color-hover", "#555");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*deleteConsumer, consumerId*/
      6 && (r.buttons = [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            n[8]
          )
        }
      ]), l & /*$$scope, consumer, $item, consumerId*/
      8203 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Nee, "create_fragment$2Y");
function jee(i, e, t) {
  let s, n, { consumer: l } = e, { consumerId: r } = e, { deleteConsumer: o } = e;
  const a = de("item");
  pe(i, a, (_) => t(3, n = _));
  const c = de("actionId");
  function f() {
    te(n, `system.actions.${c}.consumers.${r}.defaultDie`, s);
  }
  u(f, "updateSelection");
  const p = (n.actor ? N5(n.actor) : []).reduce(
    (_, { die: y, total: v }) => (v > 0 && _.push([y, y]), _),
    []
  ), m = p.length ? p[0][0] : "";
  s || f();
  const g = /* @__PURE__ */ u(({ target: _ }) => te(n, `system.actions.${c}.consumers.${r}.label`, _.value), "change_handler"), h = /* @__PURE__ */ u(() => o(c, r), "func");
  return i.$$set = (_) => {
    "consumer" in _ && t(0, l = _.consumer), "consumerId" in _ && t(1, r = _.consumerId), "deleteConsumer" in _ && t(2, o = _.deleteConsumer);
  }, i.$$.update = () => {
    i.$$.dirty & /*consumer*/
    1 && t(6, s = l.defaultDie ?? m), i.$$.dirty & /*selected*/
    64 && f();
  }, [
    l,
    r,
    o,
    n,
    a,
    c,
    s,
    g,
    h
  ];
}
u(jee, "instance$2P");
const yE = class yE extends re {
  constructor(e) {
    super(), oe(this, e, jee, Nee, le, {
      consumer: 0,
      consumerId: 1,
      deleteConsumer: 2
    });
  }
};
u(yE, "HitDiceConsumer");
let Vy = yE;
function jI(i, e, t) {
  const s = i.slice();
  return s[16] = e[t][0], s[17] = e[t][1], s;
}
u(jI, "get_each_context$19");
function LI(i, e, t) {
  const s = i.slice();
  return s[20] = e[t].name, s[21] = e[t].id, s;
}
u(LI, "get_each_context_1$h");
function Lee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Lee, "create_default_slot_5$h");
function Bee(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Select Consumer Automatically in Roll Prompt",
      checked: (
        /*consumer*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[11]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*consumer*/
      1 && (l.checked = /*consumer*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Bee, "create_default_slot_4$j");
function BI(i) {
  let e, t, s, n, l, r = ue(Object.entries(
    /*optGroup*/
    i[5]
  )), o = [];
  for (let a = 0; a < r.length; a += 1)
    o[a] = GI(jI(i, r, a));
  return {
    c() {
      e = E("select"), t = E("option");
      for (let a = 0; a < o.length; a += 1)
        o[a].c();
      t.__value = "", He(t, t.__value), b(e, "id", s = /*actionId*/
      i[7] + "-" + /*consumerId*/
      i[1] + "-item-id"), b(e, "class", "u-w-fit"), /*selectedItem*/
      i[3] === void 0 && ks(() => (
        /*select_change_handler*/
        i[12].call(e)
      ));
    },
    m(a, c) {
      T(a, e, c), A(e, t);
      for (let f = 0; f < o.length; f += 1)
        o[f] && o[f].m(e, null);
      Ys(
        e,
        /*selectedItem*/
        i[3],
        !0
      ), n || (l = W(
        e,
        "change",
        /*select_change_handler*/
        i[12]
      ), n = !0);
    },
    p(a, c) {
      if (c & /*A5E, Object, optGroup, consumer*/
      289) {
        r = ue(Object.entries(
          /*optGroup*/
          a[5]
        ));
        let f;
        for (f = 0; f < r.length; f += 1) {
          const d = jI(a, r, f);
          o[f] ? o[f].p(d, c) : (o[f] = GI(d), o[f].c(), o[f].m(e, null));
        }
        for (; f < o.length; f += 1)
          o[f].d(1);
        o.length = r.length;
      }
      c & /*consumerId*/
      2 && s !== (s = /*actionId*/
      a[7] + "-" + /*consumerId*/
      a[1] + "-item-id") && b(e, "id", s), c & /*selectedItem, Object, optGroup*/
      40 && Ys(
        e,
        /*selectedItem*/
        a[3]
      );
    },
    d(a) {
      a && C(e), Le(o, a), n = !1, l();
    }
  };
}
u(BI, "create_if_block$1H");
function qI(i, e) {
  let t, s = (
    /*name*/
    e[20] + ""
  ), n, l, r, o;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = Q(s), l = F(), t.__value = r = /*id*/
      e[21], He(t, t.__value), t.selected = o = /*consumer*/
      e[0].itemId, this.first = t;
    },
    m(a, c) {
      T(a, t, c), A(t, n), A(t, l);
    },
    p(a, c) {
      e = a, c & /*optGroup*/
      32 && s !== (s = /*name*/
      e[20] + "") && be(n, s), c & /*optGroup*/
      32 && r !== (r = /*id*/
      e[21]) && (t.__value = r, He(t, t.__value)), c & /*consumer*/
      1 && o !== (o = /*consumer*/
      e[0].itemId) && (t.selected = o);
    },
    d(a) {
      a && C(t);
    }
  };
}
u(qI, "create_each_block_1$h");
function GI(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l = ue(
    /*objects*/
    i[17].sort(zI)
  );
  const r = /* @__PURE__ */ u((o) => (
    /*id*/
    o[21]
  ), "get_key");
  for (let o = 0; o < l.length; o += 1) {
    let a = LI(i, l, o), c = r(a);
    s.set(c, t[o] = qI(c, a));
  }
  return {
    c() {
      e = E("optgroup");
      for (let o = 0; o < t.length; o += 1)
        t[o].c();
      b(e, "label", n = K(
        /*A5E*/
        i[8].objectTypesPlural[
          /*type*/
          i[16]
        ]
      ));
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < t.length; c += 1)
        t[c] && t[c].m(e, null);
    },
    p(o, a) {
      a & /*Object, optGroup, consumer*/
      33 && (l = ue(
        /*objects*/
        o[17].sort(zI)
      ), t = Lt(t, a, r, 1, o, l, s, e, an, qI, null, LI)), a & /*optGroup*/
      32 && n !== (n = K(
        /*A5E*/
        o[8].objectTypesPlural[
          /*type*/
          o[16]
        ]
      )) && b(e, "label", n);
    },
    d(o) {
      o && C(e);
      for (let a = 0; a < t.length; a += 1)
        t[a].d();
    }
  };
}
u(GI, "create_each_block$19");
function qee(i) {
  let e, t = (
    /*$item*/
    i[4].actor && BI(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*$item*/
      s[4].actor ? t ? t.p(s, n) : (t = BI(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(qee, "create_default_slot_3$s");
function Gee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), e.value = t = /*consumer*/
      i[0].quantity ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[13]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].quantity ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Gee, "create_default_slot_2$z");
function zee(i) {
  let e, t, s, n, l;
  return e = new ie({
    props: {
      heading: "A5E.Item",
      warning: "Item selection will be available when item is on an actor.",
      showWarning: !/*$item*/
      i[4].actor,
      $$slots: { default: [qee] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      heading: "A5E.ItemQuantity",
      $$slots: { default: [Gee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), n = E("div"), j(s.$$.fragment), G(n, "display", "contents"), G(n, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(r, o) {
      R(e, r, o), T(r, t, o), T(r, n, o), R(s, n, null), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$item*/
      16 && (a.showWarning = !/*$item*/
      r[4].actor), o & /*$$scope, consumerId, selectedItem, optGroup, consumer, $item*/
      16777275 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, consumer, $item, consumerId*/
      16777235 && (c.$$scope = { dirty: o, ctx: r }), s.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(s.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(s.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(t), N(e, r), r && s && C(n), N(s, r);
    }
  };
}
u(zee, "create_default_slot_1$H");
function Hee(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Delete item when quantity reaches zero",
      checked: (
        /*consumer*/
        i[0].deleteOnZero ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[14]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*consumer*/
      1 && (l.checked = /*consumer*/
      s[0].deleteOnZero ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Hee, "create_default_slot$1i");
function Uee(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            i[10]
          )
        }
      ],
      $$slots: { default: [Lee] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      $$slots: { default: [Bee] },
      $$scope: { ctx: i }
    }
  }), r = new De({
    props: {
      $$slots: { default: [zee] },
      $$scope: { ctx: i }
    }
  }), c = new ie({
    props: {
      $$slots: { default: [Hee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), o = E("div"), j(r.$$.fragment), a = F(), j(c.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), G(t, "--a5e-header-button-color-hover", "#555"), G(o, "display", "contents"), G(o, "--a5e-section-body-direction", "row"), G(o, "--a5e-section-body-padding", "0"), G(o, "--a5e-section-body-gap", "0.5rem");
    },
    m(d, p) {
      T(d, t, p), R(e, t, null), T(d, s, p), R(n, d, p), T(d, l, p), T(d, o, p), R(r, o, null), T(d, a, p), R(c, d, p), f = !0;
    },
    p(d, [p]) {
      const m = {};
      p & /*deleteConsumer, consumerId*/
      6 && (m.buttons = [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            d[10]
          )
        }
      ]), p & /*$$scope, consumer, $item, consumerId*/
      16777235 && (m.$$scope = { dirty: p, ctx: d }), e.$set(m);
      const g = {};
      p & /*$$scope, consumer, $item, consumerId*/
      16777235 && (g.$$scope = { dirty: p, ctx: d }), n.$set(g);
      const h = {};
      p & /*$$scope, consumer, $item, consumerId, selectedItem, optGroup*/
      16777275 && (h.$$scope = { dirty: p, ctx: d }), r.$set(h);
      const _ = {};
      p & /*$$scope, consumer, $item, consumerId*/
      16777235 && (_.$$scope = { dirty: p, ctx: d }), c.$set(_);
    },
    i(d) {
      f || (w(e.$$.fragment, d), w(n.$$.fragment, d), w(r.$$.fragment, d), w(c.$$.fragment, d), f = !0);
    },
    o(d) {
      O(e.$$.fragment, d), O(n.$$.fragment, d), O(r.$$.fragment, d), O(c.$$.fragment, d), f = !1;
    },
    d(d) {
      d && (C(s), C(l), C(a)), d && e && C(t), N(e, d), N(n, d), d && r && C(o), N(r, d), N(c, d);
    }
  };
}
u(Uee, "create_fragment$2X");
const zI = /* @__PURE__ */ u((i, e) => i.name.toLowerCase().localeCompare(e.name.toLowerCase()), "func_1$2");
function Vee(i, e, t) {
  let s, n, { consumer: l } = e, { consumerId: r } = e, { deleteConsumer: o } = e;
  const a = de("item");
  pe(i, a, (k) => t(4, n = k));
  const c = de("actionId"), f = CONFIG.A5E;
  function d() {
    te(n, `system.actions.${c}.consumers.${r}.itemId`, p);
  }
  u(d, "updateItemSelection");
  let p = l.itemId ?? "";
  const m = /* @__PURE__ */ u(() => te(n, `system.actions.${c}.consumers.${r}.label`), "change_handler"), g = /* @__PURE__ */ u(() => o(c, r), "func"), h = /* @__PURE__ */ u(({ detail: k }) => te(n, `system.actions.${c}.consumers.${r}.default`, k), "updateSelection_handler");
  function _() {
    p = fo(this), t(3, p), t(5, s), t(4, n);
  }
  u(_, "select_change_handler");
  const y = /* @__PURE__ */ u(({ target: k }) => te(n, `system.actions.${c}.consumers.${r}.quantity`, Number(k.value)), "change_handler_1"), v = /* @__PURE__ */ u(({ detail: k }) => te(n, `system.actions.${c}.consumers.${r}.deleteOnZero`, k), "updateSelection_handler_1");
  return i.$$set = (k) => {
    "consumer" in k && t(0, l = k.consumer), "consumerId" in k && t(1, r = k.consumerId), "deleteConsumer" in k && t(2, o = k.deleteConsumer);
  }, i.$$.update = () => {
    i.$$.dirty & /*selectedItem*/
    8 && d(), i.$$.dirty & /*$item*/
    16 && t(5, s = n.actor ? n.actor.items.reduce(
      (k, S) => {
        if (S.type !== "object" || S.system.objectType === "ammunition") return k;
        const D = S.system.objectType, I = { name: S.name, id: S.id };
        return k != null && k[D] ? k[D].push(I) : k[D] = [I], k;
      },
      {}
    ) : []);
  }, [
    l,
    r,
    o,
    p,
    n,
    s,
    a,
    c,
    f,
    m,
    g,
    h,
    _,
    y,
    v
  ];
}
u(Vee, "instance$2O");
const vE = class vE extends re {
  constructor(e) {
    super(), oe(this, e, Vee, Uee, le, {
      consumer: 0,
      consumerId: 1,
      deleteConsumer: 2
    });
  }
};
u(vE, "QuantityConsumer");
let Wy = vE;
function HI(i, e, t) {
  const s = i.slice();
  return s[16] = e[t][0], s[17] = e[t][1].label, s;
}
u(HI, "get_each_context$18");
function Wee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Wee, "create_default_slot_4$i");
function Kee(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Select Consumer Automatically in Roll Prompt",
      checked: (
        /*consumer*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[10]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*consumer*/
      1 && (l.checked = /*consumer*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Kee, "create_default_slot_3$r");
function UI(i, e) {
  let t, s = K(
    /*label*/
    e[17]
  ) + "", n, l;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = Q(s), l = F(), t.__value = /*value*/
      e[16], He(t, t.__value), this.first = t;
    },
    m(r, o) {
      T(r, t, o), A(t, n), A(t, l);
    },
    p(r, o) {
      e = r;
    },
    d(r) {
      r && C(t);
    }
  };
}
u(UI, "create_each_block$18");
function Yee(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r, o, a = ue(Object.entries(
    /*A5E*/
    i[7].resourceConsumerConfig
  ));
  const c = /* @__PURE__ */ u((f) => (
    /*value*/
    f[16]
  ), "get_key");
  for (let f = 0; f < a.length; f += 1) {
    let d = HI(i, a, f), p = c(d);
    n.set(p, s[f] = UI(p, d));
  }
  return {
    c() {
      e = E("select"), t = E("option");
      for (let f = 0; f < s.length; f += 1)
        s[f].c();
      t.__value = "", He(t, t.__value), b(e, "name", l = /*actionId*/
      i[6] + "-" + /*consumerId*/
      i[1] + "-item-id"), b(e, "class", "u-w-fit"), /*selectedResource*/
      i[3] === void 0 && ks(() => (
        /*select_change_handler*/
        i[11].call(e)
      ));
    },
    m(f, d) {
      T(f, e, d), A(e, t);
      for (let p = 0; p < s.length; p += 1)
        s[p] && s[p].m(e, null);
      Ys(
        e,
        /*selectedResource*/
        i[3],
        !0
      ), r || (o = W(
        e,
        "change",
        /*select_change_handler*/
        i[11]
      ), r = !0);
    },
    p(f, d) {
      d & /*Object, A5E*/
      128 && (a = ue(Object.entries(
        /*A5E*/
        f[7].resourceConsumerConfig
      )), s = Lt(s, d, c, 1, f, a, n, e, an, UI, null, HI)), d & /*consumerId*/
      2 && l !== (l = /*actionId*/
      f[6] + "-" + /*consumerId*/
      f[1] + "-item-id") && b(e, "name", l), d & /*selectedResource, Object, A5E*/
      136 && Ys(
        e,
        /*selectedResource*/
        f[3]
      );
    },
    d(f) {
      f && C(e);
      for (let d = 0; d < s.length; d += 1)
        s[d].d();
      r = !1, o();
    }
  };
}
u(Yee, "create_default_slot_2$y");
function VI(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "Resource Identifier",
      $$slots: { default: [Xee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-width", "16rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, consumer, $item, consumerId*/
      1048595 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(VI, "create_if_block_2$N");
function Xee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--slim"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].classIdentifier ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[12]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].classIdentifier ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Xee, "create_default_slot_1$G");
function WI(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "A5E.ConsumeValue",
      $$slots: { default: [Jee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, consumer, $item, consumerId*/
      1048595 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(WI, "create_if_block_1$18");
function Jee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), e.value = t = /*consumer*/
      i[0].quantity ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_2*/
        i[13]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].quantity ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Jee, "create_default_slot$1h");
function KI(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.ConsumerRestoreResourceOnUse",
      checked: (
        /*consumer*/
        i[0].restore ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[14]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*consumer*/
      1 && (l.checked = /*consumer*/
      s[0].restore ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(KI, "create_if_block$1G");
function Zee(i) {
  var _, y, v, k;
  let e, t, s, n, l, r, o, a, c, f, d, p;
  e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            i[9]
          )
        }
      ],
      $$slots: { default: [Wee] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      $$slots: { default: [Kee] },
      $$scope: { ctx: i }
    }
  }), o = new ie({
    props: {
      heading: "A5E.Resource",
      $$slots: { default: [Yee] },
      $$scope: { ctx: i }
    }
  });
  let m = (
    /*selectedResource*/
    i[3] === "classResource" && VI(i)
  ), g = (
    /*A5E*/
    ((y = (_ = i[7].resourceConsumerConfig) == null ? void 0 : _[
      /*selectedResource*/
      i[3]
    ]) == null ? void 0 : y.type) === "value" && WI(i)
  ), h = (
    /*A5E*/
    ((k = (v = i[7].resourceConsumerConfig) == null ? void 0 : v[
      /*selectedResource*/
      i[3]
    ]) == null ? void 0 : k.type) === "boolean" && KI(i)
  );
  return {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), r = E("div"), j(o.$$.fragment), a = F(), m && m.c(), c = F(), g && g.c(), f = F(), h && h.c(), d = $e(), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), G(t, "--a5e-header-button-color-hover", "#555"), b(r, "class", "a5e-field-group u-flex-row u-gap-md");
    },
    m(S, D) {
      T(S, t, D), R(e, t, null), T(S, s, D), R(n, S, D), T(S, l, D), T(S, r, D), R(o, r, null), A(r, a), m && m.m(r, null), A(r, c), g && g.m(r, null), T(S, f, D), h && h.m(S, D), T(S, d, D), p = !0;
    },
    p(S, [D]) {
      var B, z, q, U;
      const I = {};
      D & /*deleteConsumer, consumerId*/
      6 && (I.buttons = [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            S[9]
          )
        }
      ]), D & /*$$scope, consumer, $item, consumerId*/
      1048595 && (I.$$scope = { dirty: D, ctx: S }), e.$set(I);
      const M = {};
      D & /*$$scope, consumer, $item, consumerId*/
      1048595 && (M.$$scope = { dirty: D, ctx: S }), n.$set(M);
      const L = {};
      D & /*$$scope, consumerId, selectedResource*/
      1048586 && (L.$$scope = { dirty: D, ctx: S }), o.$set(L), /*selectedResource*/
      S[3] === "classResource" ? m ? (m.p(S, D), D & /*selectedResource*/
      8 && w(m, 1)) : (m = VI(S), m.c(), w(m, 1), m.m(r, c)) : m && (ae(), O(m, 1, 1, () => {
        m = null;
      }), ce()), /*A5E*/
      ((z = (B = S[7].resourceConsumerConfig) == null ? void 0 : B[
        /*selectedResource*/
        S[3]
      ]) == null ? void 0 : z.type) === "value" ? g ? (g.p(S, D), D & /*selectedResource*/
      8 && w(g, 1)) : (g = WI(S), g.c(), w(g, 1), g.m(r, null)) : g && (ae(), O(g, 1, 1, () => {
        g = null;
      }), ce()), /*A5E*/
      ((U = (q = S[7].resourceConsumerConfig) == null ? void 0 : q[
        /*selectedResource*/
        S[3]
      ]) == null ? void 0 : U.type) === "boolean" ? h ? (h.p(S, D), D & /*selectedResource*/
      8 && w(h, 1)) : (h = KI(S), h.c(), w(h, 1), h.m(d.parentNode, d)) : h && (ae(), O(h, 1, 1, () => {
        h = null;
      }), ce());
    },
    i(S) {
      p || (w(e.$$.fragment, S), w(n.$$.fragment, S), w(o.$$.fragment, S), w(m), w(g), w(h), p = !0);
    },
    o(S) {
      O(e.$$.fragment, S), O(n.$$.fragment, S), O(o.$$.fragment, S), O(m), O(g), O(h), p = !1;
    },
    d(S) {
      S && (C(s), C(l), C(r), C(f), C(d)), S && e && C(t), N(e, S), N(n, S), N(o), m && m.d(), g && g.d(), h && h.d(S);
    }
  };
}
u(Zee, "create_fragment$2W");
function Qee(i, e, t) {
  let s, { consumer: n } = e, { consumerId: l } = e, { deleteConsumer: r } = e;
  const o = de("item");
  pe(i, o, (k) => t(4, s = k));
  const a = de("actionId"), c = CONFIG.A5E;
  function f() {
    te(s, `system.actions.${a}.consumers.${l}.resource`, d);
  }
  u(f, "updateResourceSelection");
  let d = n.resource ?? "";
  const p = /* @__PURE__ */ u(() => te(s, `system.actions.${a}.consumers.${l}.label`), "change_handler"), m = /* @__PURE__ */ u(() => r(a, l), "func"), g = /* @__PURE__ */ u(({ detail: k }) => te(s, `system.actions.${a}.consumers.${l}.default`, k), "updateSelection_handler");
  function h() {
    d = fo(this), t(3, d), t(7, c);
  }
  u(h, "select_change_handler");
  const _ = /* @__PURE__ */ u(({ target: k }) => te(s, `system.actions.${a}.consumers.${l}.classIdentifier`, k.value), "change_handler_1"), y = /* @__PURE__ */ u(({ target: k }) => te(s, `system.actions.${a}.consumers.${l}.quantity`, Number(k.value)), "change_handler_2"), v = /* @__PURE__ */ u(({ detail: k }) => te(s, `system.actions.${a}.consumers.${l}.restore`, k), "updateSelection_handler_1");
  return i.$$set = (k) => {
    "consumer" in k && t(0, n = k.consumer), "consumerId" in k && t(1, l = k.consumerId), "deleteConsumer" in k && t(2, r = k.deleteConsumer);
  }, i.$$.update = () => {
    i.$$.dirty & /*selectedResource*/
    8 && f();
  }, [
    n,
    l,
    r,
    d,
    s,
    o,
    a,
    c,
    p,
    m,
    g,
    h,
    _,
    y,
    v
  ];
}
u(Qee, "instance$2N");
const kE = class kE extends re {
  constructor(e) {
    super(), oe(this, e, Qee, Zee, le, {
      consumer: 0,
      consumerId: 1,
      deleteConsumer: 2
    });
  }
};
u(kE, "ResourceConsumer");
let Ky = kE;
function YI(i, e, t) {
  const s = i.slice();
  return s[20] = e[t][0], s[21] = e[t][1], s;
}
u(YI, "get_each_context$17");
function XI(i, e, t) {
  const s = i.slice();
  return s[20] = e[t][0], s[21] = e[t][1], s;
}
u(XI, "get_each_context_1$g");
function xee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(xee, "create_default_slot_6$e");
function JI(i) {
  let e, t = K(
    /*label*/
    i[21]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = Q(t), n = F(), e.__value = /*value*/
      i[20], He(e, e.__value), e.selected = l = /*mode*/
      i[3] === /*value*/
      i[20];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*mode, Object, A5E*/
      520 && l !== (l = /*mode*/
      r[3] === /*value*/
      r[20]) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(JI, "create_each_block_1$g");
function ete(i) {
  let e, t, s, n, l = ue(Object.entries(
    /*A5E*/
    i[9].spellConsumerModes
  )), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = JI(XI(i, l, o));
  return {
    c() {
      e = E("select");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      b(e, "name", t = /*actionId*/
      i[8] + "-" + /*consumerId*/
      i[1] + "-item-id"), b(e, "class", "u-w-fit"), /*mode*/
      i[3] === void 0 && ks(() => (
        /*select_change_handler*/
        i[12].call(e)
      ));
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(e, null);
      Ys(
        e,
        /*mode*/
        i[3],
        !0
      ), s || (n = W(
        e,
        "change",
        /*select_change_handler*/
        i[12]
      ), s = !0);
    },
    p(o, a) {
      if (a & /*Object, A5E, mode*/
      520) {
        l = ue(Object.entries(
          /*A5E*/
          o[9].spellConsumerModes
        ));
        let c;
        for (c = 0; c < l.length; c += 1) {
          const f = XI(o, l, c);
          r[c] ? r[c].p(f, a) : (r[c] = JI(f), r[c].c(), r[c].m(e, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
      a & /*consumerId*/
      2 && t !== (t = /*actionId*/
      o[8] + "-" + /*consumerId*/
      o[1] + "-item-id") && b(e, "name", t), a & /*mode, Object, A5E*/
      520 && Ys(
        e,
        /*mode*/
        o[3]
      );
    },
    d(o) {
      o && C(e), Le(r, o), s = !1, n();
    }
  };
}
u(ete, "create_default_slot_5$g");
function ZI(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.SpellLevel",
      $$slots: { default: [tte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, consumerId, spellLevel*/
      67108882 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(ZI, "create_if_block_4$q");
function QI(i) {
  let e, t = K(
    /*label*/
    i[21]
  ) + "", s, n;
  return {
    c() {
      e = E("option"), s = Q(t), n = F(), e.__value = Number(
        /*value*/
        i[20]
      ), He(e, e.__value);
    },
    m(l, r) {
      T(l, e, r), A(e, s), A(e, n);
    },
    p: se,
    d(l) {
      l && C(e);
    }
  };
}
u(QI, "create_each_block$17");
function tte(i) {
  let e, t, s, n, l = ue(Object.entries(
    /*A5E*/
    i[9].spellLevels
  ).slice(1)), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = QI(YI(i, l, o));
  return {
    c() {
      e = E("select");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      b(e, "name", t = /*actionId*/
      i[8] + "-" + /*consumerId*/
      i[1] + "-item-id"), b(e, "class", "u-w-fit"), /*spellLevel*/
      i[4] === void 0 && ks(() => (
        /*select_change_handler_1*/
        i[13].call(e)
      ));
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(e, null);
      Ys(
        e,
        /*spellLevel*/
        i[4],
        !0
      ), s || (n = W(
        e,
        "change",
        /*select_change_handler_1*/
        i[13]
      ), s = !0);
    },
    p(o, a) {
      if (a & /*Number, Object, A5E*/
      512) {
        l = ue(Object.entries(
          /*A5E*/
          o[9].spellLevels
        ).slice(1));
        let c;
        for (c = 0; c < l.length; c += 1) {
          const f = YI(o, l, c);
          r[c] ? r[c].p(f, a) : (r[c] = QI(f), r[c].c(), r[c].m(e, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
      a & /*consumerId*/
      2 && t !== (t = /*actionId*/
      o[8] + "-" + /*consumerId*/
      o[1] + "-item-id") && b(e, "name", t), a & /*spellLevel, Number, Object, A5E*/
      528 && Ys(
        e,
        /*spellLevel*/
        o[4]
      );
    },
    d(o) {
      o && C(e), Le(r, o), s = !1, n();
    }
  };
}
u(tte, "create_default_slot_4$h");
function xI(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "A5E.ArtifactCharges",
      $$slots: { default: [ste] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, consumer, $item, consumerId*/
      67108931 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(xI, "create_if_block_3$v");
function ste(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), e.value = t = /*consumer*/
      i[0].charges ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].charges ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(ste, "create_default_slot_3$q");
function eP(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "A5E.SpellInventions",
      $$slots: { default: [nte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, consumer, $item, consumerId*/
      67108931 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(eP, "create_if_block_2$M");
function nte(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), e.value = t = /*consumer*/
      i[0].inventions ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_2*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].inventions ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(nte, "create_default_slot_2$x");
function tP(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "A5E.SpellPoints",
      $$slots: { default: [ite] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, consumer, $item, consumerId*/
      67108931 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(tP, "create_if_block_1$17");
function ite(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), e.value = t = /*consumer*/
      i[0].points ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_3*/
        i[16]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].points ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(ite, "create_default_slot_1$F");
function sP(i) {
  let e;
  return {
    c() {
      e = E("div"), e.innerHTML = `<dt class="u-text-bold">Variable</dt> <dd class="u-m-0 u-p-0">Variable mode allows you to select from spell slots or spell points at
                casting time.</dd> <dt class="u-text-bold">Spell Points Only</dt> <dd class="u-m-0 u-p-0">Always consumes spells points, ignoring available spell slots.</dd> <dt class="u-text-bold">Spell Slots Only</dt> <dd class="u-m-0 u-p-0">Always consumes spell slots, ignoring available spell points.</dd>`, b(e, "class", "a5e-box hint svelte-1111su9");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(sP, "create_if_block$1F");
function lte(i) {
  let e, t = (
    /*hintToggle*/
    i[5] && sP()
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*hintToggle*/
      s[5] ? t || (t = sP(), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(lte, "create_default_slot$1g");
function rte(i) {
  let e, t, s, n, l, r, o = ["variable", "slotsOnly"].includes(
    /*mode*/
    i[3]
  ), a, c, f, d, p, m, g;
  e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            i[11]
          )
        }
      ],
      $$slots: { default: [xee] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      heading: "A5E.ConsumerSpellMode",
      $$slots: { default: [ete] },
      $$scope: { ctx: i }
    }
  });
  let h = o && ZI(i), _ = (
    /*mode*/
    i[3] === "chargesOnly" && xI(i)
  ), y = (
    /*mode*/
    i[3] === "inventionsOnly" && eP(i)
  ), v = (
    /*mode*/
    i[3] === "pointsOnly" && tP(i)
  );
  return p = new ie({
    props: {
      heading: "A5E.ConsumerSpellModeHintTitle",
      buttons: [
        {
          classes: `fa-solid ${/*hintToggle*/
          i[5] ? "fa-minus" : "fa-plus"}`,
          handler: (
            /*func_1*/
            i[17]
          )
        }
      ],
      $$slots: { default: [lte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), n = E("div"), j(l.$$.fragment), r = F(), h && h.c(), a = F(), _ && _.c(), c = F(), y && y.c(), f = F(), v && v.c(), d = F(), m = E("div"), j(p.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), G(t, "--a5e-header-button-color-hover", "#555"), b(n, "class", "a5e-field-group u-flex-row u-gap-md"), G(m, "display", "contents"), G(m, "--a5e-field-wrapper-header-item-justification", "flex-start"), G(m, "--a5e-field-wrapper-header-gap", "0.5rem");
    },
    m(k, S) {
      T(k, t, S), R(e, t, null), T(k, s, S), T(k, n, S), R(l, n, null), A(n, r), h && h.m(n, null), A(n, a), _ && _.m(n, null), A(n, c), y && y.m(n, null), A(n, f), v && v.m(n, null), T(k, d, S), T(k, m, S), R(p, m, null), g = !0;
    },
    p(k, [S]) {
      const D = {};
      S & /*deleteConsumer, consumerId*/
      6 && (D.buttons = [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            k[11]
          )
        }
      ]), S & /*$$scope, consumer, $item, consumerId*/
      67108931 && (D.$$scope = { dirty: S, ctx: k }), e.$set(D);
      const I = {};
      S & /*$$scope, consumerId, mode*/
      67108874 && (I.$$scope = { dirty: S, ctx: k }), l.$set(I), S & /*mode*/
      8 && (o = ["variable", "slotsOnly"].includes(
        /*mode*/
        k[3]
      )), o ? h ? (h.p(k, S), S & /*mode*/
      8 && w(h, 1)) : (h = ZI(k), h.c(), w(h, 1), h.m(n, a)) : h && (ae(), O(h, 1, 1, () => {
        h = null;
      }), ce()), /*mode*/
      k[3] === "chargesOnly" ? _ ? (_.p(k, S), S & /*mode*/
      8 && w(_, 1)) : (_ = xI(k), _.c(), w(_, 1), _.m(n, c)) : _ && (ae(), O(_, 1, 1, () => {
        _ = null;
      }), ce()), /*mode*/
      k[3] === "inventionsOnly" ? y ? (y.p(k, S), S & /*mode*/
      8 && w(y, 1)) : (y = eP(k), y.c(), w(y, 1), y.m(n, f)) : y && (ae(), O(y, 1, 1, () => {
        y = null;
      }), ce()), /*mode*/
      k[3] === "pointsOnly" ? v ? (v.p(k, S), S & /*mode*/
      8 && w(v, 1)) : (v = tP(k), v.c(), w(v, 1), v.m(n, null)) : v && (ae(), O(v, 1, 1, () => {
        v = null;
      }), ce());
      const M = {};
      S & /*hintToggle*/
      32 && (M.buttons = [
        {
          classes: `fa-solid ${/*hintToggle*/
          k[5] ? "fa-minus" : "fa-plus"}`,
          handler: (
            /*func_1*/
            k[17]
          )
        }
      ]), S & /*$$scope, hintToggle*/
      67108896 && (M.$$scope = { dirty: S, ctx: k }), p.$set(M);
    },
    i(k) {
      g || (w(e.$$.fragment, k), w(l.$$.fragment, k), w(h), w(_), w(y), w(v), w(p.$$.fragment, k), g = !0);
    },
    o(k) {
      O(e.$$.fragment, k), O(l.$$.fragment, k), O(h), O(_), O(y), O(v), O(p.$$.fragment, k), g = !1;
    },
    d(k) {
      k && (C(s), C(n), C(d)), k && e && C(t), N(e, k), N(l), h && h.d(), _ && _.d(), y && y.d(), v && v.d(), k && p && C(m), N(p, k);
    }
  };
}
u(rte, "create_fragment$2V");
function ote(i, e, t) {
  let s, { consumer: n } = e, { consumerId: l } = e, { deleteConsumer: r } = e;
  const o = de("item");
  pe(i, o, (M) => t(6, s = M));
  const a = de("actionId"), c = CONFIG.A5E;
  function f() {
    te(s, `system.actions.${a}.consumers.${l}.mode`, p);
  }
  u(f, "updateMode");
  function d() {
    te(s, `system.actions.${a}.consumers.${l}.spellLevel`, Number(m));
  }
  u(d, "updateSpellLevel");
  let p = n.mode ?? "variable", m = n.spellLevel ?? 1, g = !1;
  const h = /* @__PURE__ */ u(() => te(s, `system.actions.${a}.consumers.${l}.label`), "change_handler"), _ = /* @__PURE__ */ u(() => r(a, l), "func");
  function y() {
    p = fo(this), t(3, p), t(9, c);
  }
  u(y, "select_change_handler");
  function v() {
    m = fo(this), t(4, m), t(9, c);
  }
  u(v, "select_change_handler_1");
  const k = /* @__PURE__ */ u(({ target: M }) => te(s, `system.actions.${a}.consumers.${l}.charges`, Number(M.value)), "change_handler_1"), S = /* @__PURE__ */ u(({ target: M }) => te(s, `system.actions.${a}.consumers.${l}.inventions`, Number(M.value)), "change_handler_2"), D = /* @__PURE__ */ u(({ target: M }) => te(s, `system.actions.${a}.consumers.${l}.points`, Number(M.value)), "change_handler_3"), I = /* @__PURE__ */ u(() => t(5, g = !g), "func_1");
  return i.$$set = (M) => {
    "consumer" in M && t(0, n = M.consumer), "consumerId" in M && t(1, l = M.consumerId), "deleteConsumer" in M && t(2, r = M.deleteConsumer);
  }, i.$$.update = () => {
    i.$$.dirty & /*mode*/
    8 && f(), i.$$.dirty & /*spellLevel*/
    16 && d();
  }, [
    n,
    l,
    r,
    p,
    m,
    g,
    s,
    o,
    a,
    c,
    h,
    _,
    y,
    v,
    k,
    S,
    D,
    I
  ];
}
u(ote, "instance$2M");
const wE = class wE extends re {
  constructor(e) {
    super(), oe(this, e, ote, rte, le, {
      consumer: 0,
      consumerId: 1,
      deleteConsumer: 2
    });
  }
};
u(wE, "SpellConsumer");
let Yy = wE;
function ate(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(ate, "create_default_slot_2$w");
function cte(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Select Consumer Automatically in Roll Prompt",
      checked: (
        /*consumer*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*consumer*/
      1 && (l.checked = /*consumer*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(cte, "create_default_slot_1$E");
function ute(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), e.value = t = /*consumer*/
      i[0].quantity ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].quantity ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(ute, "create_default_slot$1f");
function fte(i) {
  let e, t, s, n, l, r, o, a;
  return e = new ie({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            i[7]
          )
        }
      ],
      $$slots: { default: [ate] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      $$slots: { default: [cte] },
      $$scope: { ctx: i }
    }
  }), r = new ie({
    props: {
      heading: "Default Consumption Amount",
      $$slots: { default: [ute] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), o = E("div"), j(r.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), G(t, "--a5e-header-button-color-hover", "#555"), G(o, "display", "contents"), G(o, "--a5e-field-wrapper-width", "14rem");
    },
    m(c, f) {
      T(c, t, f), R(e, t, null), T(c, s, f), R(n, c, f), T(c, l, f), T(c, o, f), R(r, o, null), a = !0;
    },
    p(c, [f]) {
      const d = {};
      f & /*deleteConsumer, consumerId*/
      6 && (d.buttons = [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            c[7]
          )
        }
      ]), f & /*$$scope, consumer, $item, consumerId*/
      1035 && (d.$$scope = { dirty: f, ctx: c }), e.$set(d);
      const p = {};
      f & /*$$scope, consumer, $item, consumerId*/
      1035 && (p.$$scope = { dirty: f, ctx: c }), n.$set(p);
      const m = {};
      f & /*$$scope, consumer, $item, consumerId*/
      1035 && (m.$$scope = { dirty: f, ctx: c }), r.$set(m);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(n.$$.fragment, c), w(r.$$.fragment, c), a = !0);
    },
    o(c) {
      O(e.$$.fragment, c), O(n.$$.fragment, c), O(r.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (C(s), C(l)), c && e && C(t), N(e, c), N(n, c), c && r && C(o), N(r, c);
    }
  };
}
u(fte, "create_fragment$2U");
function dte(i, e, t) {
  let s, { consumer: n } = e, { consumerId: l } = e, { deleteConsumer: r } = e;
  const o = de("item");
  pe(i, o, (m) => t(3, s = m));
  const a = de("actionId"), c = /* @__PURE__ */ u(({ target: m }) => te(s, `system.actions.${a}.consumers.${l}.label`, m.value), "change_handler"), f = /* @__PURE__ */ u(() => r(a, l), "func"), d = /* @__PURE__ */ u(({ detail: m }) => te(s, `system.actions.${a}.consumers.${l}.default`, m), "updateSelection_handler"), p = /* @__PURE__ */ u(({ target: m }) => te(s, `system.actions.${a}.consumers.${l}.quantity`, Number(m.value)), "change_handler_1");
  return i.$$set = (m) => {
    "consumer" in m && t(0, n = m.consumer), "consumerId" in m && t(1, l = m.consumerId), "deleteConsumer" in m && t(2, r = m.deleteConsumer);
  }, [
    n,
    l,
    r,
    s,
    o,
    a,
    c,
    f,
    d,
    p
  ];
}
u(dte, "instance$2L");
const $E = class $E extends re {
  constructor(e) {
    super(), oe(this, e, dte, fte, le, {
      consumer: 0,
      consumerId: 1,
      deleteConsumer: 2
    });
  }
};
u($E, "UsesConsumer");
let Tp = $E;
function j5(i) {
  return !!i.includes("@classResources.");
}
u(j5, "formulaIsClassResource");
function hc(i, e = {}) {
  try {
    mt(i, e);
  } catch {
    throw ui.notifications.error("Invalid roll formula."), new Error("Invalid Roll Formula.");
  }
}
u(hc, "handleDeterministicInput");
function nP(i, e, t) {
  const s = i.slice();
  return s[19] = e[t][0], s[20] = e[t][1].heading, s[21] = e[t][1].component, s;
}
u(nP, "get_each_context$16");
function iP(i, e, t) {
  const s = i.slice();
  return s[24] = e[t][0], s[25] = e[t][1], s;
}
u(iP, "get_each_context_1$f");
function lP(i, e, t) {
  const s = i.slice();
  return s[28] = e[t][0], s[29] = e[t][1], s;
}
u(lP, "get_each_context_2$3");
function rP(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "A5E.UsesCurrent",
      $$slots: { default: [pte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l[0] & /*action, $item*/
      5 | l[1] & /*$$scope*/
      2 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(rP, "create_if_block_2$L");
function pte(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "number"), b(e, "name", "system.actions." + /*actionId*/
      i[7] + ".uses.value"), e.value = t = /*action*/
      ((l = i[0].uses) == null ? void 0 : l.value) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[12]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r[0] & /*action*/
      1 && t !== (t = /*action*/
      ((o = l[0].uses) == null ? void 0 : o.value) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(pte, "create_default_slot_7$a");
function mte(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "text"), b(e, "name", "system.actions." + /*actionId*/
      i[7] + ".uses.max"), e.value = t = /*action*/
      ((l = i[0].uses) == null ? void 0 : l.max) ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[13]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r[0] & /*action*/
      1 && t !== (t = /*action*/
      ((o = l[0].uses) == null ? void 0 : o.max) ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(mte, "create_default_slot_6$d");
function oP(i) {
  let e, t = K(
    /*name*/
    i[29]
  ) + "", s, n, l;
  return {
    c() {
      var r;
      e = E("option"), s = Q(t), n = F(), e.__value = /*key*/
      i[28], He(e, e.__value), e.selected = l = /*action*/
      ((r = i[0].uses) == null ? void 0 : r.per) === /*key*/
      i[28];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a;
      o[0] & /*action*/
      1 && l !== (l = /*action*/
      ((a = r[0].uses) == null ? void 0 : a.per) === /*key*/
      r[28]) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(oP, "create_each_block_2$3");
function hte(i) {
  let e, t, s, n, l = ue(Object.entries(
    /*A5E*/
    i[8].resourceRecoveryOptions
  )), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = oP(lP(i, l, o));
  return {
    c() {
      e = E("select"), t = E("option");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      t.__value = "", He(t, t.__value), b(e, "class", "u-w-40"), b(e, "name", "system.actions." + /*actionId*/
      i[7] + ".uses.per");
    },
    m(o, a) {
      T(o, e, a), A(e, t);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(e, null);
      s || (n = W(
        e,
        "change",
        /*change_handler_2*/
        i[14]
      ), s = !0);
    },
    p(o, a) {
      if (a[0] & /*A5E, action*/
      257) {
        l = ue(Object.entries(
          /*A5E*/
          o[8].resourceRecoveryOptions
        ));
        let c;
        for (c = 0; c < l.length; c += 1) {
          const f = lP(o, l, c);
          r[c] ? r[c].p(f, a) : (r[c] = oP(f), r[c].c(), r[c].m(e, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
    },
    d(o) {
      o && C(e), Le(r, o), s = !1, n();
    }
  };
}
u(hte, "create_default_slot_5$f");
function gte(i) {
  let e, t, s, n, l, r, o = !/*isClassResource*/
  i[4] && rP(i);
  return t = new ie({
    props: {
      heading: "A5E.UsesMax",
      $$slots: { default: [mte] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      heading: "A5E.UsesPer",
      $$slots: { default: [hte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      o && o.c(), e = F(), s = E("div"), j(t.$$.fragment), n = F(), j(l.$$.fragment), G(s, "display", "contents"), G(s, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(a, c) {
      o && o.m(a, c), T(a, e, c), T(a, s, c), R(t, s, null), T(a, n, c), R(l, a, c), r = !0;
    },
    p(a, c) {
      /*isClassResource*/
      a[4] ? o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce()) : o ? (o.p(a, c), c[0] & /*isClassResource*/
      16 && w(o, 1)) : (o = rP(a), o.c(), w(o, 1), o.m(e.parentNode, e));
      const f = {};
      c[0] & /*action, $item*/
      5 | c[1] & /*$$scope*/
      2 && (f.$$scope = { dirty: c, ctx: a }), t.$set(f);
      const d = {};
      c[0] & /*$item, action*/
      5 | c[1] & /*$$scope*/
      2 && (d.$$scope = { dirty: c, ctx: a }), l.$set(d);
    },
    i(a) {
      r || (w(o), w(t.$$.fragment, a), w(l.$$.fragment, a), r = !0);
    },
    o(a) {
      O(o), O(t.$$.fragment, a), O(l.$$.fragment, a), r = !1;
    },
    d(a) {
      a && (C(e), C(n)), o && o.d(a), a && t && C(s), N(t, a), N(l, a);
    }
  };
}
u(gte, "create_default_slot_4$g");
function aP(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.ItemRechargeConfiguration",
      $$slots: { default: [yte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-direction", "row"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l[0] & /*action, $item*/
      5 | l[1] & /*$$scope*/
      2 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(aP, "create_if_block_1$16");
function bte(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(
        e,
        "id",
        /*actionId*/
        i[7] + "-recharge-formula"
      ), b(e, "type", "text"), e.value = t = /*action*/
      ((r = (l = i[0].uses) == null ? void 0 : l.recharge) == null ? void 0 : r.formula) ?? "1d6", b(e, "placeholder", "1d6");
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_3*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r[0] & /*action*/
      1 && t !== (t = /*action*/
      ((a = (o = l[0].uses) == null ? void 0 : o.recharge) == null ? void 0 : a.formula) ?? "1d6") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(bte, "create_default_slot_3$p");
function _te(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(
        e,
        "id",
        /*actionId*/
        i[7] + "-recharge-threshold"
      ), b(e, "class", "u-text-center"), b(e, "type", "number"), e.value = t = /*action*/
      ((r = (l = i[0].uses) == null ? void 0 : l.recharge) == null ? void 0 : r.threshold) ?? 6;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_4*/
        i[16]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r[0] & /*action*/
      1 && t !== (t = /*action*/
      ((a = (o = l[0].uses) == null ? void 0 : o.recharge) == null ? void 0 : a.threshold) ?? 6) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(_te, "create_default_slot_2$v");
function yte(i) {
  let e, t, s, n, l;
  return e = new ie({
    props: {
      heading: "A5E.ItemRechargeFormula",
      $$slots: { default: [bte] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.ItemRechargeThreshold",
      $$slots: { default: [_te] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-grow", "1");
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), T(r, s, o), R(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o[0] & /*action, $item*/
      5 | o[1] & /*$$scope*/
      2 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o[0] & /*action, $item*/
      5 | o[1] & /*$$scope*/
      2 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(s), r && e && C(t), N(e, r), N(n, r);
    }
  };
}
u(yte, "create_default_slot_1$D");
function cP(i) {
  let e, t, s, n, l;
  return t = new De({
    props: {
      heading: (
        /*heading*/
        i[20]
      ),
      $$slots: { default: [vte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("li"), s = E("div"), j(t.$$.fragment), n = F(), G(s, "display", "contents"), G(s, "--a5e-section-gap", "0"), b(e, "class", "consumers-config-list__item svelte-130759s");
    },
    m(r, o) {
      T(r, e, o), A(e, s), R(t, s, null), A(e, n), l = !0;
    },
    p(r, o) {
      const a = {};
      o[0] & /*consumers*/
      2 | o[1] & /*$$scope*/
      2 && (a.$$scope = { dirty: o, ctx: r }), t.$set(a);
    },
    i(r) {
      l || (w(t.$$.fragment, r), l = !0);
    },
    o(r) {
      O(t.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(e), N(t);
    }
  };
}
u(cP, "create_if_block$1E");
function uP(i, e) {
  let t, s, n, l;
  var r = (
    /*component*/
    e[21]
  );
  function o(a, c) {
    return {
      props: {
        consumer: (
          /*consumer*/
          a[25]
        ),
        consumerId: (
          /*consumerId*/
          a[24]
        ),
        deleteConsumer: (
          /*deleteConsumer*/
          a[5]
        )
      }
    };
  }
  return u(o, "switch_props"), r && (s = et(r, o(e))), {
    key: i,
    first: null,
    c() {
      t = E("li"), s && j(s.$$.fragment), n = F(), b(t, "class", "a5e-item a5e-item--action-config"), this.first = t;
    },
    m(a, c) {
      T(a, t, c), s && R(s, t, null), A(t, n), l = !0;
    },
    p(a, c) {
      if (e = a, r !== (r = /*component*/
      e[21])) {
        if (s) {
          ae();
          const f = s;
          O(f.$$.fragment, 1, 0, () => {
            N(f, 1);
          }), ce();
        }
        r ? (s = et(r, o(e)), j(s.$$.fragment), w(s.$$.fragment, 1), R(s, t, n)) : s = null;
      } else if (r) {
        const f = {};
        c[0] & /*consumers*/
        2 && (f.consumer = /*consumer*/
        e[25]), c[0] & /*consumers*/
        2 && (f.consumerId = /*consumerId*/
        e[24]), s.$set(f);
      }
    },
    i(a) {
      l || (s && w(s.$$.fragment, a), l = !0);
    },
    o(a) {
      s && O(s.$$.fragment, a), l = !1;
    },
    d(a) {
      a && C(t), s && N(s);
    }
  };
}
u(uP, "create_each_block_1$f");
function vte(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n;
  function l(...a) {
    return (
      /*func_1*/
      i[17](
        /*consumerType*/
        i[19],
        ...a
      )
    );
  }
  u(l, "func_1");
  let r = ue(Object.entries(
    /*consumers*/
    i[1]
  ).filter(l));
  const o = /* @__PURE__ */ u((a) => (
    /*consumerId*/
    a[24]
  ), "get_key");
  for (let a = 0; a < r.length; a += 1) {
    let c = iP(i, r, a), f = o(c);
    s.set(f, t[a] = uP(f, c));
  }
  return {
    c() {
      e = E("ul");
      for (let a = 0; a < t.length; a += 1)
        t[a].c();
      b(e, "class", "a5e-item-list");
    },
    m(a, c) {
      T(a, e, c);
      for (let f = 0; f < t.length; f += 1)
        t[f] && t[f].m(e, null);
      n = !0;
    },
    p(a, c) {
      i = a, c[0] & /*consumerTypes, consumers, deleteConsumer*/
      546 && (r = ue(Object.entries(
        /*consumers*/
        i[1]
      ).filter(l)), ae(), t = Lt(t, c, o, 1, i, r, s, e, cn, uP, null, iP), ce());
    },
    i(a) {
      if (!n) {
        for (let c = 0; c < r.length; c += 1)
          w(t[c]);
        n = !0;
      }
    },
    o(a) {
      for (let c = 0; c < t.length; c += 1)
        O(t[c]);
      n = !1;
    },
    d(a) {
      a && C(e);
      for (let c = 0; c < t.length; c += 1)
        t[c].d();
    }
  };
}
u(vte, "create_default_slot$1e");
function fP(i, e) {
  let t, s = Object.values(
    /*consumers*/
    e[1]
  ).filter(r).length, n, l;
  function r(...a) {
    return (
      /*func*/
      e[11](
        /*consumerType*/
        e[19],
        ...a
      )
    );
  }
  u(r, "func");
  let o = s && cP(e);
  return {
    key: i,
    first: null,
    c() {
      t = $e(), o && o.c(), n = $e(), this.first = t;
    },
    m(a, c) {
      T(a, t, c), o && o.m(a, c), T(a, n, c), l = !0;
    },
    p(a, c) {
      e = a, c[0] & /*consumers*/
      2 && (s = Object.values(
        /*consumers*/
        e[1]
      ).filter(r).length), s ? o ? (o.p(e, c), c[0] & /*consumers*/
      2 && w(o, 1)) : (o = cP(e), o.c(), w(o, 1), o.m(n.parentNode, n)) : o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce());
    },
    i(a) {
      l || (w(o), l = !0);
    },
    o(a) {
      O(o), l = !1;
    },
    d(a) {
      a && (C(t), C(n)), o && o.d(a);
    }
  };
}
u(fP, "create_each_block$16");
function kte(i) {
  var _;
  let e, t, s, n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, f, d, p;
  t = new De({
    props: {
      heading: "A5E.Uses",
      $$slots: { default: [gte] },
      $$scope: { ctx: i }
    }
  });
  let m = (
    /*action*/
    ((_ = i[0].uses) == null ? void 0 : _.per) === "recharge" && aP(i)
  ), g = ue(Object.entries(
    /*consumerTypes*/
    i[9]
  ));
  const h = /* @__PURE__ */ u((y) => (
    /*consumerType*/
    y[19]
  ), "get_key");
  for (let y = 0; y < g.length; y += 1) {
    let v = nP(i, g, y), k = h(v);
    a.set(k, o[y] = fP(k, v));
  }
  return d = new Tn({
    props: {
      menuList: (
        /*menuList*/
        i[3]
      ),
      offset: { x: -110, y: -100 },
      documentName: "Consumer"
    }
  }), d.$on(
    "press",
    /*press_handler*/
    i[18]
  ), {
    c() {
      e = E("div"), s = E("div"), j(t.$$.fragment), n = F(), m && m.c(), l = F(), r = E("ul");
      for (let y = 0; y < o.length; y += 1)
        o[y].c();
      c = F(), f = E("div"), j(d.$$.fragment), G(s, "display", "contents"), G(s, "--a5e-section-body-direction", "row"), G(s, "--a5e-section-body-gap", "0.5rem"), b(r, "class", "consumers-config-list svelte-130759s"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(f, "class", "sticky-add-button svelte-130759s");
    },
    m(y, v) {
      T(y, e, v), A(e, s), R(t, s, null), A(e, n), m && m.m(e, null), A(e, l), A(e, r);
      for (let k = 0; k < o.length; k += 1)
        o[k] && o[k].m(r, null);
      T(y, c, v), T(y, f, v), R(d, f, null), p = !0;
    },
    p(y, v) {
      var D;
      const k = {};
      v[0] & /*$item, action, isClassResource*/
      21 | v[1] & /*$$scope*/
      2 && (k.$$scope = { dirty: v, ctx: y }), t.$set(k), /*action*/
      ((D = y[0].uses) == null ? void 0 : D.per) === "recharge" ? m ? (m.p(y, v), v[0] & /*action*/
      1 && w(m, 1)) : (m = aP(y), m.c(), w(m, 1), m.m(e, l)) : m && (ae(), O(m, 1, 1, () => {
        m = null;
      }), ce()), v[0] & /*consumerTypes, consumers, deleteConsumer*/
      546 && (g = ue(Object.entries(
        /*consumerTypes*/
        y[9]
      )), ae(), o = Lt(o, v, h, 1, y, g, a, r, cn, fP, null, nP), ce());
      const S = {};
      v[0] & /*menuList*/
      8 && (S.menuList = /*menuList*/
      y[3]), d.$set(S);
    },
    i(y) {
      if (!p) {
        w(t.$$.fragment, y), w(m);
        for (let v = 0; v < g.length; v += 1)
          w(o[v]);
        w(d.$$.fragment, y), p = !0;
      }
    },
    o(y) {
      O(t.$$.fragment, y), O(m);
      for (let v = 0; v < o.length; v += 1)
        O(o[v]);
      O(d.$$.fragment, y), p = !1;
    },
    d(y) {
      y && (C(e), C(c), C(f)), N(t), m && m.d();
      for (let v = 0; v < o.length; v += 1)
        o[v].d();
      N(d);
    }
  };
}
u(kte, "create_fragment$2T");
function wte(i, e, t) {
  let s, n, l, r, o, a;
  function c(I, M) {
    a.update({
      [`system.actions.${I}.consumers`]: { [`-=${M}`]: null }
    });
  }
  u(c, "deleteConsumer");
  const f = de("item");
  pe(i, f, (I) => t(2, a = I));
  const d = de("actionId"), { A5E: p } = CONFIG, m = {
    ammunition: {
      heading: "A5E.ConsumerAmmunition",
      singleLabel: "A5E.ObjectTypeAmmunition",
      component: Uy
    },
    hitDice: {
      heading: "A5E.ConsumerHitDice",
      singleLabel: "A5E.HitDiceLabel",
      component: Vy
    },
    quantity: {
      heading: "A5E.ConsumerQuantity",
      singleLabel: "A5E.ItemQuantity",
      component: Wy
    },
    resource: {
      heading: "A5E.ConsumerResource",
      singleLabel: "A5E.Resource",
      component: Ky
    },
    spell: {
      heading: "A5E.ConsumerSpell",
      singleLabel: "A5E.Spell",
      component: Yy
    },
    actionUses: {
      heading: "A5E.ConsumerUsesAction",
      singleLabel: "A5E.ConsumerActionUses",
      component: Tp
    },
    itemUses: {
      heading: "A5E.ConsumerUsesItem",
      singleLabel: "A5E.ConsumerItemUses",
      component: Tp
    }
  }, g = /* @__PURE__ */ u((I, M) => M.type === I, "func"), h = /* @__PURE__ */ u(({ target: I }) => te(
    a,
    // @ts-expect-error
    I.name,
    // @ts-expect-error
    Number(I.value)
  ), "change_handler"), _ = /* @__PURE__ */ u(({ target: I }) => {
    hc(I.value), te(a, I.name, I.value);
  }, "change_handler_1"), y = /* @__PURE__ */ u(({ target: I }) => (
    // @ts-expect-error
    te(a, I.name, I.value)
  ), "change_handler_2"), v = /* @__PURE__ */ u(({ target: I }) => {
    hc(I.value), te(
      a,
      `system.actions.${d}.uses.recharge.formula`,
      // @ts-expect-error
      I.value
    );
  }, "change_handler_3"), k = /* @__PURE__ */ u(({ target: I }) => te(
    a,
    `system.actions.${d}.uses.recharge.threshold`,
    // @ts-expect-error
    Number(I.value)
  ), "change_handler_4"), S = /* @__PURE__ */ u((I, [M, L]) => L.type === I, "func_1"), D = /* @__PURE__ */ u(({ detail: I }) => cl.addConsumer(a, [d, s], I), "press_handler");
  return i.$$.update = () => {
    var I;
    i.$$.dirty[0] & /*$item*/
    4 && t(0, s = a.actions.get(d)), i.$$.dirty[0] & /*action*/
    1 && t(1, n = s.consumers ?? {}), i.$$.dirty[0] & /*consumers*/
    2 && t(10, l = new Set(Object.values(n).map((M) => M.type))), i.$$.dirty[0] & /*action*/
    1 && t(4, r = j5(((I = s.uses) == null ? void 0 : I.max) ?? "")), i.$$.dirty[0] & /*existingConsumers*/
    1024 && t(3, o = Object.entries(m).reduce(
      (M, [L, { singleLabel: B }]) => ((L === "resource" || !l.has(L)) && M.push([L, B]), M),
      []
    ));
  }, [
    s,
    n,
    a,
    o,
    r,
    c,
    f,
    d,
    p,
    m,
    l,
    g,
    h,
    _,
    y,
    v,
    k,
    S,
    D
  ];
}
u(wte, "instance$2K");
const AE = class AE extends re {
  constructor(e) {
    super(), oe(this, e, wte, kte, le, {}, null, [-1, -1]);
  }
};
u(AE, "ActionsResourceManagementTab");
let Xy = AE;
var Hf, Uf, ri;
const EE = class EE extends MeasuredTemplate {
  constructor() {
    super(...arguments);
    x(this, Hf, 0);
    x(this, Uf);
    x(this, ri);
  }
  async drawPreview() {
    const t = canvas.activeLayer;
    this.draw();
    try {
      this.layer.activate();
    } catch (s) {
      if (s.name !== "TypeError") throw new Error(s);
    }
    return this.layer.preview.addChild(this), this.activatePreviewListeners(t);
  }
  activatePreviewListeners(t) {
    return new Promise((s, n) => {
      Ae(this, Uf, t), Ae(this, ri, {
        cancel: this._onCancel.bind(this),
        confirm: this._onConfirm.bind(this),
        move: this._onMove.bind(this),
        rotate: this._onRotate.bind(this),
        resolve: s,
        reject: n
      }), canvas.stage.on("mousemove", P(this, ri).move), canvas.stage.on("mousedown", P(this, ri).confirm), canvas.app.view.oncontextmenu = P(this, ri).cancel, canvas.app.view.onwheel = P(this, ri).rotate;
    });
  }
  async _finishPlacement(t) {
    this.layer._onDragLeftCancel(t ?? {}), canvas.stage.off("mousemove", P(this, ri).move), canvas.stage.off("mousedown", P(this, ri).confirm), canvas.app.view.oncontextmenu = null, canvas.app.view.onwheel = null, P(this, Uf).activate();
  }
  _onMove(t) {
    t.stopPropagation();
    const s = Date.now();
    if (s - P(this, Hf) <= 10) return;
    const n = t.data.getLocalPosition(this.layer), l = canvas.templates.getSnappedPoint(n);
    this.document.updateSource({ x: l.x, y: l.y }), this.refresh(), Ae(this, Hf, s);
  }
  _onRotate(t) {
    t.ctrlKey && t.preventDefault(), t.stopPropagation();
    const s = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 30 : 15, n = t.shiftKey ? s : 5, l = {
      direction: this.document.direction + n * Math.sign(t.deltaY)
    };
    this.document.updateSource(l), this.refresh();
  }
  async _onConfirm(t) {
    await this._finishPlacement(t);
    const s = canvas.templates.getSnappedPoint({
      x: this.document.x,
      y: this.document.y
    });
    this.document.updateSource(s), P(this, ri).resolve(
      canvas.scene.createEmbeddedDocuments("MeasuredTemplate", [this.document.toObject()])
    );
  }
  async _onCancel(t) {
    await this._finishPlacement(t ?? {}), P(this, ri).reject();
  }
};
Hf = new WeakMap(), Uf = new WeakMap(), ri = new WeakMap(), u(EE, "ItemMeasuredTemplate");
let Jy = EE;
var Ua, oi, Ol, Dl, ht, aB, cB, uB, fB, dB, pB, mB, Nd, hB, Zy, gB, Qy, bB, _B, yB, vB, kB, wB, $B, Fo;
const au = class au {
  constructor(e, t, s, n = {}) {
    x(this, ht);
    x(this, Ua);
    x(this, oi);
    x(this, Ol);
    x(this, Dl);
    Ae(this, oi, e), Ae(this, Ua, s), Ae(this, Ol, n), Ae(this, Dl, t);
  }
  get TEMPLATE_FUNCTION_MAP() {
    return {
      circle: X(this, ht, Nd),
      cone: X(this, ht, hB),
      cube: X(this, ht, Zy),
      cylinder: X(this, ht, Nd),
      emanation: X(this, ht, gB),
      line: X(this, ht, Qy),
      sphere: X(this, ht, Nd),
      square: X(this, ht, Zy),
      wall: X(this, ht, Qy)
    };
  }
  // --------------------------------------------
  // Public Functions
  // --------------------------------------------
  async placeActionTemplates() {
    var n, l, r, o, a;
    const { area: e } = P(this, Ua);
    let t = foundry.utils.deepClone(e);
    t = X(this, ht, bB).call(this, t);
    const s = t.quantity ?? 1;
    await ((l = (n = P(this, oi)) == null ? void 0 : n.sheet) == null ? void 0 : l.minimize());
    try {
      for (let c = 0; c < s; c += 1) {
        const f = X(this, ht, mB).call(this, t), d = new Jy(f);
        if (!d) return;
        d.item = P(this, Dl), d.actorSheet = ((r = P(this, oi)) == null ? void 0 : r.sheet) || null;
        let p = !1;
        setTimeout(() => {
          if (!p)
            throw d == null || d._onCancel(), new Error("Time limit for placing template exceeded");
        }, 3e4);
        const m = await (d == null ? void 0 : d.drawPreview());
        p = !0, m && Hooks.callAll("a5e.measuredTemplatePlaced", P(this, Dl), m, game.user.id);
      }
    } catch {
    } finally {
      await ((a = (o = P(this, oi)) == null ? void 0 : o.sheet) == null ? void 0 : a.maximize());
    }
  }
  /**
   *
   * @param {ItemA5e} item
   * @param {Action} action
   * @returns {Boolean} validTemplate
   */
  validateBaseTemplateData(e = P(this, Ua)) {
    const { area: t } = e ?? {};
    return foundry.utils.isEmpty(t) || (t.quantity ?? (t.quantity = 1), !t.shape) || t.quantity <= 0 ? !1 : t.shape === "cone" ? X(this, ht, aB).call(this, t) : ["cube", "square"].includes(t.shape) ? X(this, ht, cB).call(this, t) : ["circle", "emanation", "sphere"].includes(t.shape) ? X(this, ht, uB).call(this, t) : t.shape === "cylinder" ? X(this, ht, fB).call(this, t) : t.shape === "line" ? X(this, ht, dB).call(this, t) : t.shape === "wall" ? X(this, ht, pB).call(this, t) : !1;
  }
  // --------------------------------------------
  // Static Functions
  // --------------------------------------------
  static getShapeProperties(e) {
    switch (e) {
      case "circle":
      case "emanation":
      case "sphere":
        return ["radius"];
      case "cone":
        return ["length"];
      case "cube":
      case "square":
        return ["width"];
      case "cylinder":
        return ["radius", "height"];
      case "line":
        return ["length", "width"];
      case "wall":
        return ["length", "height", "width"];
      default:
        return [];
    }
  }
};
Ua = new WeakMap(), oi = new WeakMap(), Ol = new WeakMap(), Dl = new WeakMap(), ht = new WeakSet(), // --------------------------------------------
// Internal Functions - Validators
// --------------------------------------------
aB = /* @__PURE__ */ u(function(e) {
  const t = parseInt(e == null ? void 0 : e.length, 10);
  return !(!t || t <= 0);
}, "#validateCone"), cB = /* @__PURE__ */ u(function(e) {
  const t = parseInt(e == null ? void 0 : e.width, 10);
  return !(!t || t <= 0);
}, "#validateQuadrilateral"), uB = /* @__PURE__ */ u(function(e) {
  const t = parseInt(e == null ? void 0 : e.radius, 10);
  return !(!t || t <= 0);
}, "#validateRadialObject"), fB = /* @__PURE__ */ u(function(e) {
  const t = parseInt(e == null ? void 0 : e.radius, 10), s = parseInt(e == null ? void 0 : e.radius, 10);
  return !(!t || !s || t <= 0 || s <= 0);
}, "#validateCylinder"), dB = /* @__PURE__ */ u(function(e) {
  const t = parseInt(e == null ? void 0 : e.length, 10), s = parseInt(e == null ? void 0 : e.width, 10);
  return !(!s || !t || s <= 0 || t <= 0);
}, "#validateLine"), pB = /* @__PURE__ */ u(function(e) {
  const t = parseInt(e == null ? void 0 : e.length, 10), s = parseInt(e == null ? void 0 : e.width, 10), n = parseInt(e == null ? void 0 : e.height, 10);
  return !(!s || !t || !n || s <= 0 || t <= 0 || n <= 0);
}, "#validateWall"), // --------------------------------------------
// Internal Functions - Template Creations
// --------------------------------------------
mB = /* @__PURE__ */ u(function(e) {
  const { shape: t } = e, n = this.TEMPLATE_FUNCTION_MAP[t].apply(this, [e]);
  if (!n) return null;
  const l = CONFIG.MeasuredTemplate.documentClass;
  return new l(n, { parent: canvas.scene });
}, "#createTemplateDocument"), Nd = /* @__PURE__ */ u(function(e) {
  return {
    direction: 0,
    distance: parseInt(e.radius, 10),
    fillColor: game.user.color,
    t: "circle",
    user: game.user.id,
    x: 0,
    y: 0
  };
}, "#getCircleTemplateData"), hB = /* @__PURE__ */ u(function(e) {
  const t = parseInt(e.length, 10);
  return {
    angle: CONFIG.MeasuredTemplate.defaults.angle,
    direction: 0,
    distance: t,
    fillColor: game.user.color,
    t: "cone",
    user: game.user.id,
    x: 0,
    y: 0
  };
}, "#getConeTemplateData"), Zy = /* @__PURE__ */ u(function(e) {
  const t = parseInt(e.width, 10);
  return {
    direction: 45,
    distance: Math.hypot(t, t),
    fillColor: game.user.color,
    t: "rect",
    user: game.user.id,
    width: t,
    x: 0,
    y: 0
  };
}, "#getCubeTemplateData"), gB = /* @__PURE__ */ u(function(e) {
  var r;
  let t = parseInt(e.radius, 10);
  const s = P(this, oi).system.traits.size ?? "med", n = (r = P(this, oi).getActiveTokens()) == null ? void 0 : r[0];
  let l;
  if (n) {
    const o = n.document.width, a = n.document.height;
    l = Math.max(o, a) / 2, t += l * 5;
  } else s !== "tiny" && (l = CONFIG.A5E.tokenDimensions[s] / 2, t += l * 5);
  return {
    direction: 0,
    distance: t,
    fillColor: game.user.color,
    t: "circle",
    user: game.user.id,
    x: 0,
    y: 0
  };
}, "#getEmanationTemplateData"), Qy = /* @__PURE__ */ u(function(e) {
  const t = parseInt(e.length, 10), s = parseInt(e.width, 10);
  return {
    direction: 0,
    distance: t,
    fillColor: game.user.color,
    t: "ray",
    user: game.user.id,
    width: s,
    x: 0,
    y: 0
  };
}, "#getLineTemplateData"), // --------------------------------------------
// Internal Functions - Scaling
// --------------------------------------------
bB = /* @__PURE__ */ u(function(e) {
  var s;
  const t = (s = e.scaling) == null ? void 0 : s.mode;
  return t ? t === "cantrip" ? X(this, ht, _B).call(this, e) : t === "spellLevel" ? X(this, ht, yB).call(this, e) : t === "spellPoints" ? X(this, ht, vB).call(this, e) : t === "artifactCharges" ? X(this, ht, kB).call(this, e) : t === "actionUses" ? X(this, ht, wB).call(this, e) : t === "itemUses" ? X(this, ht, $B).call(this, e) : e : e;
}, "#applyTemplateScaling"), _B = /* @__PURE__ */ u(function(e) {
  const t = P(this, oi).system, s = t.details.level ?? t.attributes.casterLevel;
  if (s < 5) return e;
  const n = ["quantity", ...au.getShapeProperties(e.shape)];
  let l = 0;
  return s >= 17 ? l = 3 : s >= 11 ? l = 2 : s >= 5 && (l = 1), n.forEach((r) => {
    var a, c;
    const o = mt(
      ((c = (a = e.scaling) == null ? void 0 : a.formula) == null ? void 0 : c[r]) ?? 0,
      P(this, oi).getRollData(P(this, Dl))
    ) ?? 1;
    e[r] = parseInt(e[r], 10) + o * l;
  }), e;
}, "#applyCantripScaling"), yB = /* @__PURE__ */ u(function(e) {
  var l;
  const t = P(this, Dl).system.level, n = (((l = P(this, Ol).spell) == null ? void 0 : l.level) ?? t) - t;
  return X(this, ht, Fo).call(this, e, n);
}, "#applySpellLevelScaling"), vB = /* @__PURE__ */ u(function(e) {
  const t = P(this, Ol).spell;
  if (foundry.utils.isEmpty(t)) return e;
  const { basePoints: s } = t;
  if (s >= t.points) return e;
  const n = Math.max(0, t.points - s);
  return X(this, ht, Fo).call(this, e, n);
}, "#applySpellPointScaling"), kB = /* @__PURE__ */ u(function(e) {
  const t = P(this, Ol).spell;
  if (foundry.utils.isEmpty(t)) return e;
  const { baseCharges: s } = t;
  if (s >= t.charges) return e;
  const n = Math.max(0, t.charges - s);
  return X(this, ht, Fo).call(this, e, n);
}, "#applyArtifactChargesScaling"), wB = /* @__PURE__ */ u(function(e) {
  const t = P(this, Ol).actionUses;
  if (foundry.utils.isEmpty(t)) return e;
  const s = t.baseUses;
  if (s >= t.quantity) return e;
  const n = t.quantity - s;
  return X(this, ht, Fo).call(this, e, n);
}, "#applyActionUsesScaling"), $B = /* @__PURE__ */ u(function(e) {
  const t = P(this, Ol).itemUses;
  if (foundry.utils.isEmpty(t)) return e;
  const s = t.baseUses;
  if (s >= t.quantity) return e;
  const n = t.quantity - s;
  return X(this, ht, Fo).call(this, e, n);
}, "#applyItemUsesScaling"), Fo = /* @__PURE__ */ u(function(e, t) {
  var a;
  const { shape: s, scaling: n } = e;
  if (!t || foundry.utils.isEmpty(n)) return e;
  const l = ["quantity", ...au.getShapeProperties(s)], r = ((a = e.scaling) == null ? void 0 : a.step) || 1, o = Math.floor(t / r);
  return o === 0 || l.forEach((c) => {
    var d, p;
    const f = mt(
      ((p = (d = e.scaling) == null ? void 0 : d.formula) == null ? void 0 : p[c]) ?? 0,
      P(this, oi).getRollData(P(this, Dl))
    ) ?? 1;
    e[c] = parseInt(e[c], 10) + f * o;
  }), e;
}, "#applyResourceBasedScaling"), u(au, "TemplatePreparationManager");
let gc = au;
function $te(i) {
  let e, t, s, n, l, r, o, a = (
    /*A5E*/
    i[6].areaIcons[
      /*key*/
      i[3]
    ] + ""
  ), c, f = K(
    /*name*/
    i[4]
  ) + "", d, p, m, g;
  return {
    c() {
      var h, _;
      e = E("input"), l = F(), r = E("label"), o = E("span"), c = F(), d = Q(f), b(e, "class", "area-shape__input svelte-1rkg8ip"), b(e, "id", t = "area-" + /*actionId*/
      i[1] + "-" + /*key*/
      i[3]), b(e, "name", s = /*actionId*/
      i[1] + "-area-shape"), e.value = /*key*/
      i[3], b(e, "type", "radio"), e.checked = n = /*action*/
      ((_ = (h = i[0]) == null ? void 0 : h.area) == null ? void 0 : _.shape) === /*key*/
      i[3], b(o, "class", "u-text-sm"), b(r, "class", "area-shape__label svelte-1rkg8ip"), b(r, "for", p = "area-" + /*actionId*/
      i[1] + "-" + /*key*/
      i[3]);
    },
    m(h, _) {
      T(h, e, _), T(h, l, _), T(h, r, _), A(r, o), o.innerHTML = a, A(r, c), A(r, d), m || (g = W(
        e,
        "click",
        /*click_handler*/
        i[8]
      ), m = !0);
    },
    p(h, [_]) {
      var y, v;
      _ & /*actionId, key*/
      10 && t !== (t = "area-" + /*actionId*/
      h[1] + "-" + /*key*/
      h[3]) && b(e, "id", t), _ & /*actionId*/
      2 && s !== (s = /*actionId*/
      h[1] + "-area-shape") && b(e, "name", s), _ & /*key*/
      8 && (e.value = /*key*/
      h[3]), _ & /*action, key*/
      9 && n !== (n = /*action*/
      ((v = (y = h[0]) == null ? void 0 : y.area) == null ? void 0 : v.shape) === /*key*/
      h[3]) && (e.checked = n), _ & /*key*/
      8 && a !== (a = /*A5E*/
      h[6].areaIcons[
        /*key*/
        h[3]
      ] + "") && (o.innerHTML = a), _ & /*name*/
      16 && f !== (f = K(
        /*name*/
        h[4]
      ) + "") && be(d, f), _ & /*actionId, key*/
      10 && p !== (p = "area-" + /*actionId*/
      h[1] + "-" + /*key*/
      h[3]) && b(r, "for", p);
    },
    i: se,
    o: se,
    d(h) {
      h && (C(e), C(l), C(r)), m = !1, g();
    }
  };
}
u($te, "create_fragment$2S");
function Ate(i, e, t) {
  let s, n = se, l = /* @__PURE__ */ u(() => (n(), n = Xt(a, (g) => t(5, s = g)), a), "$$subscribe_item");
  i.$$.on_destroy.push(() => n());
  let { action: r } = e, { actionId: o } = e, { item: a } = e;
  l();
  let { key: c } = e, { name: f } = e;
  const d = CONFIG.A5E;
  function p() {
    s.update({
      [`system.actions.${o}.area`]: {
        "-=width": null,
        "-=radius": null,
        "-=height": null,
        "-=length": null
      }
    });
  }
  u(p, "removeArea");
  const m = /* @__PURE__ */ u(({ target: g }) => {
    p(), kp(s, `system.actions.${o}.area.shape`, g.value, `system.actions.${o}.area.quantity`);
  }, "click_handler");
  return i.$$set = (g) => {
    "action" in g && t(0, r = g.action), "actionId" in g && t(1, o = g.actionId), "item" in g && l(t(2, a = g.item)), "key" in g && t(3, c = g.key), "name" in g && t(4, f = g.name);
  }, [r, o, a, c, f, s, d, p, m];
}
u(Ate, "instance$2J");
const SE = class SE extends re {
  constructor(e) {
    super(), oe(this, e, Ate, $te, le, {
      action: 0,
      actionId: 1,
      item: 2,
      key: 3,
      name: 4
    });
  }
};
u(SE, "AreaShape");
let xy = SE;
function dP(i, e, t) {
  const s = i.slice();
  return s[14] = e[t], s;
}
u(dP, "get_each_context_2$2");
function pP(i, e, t) {
  const s = i.slice();
  return s[14] = e[t], s;
}
u(pP, "get_each_context_1$e");
function mP(i, e, t) {
  const s = i.slice();
  return s[14] = e[t], s;
}
u(mP, "get_each_context$15");
function Ete(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [Tte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, scalingMode, actionId, area, $item, properties*/
      2097211 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Ete, "create_if_block_2$K");
function Ste(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [Ote] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, actionId, area, $item, properties*/
      2097179 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Ste, "create_if_block_1$15");
function Cte(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "This increment will be applied automatically based on your caster level.",
      $$slots: { default: [Dte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, properties, actionId, action, $item*/
      2097181 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Cte, "create_if_block$1D");
function hP(i) {
  let e, t, s = (
    /*property*/
    i[14].capitalize() + ""
  ), n, l, r, o, a, c, f, d, p, m;
  return {
    c() {
      var g, h, _;
      e = E("div"), t = E("label"), n = Q(s), l = Q(" Increment"), o = F(), a = E("input"), b(t, "for", r = /*actionId*/
      i[0] + "-area-scaling-formula"), b(t, "class", "svelte-12arw9v"), b(a, "id", c = /*actionId*/
      i[0] + "-" + /*property*/
      i[14] + "-scaling-formula"), b(a, "type", "text"), b(a, "name", f = "system.actions." + /*actionId*/
      i[0] + ".area.scaling.formula." + /*property*/
      i[14]), a.value = d = /*area*/
      ((_ = (h = (g = i[1]) == null ? void 0 : g.scaling) == null ? void 0 : h.formula) == null ? void 0 : _[
        /*property*/
        i[14]
      ]) ?? 0, b(a, "class", "svelte-12arw9v"), b(e, "class", "a5e-field-group a5e-field-group--formula a5e-field-group--spell-level svelte-12arw9v");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(t, n), A(t, l), A(e, o), A(e, a), p || (m = W(
        a,
        "change",
        /*change_handler_3*/
        i[12]
      ), p = !0);
    },
    p(g, h) {
      var _, y, v;
      h & /*properties*/
      16 && s !== (s = /*property*/
      g[14].capitalize() + "") && be(n, s), h & /*actionId*/
      1 && r !== (r = /*actionId*/
      g[0] + "-area-scaling-formula") && b(t, "for", r), h & /*actionId, properties*/
      17 && c !== (c = /*actionId*/
      g[0] + "-" + /*property*/
      g[14] + "-scaling-formula") && b(a, "id", c), h & /*actionId, properties*/
      17 && f !== (f = "system.actions." + /*actionId*/
      g[0] + ".area.scaling.formula." + /*property*/
      g[14]) && b(a, "name", f), h & /*area, properties*/
      18 && d !== (d = /*area*/
      ((v = (y = (_ = g[1]) == null ? void 0 : _.scaling) == null ? void 0 : y.formula) == null ? void 0 : v[
        /*property*/
        g[14]
      ]) ?? 0) && a.value !== d && (a.value = d);
    },
    d(g) {
      g && C(e), p = !1, m();
    }
  };
}
u(hP, "create_each_block_2$2");
function Tte(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _ = (
    /*scalingMode*/
    i[5] === "spellPoints" ? "Points" : "Uses"
  ), y, v, k, S = ue(
    /*properties*/
    i[4]
  ), D = [];
  for (let I = 0; I < S.length; I += 1)
    D[I] = hP(dP(i, S, I));
  return {
    c() {
      var I, M;
      e = E("section");
      for (let L = 0; L < D.length; L += 1)
        D[L].c();
      t = F(), s = E("div"), n = E("label"), l = Q("Per"), o = F(), a = E("input"), p = F(), m = E("div"), g = E("span"), h = Q("Additional "), y = Q(_), b(n, "for", r = /*actionId*/
      i[0] + "-area-scaling-step"), b(n, "class", "svelte-12arw9v"), b(a, "id", c = /*actionId*/
      i[0] + "-area-scaling-step"), G(a, "text-align", "center"), b(a, "type", "number"), b(a, "name", f = "system.actions." + /*actionId*/
      i[0] + ".area.scaling.step"), a.value = d = /*area*/
      ((M = (I = i[1]) == null ? void 0 : I.scaling) == null ? void 0 : M.step) ?? 1, b(a, "class", "svelte-12arw9v"), b(s, "class", "a5e-field-group u-w-12"), b(g, "class", "levels svelte-12arw9v"), b(m, "class", "a5e-field-group levels-wrapper svelte-12arw9v"), b(e, "class", "row u-flex-wrap svelte-12arw9v");
    },
    m(I, M) {
      T(I, e, M);
      for (let L = 0; L < D.length; L += 1)
        D[L] && D[L].m(e, null);
      A(e, t), A(e, s), A(s, n), A(n, l), A(s, o), A(s, a), A(e, p), A(e, m), A(m, g), A(g, h), A(g, y), v || (k = W(
        a,
        "change",
        /*change_handler_4*/
        i[13]
      ), v = !0);
    },
    p(I, M) {
      var L, B;
      if (M & /*actionId, properties, area, $item*/
      27) {
        S = ue(
          /*properties*/
          I[4]
        );
        let z;
        for (z = 0; z < S.length; z += 1) {
          const q = dP(I, S, z);
          D[z] ? D[z].p(q, M) : (D[z] = hP(q), D[z].c(), D[z].m(e, t));
        }
        for (; z < D.length; z += 1)
          D[z].d(1);
        D.length = S.length;
      }
      M & /*actionId*/
      1 && r !== (r = /*actionId*/
      I[0] + "-area-scaling-step") && b(n, "for", r), M & /*actionId*/
      1 && c !== (c = /*actionId*/
      I[0] + "-area-scaling-step") && b(a, "id", c), M & /*actionId*/
      1 && f !== (f = "system.actions." + /*actionId*/
      I[0] + ".area.scaling.step") && b(a, "name", f), M & /*area*/
      2 && d !== (d = /*area*/
      ((B = (L = I[1]) == null ? void 0 : L.scaling) == null ? void 0 : B.step) ?? 1) && a.value !== d && (a.value = d), M & /*scalingMode*/
      32 && _ !== (_ = /*scalingMode*/
      I[5] === "spellPoints" ? "Points" : "Uses") && be(y, _);
    },
    d(I) {
      I && C(e), Le(D, I), v = !1, k();
    }
  };
}
u(Tte, "create_default_slot_2$u");
function gP(i) {
  let e, t, s = (
    /*property*/
    i[14].capitalize() + ""
  ), n, l, r, o, a, c, f, d, p, m;
  return {
    c() {
      var g, h, _;
      e = E("div"), t = E("label"), n = Q(s), l = Q(" Increment"), o = F(), a = E("input"), b(t, "for", r = /*actionId*/
      i[0] + "-" + /*property*/
      i[14] + "-scaling-formula"), b(t, "class", "svelte-12arw9v"), b(a, "id", c = /*actionId*/
      i[0] + "-area-scaling-formula"), b(a, "type", "text"), b(a, "name", f = "system.actions." + /*actionId*/
      i[0] + ".area.scaling.formula." + /*property*/
      i[14]), a.value = d = /*area*/
      ((_ = (h = (g = i[1]) == null ? void 0 : g.scaling) == null ? void 0 : h.formula) == null ? void 0 : _[
        /*property*/
        i[14]
      ]) ?? 0, b(a, "class", "svelte-12arw9v"), b(e, "class", "a5e-field-group a5e-field-group--formula a5e-field-group--spell-level svelte-12arw9v");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(t, n), A(t, l), A(e, o), A(e, a), p || (m = W(
        a,
        "change",
        /*change_handler_1*/
        i[10]
      ), p = !0);
    },
    p(g, h) {
      var _, y, v;
      h & /*properties*/
      16 && s !== (s = /*property*/
      g[14].capitalize() + "") && be(n, s), h & /*actionId, properties*/
      17 && r !== (r = /*actionId*/
      g[0] + "-" + /*property*/
      g[14] + "-scaling-formula") && b(t, "for", r), h & /*actionId*/
      1 && c !== (c = /*actionId*/
      g[0] + "-area-scaling-formula") && b(a, "id", c), h & /*actionId, properties*/
      17 && f !== (f = "system.actions." + /*actionId*/
      g[0] + ".area.scaling.formula." + /*property*/
      g[14]) && b(a, "name", f), h & /*area, properties*/
      18 && d !== (d = /*area*/
      ((v = (y = (_ = g[1]) == null ? void 0 : _.scaling) == null ? void 0 : y.formula) == null ? void 0 : v[
        /*property*/
        g[14]
      ]) ?? 0) && a.value !== d && (a.value = d);
    },
    d(g) {
      g && C(e), p = !1, m();
    }
  };
}
u(gP, "create_each_block_1$e");
function Ote(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _ = ue(
    /*properties*/
    i[4]
  ), y = [];
  for (let v = 0; v < _.length; v += 1)
    y[v] = gP(pP(i, _, v));
  return {
    c() {
      var v, k;
      e = E("section");
      for (let S = 0; S < y.length; S += 1)
        y[S].c();
      t = F(), s = E("div"), n = E("label"), l = Q("Per"), o = F(), a = E("input"), p = F(), m = E("div"), m.innerHTML = '<span class="levels svelte-12arw9v">Levels</span>', b(n, "for", r = /*actionId*/
      i[0] + "-area-scaling-step"), b(n, "class", "svelte-12arw9v"), b(a, "id", c = /*actionId*/
      i[0] + "-area-scaling-step"), G(a, "text-align", "center"), b(a, "type", "number"), b(a, "name", f = "system.actions." + /*actionId*/
      i[0] + ".area.scaling.step"), a.value = d = /*area*/
      ((k = (v = i[1]) == null ? void 0 : v.scaling) == null ? void 0 : k.step) ?? 1, b(a, "class", "svelte-12arw9v"), b(s, "class", "a5e-field-group u-w-12"), b(m, "class", "a5e-field-group levels-wrapper svelte-12arw9v"), b(e, "class", "row u-flex-wrap svelte-12arw9v");
    },
    m(v, k) {
      T(v, e, k);
      for (let S = 0; S < y.length; S += 1)
        y[S] && y[S].m(e, null);
      A(e, t), A(e, s), A(s, n), A(n, l), A(s, o), A(s, a), A(e, p), A(e, m), g || (h = W(
        a,
        "change",
        /*change_handler_2*/
        i[11]
      ), g = !0);
    },
    p(v, k) {
      var S, D;
      if (k & /*actionId, properties, area, $item*/
      27) {
        _ = ue(
          /*properties*/
          v[4]
        );
        let I;
        for (I = 0; I < _.length; I += 1) {
          const M = pP(v, _, I);
          y[I] ? y[I].p(M, k) : (y[I] = gP(M), y[I].c(), y[I].m(e, t));
        }
        for (; I < y.length; I += 1)
          y[I].d(1);
        y.length = _.length;
      }
      k & /*actionId*/
      1 && r !== (r = /*actionId*/
      v[0] + "-area-scaling-step") && b(n, "for", r), k & /*actionId*/
      1 && c !== (c = /*actionId*/
      v[0] + "-area-scaling-step") && b(a, "id", c), k & /*actionId*/
      1 && f !== (f = "system.actions." + /*actionId*/
      v[0] + ".area.scaling.step") && b(a, "name", f), k & /*area*/
      2 && d !== (d = /*area*/
      ((D = (S = v[1]) == null ? void 0 : S.scaling) == null ? void 0 : D.step) ?? 1) && a.value !== d && (a.value = d);
    },
    d(v) {
      v && C(e), Le(y, v), g = !1, h();
    }
  };
}
u(Ote, "create_default_slot_1$C");
function bP(i) {
  let e, t, s = (
    /*property*/
    i[14].capitalize() + ""
  ), n, l, r, o, a, c, f, d, p, m;
  return {
    c() {
      var g, h;
      e = E("div"), t = E("label"), n = Q(s), l = Q(" Increment"), o = F(), a = E("input"), d = F(), b(t, "for", r = /*actionId*/
      i[0] + "-" + /*property*/
      i[14] + "-scaling-formula"), b(t, "class", "svelte-12arw9v"), b(a, "class", "a5e-input svelte-12arw9v"), b(a, "type", "text"), b(a, "name", c = "system.actions." + /*actionId*/
      i[0] + ".area.scaling.formula." + /*property*/
      i[14]), a.value = f = /*action*/
      ((h = (g = i[2].area.scaling) == null ? void 0 : g.formula) == null ? void 0 : h[
        /*property*/
        i[14]
      ]) ?? 0, b(e, "class", "a5e-field-group a5e-field-group--formula a5e-field-group--spell-level svelte-12arw9v");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(t, n), A(t, l), A(e, o), A(e, a), A(e, d), p || (m = W(
        a,
        "change",
        /*change_handler*/
        i[9]
      ), p = !0);
    },
    p(g, h) {
      var _, y;
      h & /*properties*/
      16 && s !== (s = /*property*/
      g[14].capitalize() + "") && be(n, s), h & /*actionId, properties*/
      17 && r !== (r = /*actionId*/
      g[0] + "-" + /*property*/
      g[14] + "-scaling-formula") && b(t, "for", r), h & /*actionId, properties*/
      17 && c !== (c = "system.actions." + /*actionId*/
      g[0] + ".area.scaling.formula." + /*property*/
      g[14]) && b(a, "name", c), h & /*action, properties*/
      20 && f !== (f = /*action*/
      ((y = (_ = g[2].area.scaling) == null ? void 0 : _.formula) == null ? void 0 : y[
        /*property*/
        g[14]
      ]) ?? 0) && a.value !== f && (a.value = f);
    },
    d(g) {
      g && C(e), p = !1, m();
    }
  };
}
u(bP, "create_each_block$15");
function Dte(i) {
  let e, t = ue(
    /*properties*/
    i[4]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = bP(mP(i, t, n));
  return {
    c() {
      e = E("section");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "row u-flex-wrap svelte-12arw9v");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*actionId, properties, action, $item*/
      29) {
        t = ue(
          /*properties*/
          n[4]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = mP(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = bP(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(Dte, "create_default_slot$1d");
function Ite(i) {
  let e, t, s, n, l, r, o;
  t = new Ke({
    props: {
      heading: "Scaling Mode",
      options: Pte(),
      selected: (
        /*scalingMode*/
        i[5]
      ),
      allowDeselect: !1
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[8]
  );
  const a = [Cte, Ste, Ete], c = [];
  function f(d, p) {
    return p & /*scalingMode*/
    32 && (n = null), /*scalingMode*/
    d[5] === "cantrip" ? 0 : (
      /*scalingMode*/
      d[5] === "spellLevel" ? 1 : (n == null && (n = !!["artifactCharges", "spellPoints", "actionUses", "itemUses"].includes(
        /*scalingMode*/
        d[5]
      )), n ? 2 : -1)
    );
  }
  return u(f, "select_block_type"), ~(l = f(i, -1)) && (r = c[l] = a[l](i)), {
    c() {
      e = E("form"), j(t.$$.fragment), s = F(), r && r.c(), b(e, "class", "svelte-12arw9v");
    },
    m(d, p) {
      T(d, e, p), R(t, e, null), A(e, s), ~l && c[l].m(e, null), o = !0;
    },
    p(d, [p]) {
      const m = {};
      p & /*scalingMode*/
      32 && (m.selected = /*scalingMode*/
      d[5]), t.$set(m);
      let g = l;
      l = f(d, p), l === g ? ~l && c[l].p(d, p) : (r && (ae(), O(c[g], 1, 1, () => {
        c[g] = null;
      }), ce()), ~l ? (r = c[l], r ? r.p(d, p) : (r = c[l] = a[l](d), r.c()), w(r, 1), r.m(e, null)) : r = null);
    },
    i(d) {
      o || (w(t.$$.fragment, d), w(r), o = !0);
    },
    o(d) {
      O(t.$$.fragment, d), O(r), o = !1;
    },
    d(d) {
      d && C(e), N(t), ~l && c[l].d();
    }
  };
}
u(Ite, "create_fragment$2R");
function Pte() {
  return [[null, "A5E.None"], ...Object.entries(CONFIG.A5E.targetScalingModes)];
}
u(Pte, "getScalingOptions");
function Mte(i, e, t) {
  let s, n, l, r, o, { document: a, actionId: c } = de("#external").application, { document: f = a, actionId: d = c } = e;
  const p = f;
  pe(i, p, (k) => t(3, o = k));
  const m = /* @__PURE__ */ u((k) => {
    te(o, `system.actions.${d}.area.scaling.mode`, k.detail);
  }, "updateSelection_handler"), g = /* @__PURE__ */ u(({ target: k }) => te(o, k.name, k.value), "change_handler"), h = /* @__PURE__ */ u(({ target: k }) => te(o, k.name, k.value), "change_handler_1"), _ = /* @__PURE__ */ u(({ target: k }) => te(o, k.name, parseInt(k.value, 10)), "change_handler_2"), y = /* @__PURE__ */ u(({ target: k }) => te(o, k.name, k.value), "change_handler_3"), v = /* @__PURE__ */ u(({ target: k }) => te(o, k.name, parseInt(k.value, 10)), "change_handler_4");
  return i.$$set = (k) => {
    "document" in k && t(7, f = k.document), "actionId" in k && t(0, d = k.actionId);
  }, i.$$.update = () => {
    var k;
    i.$$.dirty & /*$item, actionId*/
    9 && t(2, s = o.actions.get(d)), i.$$.dirty & /*action*/
    4 && t(1, n = s.area ?? {}), i.$$.dirty & /*area*/
    2 && t(5, l = ((k = n == null ? void 0 : n.scaling) == null ? void 0 : k.mode) ?? null), i.$$.dirty & /*area*/
    2 && t(4, r = ["quantity", ...gc.getShapeProperties(n == null ? void 0 : n.shape)]);
  }, [
    d,
    n,
    s,
    o,
    r,
    l,
    p,
    f,
    m,
    g,
    h,
    _,
    y,
    v
  ];
}
u(Mte, "instance$2I");
const CE = class CE extends re {
  constructor(e) {
    super(), oe(this, e, Mte, Ite, le, { document: 7, actionId: 0 });
  }
};
u(CE, "TemplateScalingDialog");
let e0 = CE;
function _P(i, e, t) {
  const s = i.slice();
  return s[17] = e[t][0], s[18] = e[t][1], s;
}
u(_P, "get_each_context$14");
function yP(i, e) {
  let t, s, n;
  return s = new xy({
    props: {
      action: (
        /*action*/
        e[0]
      ),
      actionId: (
        /*actionId*/
        e[1]
      ),
      item: (
        /*item*/
        e[2]
      ),
      key: (
        /*key*/
        e[17]
      ),
      name: (
        /*name*/
        e[18]
      )
    }
  }), {
    key: i,
    first: null,
    c() {
      t = $e(), j(s.$$.fragment), this.first = t;
    },
    m(l, r) {
      T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      e = l;
      const o = {};
      r & /*action*/
      1 && (o.action = /*action*/
      e[0]), r & /*actionId*/
      2 && (o.actionId = /*actionId*/
      e[1]), r & /*item*/
      4 && (o.item = /*item*/
      e[2]), s.$set(o);
    },
    i(l) {
      n || (w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(s, l);
    }
  };
}
u(yP, "create_each_block$14");
function vP(i) {
  let e, t, s, n, l = (
    /*getShapeProperties*/
    i[8](
      /*action*/
      i[0].area.shape
    ).includes("radius")
  ), r, o = (
    /*getShapeProperties*/
    i[8](
      /*action*/
      i[0].area.shape
    ).includes("length")
  ), a, c = (
    /*getShapeProperties*/
    i[8](
      /*action*/
      i[0].area.shape
    ).includes("width")
  ), f, d = (
    /*getShapeProperties*/
    i[8](
      /*action*/
      i[0].area.shape
    ).includes("height")
  ), p, m, g, h, _;
  t = new ie({
    props: {
      heading: "A5E.ItemQuantity",
      $$slots: { default: [Fte] },
      $$scope: { ctx: i }
    }
  });
  let y = l && kP(i), v = o && wP(i), k = c && $P(i), S = d && AP(i), D = (
    /*action*/
    i[0].area.shape && EP(i)
  );
  function I(B, z) {
    var q, U, H, V, Y, J, fe, ke;
    if (z & /*action*/
    1 && (g = null), /*action*/
    ((U = (q = B[0].area) == null ? void 0 : q.scaling) == null ? void 0 : U.mode) === "cantrip") return Bte;
    if (
      /*action*/
      ((V = (H = B[0].area) == null ? void 0 : H.scaling) == null ? void 0 : V.mode) === "spellLevel"
    ) return Lte;
    if (
      /*action*/
      ((J = (Y = B[0].area) == null ? void 0 : Y.scaling) == null ? void 0 : J.mode) === "spellPoints"
    ) return jte;
    if (g == null && (g = !!["actionUses", "itemUses"].includes(
      /*action*/
      (ke = (fe = B[0].area) == null ? void 0 : fe.scaling) == null ? void 0 : ke.mode
    )), g) return Nte;
  }
  u(I, "select_block_type");
  let M = I(i, -1), L = M && M(i);
  return {
    c() {
      e = E("div"), s = E("div"), j(t.$$.fragment), n = F(), y && y.c(), r = F(), v && v.c(), a = F(), k && k.c(), f = F(), S && S.c(), p = F(), D && D.c(), m = F(), L && L.c(), h = $e(), G(s, "display", "contents"), G(s, "--a5e-field-wrapper-width", "7.5rem"), b(e, "class", "u-flex u-gap-md u-w-full");
    },
    m(B, z) {
      T(B, e, z), A(e, s), R(t, s, null), A(e, n), y && y.m(e, null), A(e, r), v && v.m(e, null), A(e, a), k && k.m(e, null), A(e, f), S && S.m(e, null), A(e, p), D && D.m(e, null), T(B, m, z), L && L.m(B, z), T(B, h, z), _ = !0;
    },
    p(B, z) {
      const q = {};
      z & /*$$scope, actionId, action, $item*/
      2097163 && (q.$$scope = { dirty: z, ctx: B }), t.$set(q), z & /*action*/
      1 && (l = /*getShapeProperties*/
      B[8](
        /*action*/
        B[0].area.shape
      ).includes("radius")), l ? y ? (y.p(B, z), z & /*action*/
      1 && w(y, 1)) : (y = kP(B), y.c(), w(y, 1), y.m(e, r)) : y && (ae(), O(y, 1, 1, () => {
        y = null;
      }), ce()), z & /*action*/
      1 && (o = /*getShapeProperties*/
      B[8](
        /*action*/
        B[0].area.shape
      ).includes("length")), o ? v ? v.p(B, z) : (v = wP(B), v.c(), v.m(e, a)) : v && (v.d(1), v = null), z & /*action*/
      1 && (c = /*getShapeProperties*/
      B[8](
        /*action*/
        B[0].area.shape
      ).includes("width")), c ? k ? k.p(B, z) : (k = $P(B), k.c(), k.m(e, f)) : k && (k.d(1), k = null), z & /*action*/
      1 && (d = /*getShapeProperties*/
      B[8](
        /*action*/
        B[0].area.shape
      ).includes("height")), d ? S ? S.p(B, z) : (S = AP(B), S.c(), S.m(e, p)) : S && (S.d(1), S = null), /*action*/
      B[0].area.shape ? D ? D.p(B, z) : (D = EP(B), D.c(), D.m(e, null)) : D && (D.d(1), D = null), M === (M = I(B, z)) && L ? L.p(B, z) : (L && L.d(1), L = M && M(B), L && (L.c(), L.m(h.parentNode, h)));
    },
    i(B) {
      _ || (w(t.$$.fragment, B), w(y), _ = !0);
    },
    o(B) {
      O(t.$$.fragment, B), O(y), _ = !1;
    },
    d(B) {
      B && (C(e), C(m), C(h)), N(t), y && y.d(), v && v.d(), k && k.d(), S && S.d(), D && D.d(), L && L.d(B);
    }
  };
}
u(vP, "create_if_block_1$14");
function Fte(i) {
  let e, t, s, n, l;
  return {
    c() {
      var r;
      e = E("input"), b(e, "id", t = /*actionId*/
      i[1] + "-area-quantity"), b(e, "type", "number"), e.value = s = /*action*/
      ((r = i[0].area) == null ? void 0 : r.quantity) ?? 1;
    },
    m(r, o) {
      T(r, e, o), n || (l = W(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), n = !0);
    },
    p(r, o) {
      var a;
      o & /*actionId*/
      2 && t !== (t = /*actionId*/
      r[1] + "-area-quantity") && b(e, "id", t), o & /*action*/
      1 && s !== (s = /*action*/
      ((a = r[0].area) == null ? void 0 : a.quantity) ?? 1) && e.value !== s && (e.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Fte, "create_default_slot_3$o");
function kP(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "Radius",
      $$slots: { default: [Rte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, actionId, action, $item*/
      2097163 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(kP, "create_if_block_13$2");
function Rte(i) {
  let e, t, s, n, l;
  return {
    c() {
      var r;
      e = E("input"), b(e, "id", t = /*actionId*/
      i[1] + "-area-radius"), b(e, "type", "number"), e.value = s = /*action*/
      ((r = i[0].area) == null ? void 0 : r.radius) ?? 0;
    },
    m(r, o) {
      T(r, e, o), n || (l = W(
        e,
        "change",
        /*change_handler_1*/
        i[11]
      ), n = !0);
    },
    p(r, o) {
      var a;
      o & /*actionId*/
      2 && t !== (t = /*actionId*/
      r[1] + "-area-radius") && b(e, "id", t), o & /*action*/
      1 && s !== (s = /*action*/
      ((a = r[0].area) == null ? void 0 : a.radius) ?? 0) && e.value !== s && (e.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Rte, "create_default_slot_2$t");
function wP(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return {
    c() {
      var d;
      e = E("div"), t = E("label"), s = Q("Length"), l = F(), r = E("input"), b(t, "for", n = /*actionId*/
      i[1] + "-area-length"), b(r, "id", o = /*actionId*/
      i[1] + "-area-length"), b(r, "type", "number"), r.value = a = /*action*/
      ((d = i[0].area) == null ? void 0 : d.length) ?? 0, b(e, "class", "u-flex u-flex-col u-gap-xs u-w-30");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, s), A(e, l), A(e, r), c || (f = W(
        r,
        "change",
        /*change_handler_2*/
        i[12]
      ), c = !0);
    },
    p(d, p) {
      var m;
      p & /*actionId*/
      2 && n !== (n = /*actionId*/
      d[1] + "-area-length") && b(t, "for", n), p & /*actionId*/
      2 && o !== (o = /*actionId*/
      d[1] + "-area-length") && b(r, "id", o), p & /*action*/
      1 && a !== (a = /*action*/
      ((m = d[0].area) == null ? void 0 : m.length) ?? 0) && r.value !== a && (r.value = a);
    },
    d(d) {
      d && C(e), c = !1, f();
    }
  };
}
u(wP, "create_if_block_12$3");
function $P(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return {
    c() {
      var d;
      e = E("div"), t = E("label"), s = Q("Width"), l = F(), r = E("input"), b(t, "for", n = /*actionId*/
      i[1] + "-area-width"), b(r, "id", o = /*actionId*/
      i[1] + "-area-width"), b(r, "type", "number"), r.value = a = /*action*/
      ((d = i[0].area) == null ? void 0 : d.width) ?? 0, b(e, "class", "u-flex u-flex-col u-gap-xs u-w-30");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, s), A(e, l), A(e, r), c || (f = W(
        r,
        "change",
        /*change_handler_3*/
        i[13]
      ), c = !0);
    },
    p(d, p) {
      var m;
      p & /*actionId*/
      2 && n !== (n = /*actionId*/
      d[1] + "-area-width") && b(t, "for", n), p & /*actionId*/
      2 && o !== (o = /*actionId*/
      d[1] + "-area-width") && b(r, "id", o), p & /*action*/
      1 && a !== (a = /*action*/
      ((m = d[0].area) == null ? void 0 : m.width) ?? 0) && r.value !== a && (r.value = a);
    },
    d(d) {
      d && C(e), c = !1, f();
    }
  };
}
u($P, "create_if_block_11$5");
function AP(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return {
    c() {
      var d;
      e = E("div"), t = E("label"), s = Q("Height"), l = F(), r = E("input"), b(t, "for", n = /*actionId*/
      i[1] + "-area-height"), b(r, "id", o = /*actionId*/
      i[1] + "-area-height"), b(r, "type", "number"), r.value = a = /*action*/
      ((d = i[0].area) == null ? void 0 : d.height) ?? 0, b(e, "class", "u-flex u-flex-col u-gap-xs u-w-30");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, s), A(e, l), A(e, r), c || (f = W(
        r,
        "change",
        /*change_handler_4*/
        i[14]
      ), c = !0);
    },
    p(d, p) {
      var m;
      p & /*actionId*/
      2 && n !== (n = /*actionId*/
      d[1] + "-area-height") && b(t, "for", n), p & /*actionId*/
      2 && o !== (o = /*actionId*/
      d[1] + "-area-height") && b(r, "id", o), p & /*action*/
      1 && a !== (a = /*action*/
      ((m = d[0].area) == null ? void 0 : m.height) ?? 0) && r.value !== a && (r.value = a);
    },
    d(d) {
      d && C(e), c = !1, f();
    }
  };
}
u(AP, "create_if_block_10$8");
function EP(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("div"), t = E("button"), t.innerHTML = '<i class="fa-solid fa-arrow-up-right-dots svelte-19rt4zx" data-tooltip="A5E.ConfigureAreaScaling" data-tooltip-direction="UP"></i>', b(t, "class", "scaling-button svelte-19rt4zx"), b(e, "class", "a5e-field-group scaling-button-wrapper svelte-19rt4zx");
    },
    m(l, r) {
      T(l, e, r), A(e, t), s || (n = W(t, "click", st(
        /*onClickScalingButton*/
        i[4]
      )), s = !0);
    },
    p: se,
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(EP, "create_if_block_9$9");
function Nte(i) {
  let e;
  function t(l, r) {
    var o, a, c, f;
    return !/*action*/
    ((a = (o = l[0].area) == null ? void 0 : o.scaling) != null && a.step) || /*action*/
    ((f = (c = l[0].area) == null ? void 0 : c.scaling) == null ? void 0 : f.step) === 1 ? Gte : qte;
  }
  u(t, "select_block_type_3");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("small"), n.c();
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(Nte, "create_if_block_7$e");
function jte(i) {
  let e;
  function t(l, r) {
    var o, a, c, f;
    return !/*action*/
    ((a = (o = l[0].area) == null ? void 0 : o.scaling) != null && a.step) || /*action*/
    ((f = (c = l[0].area) == null ? void 0 : c.scaling) == null ? void 0 : f.step) === 1 ? Hte : zte;
  }
  u(t, "select_block_type_2");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("small"), n.c();
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(jte, "create_if_block_5$i");
function Lte(i) {
  let e;
  function t(l, r) {
    var o, a, c, f;
    return !/*action*/
    ((a = (o = l[0].area) == null ? void 0 : o.scaling) != null && a.step) || /*action*/
    ((f = (c = l[0].area) == null ? void 0 : c.scaling) == null ? void 0 : f.step) === 1 ? Vte : Ute;
  }
  u(t, "select_block_type_1");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("small"), n.c();
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(Lte, "create_if_block_3$u");
function Bte(i) {
  let e, t = (
    /*getLocalization*/
    i[5](
      "cantrip",
      /*action*/
      i[0].area
    ) + ""
  ), s;
  return {
    c() {
      e = E("small"), s = Q(t);
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*action*/
      1 && t !== (t = /*getLocalization*/
      n[5](
        "cantrip",
        /*action*/
        n[0].area
      ) + "") && be(s, t);
    },
    d(n) {
      n && C(e);
    }
  };
}
u(Bte, "create_if_block_2$J");
function qte(i) {
  let e = (
    /*getLocalization*/
    i[5](
      "steppedSpellLevel",
      /*action*/
      i[0].area
    ) + ""
  ), t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*action*/
      1 && e !== (e = /*getLocalization*/
      s[5](
        "steppedSpellLevel",
        /*action*/
        s[0].area
      ) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(qte, "create_else_block_2$3");
function Gte(i) {
  let e = (
    /*getLocalization*/
    i[5](
      "steppedSpellLevel",
      /*action*/
      i[0].area
    ) + ""
  ), t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*action*/
      1 && e !== (e = /*getLocalization*/
      s[5](
        "steppedSpellLevel",
        /*action*/
        s[0].area
      ) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(Gte, "create_if_block_8$b");
function zte(i) {
  let e = (
    /*getLocalization*/
    i[5](
      "steppedSpellPoint",
      /*action*/
      i[0].area
    ) + ""
  ), t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*action*/
      1 && e !== (e = /*getLocalization*/
      s[5](
        "steppedSpellPoint",
        /*action*/
        s[0].area
      ) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(zte, "create_else_block_1$6");
function Hte(i) {
  let e = (
    /*getLocalization*/
    i[5](
      "spellPoint",
      /*action*/
      i[0].area
    ) + ""
  ), t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*action*/
      1 && e !== (e = /*getLocalization*/
      s[5](
        "spellPoint",
        /*action*/
        s[0].area
      ) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(Hte, "create_if_block_6$h");
function Ute(i) {
  let e = (
    /*getLocalization*/
    i[5](
      "steppedSpellLevel",
      /*action*/
      i[0].area
    ) + ""
  ), t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*action*/
      1 && e !== (e = /*getLocalization*/
      s[5](
        "steppedSpellLevel",
        /*action*/
        s[0].area
      ) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(Ute, "create_else_block$z");
function Vte(i) {
  let e = (
    /*getLocalization*/
    i[5](
      "spellLevel",
      /*action*/
      i[0].area
    ) + ""
  ), t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*action*/
      1 && e !== (e = /*getLocalization*/
      s[5](
        "spellLevel",
        /*action*/
        s[0].area
      ) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(Vte, "create_if_block_4$p");
function SP(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [Wte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, action, $item, actionId*/
      2097163 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(SP, "create_if_block$1C");
function Wte(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.ItemPlaceTemplate",
      checked: (
        /*action*/
        ((s = i[0].area) == null ? void 0 : s.placeTemplate) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[15]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*action*/
      1 && (r.checked = /*action*/
      ((o = n[0].area) == null ? void 0 : o.placeTemplate) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(Wte, "create_default_slot_1$B");
function Kte(i) {
  var z, q;
  let e, t, s, n, l, r, o, a, c, f = K("A5E.None") + "", d, p, m, g = [], h = /* @__PURE__ */ new Map(), _, y, v, k, S, D, I = ue(Object.entries(
    /*A5E*/
    i[7].areaTypes
  ));
  const M = /* @__PURE__ */ u((U) => (
    /*key*/
    U[17]
  ), "get_key");
  for (let U = 0; U < I.length; U += 1) {
    let H = _P(i, I, U), V = M(H);
    h.set(V, g[U] = yP(V, H));
  }
  let L = (
    /*action*/
    ((z = i[0].area) == null ? void 0 : z.shape) && vP(i)
  ), B = (
    /*action*/
    ((q = i[0].area) == null ? void 0 : q.shape) && SP(i)
  );
  return {
    c() {
      e = E("div"), t = E("input"), r = F(), o = E("label"), a = E("span"), a.innerHTML = '<i class="fas fa-times-circle"></i>', c = F(), d = Q(f), m = F();
      for (let U = 0; U < g.length; U += 1)
        g[U].c();
      _ = F(), L && L.c(), y = F(), B && B.c(), v = $e(), b(t, "class", "area-shape-input svelte-19rt4zx"), b(t, "id", s = "area-" + /*actionId*/
      i[1] + "-none"), b(t, "name", n = /*actionId*/
      i[1] + "-area-shape"), t.value = null, b(t, "type", "radio"), t.checked = l = /*isEmpty*/
      i[9](
        /*action*/
        i[0].area
      ), b(a, "class", "u-text-sm"), b(o, "class", "area-shape-label svelte-19rt4zx"), b(o, "for", p = "area-" + /*actionId*/
      i[1] + "-none"), b(e, "class", "area-shape-list svelte-19rt4zx");
    },
    m(U, H) {
      T(U, e, H), A(e, t), A(e, r), A(e, o), A(o, a), A(o, c), A(o, d), A(e, m);
      for (let V = 0; V < g.length; V += 1)
        g[V] && g[V].m(e, null);
      T(U, _, H), L && L.m(U, H), T(U, y, H), B && B.m(U, H), T(U, v, H), k = !0, S || (D = W(
        t,
        "change",
        /*removeArea*/
        i[6]
      ), S = !0);
    },
    p(U, H) {
      var V, Y;
      (!k || H & /*actionId*/
      2 && s !== (s = "area-" + /*actionId*/
      U[1] + "-none")) && b(t, "id", s), (!k || H & /*actionId*/
      2 && n !== (n = /*actionId*/
      U[1] + "-area-shape")) && b(t, "name", n), (!k || H & /*action*/
      1 && l !== (l = /*isEmpty*/
      U[9](
        /*action*/
        U[0].area
      ))) && (t.checked = l), (!k || H & /*actionId*/
      2 && p !== (p = "area-" + /*actionId*/
      U[1] + "-none")) && b(o, "for", p), H & /*action, actionId, item, Object, A5E*/
      135 && (I = ue(Object.entries(
        /*A5E*/
        U[7].areaTypes
      )), ae(), g = Lt(g, H, M, 1, U, I, h, e, cn, yP, null, _P), ce()), /*action*/
      (V = U[0].area) != null && V.shape ? L ? (L.p(U, H), H & /*action*/
      1 && w(L, 1)) : (L = vP(U), L.c(), w(L, 1), L.m(y.parentNode, y)) : L && (ae(), O(L, 1, 1, () => {
        L = null;
      }), ce()), /*action*/
      (Y = U[0].area) != null && Y.shape ? B ? (B.p(U, H), H & /*action*/
      1 && w(B, 1)) : (B = SP(U), B.c(), w(B, 1), B.m(v.parentNode, v)) : B && (ae(), O(B, 1, 1, () => {
        B = null;
      }), ce());
    },
    i(U) {
      if (!k) {
        for (let H = 0; H < I.length; H += 1)
          w(g[H]);
        w(L), w(B), k = !0;
      }
    },
    o(U) {
      for (let H = 0; H < g.length; H += 1)
        O(g[H]);
      O(L), O(B), k = !1;
    },
    d(U) {
      U && (C(e), C(_), C(y), C(v));
      for (let H = 0; H < g.length; H += 1)
        g[H].d();
      L && L.d(U), B && B.d(U), S = !1, D();
    }
  };
}
u(Kte, "create_default_slot$1c");
function Yte(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.ItemAreaShape",
      $$slots: { default: [Kte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, action, $item, actionId, item*/
      2097167 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Yte, "create_fragment$2Q");
function Xte(i, e, t) {
  let s, n, l = se, r = /* @__PURE__ */ u(() => (l(), l = Xt(c, (I) => t(3, n = I)), c), "$$subscribe_item");
  i.$$.on_destroy.push(() => l());
  let { action: o } = e, { actionId: a } = e, { item: c } = e;
  r();
  function f() {
    let I = n.dialogs.areaScaling[a];
    I || (wo(c, n.dialogs.areaScaling[a] = new gi(n, `${n.name} Target Scaling Configuration`, e0, { actionId: a }), n), I = n.dialogs.areaScaling[a]), I.render(!0);
  }
  u(f, "onClickScalingButton");
  function d(I) {
    var M, L, B, z, q, U, H, V, Y, J;
    if (s.length === 1) return K(`A5E.scaling.summaries.${I}.template`, {
      shape: o == null ? void 0 : o.area.shape,
      formula: ((L = (M = o == null ? void 0 : o.area.scaling) == null ? void 0 : M.formula) == null ? void 0 : L[s[0]]) ?? 0,
      property: s[0],
      unit: "feet",
      level: Bl(n.system.level ?? 0),
      step: (z = (B = o.area) == null ? void 0 : B.scaling) == null ? void 0 : z.step
    });
    if (s.length === 2) return K(`A5E.scaling.summaries.${I}.templateMulti`, {
      shape: o == null ? void 0 : o.area.shape,
      formula1: ((U = (q = o.area.scaling) == null ? void 0 : q.formula) == null ? void 0 : U[s[0]]) ?? 0,
      formula2: ((V = (H = o.area.scaling) == null ? void 0 : H.formula) == null ? void 0 : V[s[1]]) ?? 0,
      property1: s[0],
      property2: s[1],
      unit: "feet",
      level: Bl(n.system.level ?? 0),
      step: (J = (Y = o.area) == null ? void 0 : Y.scaling) == null ? void 0 : J.step
    });
  }
  u(d, "getLocalization");
  function p() {
    n.update({
      [`system.actions.${a}`]: { "-=area": null }
    });
  }
  u(p, "removeArea");
  const { A5E: m } = CONFIG, g = gc.getShapeProperties, { isEmpty: h } = foundry.utils, _ = /* @__PURE__ */ u(({ target: I }) => te(n, `system.actions.${a}.area.quantity`, Number(I.value)), "change_handler"), y = /* @__PURE__ */ u(({ target: I }) => te(n, `system.actions.${a}.area.radius`, Number(I.value)), "change_handler_1"), v = /* @__PURE__ */ u(({ target: I }) => te(n, `system.actions.${a}.area.length`, Number(I.value)), "change_handler_2"), k = /* @__PURE__ */ u(({ target: I }) => te(n, `system.actions.${a}.area.width`, Number(I.value)), "change_handler_3"), S = /* @__PURE__ */ u(({ target: I }) => te(n, `system.actions.${a}.area.height`, Number(I.value)), "change_handler_4"), D = /* @__PURE__ */ u(({ detail: I }) => {
    te(n, `system.actions.${a}.area.placeTemplate`, I);
  }, "updateSelection_handler");
  return i.$$set = (I) => {
    "action" in I && t(0, o = I.action), "actionId" in I && t(1, a = I.actionId), "item" in I && r(t(2, c = I.item));
  }, i.$$.update = () => {
    var I;
    i.$$.dirty & /*action*/
    1 && (s = [...g((I = o.area) == null ? void 0 : I.shape)]);
  }, [
    o,
    a,
    c,
    n,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    v,
    k,
    S,
    D
  ];
}
u(Xte, "instance$2H");
const TE = class TE extends re {
  constructor(e) {
    super(), oe(this, e, Xte, Yte, le, { action: 0, actionId: 1, item: 2 });
  }
};
u(TE, "AreaConfig");
let t0 = TE;
function Ng(i) {
  return i !== "other" && Object.keys(CONFIG.A5E.rangeDescriptors).includes(i);
}
u(Ng, "isStandardRange");
function CP(i, e, t) {
  const s = i.slice();
  return s[21] = e[t][0], s[22] = e[t][1], s;
}
u(CP, "get_each_context$13");
function TP(i) {
  let e, t, s, n, l;
  return e = new Te({
    props: {
      label: "A5E.IncludeUnit",
      checked: (
        /*includeUnit*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), s = new De({
    props: {
      hint: (
        /*includeUnit*/
        i[3] ? "When units are selected range must be a number." : null
      ),
      $$slots: { default: [Jte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), n = E("div"), j(s.$$.fragment), G(n, "display", "contents"), G(n, "--a5e-section-body-padding", "0");
    },
    m(r, o) {
      R(e, r, o), T(r, t, o), T(r, n, o), R(s, n, null), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*includeUnit*/
      8 && (a.checked = /*includeUnit*/
      r[3]), e.$set(a);
      const c = {};
      o & /*includeUnit*/
      8 && (c.hint = /*includeUnit*/
      r[3] ? "When units are selected range must be a number." : null), o & /*$$scope, id, rangeObject, includeUnit, customValue*/
      33554447 && (c.$$scope = { dirty: o, ctx: r }), s.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(s.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(s.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(t), N(e, r), r && s && C(n), N(s, r);
    }
  };
}
u(TP, "create_if_block$1B");
function OP(i) {
  let e, t, s, n, l, r = ue(Object.entries(
    /*A5E*/
    i[7].distanceUnits
  )), o = [];
  for (let a = 0; a < r.length; a += 1)
    o[a] = DP(CP(i, r, a));
  return {
    c() {
      e = E("select"), t = E("option"), t.textContent = `${K("A5E.None")}`;
      for (let a = 0; a < o.length; a += 1)
        o[a].c();
      t.__value = null, He(t, t.__value), b(e, "class", "u-w-30"), b(e, "name", s = "system.actions.$" + /*actionId*/
      i[6] + ".ranges." + /*id*/
      i[0] + ".unit");
    },
    m(a, c) {
      T(a, e, c), A(e, t);
      for (let f = 0; f < o.length; f += 1)
        o[f] && o[f].m(e, null);
      n || (l = W(
        e,
        "change",
        /*selectRangeUnit*/
        i[9]
      ), n = !0);
    },
    p(a, c) {
      if (c & /*Object, A5E, rangeObject*/
      130) {
        r = ue(Object.entries(
          /*A5E*/
          a[7].distanceUnits
        ));
        let f;
        for (f = 0; f < r.length; f += 1) {
          const d = CP(a, r, f);
          o[f] ? o[f].p(d, c) : (o[f] = DP(d), o[f].c(), o[f].m(e, null));
        }
        for (; f < o.length; f += 1)
          o[f].d(1);
        o.length = r.length;
      }
      c & /*id*/
      1 && s !== (s = "system.actions.$" + /*actionId*/
      a[6] + ".ranges." + /*id*/
      a[0] + ".unit") && b(e, "name", s);
    },
    d(a) {
      a && C(e), Le(o, a), n = !1, l();
    }
  };
}
u(OP, "create_if_block_1$13");
function DP(i) {
  let e, t = K(
    /*label*/
    i[22]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = Q(t), n = F(), e.__value = /*unit*/
      i[21], He(e, e.__value), e.selected = l = /*rangeObject*/
      i[1].unit === /*unit*/
      i[21];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*rangeObject*/
      2 && l !== (l = /*rangeObject*/
      r[1].unit === /*unit*/
      r[21]) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(DP, "create_each_block$13");
function Jte(i) {
  let e, t, s, n, l, r = (
    /*includeUnit*/
    i[3] && OP(i)
  );
  return {
    c() {
      e = E("div"), t = E("input"), s = F(), r && r.c(), G(t, "flex-shrink", "1"), b(t, "type", "text"), G(e, "display", "flex"), G(e, "gap", "0.5rem"), G(e, "flex-wrap", "nowrap");
    },
    m(o, a) {
      T(o, e, a), A(e, t), He(
        t,
        /*customValue*/
        i[2]
      ), A(e, s), r && r.m(e, null), n || (l = [
        W(
          t,
          "input",
          /*input_input_handler*/
          i[18]
        ),
        W(
          t,
          "change",
          /*change_handler*/
          i[19]
        )
      ], n = !0);
    },
    p(o, a) {
      a & /*customValue*/
      4 && t.value !== /*customValue*/
      o[2] && He(
        t,
        /*customValue*/
        o[2]
      ), /*includeUnit*/
      o[3] ? r ? r.p(o, a) : (r = OP(o), r.c(), r.m(e, null)) : r && (r.d(1), r = null);
    },
    d(o) {
      o && C(e), r && r.d(), n = !1, Me(l);
    }
  };
}
u(Jte, "create_default_slot$1b");
function Zte(i) {
  let e, t, s, n, l;
  e = new Ke({
    props: {
      buttons: [
        {
          classes: "fa-solid fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*deleteRangeIncrement*/
            i[11]
          ),
          tooltip: "Delete Range Increment"
        }
      ],
      heading: (
        /*heading*/
        i[12]
      ),
      options: (
        /*options*/
        i[13]
      ),
      selected: (
        /*selected*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  );
  let r = (
    /*selected*/
    i[4] === "other" && TP(i)
  );
  return {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), r && r.c(), n = $e(), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-header-width", "100%"), G(t, "--a5e-field-wrapper-label-width", "100%"), G(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), G(t, "--a5e-header-button-color-hover", "#555");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*selected*/
      16 && (c.selected = /*selected*/
      o[4]), e.$set(c), /*selected*/
      o[4] === "other" ? r ? (r.p(o, a), a & /*selected*/
      16 && w(r, 1)) : (r = TP(o), r.c(), w(r, 1), r.m(n.parentNode, n)) : r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce());
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(r), l = !1;
    },
    d(o) {
      o && (C(s), C(n)), o && e && C(t), N(e, o), r && r.d(o);
    }
  };
}
u(Zte, "create_fragment$2P");
function Qte(i, e, t) {
  let s, n, { index: l } = e, { id: r } = e, { rangeObject: o } = e, a = o.range;
  const c = de("item");
  pe(i, c, (L) => t(20, n = L));
  const f = de("actionId"), d = CONFIG.A5E;
  function p(L) {
    Ng(L) ? (t(15, a = L), t(2, v = "")) : k ? t(15, a = parseInt(L, 10)) : t(15, a = v), te(n, `system.actions.${f}.ranges.${r}.range`, a);
  }
  u(p, "updateRangeValue");
  function m(L) {
    var z, q;
    const B = (q = (z = L.target) == null ? void 0 : z.selectedOptions[0]) == null ? void 0 : q.value;
    B === "null" ? n.update({
      [`system.actions.${f}.ranges.${r}`]: { "-=unit": null }
    }) : n.update({
      [`system.actions.${f}.ranges.${r}`]: { unit: B }
    });
  }
  u(m, "selectRangeUnit");
  function g(L) {
    var z;
    ((z = L.target) == null ? void 0 : z.checked) !== !0 && n.update({
      [`system.actions.${f}.ranges.${r}`]: { "-=unit": null }
    });
  }
  u(g, "deleteRangeUnit");
  function h() {
    n.update({
      [`system.actions.${f}.ranges`]: { [`-=${r}`]: null }
    });
  }
  u(h, "deleteRangeIncrement");
  const _ = K("A5E.ItemRangeIncrement", { increment: Bl(l + 1) }), y = Object.entries(CONFIG.A5E.rangeDescriptors).map(([L, B]) => {
    if (["short", "medium", "long"].includes(L)) {
      const z = CONFIG.A5E.rangeValues[L];
      return [L, `${K(B)} (${z} ft.)`];
    }
    return [L, B];
  });
  let v = Ng(a) ? "" : a, k = !!o.unit;
  const S = /* @__PURE__ */ u(({ detail: L }) => p(L), "updateSelection_handler"), D = /* @__PURE__ */ u((L) => {
    t(3, k = L.detail), g(L);
  }, "updateSelection_handler_1");
  function I() {
    v = this.value, t(2, v);
  }
  u(I, "input_input_handler");
  const M = /* @__PURE__ */ u(() => p(v), "change_handler");
  return i.$$set = (L) => {
    "index" in L && t(14, l = L.index), "id" in L && t(0, r = L.id), "rangeObject" in L && t(1, o = L.rangeObject);
  }, i.$$.update = () => {
    i.$$.dirty & /*range*/
    32768 && t(4, s = Ng(a) ? a : "other");
  }, [
    r,
    o,
    v,
    k,
    s,
    c,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    l,
    a,
    S,
    D,
    I,
    M
  ];
}
u(Qte, "instance$2G");
const OE = class OE extends re {
  constructor(e) {
    super(), oe(this, e, Qte, Zte, le, { index: 14, id: 0, rangeObject: 1 });
  }
};
u(OE, "TargetRangeIncrement");
let s0 = OE;
function xte(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [sse] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, scalingMode, actionId, target, $item*/
      8219 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(xte, "create_if_block_2$I");
function ese(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [nse] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, actionId, target, $item*/
      8203 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(ese, "create_if_block_1$12");
function tse(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "Targets Increment",
      hint: "This increment will be applied automatically based on your caster level.",
      $$slots: { default: [ise] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, actionId, action, $item*/
      8205 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(tse, "create_if_block$1A");
function sse(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S, D, I, M, L, B = (
    /*scalingMode*/
    i[4] === "spellPoints" ? "Points" : "Uses"
  ), z, q, U;
  return {
    c() {
      var H, V, Y, J;
      e = E("section"), t = E("div"), s = E("label"), n = Q("Targets Increment"), r = F(), o = E("input"), d = F(), p = E("div"), m = E("label"), g = Q("Per"), _ = F(), y = E("input"), D = F(), I = E("div"), M = E("span"), L = Q("Additional "), z = Q(B), b(s, "for", l = /*actionId*/
      i[0] + "-targets-healing-scaling-formula"), b(s, "class", "svelte-171ivr7"), b(o, "id", a = /*actionId*/
      i[0] + "-targets-scaling-formula"), b(o, "type", "text"), b(o, "name", c = "system.actions." + /*actionId*/
      i[0] + ".target.scaling.formula"), o.value = f = /*target*/
      ((V = (H = i[1]) == null ? void 0 : H.scaling) == null ? void 0 : V.formula) ?? 0, b(o, "class", "svelte-171ivr7"), b(t, "class", "a5e-field-group a5e-field-group--formula"), b(m, "for", h = /*actionId*/
      i[0] + "-targets-scaling-step"), b(m, "class", "svelte-171ivr7"), b(y, "id", v = /*actionId*/
      i[0] + "-targets-scaling-step"), G(y, "text-align", "center"), b(y, "type", "number"), b(y, "name", k = "system.actions." + /*actionId*/
      i[0] + ".target.scaling.step"), y.value = S = /*target*/
      ((J = (Y = i[1]) == null ? void 0 : Y.scaling) == null ? void 0 : J.step) ?? 1, b(y, "class", "svelte-171ivr7"), b(p, "class", "a5e-field-group u-w-12"), b(M, "class", "levels svelte-171ivr7"), b(I, "class", "a5e-field-group levels-wrapper svelte-171ivr7"), b(e, "class", "row u-flex-wrap svelte-171ivr7");
    },
    m(H, V) {
      T(H, e, V), A(e, t), A(t, s), A(s, n), A(t, r), A(t, o), A(e, d), A(e, p), A(p, m), A(m, g), A(p, _), A(p, y), A(e, D), A(e, I), A(I, M), A(M, L), A(M, z), q || (U = [
        W(
          o,
          "change",
          /*change_handler_3*/
          i[11]
        ),
        W(
          y,
          "change",
          /*change_handler_4*/
          i[12]
        )
      ], q = !0);
    },
    p(H, V) {
      var Y, J, fe, ke;
      V & /*actionId*/
      1 && l !== (l = /*actionId*/
      H[0] + "-targets-healing-scaling-formula") && b(s, "for", l), V & /*actionId*/
      1 && a !== (a = /*actionId*/
      H[0] + "-targets-scaling-formula") && b(o, "id", a), V & /*actionId*/
      1 && c !== (c = "system.actions." + /*actionId*/
      H[0] + ".target.scaling.formula") && b(o, "name", c), V & /*target*/
      2 && f !== (f = /*target*/
      ((J = (Y = H[1]) == null ? void 0 : Y.scaling) == null ? void 0 : J.formula) ?? 0) && o.value !== f && (o.value = f), V & /*actionId*/
      1 && h !== (h = /*actionId*/
      H[0] + "-targets-scaling-step") && b(m, "for", h), V & /*actionId*/
      1 && v !== (v = /*actionId*/
      H[0] + "-targets-scaling-step") && b(y, "id", v), V & /*actionId*/
      1 && k !== (k = "system.actions." + /*actionId*/
      H[0] + ".target.scaling.step") && b(y, "name", k), V & /*target*/
      2 && S !== (S = /*target*/
      ((ke = (fe = H[1]) == null ? void 0 : fe.scaling) == null ? void 0 : ke.step) ?? 1) && y.value !== S && (y.value = S), V & /*scalingMode*/
      16 && B !== (B = /*scalingMode*/
      H[4] === "spellPoints" ? "Points" : "Uses") && be(z, B);
    },
    d(H) {
      H && C(e), q = !1, Me(U);
    }
  };
}
u(sse, "create_default_slot_2$s");
function nse(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S, D, I, M, L;
  return {
    c() {
      var B, z, q, U;
      e = E("section"), t = E("div"), s = E("label"), n = Q("Targets Increment"), r = F(), o = E("input"), d = F(), p = E("div"), m = E("label"), g = Q("Per"), _ = F(), y = E("input"), D = F(), I = E("div"), I.innerHTML = '<span class="levels svelte-171ivr7">Levels</span>', b(s, "for", l = /*actionId*/
      i[0] + "-targets-scaling-formula"), b(s, "class", "svelte-171ivr7"), b(o, "id", a = /*actionId*/
      i[0] + "-targets-scaling-formula"), b(o, "type", "text"), b(o, "name", c = "system.actions." + /*actionId*/
      i[0] + ".target.scaling.formula"), o.value = f = /*target*/
      ((z = (B = i[1]) == null ? void 0 : B.scaling) == null ? void 0 : z.formula) ?? 0, b(o, "class", "svelte-171ivr7"), b(t, "class", "a5e-field-group a5e-field-group--formula a5e-field-group--spell-level svelte-171ivr7"), b(m, "for", h = /*actionId*/
      i[0] + "targets-scaling-step"), b(m, "class", "svelte-171ivr7"), b(y, "id", v = /*actionId*/
      i[0] + "-targets-scaling-step"), b(y, "type", "number"), b(y, "name", k = "system.actions." + /*actionId*/
      i[0] + ".target.scaling.step"), y.value = S = /*target*/
      ((U = (q = i[1]) == null ? void 0 : q.scaling) == null ? void 0 : U.step) ?? 1, b(y, "class", "svelte-171ivr7"), b(p, "class", "a5e-field-group u-w-12 a5e-field-group--spell-level svelte-171ivr7"), b(I, "class", "a5e-field-group levels-wrapper svelte-171ivr7"), b(e, "class", "row u-flex-wrap svelte-171ivr7");
    },
    m(B, z) {
      T(B, e, z), A(e, t), A(t, s), A(s, n), A(t, r), A(t, o), A(e, d), A(e, p), A(p, m), A(m, g), A(p, _), A(p, y), A(e, D), A(e, I), M || (L = [
        W(
          o,
          "change",
          /*change_handler_1*/
          i[9]
        ),
        W(
          y,
          "change",
          /*change_handler_2*/
          i[10]
        )
      ], M = !0);
    },
    p(B, z) {
      var q, U, H, V;
      z & /*actionId*/
      1 && l !== (l = /*actionId*/
      B[0] + "-targets-scaling-formula") && b(s, "for", l), z & /*actionId*/
      1 && a !== (a = /*actionId*/
      B[0] + "-targets-scaling-formula") && b(o, "id", a), z & /*actionId*/
      1 && c !== (c = "system.actions." + /*actionId*/
      B[0] + ".target.scaling.formula") && b(o, "name", c), z & /*target*/
      2 && f !== (f = /*target*/
      ((U = (q = B[1]) == null ? void 0 : q.scaling) == null ? void 0 : U.formula) ?? 0) && o.value !== f && (o.value = f), z & /*actionId*/
      1 && h !== (h = /*actionId*/
      B[0] + "targets-scaling-step") && b(m, "for", h), z & /*actionId*/
      1 && v !== (v = /*actionId*/
      B[0] + "-targets-scaling-step") && b(y, "id", v), z & /*actionId*/
      1 && k !== (k = "system.actions." + /*actionId*/
      B[0] + ".target.scaling.step") && b(y, "name", k), z & /*target*/
      2 && S !== (S = /*target*/
      ((V = (H = B[1]) == null ? void 0 : H.scaling) == null ? void 0 : V.step) ?? 1) && y.value !== S && (y.value = S);
    },
    d(B) {
      B && C(e), M = !1, Me(L);
    }
  };
}
u(nse, "create_default_slot_1$A");
function ise(i) {
  let e, t, s, n, l;
  return {
    c() {
      var r;
      e = E("input"), b(e, "class", "a5e-input svelte-171ivr7"), b(e, "type", "text"), b(e, "name", t = "system.actions." + /*actionId*/
      i[0] + ".target.scaling.formula"), e.value = s = /*action*/
      ((r = i[2].target.scaling) == null ? void 0 : r.formula) ?? 0;
    },
    m(r, o) {
      T(r, e, o), n || (l = W(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), n = !0);
    },
    p(r, o) {
      var a;
      o & /*actionId*/
      1 && t !== (t = "system.actions." + /*actionId*/
      r[0] + ".target.scaling.formula") && b(e, "name", t), o & /*action*/
      4 && s !== (s = /*action*/
      ((a = r[2].target.scaling) == null ? void 0 : a.formula) ?? 0) && e.value !== s && (e.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(ise, "create_default_slot$1a");
function lse(i) {
  let e, t, s, n, l, r, o;
  t = new Ke({
    props: {
      heading: "Scaling Mode",
      options: rse(),
      selected: (
        /*scalingMode*/
        i[4]
      ),
      allowDeselect: !1
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  );
  const a = [tse, ese, xte], c = [];
  function f(d, p) {
    return p & /*scalingMode*/
    16 && (n = null), /*scalingMode*/
    d[4] === "cantrip" ? 0 : (
      /*scalingMode*/
      d[4] === "spellLevel" ? 1 : (n == null && (n = !!["artifactCharges", "spellPoints", "actionUses", "itemUses"].includes(
        /*scalingMode*/
        d[4]
      )), n ? 2 : -1)
    );
  }
  return u(f, "select_block_type"), ~(l = f(i, -1)) && (r = c[l] = a[l](i)), {
    c() {
      e = E("form"), j(t.$$.fragment), s = F(), r && r.c(), b(e, "class", "svelte-171ivr7");
    },
    m(d, p) {
      T(d, e, p), R(t, e, null), A(e, s), ~l && c[l].m(e, null), o = !0;
    },
    p(d, [p]) {
      const m = {};
      p & /*scalingMode*/
      16 && (m.selected = /*scalingMode*/
      d[4]), t.$set(m);
      let g = l;
      l = f(d, p), l === g ? ~l && c[l].p(d, p) : (r && (ae(), O(c[g], 1, 1, () => {
        c[g] = null;
      }), ce()), ~l ? (r = c[l], r ? r.p(d, p) : (r = c[l] = a[l](d), r.c()), w(r, 1), r.m(e, null)) : r = null);
    },
    i(d) {
      o || (w(t.$$.fragment, d), w(r), o = !0);
    },
    o(d) {
      O(t.$$.fragment, d), O(r), o = !1;
    },
    d(d) {
      d && C(e), N(t), ~l && c[l].d();
    }
  };
}
u(lse, "create_fragment$2O");
function rse() {
  return [[null, "A5E.None"], ...Object.entries(CONFIG.A5E.targetScalingModes)];
}
u(rse, "getTargetScalingOptions");
function ose(i, e, t) {
  let s, n, l, r, { document: o, actionId: a } = de("#external").application, { document: c = o, actionId: f = a } = e;
  const d = c;
  pe(i, d, (v) => t(3, r = v));
  const p = /* @__PURE__ */ u((v) => {
    te(r, `system.actions.${f}.target.scaling.mode`, v.detail);
  }, "updateSelection_handler"), m = /* @__PURE__ */ u(({ target: v }) => te(r, v.name, v.value), "change_handler"), g = /* @__PURE__ */ u(({ target: v }) => te(r, v.name, v.value), "change_handler_1"), h = /* @__PURE__ */ u(({ target: v }) => te(r, v.name, parseInt(v.value, 10)), "change_handler_2"), _ = /* @__PURE__ */ u(({ target: v }) => te(r, v.name, v.value), "change_handler_3"), y = /* @__PURE__ */ u(({ target: v }) => te(r, v.name, parseInt(v.value, 10)), "change_handler_4");
  return i.$$set = (v) => {
    "document" in v && t(6, c = v.document), "actionId" in v && t(0, f = v.actionId);
  }, i.$$.update = () => {
    var v;
    i.$$.dirty & /*$item, actionId*/
    9 && t(2, s = r.actions.get(f)), i.$$.dirty & /*action*/
    4 && t(1, n = s.target ?? {}), i.$$.dirty & /*target*/
    2 && t(4, l = ((v = n == null ? void 0 : n.scaling) == null ? void 0 : v.mode) ?? null);
  }, [
    f,
    n,
    s,
    r,
    l,
    d,
    c,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
u(ose, "instance$2F");
const DE = class DE extends re {
  constructor(e) {
    super(), oe(this, e, ose, lse, le, { document: 6, actionId: 0 });
  }
};
u(DE, "TargetScalingDialog");
let n0 = DE;
function IP(i, e, t) {
  const s = i.slice();
  return s[10] = e[t][0], s[11] = e[t][1], s;
}
u(IP, "get_each_context$12");
function PP(i, e, t) {
  const s = i.slice();
  return s[14] = e[t][0], s[15] = e[t][1], s[17] = t, s;
}
u(PP, "get_each_context_1$d");
function MP(i, e) {
  let t, s, n, l, r;
  return s = new s0({
    props: {
      index: (
        /*index*/
        e[17]
      ),
      id: (
        /*id*/
        e[14]
      ),
      rangeObject: (
        /*range*/
        e[15]
      )
    }
  }), {
    key: i,
    first: null,
    c() {
      t = E("li"), j(s.$$.fragment), n = F(), b(t, "class", "a5e-item a5e-item--action-config"), b(t, "data-range-id", l = /*id*/
      e[14]), this.first = t;
    },
    m(o, a) {
      T(o, t, a), R(s, t, null), A(t, n), r = !0;
    },
    p(o, a) {
      e = o;
      const c = {};
      a & /*action*/
      2 && (c.index = /*index*/
      e[17]), a & /*action*/
      2 && (c.id = /*id*/
      e[14]), a & /*action*/
      2 && (c.rangeObject = /*range*/
      e[15]), s.$set(c), (!r || a & /*action*/
      2 && l !== (l = /*id*/
      e[14])) && b(t, "data-range-id", l);
    },
    i(o) {
      r || (w(s.$$.fragment, o), r = !0);
    },
    o(o) {
      O(s.$$.fragment, o), r = !1;
    },
    d(o) {
      o && C(t), N(s);
    }
  };
}
u(MP, "create_each_block_1$d");
function ase(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l = ue(Object.entries(
    /*action*/
    i[1].ranges ?? {}
  ));
  const r = /* @__PURE__ */ u((o) => (
    /*id*/
    o[14]
  ), "get_key");
  for (let o = 0; o < l.length; o += 1) {
    let a = PP(i, l, o), c = r(a);
    s.set(c, t[o] = MP(c, a));
  }
  return {
    c() {
      e = E("ul");
      for (let o = 0; o < t.length; o += 1)
        t[o].c();
      b(e, "class", "a5e-item-list");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < t.length; c += 1)
        t[c] && t[c].m(e, null);
      n = !0;
    },
    p(o, a) {
      a & /*Object, action*/
      2 && (l = ue(Object.entries(
        /*action*/
        o[1].ranges ?? {}
      )), ae(), t = Lt(t, a, r, 1, o, l, s, e, cn, MP, null, PP), ce());
    },
    i(o) {
      if (!n) {
        for (let a = 0; a < l.length; a += 1)
          w(t[a]);
        n = !0;
      }
    },
    o(o) {
      for (let a = 0; a < t.length; a += 1)
        O(t[a]);
      n = !1;
    },
    d(o) {
      o && C(e);
      for (let a = 0; a < t.length; a += 1)
        t[a].d();
    }
  };
}
u(ase, "create_default_slot_2$r");
function FP(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "class", "small-input"), b(e, "type", "number"), b(e, "name", "targetQuantity"), e.value = t = /*action*/
      ((l = i[1].target) == null ? void 0 : l.quantity) ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = [
        W(
          e,
          "change",
          /*change_handler*/
          i[9]
        ),
        W(e, "click", wse)
      ], s = !0);
    },
    p(l, r) {
      var o;
      r & /*action*/
      2 && t !== (t = /*action*/
      ((o = l[1].target) == null ? void 0 : o.quantity) ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, Me(n);
    }
  };
}
u(FP, "create_if_block_8$a");
function RP(i, e) {
  let t, s = K(
    /*name*/
    e[11]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      var o, a;
      t = E("option"), n = Q(s), l = F(), t.__value = /*key*/
      e[10], He(t, t.__value), t.selected = r = /*action*/
      ((a = (o = e[1]) == null ? void 0 : o.target) == null ? void 0 : a.type) === /*key*/
      e[10], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      var c, f;
      e = o, a & /*action*/
      2 && r !== (r = /*action*/
      ((f = (c = e[1]) == null ? void 0 : c.target) == null ? void 0 : f.type) === /*key*/
      e[10]) && (t.selected = r);
    },
    d(o) {
      o && C(t);
    }
  };
}
u(RP, "create_each_block$12");
function NP(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("div"), t = E("button"), t.innerHTML = '<i class="fa-solid fa-arrow-up-right-dots svelte-1gu1x96" data-tooltip="A5E.ConfigureTargetScaling" data-tooltip-direction="UP"></i>', b(t, "class", "scaling-button svelte-1gu1x96"), b(e, "class", "a5e-field-group scaling-button-wrapper svelte-1gu1x96");
    },
    m(l, r) {
      T(l, e, r), A(e, t), s || (n = W(t, "click", st(
        /*onClickTargetScalingButton*/
        i[6]
      )), s = !0);
    },
    p: se,
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(NP, "create_if_block_7$d");
function cse(i) {
  let e;
  function t(l, r) {
    var o, a, c, f;
    return !/*action*/
    ((a = (o = l[1].target) == null ? void 0 : o.scaling) != null && a.step) || /*action*/
    ((f = (c = l[1].target) == null ? void 0 : c.scaling) == null ? void 0 : f.step) === 1 ? mse : pse;
  }
  u(t, "select_block_type_3");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("small"), n.c();
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(cse, "create_if_block_5$h");
function use(i) {
  let e;
  function t(l, r) {
    var o, a, c, f;
    return !/*action*/
    ((a = (o = l[1].target) == null ? void 0 : o.scaling) != null && a.step) || /*action*/
    ((f = (c = l[1].target) == null ? void 0 : c.scaling) == null ? void 0 : f.step) === 1 ? gse : hse;
  }
  u(t, "select_block_type_2");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("small"), n.c();
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(use, "create_if_block_3$t");
function fse(i) {
  let e;
  function t(l, r) {
    var o, a, c, f;
    return !/*action*/
    ((a = (o = l[1].target) == null ? void 0 : o.scaling) != null && a.step) || /*action*/
    ((f = (c = l[1].target) == null ? void 0 : c.scaling) == null ? void 0 : f.step) === 1 ? _se : bse;
  }
  u(t, "select_block_type_1");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("small"), n.c();
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(fse, "create_if_block_1$11");
function dse(i) {
  var n, l, r;
  let e, t = K("A5E.scaling.summaries.cantrip.target", {
    formula: (
      /*action*/
      ((n = i[1].target) == null ? void 0 : n.scaling.formula) ?? 0
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (r = (l = i[1]) == null ? void 0 : l.target) == null ? void 0 : r.type
      ]
    )
  }) + "", s;
  return {
    c() {
      e = E("small"), s = Q(t);
    },
    m(o, a) {
      T(o, e, a), A(e, s);
    },
    p(o, a) {
      var c, f, d;
      a & /*action*/
      2 && t !== (t = K("A5E.scaling.summaries.cantrip.target", {
        formula: (
          /*action*/
          ((c = o[1].target) == null ? void 0 : c.scaling.formula) ?? 0
        ),
        targetType: (
          /*A5E*/
          o[4].targetTypesPlural[
            /*action*/
            (d = (f = o[1]) == null ? void 0 : f.target) == null ? void 0 : d.type
          ]
        )
      }) + "") && be(s, t);
    },
    d(o) {
      o && C(e);
    }
  };
}
u(dse, "create_if_block$1z");
function pse(i) {
  var s, n, l, r;
  let e = K("A5E.scaling.summaries.steppedUses.target", {
    formula: (
      /*action*/
      ((s = i[1].target) == null ? void 0 : s.scaling.formula) ?? 0
    ),
    step: (
      /*action*/
      (n = i[1].target) == null ? void 0 : n.scaling.step
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (r = (l = i[1]) == null ? void 0 : l.target) == null ? void 0 : r.type
      ]
    )
  }) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(o, a) {
      T(o, t, a);
    },
    p(o, a) {
      var c, f, d, p;
      a & /*action*/
      2 && e !== (e = K("A5E.scaling.summaries.steppedUses.target", {
        formula: (
          /*action*/
          ((c = o[1].target) == null ? void 0 : c.scaling.formula) ?? 0
        ),
        step: (
          /*action*/
          (f = o[1].target) == null ? void 0 : f.scaling.step
        ),
        targetType: (
          /*A5E*/
          o[4].targetTypesPlural[
            /*action*/
            (p = (d = o[1]) == null ? void 0 : d.target) == null ? void 0 : p.type
          ]
        )
      }) + "") && be(t, e);
    },
    d(o) {
      o && C(t);
    }
  };
}
u(pse, "create_else_block_2$2");
function mse(i) {
  var s, n, l;
  let e = K("A5E.scaling.summaries.uses.target", {
    formula: (
      /*action*/
      ((s = i[1].target) == null ? void 0 : s.scaling.formula) ?? 0
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (l = (n = i[1]) == null ? void 0 : n.target) == null ? void 0 : l.type
      ]
    )
  }) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(r, o) {
      T(r, t, o);
    },
    p(r, o) {
      var a, c, f;
      o & /*action*/
      2 && e !== (e = K("A5E.scaling.summaries.uses.target", {
        formula: (
          /*action*/
          ((a = r[1].target) == null ? void 0 : a.scaling.formula) ?? 0
        ),
        targetType: (
          /*A5E*/
          r[4].targetTypesPlural[
            /*action*/
            (f = (c = r[1]) == null ? void 0 : c.target) == null ? void 0 : f.type
          ]
        )
      }) + "") && be(t, e);
    },
    d(r) {
      r && C(t);
    }
  };
}
u(mse, "create_if_block_6$g");
function hse(i) {
  var s, n, l, r, o, a;
  let e = K("A5E.scaling.summaries.steppedSpellPoint.target", {
    formula: (
      /*action*/
      ((n = (s = i[1].target) == null ? void 0 : s.scaling) == null ? void 0 : n.formula) ?? 0
    ),
    step: (
      /*action*/
      (r = (l = i[1].target) == null ? void 0 : l.scaling) == null ? void 0 : r.step
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (a = (o = i[1]) == null ? void 0 : o.target) == null ? void 0 : a.type
      ]
    )
  }) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(c, f) {
      T(c, t, f);
    },
    p(c, f) {
      var d, p, m, g, h, _;
      f & /*action*/
      2 && e !== (e = K("A5E.scaling.summaries.steppedSpellPoint.target", {
        formula: (
          /*action*/
          ((p = (d = c[1].target) == null ? void 0 : d.scaling) == null ? void 0 : p.formula) ?? 0
        ),
        step: (
          /*action*/
          (g = (m = c[1].target) == null ? void 0 : m.scaling) == null ? void 0 : g.step
        ),
        targetType: (
          /*A5E*/
          c[4].targetTypesPlural[
            /*action*/
            (_ = (h = c[1]) == null ? void 0 : h.target) == null ? void 0 : _.type
          ]
        )
      }) + "") && be(t, e);
    },
    d(c) {
      c && C(t);
    }
  };
}
u(hse, "create_else_block_1$5");
function gse(i) {
  var s, n, l;
  let e = K("A5E.scaling.summaries.spellPoint.target", {
    formula: (
      /*action*/
      ((s = i[1].target) == null ? void 0 : s.scaling.formula) ?? 0
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (l = (n = i[1]) == null ? void 0 : n.target) == null ? void 0 : l.type
      ]
    )
  }) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(r, o) {
      T(r, t, o);
    },
    p(r, o) {
      var a, c, f;
      o & /*action*/
      2 && e !== (e = K("A5E.scaling.summaries.spellPoint.target", {
        formula: (
          /*action*/
          ((a = r[1].target) == null ? void 0 : a.scaling.formula) ?? 0
        ),
        targetType: (
          /*A5E*/
          r[4].targetTypesPlural[
            /*action*/
            (f = (c = r[1]) == null ? void 0 : c.target) == null ? void 0 : f.type
          ]
        )
      }) + "") && be(t, e);
    },
    d(r) {
      r && C(t);
    }
  };
}
u(gse, "create_if_block_4$o");
function bse(i) {
  var s, n, l, r, o, a;
  let e = K("A5E.scaling.summaries.steppedSpellLevel.target", {
    formula: (
      /*action*/
      ((n = (s = i[1].target) == null ? void 0 : s.scaling) == null ? void 0 : n.formula) ?? 0
    ),
    step: (
      /*action*/
      (r = (l = i[1].target) == null ? void 0 : l.scaling) == null ? void 0 : r.step
    ),
    level: Bl(
      /*$item*/
      i[0].system.level
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (a = (o = i[1]) == null ? void 0 : o.target) == null ? void 0 : a.type
      ]
    )
  }) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(c, f) {
      T(c, t, f);
    },
    p(c, f) {
      var d, p, m, g, h, _;
      f & /*action, $item*/
      3 && e !== (e = K("A5E.scaling.summaries.steppedSpellLevel.target", {
        formula: (
          /*action*/
          ((p = (d = c[1].target) == null ? void 0 : d.scaling) == null ? void 0 : p.formula) ?? 0
        ),
        step: (
          /*action*/
          (g = (m = c[1].target) == null ? void 0 : m.scaling) == null ? void 0 : g.step
        ),
        level: Bl(
          /*$item*/
          c[0].system.level
        ),
        targetType: (
          /*A5E*/
          c[4].targetTypesPlural[
            /*action*/
            (_ = (h = c[1]) == null ? void 0 : h.target) == null ? void 0 : _.type
          ]
        )
      }) + "") && be(t, e);
    },
    d(c) {
      c && C(t);
    }
  };
}
u(bse, "create_else_block$y");
function _se(i) {
  var s, n, l;
  let e = K("A5E.scaling.summaries.spellLevel.target", {
    formula: (
      /*action*/
      ((s = i[1].target) == null ? void 0 : s.scaling.formula) ?? 0
    ),
    level: Bl(
      /*$item*/
      i[0].system.level
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (l = (n = i[1]) == null ? void 0 : n.target) == null ? void 0 : l.type
      ]
    )
  }) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(r, o) {
      T(r, t, o);
    },
    p(r, o) {
      var a, c, f;
      o & /*action, $item*/
      3 && e !== (e = K("A5E.scaling.summaries.spellLevel.target", {
        formula: (
          /*action*/
          ((a = r[1].target) == null ? void 0 : a.scaling.formula) ?? 0
        ),
        level: Bl(
          /*$item*/
          r[0].system.level
        ),
        targetType: (
          /*A5E*/
          r[4].targetTypesPlural[
            /*action*/
            (f = (c = r[1]) == null ? void 0 : c.target) == null ? void 0 : f.type
          ]
        )
      }) + "") && be(t, e);
    },
    d(r) {
      r && C(t);
    }
  };
}
u(_se, "create_if_block_2$H");
function yse(i) {
  var B, z, q;
  let e, t = ["creature", "object", "creatureObject"].includes(
    /*action*/
    (B = i[1].target) == null ? void 0 : B.type
  ), s, n, l, r = K("A5E.None") + "", o, a, c, f = [], d = /* @__PURE__ */ new Map(), p, m = ["creature", "object", "creatureObject"].includes(
    /*action*/
    (q = (z = i[1]) == null ? void 0 : z.target) == null ? void 0 : q.type
  ), g, h, _, y, v = t && FP(i), k = ue(Object.entries(
    /*A5E*/
    i[4].targetTypes
  ));
  const S = /* @__PURE__ */ u((U) => (
    /*key*/
    U[10]
  ), "get_key");
  for (let U = 0; U < k.length; U += 1) {
    let H = IP(i, k, U), V = S(H);
    d.set(V, f[U] = RP(V, H));
  }
  let D = m && NP(i);
  function I(U, H) {
    var V, Y, J, fe, ke, ee, ne, Ee;
    if (H & /*action*/
    2 && (h = null), /*action*/
    ((Y = (V = U[1].target) == null ? void 0 : V.scaling) == null ? void 0 : Y.mode) === "cantrip") return dse;
    if (
      /*action*/
      ((fe = (J = U[1].target) == null ? void 0 : J.scaling) == null ? void 0 : fe.mode) === "spellLevel"
    ) return fse;
    if (
      /*action*/
      ((ee = (ke = U[1].target) == null ? void 0 : ke.scaling) == null ? void 0 : ee.mode) === "spellPoints"
    ) return use;
    if (h == null && (h = !!["actionUses", "itemUses"].includes(
      /*action*/
      (Ee = (ne = U[1].target) == null ? void 0 : ne.scaling) == null ? void 0 : Ee.mode
    )), h) return cse;
  }
  u(I, "select_block_type");
  let M = I(i, -1), L = M && M(i);
  return {
    c() {
      var U;
      e = E("div"), v && v.c(), s = F(), n = E("select"), l = E("option"), o = Q(r), a = F();
      for (let H = 0; H < f.length; H += 1)
        f[H].c();
      p = F(), D && D.c(), g = F(), L && L.c(), l.__value = null, He(l, l.__value), l.selected = c = /*isEmpty*/
      i[5](
        /*action*/
        (U = i[1]) == null ? void 0 : U.target
      ), b(n, "class", "u-w-fit"), b(e, "class", "action-config__component");
    },
    m(U, H) {
      T(U, e, H), v && v.m(e, null), A(e, s), A(e, n), A(n, l), A(l, o), A(l, a);
      for (let V = 0; V < f.length; V += 1)
        f[V] && f[V].m(n, null);
      A(e, p), D && D.m(e, null), A(e, g), L && L.m(e, null), _ || (y = W(
        n,
        "change",
        /*selectTarget*/
        i[8]
      ), _ = !0);
    },
    p(U, H) {
      var V, Y, J, fe;
      H & /*action*/
      2 && (t = ["creature", "object", "creatureObject"].includes(
        /*action*/
        (V = U[1].target) == null ? void 0 : V.type
      )), t ? v ? v.p(U, H) : (v = FP(U), v.c(), v.m(e, s)) : v && (v.d(1), v = null), H & /*action*/
      2 && c !== (c = /*isEmpty*/
      U[5](
        /*action*/
        (Y = U[1]) == null ? void 0 : Y.target
      )) && (l.selected = c), H & /*Object, A5E, action*/
      18 && (k = ue(Object.entries(
        /*A5E*/
        U[4].targetTypes
      )), f = Lt(f, H, S, 1, U, k, d, n, an, RP, null, IP)), H & /*action*/
      2 && (m = ["creature", "object", "creatureObject"].includes(
        /*action*/
        (fe = (J = U[1]) == null ? void 0 : J.target) == null ? void 0 : fe.type
      )), m ? D ? D.p(U, H) : (D = NP(U), D.c(), D.m(e, g)) : D && (D.d(1), D = null), M === (M = I(U, H)) && L ? L.p(U, H) : (L && L.d(1), L = M && M(U), L && (L.c(), L.m(e, null)));
    },
    d(U) {
      U && C(e), v && v.d();
      for (let H = 0; H < f.length; H += 1)
        f[H].d();
      D && D.d(), L && L.d(), _ = !1, y();
    }
  };
}
u(yse, "create_default_slot_1$z");
function vse(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [yse] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, action, $item*/
      262147 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(vse, "create_default_slot$19");
function kse(i) {
  let e, t, s, n, l, r, o, a, c;
  return t = new De({
    props: {
      heading: "A5E.TabRanges",
      headerButtons: [
        {
          classes: "add-button",
          label: "A5E.ButtonAddRangeIncrement",
          handler: (
            /*addRangeIncrement*/
            i[7]
          )
        }
      ],
      $$slots: { default: [ase] },
      $$scope: { ctx: i }
    }
  }), l = new t0({
    props: {
      action: (
        /*action*/
        i[1]
      ),
      actionId: (
        /*actionId*/
        i[2]
      ),
      item: (
        /*item*/
        i[3]
      )
    }
  }), o = new De({
    props: {
      heading: "Target",
      $$slots: { default: [vse] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("section"), s = E("div"), j(t.$$.fragment), n = F(), j(l.$$.fragment), r = F(), a = E("div"), j(o.$$.fragment), G(s, "display", "contents"), G(s, "--a5e-section-gap", "0"), G(a, "display", "contents"), G(a, "--a5e-section-gap", "0.5rem"), b(e, "class", "a5e-page-wrapper svelte-1gu1x96");
    },
    m(f, d) {
      T(f, e, d), A(e, s), R(t, s, null), A(e, n), R(l, e, null), A(e, r), A(e, a), R(o, a, null), c = !0;
    },
    p(f, [d]) {
      const p = {};
      d & /*$$scope, action*/
      262146 && (p.$$scope = { dirty: d, ctx: f }), t.$set(p);
      const m = {};
      d & /*action*/
      2 && (m.action = /*action*/
      f[1]), l.$set(m);
      const g = {};
      d & /*$$scope, action, $item*/
      262147 && (g.$$scope = { dirty: d, ctx: f }), o.$set(g);
    },
    i(f) {
      c || (w(t.$$.fragment, f), w(l.$$.fragment, f), w(o.$$.fragment, f), c = !0);
    },
    o(f) {
      O(t.$$.fragment, f), O(l.$$.fragment, f), O(o.$$.fragment, f), c = !1;
    },
    d(f) {
      f && C(e), N(t), N(l), N(o);
    }
  };
}
u(kse, "create_fragment$2N");
const wse = /* @__PURE__ */ u(({ target: i }) => {
  i.select();
}, "click_handler$1");
function $se(i, e, t) {
  let s, n;
  const l = de("actionId"), r = de("item");
  pe(i, r, (m) => t(0, n = m));
  const { A5E: o } = CONFIG, { isEmpty: a } = foundry.utils;
  function c() {
    let m = n.dialogs.targetScaling[l];
    m || (wo(r, n.dialogs.targetScaling[l] = new gi(n, `${n.name} Target Scaling Configuration`, n0, { actionId: l }), n), m = n.dialogs.targetScaling[l]), m.render(!0);
  }
  u(c, "onClickTargetScalingButton");
  function f() {
    const m = { range: "" };
    n.update({
      [`system.actions.${l}.ranges`]: {
        ...s.ranges,
        [foundry.utils.randomID()]: m
      }
    });
  }
  u(f, "addRangeIncrement");
  function d(m) {
    var h, _;
    const g = (_ = (h = m.target) == null ? void 0 : h.selectedOptions[0]) == null ? void 0 : _.value;
    g === "null" ? n.update({
      [`system.actions.${l}`]: { "-=target": null }
    }) : kp(n, `system.actions.${l}.target.type`, g, `system.actions.${l}.target.quantity`);
  }
  u(d, "selectTarget");
  const p = /* @__PURE__ */ u(({ target: m }) => te(
    n,
    `system.actions.${l}.target.quantity`,
    // @ts-expect-error
    Number(m.value || 0)
  ), "change_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(1, s = n.actions.get(l));
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c,
    f,
    d,
    p
  ];
}
u($se, "instance$2E");
const IE = class IE extends re {
  constructor(e) {
    super(), oe(this, e, $se, kse, le, {});
  }
};
u(IE, "ActionsTargetingTab");
let i0 = IE;
function Ase(i) {
  if (i.key !== "Tab") return;
  i.preventDefault();
  const e = i.currentTarget;
  i.shiftKey || e.setRangeText("	", e.selectionStart, e.selectionEnd, "end");
}
u(Ase, "overrideTextAreaBehavior");
function Ese(i) {
  let e, t, s;
  return {
    c() {
      e = E("textarea"), b(e, "class", "a5e-code-block__text-area svelte-1ok6ccg"), e.value = /*macro*/
      i[0], b(e, "autocapitalize", "off"), b(e, "autocomplete", "off"), b(e, "contenteditable", "true"), b(e, "autocorrect", "off"), b(e, "spellcheck", !1), b(e, "wrap", "soft");
    },
    m(n, l) {
      T(n, e, l), t || (s = [
        W(
          e,
          "change",
          /*change_handler*/
          i[4]
        ),
        W(e, "keydown", Ase)
      ], t = !0);
    },
    p(n, l) {
      l & /*macro*/
      1 && (e.value = /*macro*/
      n[0]);
    },
    d(n) {
      n && C(e), t = !1, Me(s);
    }
  };
}
u(Ese, "create_default_slot$18");
function Sse(i) {
  let e, t, s;
  return t = new De({
    props: {
      heading: "Command",
      $$slots: { default: [Ese] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("article"), j(t.$$.fragment);
    },
    m(n, l) {
      T(n, e, l), R(t, e, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, macro*/
      65 && (r.$$scope = { dirty: l, ctx: n }), t.$set(r);
    },
    i(n) {
      s || (w(t.$$.fragment, n), s = !0);
    },
    o(n) {
      O(t.$$.fragment, n), s = !1;
    },
    d(n) {
      n && C(e), N(t);
    }
  };
}
u(Sse, "create_fragment$2M");
function Cse(i, e, t) {
  let s, n, l = de("item");
  pe(i, l, (c) => t(3, n = c));
  let r = de("actionId");
  function o(c) {
    const f = r ? `system.actions.${r}.macro` : "system.macro";
    te(n, f, c.trim());
  }
  u(o, "updateMacro");
  const a = /* @__PURE__ */ u(({ target: c }) => o(c.value), "change_handler");
  return i.$$.update = () => {
    var c, f;
    i.$$.dirty & /*$item*/
    8 && t(0, s = r ? (c = n.actions.get(r)) == null ? void 0 : c.macro : (f = n.system) == null ? void 0 : f.macro);
  }, [s, l, o, n, a];
}
u(Cse, "instance$2D");
const PE = class PE extends re {
  constructor(e) {
    super(), oe(this, e, Cse, Sse, le, {});
  }
};
u(PE, "ItemMacroTab");
let Op = PE;
function Tse(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "sheet-lock fas fa-plus svelte-qvafg7");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler*/
        i[1]
      ), t = !0);
    },
    p: se,
    i: se,
    o: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(Tse, "create_fragment$2L");
function Ose(i) {
  const e = ft();
  return [e, /* @__PURE__ */ u(() => e("add-button-clicked"), "click_handler")];
}
u(Ose, "instance$2C");
const ME = class ME extends re {
  constructor(e) {
    super(), oe(this, e, Ose, Tse, le, {});
  }
};
u(ME, "AddButton");
let l0 = ME;
function AB(i) {
  const e = i.getFlag("a5e", "sheetIsLocked") ?? !0;
  i.update({ "flags.a5e.sheetIsLocked": !e });
}
u(AB, "toggleSheetLockedState");
function Dse(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", t = "sheet-lock fas " + /*sheetIsLocked*/
      (i[0] ? "fa-lock" : "fa-unlock") + " svelte-qvafg7");
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "click",
        /*click_handler*/
        i[3]
      ), s = !0);
    },
    p(l, [r]) {
      r & /*sheetIsLocked*/
      1 && t !== (t = "sheet-lock fas " + /*sheetIsLocked*/
      (l[0] ? "fa-lock" : "fa-unlock") + " svelte-qvafg7") && b(e, "class", t);
    },
    i: se,
    o: se,
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Dse, "create_fragment$2K");
function Ise(i, e, t) {
  let s, { sheetIsLocked: n } = e;
  const l = de("actor");
  pe(i, l, (o) => t(1, s = o));
  const r = /* @__PURE__ */ u(({ target: o }) => {
    AB(s), o.blur();
  }, "click_handler");
  return i.$$set = (o) => {
    "sheetIsLocked" in o && t(0, n = o.sheetIsLocked);
  }, i.$$.update = () => {
    var o, a;
    i.$$.dirty & /*$actor*/
    2 && t(0, n = s.isOwner ? ((a = (o = s.flags) == null ? void 0 : o.a5e) == null ? void 0 : a.sheetIsLocked) ?? !0 : !0);
  }, [n, s, l, r];
}
u(Ise, "instance$2B");
const FE = class FE extends re {
  constructor(e) {
    super(), oe(this, e, Ise, Dse, le, { sheetIsLocked: 0 });
  }
};
u(FE, "LockButton");
let r0 = FE;
function jP(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", t = "nav-icon " + /*tab*/
      i[2].icon + " svelte-a41y6j");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*tab*/
      4 && t !== (t = "nav-icon " + /*tab*/
      s[2].icon + " svelte-a41y6j") && b(e, "class", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(jP, "create_if_block_1$10");
function LP(i) {
  let e = K(
    /*tab*/
    i[2].label
  ) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*tab*/
      4 && e !== (e = K(
        /*tab*/
        s[2].label
      ) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(LP, "create_if_block$1y");
function Pse(i) {
  let e, t, s, n, l, r = (
    /*tab*/
    i[2].icon && jP(i)
  ), o = (
    /*tab*/
    i[2].label && LP(i)
  );
  return {
    c() {
      e = E("li"), t = E("button"), r && r.c(), s = F(), o && o.c(), b(t, "class", "nav-item svelte-a41y6j"), Z(
        t,
        "nav-item-active",
        /*tab*/
        i[2].name === /*currentTab*/
        i[0].name
      );
    },
    m(a, c) {
      T(a, e, c), A(e, t), r && r.m(t, null), A(t, s), o && o.m(t, null), n || (l = W(
        t,
        "click",
        /*click_handler*/
        i[4]
      ), n = !0);
    },
    p(a, [c]) {
      /*tab*/
      a[2].icon ? r ? r.p(a, c) : (r = jP(a), r.c(), r.m(t, s)) : r && (r.d(1), r = null), /*tab*/
      a[2].label ? o ? o.p(a, c) : (o = LP(a), o.c(), o.m(t, null)) : o && (o.d(1), o = null), c & /*tab, currentTab*/
      5 && Z(
        t,
        "nav-item-active",
        /*tab*/
        a[2].name === /*currentTab*/
        a[0].name
      );
    },
    i: se,
    o: se,
    d(a) {
      a && C(e), r && r.d(), o && o.d(), n = !1, l();
    }
  };
}
u(Pse, "create_fragment$2J");
function Mse(i, e, t) {
  let { currentTab: s } = e, { index: n } = e, { tab: l } = e;
  const r = ft(), o = /* @__PURE__ */ u(() => r("tab-change", n), "click_handler");
  return i.$$set = (a) => {
    "currentTab" in a && t(0, s = a.currentTab), "index" in a && t(1, n = a.index), "tab" in a && t(2, l = a.tab);
  }, [s, n, l, r, o];
}
u(Mse, "instance$2A");
const RE = class RE extends re {
  constructor(e) {
    super(), oe(this, e, Mse, Pse, le, { currentTab: 0, index: 1, tab: 2 });
  }
};
u(RE, "NavigationItem");
let o0 = RE;
function BP(i, e, t) {
  const s = i.slice();
  return s[9] = e[t], s[11] = t, s;
}
u(BP, "get_each_context$11");
function qP(i) {
  let e, t;
  return e = new o0({
    props: {
      tab: (
        /*tab*/
        i[9]
      ),
      index: (
        /*index*/
        i[11]
      ),
      currentTab: (
        /*currentTab*/
        i[0]
      )
    }
  }), e.$on(
    "tab-change",
    /*tab_change_handler*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*tabs*/
      2 && (l.tab = /*tab*/
      s[9]), n & /*currentTab*/
      1 && (l.currentTab = /*currentTab*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(qP, "create_if_block_2$G");
function GP(i) {
  var n;
  let e, t, s = (
    /*tab*/
    (((n = i[9]) == null ? void 0 : n.display) ?? !0) && qP(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(l, r) {
      s && s.m(l, r), T(l, e, r), t = !0;
    },
    p(l, r) {
      var o;
      /*tab*/
      ((o = l[9]) == null ? void 0 : o.display) ?? !0 ? s ? (s.p(l, r), r & /*tabs*/
      2 && w(s, 1)) : (s = qP(l), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(l) {
      t || (w(s), t = !0);
    },
    o(l) {
      O(s), t = !1;
    },
    d(l) {
      l && C(e), s && s.d(l);
    }
  };
}
u(GP, "create_each_block$11");
function zP(i) {
  let e, t;
  return e = new r0({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(zP, "create_if_block_1$$");
function HP(i) {
  let e, t;
  return e = new l0({}), e.$on(
    "add-button-clicked",
    /*add_button_clicked_handler*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(HP, "create_if_block$1x");
function Fse(i) {
  let e, t, s, n, l, r = ue(
    /*tabs*/
    i[1]
  ), o = [];
  for (let d = 0; d < r.length; d += 1)
    o[d] = GP(BP(i, r, d));
  const a = /* @__PURE__ */ u((d) => O(o[d], 1, 1, () => {
    o[d] = null;
  }), "out");
  let c = (
    /*showLock*/
    i[2] && /*$actor*/
    i[4].permission !== /*observerPermissionsLevel*/
    i[6] && zP()
  ), f = (
    /*showAdd*/
    i[3] && HP(i)
  );
  return {
    c() {
      e = E("nav"), t = E("ul");
      for (let d = 0; d < o.length; d += 1)
        o[d].c();
      s = F(), c && c.c(), n = F(), f && f.c(), b(t, "class", "nav-list svelte-catg59"), b(e, "class", "nav-wrapper svelte-catg59");
    },
    m(d, p) {
      T(d, e, p), A(e, t);
      for (let m = 0; m < o.length; m += 1)
        o[m] && o[m].m(t, null);
      A(t, s), c && c.m(t, null), A(t, n), f && f.m(t, null), l = !0;
    },
    p(d, [p]) {
      if (p & /*tabs, currentTab*/
      3) {
        r = ue(
          /*tabs*/
          d[1]
        );
        let m;
        for (m = 0; m < r.length; m += 1) {
          const g = BP(d, r, m);
          o[m] ? (o[m].p(g, p), w(o[m], 1)) : (o[m] = GP(g), o[m].c(), w(o[m], 1), o[m].m(t, s));
        }
        for (ae(), m = r.length; m < o.length; m += 1)
          a(m);
        ce();
      }
      /*showLock*/
      d[2] && /*$actor*/
      d[4].permission !== /*observerPermissionsLevel*/
      d[6] ? c ? p & /*showLock, $actor*/
      20 && w(c, 1) : (c = zP(), c.c(), w(c, 1), c.m(t, n)) : c && (ae(), O(c, 1, 1, () => {
        c = null;
      }), ce()), /*showAdd*/
      d[3] ? f ? p & /*showAdd*/
      8 && w(f, 1) : (f = HP(d), f.c(), w(f, 1), f.m(t, null)) : f && (ae(), O(f, 1, 1, () => {
        f = null;
      }), ce());
    },
    i(d) {
      if (!l) {
        for (let p = 0; p < r.length; p += 1)
          w(o[p]);
        w(c), w(f), l = !0;
      }
    },
    o(d) {
      o = o.filter(Boolean);
      for (let p = 0; p < o.length; p += 1)
        O(o[p]);
      O(c), O(f), l = !1;
    },
    d(d) {
      d && C(e), Le(o, d), c && c.d(), f && f.d();
    }
  };
}
u(Fse, "create_fragment$2I");
function Rse(i, e, t) {
  let s, { currentTab: n } = e, { tabs: l } = e, { showLock: r = !1 } = e, { showAdd: o = !1 } = e;
  const a = de("actor");
  pe(i, a, (p) => t(4, s = p));
  const c = CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER;
  function f(p) {
    bt.call(this, i, p);
  }
  u(f, "tab_change_handler");
  function d(p) {
    bt.call(this, i, p);
  }
  return u(d, "add_button_clicked_handler"), i.$$set = (p) => {
    "currentTab" in p && t(0, n = p.currentTab), "tabs" in p && t(1, l = p.tabs), "showLock" in p && t(2, r = p.showLock), "showAdd" in p && t(3, o = p.showAdd);
  }, [
    n,
    l,
    r,
    o,
    s,
    a,
    c,
    f,
    d
  ];
}
u(Rse, "instance$2z");
const NE = class NE extends re {
  constructor(e) {
    super(), oe(this, e, Rse, Fse, le, {
      currentTab: 0,
      tabs: 1,
      showLock: 2,
      showAdd: 3
    });
  }
};
u(NE, "NavigationBar");
let Wn = NE;
async function gg(i, e = {}) {
  var n;
  if ((n = game.modules.get("vtta-tokenizer")) != null && n.active && !e.shiftKey && ["character", "npc"].includes(i.type))
    return Tokenizer == null || Tokenizer.tokenizeActor(i), null;
  const t = foundry.utils.getProperty(i, `system.actions.${e == null ? void 0 : e.actionId}.img`) ?? i.img;
  return new FilePicker({
    type: "image",
    current: t,
    callback: /* @__PURE__ */ u(async (l) => {
      e != null && e.actionId ? await i.update({ [`system.actions.${e == null ? void 0 : e.actionId}.img`]: l }) : await i.update({ img: l });
    }, "callback")
  }).browse();
}
u(gg, "editDocumentImage");
function Nse(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h;
  f = new Wn({
    props: {
      currentTab: (
        /*currentTab*/
        i[2]
      ),
      tabs: (
        /*tabs*/
        i[6]
      )
    }
  }), f.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[5]
  );
  var _ = (
    /*currentTab*/
    i[2].component
  );
  function y(v, k) {
    return {};
  }
  return u(y, "switch_props"), _ && (p = et(_, y())), {
    c() {
      var v, k, S;
      e = E("article"), t = E("header"), s = E("img"), r = F(), o = E("input"), c = F(), j(f.$$.fragment), d = F(), p && j(p.$$.fragment), b(s, "class", "item-image svelte-5ynm1o"), ze(s.src, n = /*$item*/
      ((k = (v = i[3]) == null ? void 0 : v.actions.get(
        /*actionId*/
        i[0]
      )) == null ? void 0 : k.img) ?? /*$item*/
      i[3].img) || b(s, "src", n), b(s, "alt", l = /*$item*/
      i[3].name + " image"), b(o, "class", "a5e-input a5e-input--character-name"), b(o, "type", "text"), b(o, "name", "name"), o.value = a = /*$item*/
      (S = i[3].system.actions[
        /*actionId*/
        i[0]
      ]) == null ? void 0 : S.name, b(o, "placeholder", "Action Name"), b(t, "class", "action-header svelte-5ynm1o"), b(e, "class", "svelte-5ynm1o");
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(t, s), A(t, r), A(t, o), A(e, c), R(f, e, null), A(e, d), p && R(p, e, null), m = !0, g || (h = [
        W(
          s,
          "click",
          /*click_handler*/
          i[8]
        ),
        W(
          o,
          "change",
          /*change_handler*/
          i[9]
        )
      ], g = !0);
    },
    p(v, [k]) {
      var D, I, M;
      (!m || k & /*$item, actionId*/
      9 && !ze(s.src, n = /*$item*/
      ((I = (D = v[3]) == null ? void 0 : D.actions.get(
        /*actionId*/
        v[0]
      )) == null ? void 0 : I.img) ?? /*$item*/
      v[3].img)) && b(s, "src", n), (!m || k & /*$item*/
      8 && l !== (l = /*$item*/
      v[3].name + " image")) && b(s, "alt", l), (!m || k & /*$item, actionId*/
      9 && a !== (a = /*$item*/
      (M = v[3].system.actions[
        /*actionId*/
        v[0]
      ]) == null ? void 0 : M.name) && o.value !== a) && (o.value = a);
      const S = {};
      if (k & /*currentTab*/
      4 && (S.currentTab = /*currentTab*/
      v[2]), f.$set(S), k & /*currentTab*/
      4 && _ !== (_ = /*currentTab*/
      v[2].component)) {
        if (p) {
          ae();
          const L = p;
          O(L.$$.fragment, 1, 0, () => {
            N(L, 1);
          }), ce();
        }
        _ ? (p = et(_, y()), j(p.$$.fragment), w(p.$$.fragment, 1), R(p, e, null)) : p = null;
      }
    },
    i(v) {
      m || (w(f.$$.fragment, v), p && w(p.$$.fragment, v), m = !0);
    },
    o(v) {
      O(f.$$.fragment, v), p && O(p.$$.fragment, v), m = !1;
    },
    d(v) {
      v && C(e), N(f), p && N(p), g = !1, Me(h);
    }
  };
}
u(Nse, "create_fragment$2H");
function jse(i, e, t) {
  let s, { document: n, actionId: l, dialog: r } = de("#external").application, { document: o = n, actionId: a = l, dialog: c = r } = e;
  const f = o;
  pe(i, f, (_) => t(3, s = _));
  function d(_) {
    t(2, m = p[_.detail]);
  }
  u(d, "updateCurrentTab");
  const p = [
    {
      name: "description",
      label: "A5E.ItemSheetLabelDescriptionTab",
      component: _y
    },
    {
      name: "activation",
      label: "A5E.TabActivation",
      component: cy
    },
    {
      name: "targeting",
      label: "A5E.TabTargeting",
      component: i0
    },
    {
      name: "rolls",
      label: "A5E.TabRolls",
      component: Hy
    },
    {
      name: "prompts",
      label: "A5E.TabPrompts",
      component: Fy
    },
    {
      name: "consumers",
      label: "A5E.TabResourceManagement",
      component: Xy
    },
    {
      name: "effects",
      label: "A5E.TabEffects",
      component: Oy
    },
    {
      name: "macro",
      label: "A5E.TabMacro",
      component: Op
    }
  ];
  let m = p[0];
  lt("item", f), lt("actionId", a);
  const g = /* @__PURE__ */ u(() => gg(s, { actionId: a, dialog: c }), "click_handler"), h = /* @__PURE__ */ u(({ target: _ }) => te(s, `system.actions.${a}.name`, _.value), "change_handler");
  return i.$$set = (_) => {
    "document" in _ && t(7, o = _.document), "actionId" in _ && t(0, a = _.actionId), "dialog" in _ && t(1, c = _.dialog);
  }, [
    a,
    c,
    m,
    s,
    f,
    d,
    p,
    o,
    g,
    h
  ];
}
u(jse, "instance$2y");
const jE = class jE extends re {
  constructor(e) {
    super(), oe(this, e, jse, Nse, le, { document: 7, actionId: 0, dialog: 1 });
  }
  get document() {
    return this.$$.ctx[7];
  }
  set document(e) {
    this.$$set({ document: e }), Xe();
  }
  get actionId() {
    return this.$$.ctx[0];
  }
  set actionId(e) {
    this.$$set({ actionId: e }), Xe();
  }
  get dialog() {
    return this.$$.ctx[1];
  }
  set dialog(e) {
    this.$$set({ dialog: e }), Xe();
  }
};
u(jE, "ActionConfigDialog");
let a0 = jE;
var Bs;
const xl = class xl extends Map {
  constructor(t) {
    super();
    x(this, Bs);
    qe(this, "default");
    Ae(this, Bs, t);
    const { actions: s } = t.system;
    Object.entries(s ?? {}).forEach(([l, r]) => {
      r.id = l, this.set(l, r);
    });
    const n = [...this.values()].find((l) => l.default);
    n ? this.default = n : !n && this.size > 0 ? this.default = this.first : this.default = null;
  }
  /** ************************************************
   * Getters
   * ************************************************ */
  get count() {
    return this.size;
  }
  get first() {
    const t = this.values().next();
    if (t)
      return t.value;
  }
  get activationTypes() {
    return [...this.values()].reduce((t, s) => (s.activation.type && t.add(s.activation.type), t), /* @__PURE__ */ new Set());
  }
  get hasConsumer() {
    return [...this.values()].some((t) => {
      var s;
      return !!((s = Object.values(t.consumers)) != null && s.length);
    });
  }
  get hasMacro() {
    return [...this.values()].some((t) => t.macro.trim().length > 0);
  }
  get hasPrompt() {
    return [...this.values()].some((t) => {
      var s;
      return !!((s = Object.values(t.prompts)) != null && s.length);
    });
  }
  get hasRange() {
    return [...this.values()].some((t) => {
      var s;
      return !!((s = Object.values(t.ranges)) != null && s.length);
    });
  }
  get hasRoll() {
    return [...this.values()].some((t) => {
      var s;
      return !!((s = Object.values(t.rolls)) != null && s.length);
    });
  }
  /** ************************************************
   * Get actions or subsections
   * ************************************************ */
  getName(t) {
    return [...this.values()].find((s) => s.name === t);
  }
  getConsumers(t) {
    var s;
    return Object.entries(((s = this.get(t)) == null ? void 0 : s.consumers) ?? {});
  }
  getPrompts(t) {
    var s;
    return Object.entries(((s = this.get(t)) == null ? void 0 : s.prompts) ?? {});
  }
  getRolls(t) {
    var s;
    return Object.entries(((s = this.get(t)) == null ? void 0 : s.rolls) ?? {});
  }
  /** ************************************************
   * Helpers
   * ************************************************ */
  async setDefaultAction(t) {
    const s = {};
    [...this.values()].forEach((n) => {
      n.id === t ? s[`system.actions.${n.id}.default`] = !0 : s[`system.actions.${n.id}.default`] = !1;
    }), await P(this, Bs).update(s);
  }
  /** ************************************************
   * Internal methods
   * ************************************************ */
  async add(t = {}, s = !0, n = !1) {
    return xl.addAction(P(this, Bs), t, s, n);
  }
  configure(t) {
    var l;
    const s = P(this, Bs).system.actions[t].name;
    let n = P(this, Bs).dialogs.actions[t];
    n || ((l = P(this, Bs).dialogs.actions)[t] ?? (l[t] = new gi(
      P(this, Bs),
      s,
      a0,
      { actionId: t, actionName: s },
      {
        width: 555,
        height: 592,
        resizable: !0,
        isItemDocument: !0
      }
    )), n = P(this, Bs).dialogs.actions[t]), n.render(!0);
  }
  /** ----------------------------------------- */
  async duplicate(t) {
    const s = this.get(t);
    if (!s) return;
    const n = s.toObject(), l = foundry.utils.randomID();
    n.name = `${n.name} (Copy)`;
    const r = [...s.effects].map((a) => {
      var c;
      return (c = P(this, Bs).effects.get(a)) == null ? void 0 : c.toObject();
    }).filter((a) => !!a), o = await P(this, Bs).createEmbeddedDocuments("ActiveEffect", r);
    n.effects = o.map((a) => a.id), await P(this, Bs).update({
      "system.actions": {
        ...P(this, Bs).system.actions,
        [l]: n
      }
    });
  }
  /** ----------------------------------------- */
  async remove(t) {
    const s = P(this, Bs).dialogs.actions[t];
    await (s == null ? void 0 : s.close()), delete P(this, Bs).dialogs.actions[t];
    const n = this.get(t);
    n && (await P(this, Bs).update({
      "system.actions": {
        [`-=${t}`]: null
      }
    }), P(this, Bs).deleteEmbeddedDocuments("ActiveEffect", [...n.effects]));
  }
  /** ************************************************
   * Static Methods
   * ************************************************ */
  static async addAction(t, s = {}, n = !0, l = !1) {
    var f;
    const r = foundry.utils.mergeObject(
      {
        name: xl.getActionName(t) || "New Action"
      },
      s
    ), o = foundry.utils.randomID();
    let a = null;
    (f = t.system.uses) != null && f.max && (a = await xl.addConsumer(t, [o, r], "itemUses", {}, !1)), t.type === "spell" ? a = await xl.addConsumer(t, [o, r], "spell", {}, !1) : t.type === "maneuver" && (a = await xl.addConsumer(
      t,
      [o, r],
      "resource",
      { resource: "exertion" },
      !1
    )), a && (r.consumers = {
      ...r.consumers,
      ...Object.values(a)[0]
    });
    const c = {
      "system.actions": {
        ...t.system.actions,
        [o]: r
      }
    };
    return n && await t.update(c), l ? [o, c] : c;
  }
  /** ----------------------------------------- */
  static async addRoll(t, s, n, l = {}, r = !0) {
    var c, f;
    const o = {
      type: n,
      default: !0
    };
    if (n === "attack") {
      if (Object.values(((c = s[1]) == null ? void 0 : c.rolls) ?? {}).filter((p) => p.type === "attack").length > 0)
        return (f = ui.notifications) == null || f.error("Only one attack roll is allowed per action."), null;
      o.attackType = "meleeWeaponAttack", o.proficient = !0;
    }
    (n === "abilityCheck" || n === "savingThrow") && (o.ability = "str"), n === "skillCheck" && (o.skill = "acr", o.ability = "none"), n === "toolCheck" && (o.tool = "airVehicles", o.ability = "none");
    const a = {
      [`system.actions.${s[0]}.rolls`]: {
        ...s[1].rolls,
        [foundry.utils.randomID()]: foundry.utils.mergeObject(o, l)
      }
    };
    return r && t.update(a), a;
  }
  /** ----------------------------------------- */
  static async addPrompt(t, s, n, l = {}, r = !0) {
    const o = {
      type: n,
      default: !0
    };
    (n === "savingThrow" || n === "abilityCheck") && (o.ability = "str"), n === "savingThrow" && (o.saveDC = { type: "spellcasting" }), n === "skillCheck" && (o.skill = "acr");
    const a = {
      [`system.actions.${s[0]}.prompts`]: {
        ...s[1].prompts,
        [foundry.utils.randomID()]: foundry.utils.mergeObject(o, l)
      }
    };
    return r && t.update(a), a;
  }
  /** ----------------------------------------- */
  static async addConsumer(t, s, n, l = {}, r = !0) {
    var c;
    const o = {
      type: n,
      default: !0
    };
    ["ammunition", "quantity"].includes(n) && (o.itemId = "", o.quantity = 1), n === "hitDice" && (o.quantity = 1), n === "resource" && (o.classIdentifier = "", o.resource = "", o.quantity = 1), n === "spell" && (o.mode = "variable", o.charges = t.isType("spell") ? t.system.level ?? 1 : 1, o.spellLevel = t.isType("spell") ? t.system.level ?? 1 : 1, o.points = t.isType("spell") ? ((c = CONFIG.A5E.spellLevelCost) == null ? void 0 : c[t.system.level]) ?? 1 : 1), ["actionUses", "itemUses"].includes(n) && (l.quantity = 1);
    const a = {
      [`system.actions.${s[0]}.consumers`]: {
        ...s[1].consumers,
        [foundry.utils.randomID()]: foundry.utils.mergeObject(o, l)
      }
    };
    return r && t.update(a), a;
  }
  /** ----------------------------------------- */
  static async addEffect(t, s, n) {
    const l = t.actions.get(s);
    if (!l) return !1;
    const r = l.effects, o = /* @__PURE__ */ new Set([...r, n]);
    return t.update({
      [`system.actions.${s}.effects`]: o
    });
  }
  /** ----------------------------------------- */
  static getActionName(t) {
    const s = game.settings.get("a5e", "newActionNameType");
    if (s === "action") return "New Action";
    if (s === "item") return t.name ?? "New Action";
    const n = t.type;
    if (n === "feature") return "Use Feature";
    if (n === "maneuver") return "Execute";
    if (n === "spell") return "Cast Spell";
    if (t.isType("object")) {
      const { objectType: l } = t.system;
      return l === "consumable" ? "Consume" : l === "tool" ? "Use Tool" : l === "weapon" ? "Attack" : "Use Object";
    }
    return "New Action";
  }
};
Bs = new WeakMap(), u(xl, "ActionsManager");
let cl = xl;
var Ds, jd, EB, SB, CB, TB, OB, DB, IB;
const LE = class LE extends ku {
  constructor() {
    super(...arguments);
    x(this, Ds);
  }
  /** ------------------------------------------------------ */
  /**                      Data Prep                         */
  /** ------------------------------------------------------ */
  _initialize(t) {
    this.actions = null, super._initialize(t);
  }
  prepareBaseData() {
    super.prepareBaseData(), this.actions = new cl(this);
  }
  prepareDerivedData() {
    super.prepareDerivedData(), ["object", "feature"].includes(this.type) && this.prepareArmorData();
  }
  prepareArmorData() {
    const t = this.system, { baseFormula: s, maxDex: n } = t.ac ?? {};
    if (!s) return;
    let l = s;
    n && n > 0 && (l = s.replaceAll(
      /@dex\.mod|@abilities\.dex\.mod/gm,
      `min(@dex.mod, ${n})`
    )), (t == null ? void 0 : t.damagedState) === CONFIG.A5E.DAMAGED_STATES.BROKEN && (t.objectType === "armor" ? l = `10 + max(floor((${l} - 10) / 2), 1)` : l = `max(floor((${l}) / 2), 1)`), foundry.utils.setProperty(this, "system.ac.formula", l);
  }
  // *****************************************************************************************
  /**
    * A handler for activating an item. An actionId can be passed to this method to use a specific
    * action defined on the item. If there are no actions defined, this method defaults to
    * outputting the item's description.
    *
   //  * This method accepts an options object to further customize the activation process.
    *
    * @param actionId - The action id
    * @param options
    * @returns
    */
  async activate(t, s = {}) {
    var n;
    if (!(!this.actor || !(this != null && this.actor.isOwner)))
      if ((((n = this.actor) == null ? void 0 : n.getFlag("a5e", "automaticallyExecuteAvailableMacros")) ?? !0) && (s.executeMacro ?? (s.executeMacro = this.system.macro.trim().length > 0 || this.actions.hasMacro)), this.actions.count === 0)
        this.shareItemDescription(null, s);
      else if (this.actions.count === 1)
        X(this, Ds, jd).call(this, this.actions.first.id, s);
      else if (t)
        X(this, Ds, jd).call(this, t, s);
      else {
        const l = new oy(this);
        await l.render(!0);
        const r = await l.promise;
        if (!(r != null && r.actionId)) return;
        X(this, Ds, jd).call(this, r.actionId, s);
      }
  }
  // TODO: Find out where this is being used.
  async showActionActivationDialog(t, s) {
    return !!(!foundry.utils.isEmpty(s == null ? void 0 : s.rolls) || !foundry.utils.isEmpty(s == null ? void 0 : s.prompts) || new Set(
      Object.values((s == null ? void 0 : s.consumers) ?? {}).map((l) => l.type)
    ).intersects(CONFIG.A5E.configurableConsumers));
  }
  async recharge(t, s = !1) {
    var p, m, g, h, _, y, v, k, S, D, I, M;
    if (s || !this.actor) return;
    let n = mt(this.system.uses.max, this.actor.getRollData(this)) ?? 0, l = this.system.uses.value, r = this.system.uses.recharge.formula || "1d6", o = this.system.uses.recharge.threshold ?? 6, a = ((p = this.system.uses.recharge) == null ? void 0 : p.rechargeType) || "custom", c = ((m = this.system.uses.recharge) == null ? void 0 : m.rechargeAmount) || "1", f = "system.uses.value";
    if (t) {
      const L = this.actions.get(t);
      n = mt(((g = L == null ? void 0 : L.uses) == null ? void 0 : g.max) ?? "", this.actor.getRollData(this)) ?? 0, l = ((h = L == null ? void 0 : L.uses) == null ? void 0 : h.value) ?? 0, r = ((y = (_ = L == null ? void 0 : L.uses) == null ? void 0 : _.recharge) == null ? void 0 : y.formula) || "1d6", o = ((k = (v = L == null ? void 0 : L.uses) == null ? void 0 : v.recharge) == null ? void 0 : k.threshold) ?? 6, a = ((D = (S = L == null ? void 0 : L.uses) == null ? void 0 : S.recharge) == null ? void 0 : D.rechargeType) || "custom", c = ((M = (I = L == null ? void 0 : L.uses) == null ? void 0 : I.recharge) == null ? void 0 : M.rechargeAmount) || "1", f = `system.actions.${t}.uses.value`;
    }
    const d = await new Roll(r, this.actor.getRollData(this)).evaluate();
    if (d.toMessage(), !(d.total < o))
      if (a === "min") await this.update({ [f]: 0 });
      else if (a === "max") await this.update({ [f]: n });
      else {
        const L = await new Roll(
          c,
          this.actor.getRollData(this)
        ).evaluate();
        await this.update({ [f]: Math.min(n, l + L.total) });
      }
  }
  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>
  async _preCreate(t, s, n) {
    await super._preCreate(t, s, n);
  }
  async _preUpdate(t, s, n) {
    super._preUpdate(t, s, n);
  }
  _onCreate(t, s, n) {
    super._onCreate(t, s, n);
  }
  _onDelete(t, s) {
    super._onDelete(t, s);
  }
};
Ds = new WeakSet(), jd = /* @__PURE__ */ u(async function(t, s = {}) {
  var g, h, _, y, v, k, S, D, I, M, L, B, z;
  let n;
  const l = this.actions.get(t);
  if (s.skipRollDialog ? n = X(this, Ds, SB).call(this, t, s) : n = await X(this, Ds, EB).call(this, t, s), !n) return null;
  n.rolls ?? (n.rolls = []), n.rolls.push((n == null ? void 0 : n.attack) ?? {});
  const o = await new ns({
    actor: this.actor,
    item: this,
    consumers: n.consumers ?? {},
    damageBonuses: n.damageBonuses ?? {},
    healingBonuses: n.healingBonuses ?? {},
    rolls: n.rolls ?? {}
  }).prepareRolls(), a = new gc(
    this.actor,
    this,
    l,
    n.consumers ?? {}
  ), c = a.validateBaseTemplateData();
  n.placeTemplate && c && await a.placeActionTemplates(), await new ai(
    this.actor,
    this,
    t,
    n.consumers ?? {},
    n.selectedConsumers ?? []
  ).consumeResources();
  const d = {
    author: (g = game.user) == null ? void 0 : g.id,
    flavor: l.name ? `${this.name}: ${l.name}` : this.name,
    speaker: ChatMessage.getSpeaker({ actor: this.actor }),
    style: CONST.CHAT_MESSAGE_STYLES.OTHER,
    sound: CONFIG.sounds.dice,
    rolls: o.map(({ roll: q }) => q),
    rollMode: n.visibilityMode ?? game.settings.get("core", "rollMode"),
    system: {
      actionName: l.name,
      actionId: t,
      actorName: this.name,
      actorId: (h = this.actor) == null ? void 0 : h.uuid,
      img: l.img ?? this.img ?? "icons/svg/item-bag.svg",
      itemId: this.uuid,
      // @ts-expect-error
      castingLevel: ((y = (_ = n.consumers) == null ? void 0 : _.spell) == null ? void 0 : y.level) ?? this.system.level ?? null,
      actionDescription: (v = l == null ? void 0 : l.descriptionOutputs) != null && v.includes("action") ? await TextEditor.enrichHTML(l.description, {
        secrets: this.isOwner,
        relativeTo: this,
        rollData: ((k = this == null ? void 0 : this.actor) == null ? void 0 : k.getRollData(this)) ?? {}
      }) : null,
      itemDescription: ((S = l == null ? void 0 : l.descriptionOutputs) == null ? void 0 : S.includes("item")) ?? !0 ? await TextEditor.enrichHTML(this.system.description, {
        secrets: this.isOwner,
        relativeTo: this,
        rollData: ((D = this == null ? void 0 : this.actor) == null ? void 0 : D.getRollData(this)) ?? {}
      }) : null,
      unidentifiedDescription: ((I = l == null ? void 0 : l.descriptionOutputs) == null ? void 0 : I.includes("item")) ?? !0 ? (
        // @ts-expect-error
        await TextEditor.enrichHTML(this.system.unidentifiedDescription, {
          secrets: this.isOwner,
          relativeTo: this,
          rollData: ((M = this == null ? void 0 : this.actor) == null ? void 0 : M.getRollData(this)) ?? {}
        })
      ) : null,
      effects: n.effects ?? [],
      prompts: n.prompts,
      rollData: o.map(({ roll: q, ...U }) => U),
      summaryData: nd(this, l, {
        hideAttunementData: !0,
        hideCraftingComponents: !0,
        hidePrice: !0,
        hideRarity: !0,
        hideSpellClasses: !0,
        hideSpellComponents: !0,
        hideSpellLevel: !0
      })
    },
    type: "item"
  };
  ChatMessage.applyRollMode(
    d,
    n.visibilityMode ?? game.settings.get("core", "rollMode")
  );
  const p = await ChatMessage.create(d);
  if (n.effects.reduce((q, U) => {
    const H = this.effects.get(U);
    return H && H.system.applyToSelf && q.push(H), q;
  }, []).forEach((q) => q.transferEffect(this.actor)), Hooks.callAll("a5e.itemActivate", this, {
    actionId: t,
    action: l,
    dialog: n,
    // @ts-expect-error
    macro: this.system.macro,
    options: s,
    rolls: o,
    validTemplate: c
  }), s.executeMacro) {
    if (((L = this.system.macro) == null ? void 0 : L.trim().length) > 0)
      try {
        const { macro: q } = this.system, U = (/* @__PURE__ */ u(async function() {
        }, "_")).constructor;
        U("actor", "item", "options", q)(this.actor, this, { options: s });
      } catch (q) {
        (B = ui.notifications) == null || B.error(
          `Could not execute the macro for ${this.name}. See the browser console for more details.`
        ), console.error(q);
      }
    if (l.macro.trim().length > 0)
      try {
        const { macro: q } = l, U = (/* @__PURE__ */ u(async function() {
        }, "_")).constructor;
        U(
          "actor",
          "item",
          "options",
          q
        )(this.actor, this, { actionId: t, action: l, options: s, rolls: o, validTemplate: c });
      } catch (q) {
        (z = ui.notifications) == null || z.error(
          `Could not execute the macro for ${this.name}. See the browser console for more details.`
        ), console.error(q);
      }
  }
  return p;
}, "#activateAction"), EB = /* @__PURE__ */ u(async function(t, s) {
  const n = new Ub({
    actionId: t,
    options: s,
    actorDocument: this.actor,
    itemDocument: this
  });
  return n.render(!0), n.promise;
}, "#showActionActivationPrompt"), SB = /* @__PURE__ */ u(function(t, s) {
  var g;
  const n = this.actions.get(t);
  if (!n) return null;
  const l = ns.prepareRolls(this, t), r = X(this, Ds, CB).call(this, l.attack, s), o = X(this, Ds, TB).call(this, t), a = ns.getDefaultSelectedEffects(
    ns.prepareEffects(this, t)
  ), { damageBonuses: c, healingBonuses: f } = X(this, Ds, OB).call(this, this.actor, l), d = X(this, Ds, IB).call(this, l), p = X(this, Ds, DB).call(this, t), m = game.settings.get("a5e", "placeItemTemplateDefault") || ((g = n == null ? void 0 : n.area) == null ? void 0 : g.placeTemplate) || !1;
  return {
    attack: r,
    consumers: o,
    damageBonuses: c,
    effects: a,
    healingBonuses: f,
    placeTemplate: m,
    prompts: p,
    rolls: d,
    selectedConsumers: ai.getDefaultConsumerSelection(
      ns.prepareConsumers(this, t)
    )
  };
}, "#getDefaultActionActivationData"), CB = /* @__PURE__ */ u(function(t, s) {
  if (!t) return {};
  const { actor: n } = this;
  if (!n) return {};
  const l = t[0][1], r = ns.prepareAttackRollData(
    this.actor,
    this,
    l,
    s
  ), { attackAbility: o, rollMode: a, formula: c } = r;
  return {
    bonus: l.bonus ?? "",
    critThreshold: l.critThreshold ?? 20,
    type: "attack",
    attackType: l.attackType ?? "meleeWeaponAttack",
    ability: o,
    rollMode: a,
    formula: c
  };
}, "#getDefaultAttackRollData"), TB = /* @__PURE__ */ u(function(t) {
  const s = ns.prepareConsumers(this, t), { actionUsesData: n, itemUsesData: l } = ai.prepareUsesData(
    this.actor,
    this,
    s,
    t
  ), { hitDiceData: r } = ai.prepareHitDiceData(this.actor, s), {
    spellData: o
    // @ts-expect-error
  } = ai.prepareSpellData(this.actor, this, s, t);
  return {
    actionUses: n,
    hitDice: r,
    itemUses: l,
    spell: o
  };
}, "#getDefaultConsumerData"), OB = /* @__PURE__ */ u(function(t, s) {
  const n = t.BonusesManager.prepareGlobalDamageBonuses(this, s), l = t.BonusesManager.prepareGlobalHealingBonuses(this, s), r = n.reduce((a, [, c]) => ((c.default ?? !0) && a.push(c), a), []), o = l.reduce((a, [, c]) => ((c.default ?? !0) && a.push(c), a), []);
  return { damageBonuses: r, healingBonuses: o };
}, "#getDefaultBonuses"), DB = /* @__PURE__ */ u(function(t) {
  const s = ns.preparePrompts(this, t);
  return Object.entries(s).reduce((n, [l, r]) => (n.push(
    ...r.reduce((o, [, a]) => (l === "savingThrow" && (a.dc = R5(this.actor, this, a.saveDC)), (a.default ?? !0) && o.push(a), o), [])
  ), n), []);
}, "#getDefaultPrompts"), IB = /* @__PURE__ */ u(function(t) {
  return Object.entries(t).reduce((s, [n, l]) => (n === "attack" || s.push(
    ...l.reduce((r, [, o]) => ((o.default ?? !0) && r.push(o), r), [])
  ), s), []);
}, "#getDefaultRollData"), u(LE, "ItemA5e");
let bc = LE;
const BE = class BE extends bc {
  prepareBaseData() {
    super.prepareBaseData(), this.grants = new dc(this);
  }
  async _preCreate(e, t, s) {
    if (s._id !== game.userId) {
      await super._preCreate(e, t, s);
      return;
    }
    if (this.parent && this.parent.documentName === "Actor") {
      const n = this.parent;
      t.keepId = !0, t.noGrant || n.grants.createInitialGrants(this, !0);
    }
    super._preCreate(e, t, s);
  }
  _onCreate(e, t, s) {
    super._onCreate(e, t, s);
  }
  async _onDelete(e, t) {
    var n;
    if (super._onDelete(e, t), !this.parent || ((n = this.parent) == null ? void 0 : n.documentName) !== "Actor") return;
    await this.parent.grants.removeGrantsByItem(this.uuid);
  }
};
u(BE, "FeatureItemA5e");
let c0 = BE;
const qE = class qE extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return {
      _id: new e.StringField({ required: !0, initial: "" }),
      quantity: new e.NumberField({ nullable: !1, initial: 1 }),
      quantityOverride: new e.NumberField({ initial: 0, integer: !0, min: 0 }),
      uuid: new e.StringField({ required: !0, initial: "" })
    };
  }
};
u(qE, "SubObjectField");
let u0 = qE;
var hn;
const GE = class GE extends Map {
  constructor(t) {
    var n;
    if (!t)
      throw Error("Item is required to create a ContainerManager");
    if (((n = t.system) == null ? void 0 : n.objectType) !== "container")
      throw Error("Item must be a container to create a ContainerManager");
    super();
    x(this, hn);
    Ae(this, hn, t), Object.entries(P(this, hn).system.items ?? {}).forEach(([l, r]) => {
      r._id = l;
      const o = new u0(r, { parent: t });
      o && this.set(l, o);
    });
  }
  get items() {
    const t = P(this, hn), s = [...this.values()].map((l) => l.uuid);
    return t.isEmbedded ? s.map((r) => fromUuidSync(r)) : t.pack ? Promise.all(s.map((r) => fromUuid(r))) : s.map((l) => fromUuidSync(l));
  }
  /** ************************************************
   *               Functionality
   * ************************************************ */
  get allItems() {
    const t = [], { items: s } = this;
    return s instanceof Promise ? (s.then((n) => {
      t.push(...n), n.forEach((l) => {
        var r, o;
        ((r = l == null ? void 0 : l.system) == null ? void 0 : r.objectType) === "container" && t.push(...((o = l == null ? void 0 : l.containerItems) == null ? void 0 : o.allItems) ?? []);
      });
    }), t.filter((n) => !!n)) : (s.forEach((n) => {
      var l, r;
      if (t.push(n), ((l = n == null ? void 0 : n.system) == null ? void 0 : l.objectType) === "container") {
        const o = (r = n.containerItems) == null ? void 0 : r.allItems;
        o instanceof Promise ? o.then((a) => t.push(...a ?? [])) : t.push(...o ?? []);
      }
    }), t.filter((n) => !!n));
  }
  get bulkyCount() {
    const t = this.allItems;
    return t instanceof Promise ? t.then(
      (s) => s.reduce((n, l) => {
        var r;
        return (r = l.system) != null && r.bulky ? n + 1 : n;
      }, 0)
    ) : t.reduce((s, n) => {
      var l;
      return (l = n.system) != null && l.bulky ? s + 1 : s;
    }, 0);
  }
  get count() {
    const t = this.allItems;
    return t instanceof Promise ? t.then((s) => s.reduce((n, l) => n + l.system.quantity, 0)) : t.reduce((s, n) => s + n.system.quantity, 0);
  }
  get weight() {
    var n, l;
    if (((l = (n = P(this, hn).system) == null ? void 0 : n.capacity) == null ? void 0 : l.weightlessContents) ?? !1) return 0;
    const s = this.allItems;
    return s instanceof Promise ? s.then(
      (r) => r.reduce((o, a) => o + a.system.quantity * a.system.weight, 0)
    ) : s.reduce((r, o) => r + o.system.quantity * o.system.weight, 0);
  }
  async capacity() {
    const { value: t, type: s } = P(this, hn).system.capacity, n = {
      max: t ?? 1 / 0,
      percentage: 0,
      unit: "",
      value: 0
    };
    return s === "bulk" ? (n.value = await this.bulkyCount, n.unit = "bulk") : s === "weight" ? (n.value = await this.weight, n.unit = "lbs") : s === "count" && (n.value = await this.count, n.unit = "items"), n.percentage = Math.round(Math.clamp(n.max ? n.value / n.max * 100 : 0, 0, 100)), n;
  }
  /** ************************************************
   *               Data Helper methods
   * ************************************************ */
  async add(t, s) {
    var r;
    s || (s = {});
    const n = fromUuidSync(t);
    if (!n) {
      ui.notifications.error(`Could not find object with uuid: ${t}`);
      return;
    }
    foundry.utils.mergeObject(s, { uuid: t }), s.quantity = ((r = n.system) == null ? void 0 : r.quantity) ?? 1;
    const l = foundry.utils.randomID();
    await P(this, hn).update({ [`system.items.${l}`]: s });
  }
  async addMulti(t) {
    const s = {};
    t.forEach(async (n) => {
      var o;
      const l = fromUuidSync(n);
      if (!l) {
        ui.notifications.error(`Could not find object with uuid: ${n}`);
        return;
      }
      const r = foundry.utils.randomID();
      s[`system.items.${r}`] = { uuid: n, quantity: ((o = l.system) == null ? void 0 : o.quantity) ?? 1 };
    }), await P(this, hn).update(s);
  }
  async clean() {
    const t = {};
    [...this.values()].forEach((s) => {
      fromUuidSync(s.uuid) || (t[`system.items.-=${s._id}`] = null);
    }), await P(this, hn).update(t);
  }
  cleanSync() {
    const t = {};
    [...this.values()].forEach((s) => {
      fromUuidSync(s.uuid) || (t[`system.items.-=${s._id}`] = null);
    }), P(this, hn).update(t);
  }
  async remove(t) {
    var n;
    const s = (n = [...this.values()].find((l) => l.uuid === t)) == null ? void 0 : n._id;
    s && await P(this, hn).update({ [`system.items.-=${s}`]: null });
  }
  async removeMulti(t) {
    const s = [...this.values()].reduce((l, r) => (t.includes(r.uuid) && l.push(r._id), l), []);
    if (!s.length) return;
    const n = {};
    s.forEach((l) => {
      n[`system.items.-=${l}`] = null;
    }), await P(this, hn).update(n);
  }
  async removeAll() {
    const t = [...this.keys()];
    if (!t.length) return;
    const s = {};
    t.forEach((n) => {
      s[`system.items.-=${n}`] = null;
    }), await P(this, hn).update(s);
  }
  /** ************************************************
   *               Static methods
   * ************************************************ */
  static async createContainerOnActor(t, s) {
    var o;
    await ((o = s.containerItems) == null ? void 0 : o.clean());
    const n = foundry.utils.duplicate(Object.values(s.system.items));
    await s.containerItems.removeAll();
    const l = [];
    await Promise.all(
      n.map(async ({ quantityOverride: a, uuid: c }) => {
        let f = await fromUuid(c);
        f && (f = f.toObject(), f.system.containerId = s.uuid, a && (f.system.quantity = a ?? f.system.quantityOverride), c.startsWith("Compendium") && (f._stats.compendiumSource = c), l.push(f));
      })
    );
    const r = (await t.createEmbeddedDocuments("Item", l)).map((a) => a.uuid);
    return await s.containerItems.addMulti(r), s;
  }
  static async createContainerOnSidebar(t, s = null) {
    var o;
    s = s || t.folder._id || null, await ((o = t.containerItems) == null ? void 0 : o.clean());
    const n = foundry.utils.duplicate(Object.values(t.system.items));
    await t.containerItems.removeAll();
    const l = [];
    await Promise.all(
      n.map(async ({ quantityOverride: a, uuid: c }) => {
        let f = await fromUuid(c);
        f && (f = f.toObject(), f.system.containerId = t.uuid, a && (f.system.quantity = a ?? f.system.quantityOverride), c.startsWith("Compendium") && (f._stats.compendiumSource = c), s && (f.folder = s), l.push(f));
      })
    );
    const r = (await Item.createDocuments(l)).map((a) => a.uuid);
    return await t.containerItems.addMulti(r), s && await t.update({ folder: s }), t;
  }
};
hn = new WeakMap(), u(GE, "ContainerManager");
let qr = GE;
const zE = class zE extends bc {
  get weight() {
    var e;
    if (this.system.objectType === "container") {
      const t = ((e = this.containerItems) == null ? void 0 : e.weight) ?? 0;
      return t instanceof Promise ? t.then((s) => (s ?? 0) + this.system.weight) : t + this.system.weight;
    }
    return this.system.weight;
  }
  get container() {
    var e;
    return this.system.containerId ? this.isEmbedded ? this.actor.items.get(this.system.containerId) : this.pack ? (e = game.packs.get(this.pack)) == null ? void 0 : e.getDocument(this.system.containerId) : game.items.get(this.system.containerId) : null;
  }
  // TODO: Container Rework - Add a solid fix at some point
  get containerItemNames() {
    return this.containerItems ? (this.containerItems.allItems ?? []).map((t) => t.name).join(", ") : "";
  }
  get contents() {
    var e;
    return this.system.objectType !== "container" ? [] : ((e = this.containerItems) == null ? void 0 : e.items) ?? [];
  }
  /** ------------------------------------------------------ */
  /**                      Data Prep                         */
  /** ------------------------------------------------------ */
  _initialize(e) {
    var t;
    ((t = this.system) == null ? void 0 : t.objectType) === "container" && (this.containerItems = null), super._initialize(e);
  }
  prepareBaseData() {
    super.prepareBaseData(), this.system.objectType === "container" && (this.containerItems = new qr(this));
  }
  prepareDerivedData() {
    super.prepareDerivedData();
  }
  async duplicateItem() {
    return this.system.objectType !== "container" ? super.duplicateItem() : this.actor ? await qr.createContainerOnActor(this.parent, this) : null;
  }
  async toggleAttunement() {
    await this.update({
      "system.attuned": !this.system.attuned
    });
  }
  async toggleDamagedState() {
    const t = (this.system.damagedState + 1) % 3;
    await this.update({
      "system.damagedState": t
    });
  }
  async toggleEquippedState() {
    if (!this.actor) return;
    let t = (this.system.equippedState + 1) % 3;
    if (t === CONFIG.A5E.EQUIPPED_STATES.EQUIPPED && this.system.objectType === "armor") {
      const { hasArmor: s, hasUnderArmor: n } = this.actor.items.reduce(
        (r, o) => (o.system.equippedState !== CONFIG.A5E.EQUIPPED_STATES.EQUIPPED || // @ts-expect-error
        o.system.objectType !== "armor" || (o.system.materialProperties.includes("underarmor") ? r.hasUnderArmor = !0 : r.hasArmor = !0), r),
        { hasArmor: !1, hasUnderArmor: !1 }
      ), l = this.system.materialProperties.includes("underarmor");
      (l && n || !l && s) && (t = 0), t === 0 && ui.notifications.warn(game.i18n.localize("A5E.armorClass.armorAlreadyEquipped"));
    }
    t === 2 && this.system.objectType === "shield" && (this.actor.items.filter(
      (n) => (
        // @ts-expect-error
        n.system.equippedState === CONFIG.A5E.EQUIPPED_STATES.EQUIPPED && // @ts-expect-error
        n.system.objectType === "shield"
      )
    ).length >= 2 && (t = 0), t === 0 && ui.notifications.warn(game.i18n.localize("A5E.armorClass.shieldAlreadyEquipped"))), await this.update({
      "system.equippedState": t
    });
  }
  async toggleUnidentified() {
    await this.update({
      "system.unidentified": !this.system.unidentified
    });
  }
  // TODO: Container Rework - Move to manager
  async updateContainer(e) {
    var n, l, r, o, a, c;
    if (e === this.uuid) return;
    if (!e) {
      const f = await fromUuid(this.system.containerId);
      if (!f) return;
      await this.update({ "system.containerId": "" }), await ((n = f.containerItems) == null ? void 0 : n.remove(this.uuid));
      return;
    }
    const t = await fromUuid(this.system.containerId);
    t && await ((l = t.containerItems) == null ? void 0 : l.remove(this.uuid));
    const s = await fromUuid(e);
    !s || ((r = s == null ? void 0 : s.system) == null ? void 0 : r.objectType) !== "container" || ((o = s == null ? void 0 : s.parent) == null ? void 0 : o.id) !== ((a = this.parent) == null ? void 0 : a.id) || (await this.update({ "system.containerId": e }), await ((c = s.containerItems) == null ? void 0 : c.add(this.uuid)));
  }
  async _preCreate(e, t, s) {
    super._preCreate(e, t, s);
  }
  async _preUpdate(e, t, s) {
    foundry.utils.getProperty(e, "system.objectType") && await this._preUpdateObjectType(), super._preUpdate(e, t, s);
  }
  async _preUpdateObjectType() {
    if (this.system.objectType !== "container") return;
    const e = {}, t = Object.entries(this.system.items ?? {});
    for await (const [s, n] of t) {
      e[`system.items.-=${s}`] = null;
      const l = await fromUuid(n.uuid);
      l && await l.update({ "system.containerId": "" });
    }
    await this.update(e);
  }
  async _onCreate(e, t, s) {
    var o;
    if (super._onCreate(e, t, s), s !== game.userId) return;
    this.system.objectType === "container" && (((o = this.parent) == null ? void 0 : o.documentName) === "Actor" ? await qr.createContainerOnActor(this.parent, this) : this.pack || await qr.createContainerOnSidebar(this)), await fromUuid(this.system.containerId) || await this.update({ "system.containerId": "" });
    const l = {};
    Object.entries(this.system.actions ?? {}).forEach(([a, c]) => {
      Object.entries(c.consumers ?? {}).forEach(([d, p]) => {
        p.type === "quantity" && (l[`system.actions.${a}.consumers.${d}.itemId`] = this._id);
      });
    }), await this.update(l);
  }
  async _onDelete(e, t) {
    var n, l;
    if (!this.parent) return;
    if (this.system.objectType === "container") {
      const o = Object.values(this.system.items).map(({ uuid: a }) => fromUuidSync(a)).map((a) => ({ _id: a == null ? void 0 : a.id, "system.containerId": "" }));
      await ((n = this.parent) == null ? void 0 : n.updateEmbeddedDocuments("Item", o));
    }
    const s = await fromUuid(this.system.containerId);
    s && await ((l = s == null ? void 0 : s.containerItems) == null ? void 0 : l.delete(this.uuid)), super._onDelete(e, t);
  }
};
u(zE, "ObjectItemA5e");
let f0 = zE;
const HE = class HE extends bc {
  get spellBook() {
    return this.system.spellBook;
  }
  async togglePrepared() {
    if (this.type !== "spell" || !this.actor) return;
    const t = (Number(this.system.prepared) + 1) % 3;
    await this.update({
      "system.prepared": t
    });
  }
  // eslint-disable-next-line consistent-return
  async _preCreate(e, t, s) {
    var n, l, r;
    if (!((n = e.system) != null && n.spellBook) && ((l = this.parent) == null ? void 0 : l.documentName) === "Actor")
      return (r = ui.notifications) == null || r.error("You must select a spell book to create a spell."), !1;
    super._preCreate(e, t, s);
  }
};
u(HE, "SpellItemA5e");
let d0 = HE;
function Lse() {
  return {
    Actor: {
      documentClasses: {
        character: Wb,
        npc: Kb
      }
    },
    Item: {
      documentClasses: {
        feature: c0,
        object: f0,
        spell: d0,
        archetype: C_,
        background: _r,
        class: ry,
        culture: _r,
        destiny: _r,
        heritage: _r
      }
    }
  };
}
u(Lse, "registerDocumentConfig");
function Bse() {
  return {
    encounterElements: {
      acid: {
        name: "A5E.encounterElements.acid",
        description: "<p>A creature that touches acid takes 5 (2d4) acid damage. When a creature first enters into an area of acid or starts its turn there, it takes 10 (4d4) ongoing acid damage. A creature submerged in acid takes 25 (10d4) ongoing acid damage. This damage persists for 3 rounds after the creature leaves the acid. A creature ends all ongoing damage from mundane acid by using its action to wipe away the corrosive liquid.</p>",
        crModifier: 2
      },
      brownMold: {
        name: "A5E.encounterElements.brownMold",
        description: `<p>Brown mold subsists on heat, drawing away warmth from the environment and creatures around it. Most patches of brown mold have only a 10-foot radius, but the temperature in a 30-foot radius around it is unnaturally cold.</p>
      <p>When a creature moves within 5 feet of the brown mold for the first time on a turn or starts its turn there, it makes a DC 12 Constitution saving throw, taking 22 (4d10) cold damage on a failure, or half damage on a success.</p>
      <p>Brown mold is not only immune to fire damage but rapidly grows when exposed to flames. When any source of fire — the effects of a spell like fire bolt, a lit torch, and so on—happens within 5 feet of a patch of brown mold, the brown mold rapidly expands to surround it in a 10-foot radius. However, any amount of cold damage instantly destroys a patch of brown mold.</p>`,
        crModifier: 2
      },
      crowd: {
        name: "A5E.encounterElements.crowd",
        description: `<p>Throngs of humanoids are difficult terrain, and a creature surrounded by a crowd has disadvantage on hearing- and sight-based checks to perceive outside of it.</p>
      <p>In addition, making attacks in a crowd risks collateral damage and the wrath of the throng. When a creature attacks from within a crowd or attacks a target within a crowd, on a miss by 10 or more the attack hits a crowd member and the creature makes a Deception, Intimidation, or Persuasion check (DC 13 + 2 per previous check) to convince the crowd not to attack it. On a failure, the crowd transforms into a commoner mob and attacks, fighting until the creature is reduced to 0 hit points or the commoner mob is bloodied.</p>`,
        crModifier: 1
      },
      darkness: {
        name: "A5E.encounterElements.darkness",
        description: "<p>Darkness comes in two varieties: magical and nonmagical. In nonmagical darkness, creatures with darkvision can see out to the range specified by that trait as if it were dim light. In magical darkness, all vision is blocked. Creatures without darkvision cannot see in mundane or magical darkness. In addition, a frightened creature unable to see because of magical darkness is rattled.</p>",
        crModifier: 0.5
      },
      denseSmoke: {
        name: "A5E.encounterElements.denseSmoke",
        description: "<p>Creatures and objects in an area of dense smoke are heavily obscured. When a creature that needs to breathe starts its turn in an area of dense smoke, if it is not holding its breath it makes a Constitution saving throw (DC 10 + 1 per round previous turn in the dense smoke, maximum DC 20) or it begins to suffocate (see Chapter 7: Adventuring, in the Adventurer’s Handbook). A creature that covers its mouth and nose with a damp cloth has advantage on this save. Finally, smell-based checks to perceive or track creatures that have spent more than 1 round in an area of dense smoke have advantage until the creature finishes a long rest or takes at least 10 minutes to clean the smoke from itself.</p>",
        crModifier: 1
      },
      extremeCold: {
        name: "A5E.encounterElements.extremeCold",
        description: `<p>At the end of every hour a creature is exposed to temperatures at or below 0° Fahrenheit (–18° Celsius), it makes a DC 10 Constitution saving throw or suffers a level of fatigue. Resistance to cold damage, immunity to cold damage, or wearing cold weather gear grants an automatic success on this save. Creatures native to an extreme cold environment also automatically succeed on their saving throw.</p>
      <p>Saving throws made against effects or spells that deal cold damage have disadvantage.</p>`,
        crModifier: 1
      },
      extremeHeat: {
        name: "A5E.encounterElements.extremeHeat",
        description: `<p>At the end of every hour a creature is exposed to temperatures at or above 100° Fahrenheit (38 Celsius), it makes a Constitution saving throw (DC 4 + 1 per hour spent in extreme heat) or suffers a level of fatigue. Resistance to fire damage, immunity to fire damage, or keeping a light pack (less than half carrying capacity) grants an automatic success on this save, whereas a creature wearing medium armor, heavy armor, or heavy clothing has disadvantage. Creatures native to an extreme heat environment also automatically succeed on their saving throw.</p>
      <p>Saving throws made against effects or spells that deal fire damage have disadvantage.</p>`,
        crModifier: 1
      },
      falling30: {
        name: "A5E.encounterElements.falling30",
        description: "<p>The quickest way to severe harm (or even death) is from falling. Whether from a rooftop, cliff’s edge, treetop, or flying mount, falling can deal a devastating amount of damage. When a creature falls, it takes 1d6 bludgeoning damage for every 10 feet it falls (maximum 20d6) and lands prone.</p> equal to the distance it falls divided by 5).</p>",
        crModifier: 1
      },
      falling60: {
        name: "A5E.encounterElements.falling60",
        description: "<p>The quickest way to severe harm (or even death) is from falling. Whether from a rooftop, cliff’s edge, treetop, or flying mount, falling can deal a devastating amount of damage. When a creature falls, it takes 1d6 bludgeoning damage for every 10 feet it falls (maximum 20d6) and lands prone.</p> equal to the distance it falls divided by 5).</p>",
        crModifier: 2
      },
      falling90: {
        name: "A5E.encounterElements.falling90",
        description: "<p>The quickest way to severe harm (or even death) is from falling. Whether from a rooftop, cliff’s edge, treetop, or flying mount, falling can deal a devastating amount of damage. When a creature falls, it takes 1d6 bludgeoning damage for every 10 feet it falls (maximum 20d6) and lands prone.</p> equal to the distance it falls divided by 5).</p>",
        crModifier: 3
      },
      falling120: {
        name: "A5E.encounterElements.falling120",
        description: "<p>The quickest way to severe harm (or even death) is from falling. Whether from a rooftop, cliff’s edge, treetop, or flying mount, falling can deal a devastating amount of damage. When a creature falls, it takes 1d6 bludgeoning damage for every 10 feet it falls (maximum 20d6) and lands prone.</p> equal to the distance it falls divided by 5).</p>",
        crModifier: 4
      },
      fire: {
        name: "A5E.encounterElements.fire",
        description: "<p>An area of fire sheds bright light to 10 feet beyond its edges and dim light an additional 10 feet. A creature that touches fire takes 7 (2d6) ongoing fire damage. A creature may end ongoing damage from mundane fire by spending an action to extinguish the flames. Smoke and heat shimmer lightly obscure anything within or on the other side of an area of fire.</p>",
        crModifier: 2
      },
      frigidWater: {
        name: "A5E.encounterElements.frigidWater",
        description: "<p>After being in frigid water for a number of minutes equal to its Constitution score, a creature makes a DC 10 Constitution saving throw at the end of each minute or it suffers a level of fatigue. Resistance or immunity to cold damage grants an automatic success on this save. Creatures native to an extreme cold environment also automatically succeed on their saving throw.",
        crModifier: 1
      },
      greenSlime: {
        name: "A5E.encounterElements.greenSlime",
        description: `<p>This sticky, vibrantly green, slopping slime clings to and mercilessly eats away at flesh, plants, and even metal.</p>
      <p>Green slime covers a 5-foot square area or larger, though rarely greater in size than a 20-foot radius. Although it is alive and able to sense with blindsight to a range of 30 feet, green slime has no Intelligence or other ability scores. When green slime senses movement underneath it, it drops towards the ground. A creature in the green slime’s area makes a DC 10 Dexterity saving throw, becoming slimed on a failure.</p>
      <p>A slimed creature takes 5 (1d10) ongoing acid damage until the green slime is scraped off with an action. Green slime is destroyed by sunlight, any feature, spell, or trait that cures disease, or any amount of cold, fire, or radiant damage. Wood or metal exposed to green slime instead takes 11 (2d10) acid damage.</p>`,
        crModifier: 1
      },
      heavyPrecipitation: {
        name: "A5E.encounterElements.heavyPrecipitation",
        description: "<p>Heavy snowfall makes an area lightly obscured, and Perception checks relying on sight are made with disadvantage. Heavy rain has the same effects, also affecting Perception checks that rely on hearing and extinguishing any open flames.</p>",
        crModifier: 0.5
      },
      highGravity: {
        name: "A5E.encounterElements.highGravity",
        description: "<p>The ranges of ranged weapons are halved, as are all jump distances. When a creature makes its first attack in a round using a weapon that does not have the dual-wielding property, it makes a DC 12 Athletics check or subtracts 1d4 from its attack rolls for 1 round. Falling damage is treated as twice the distance in the area and there is no maximum amount of damage that can be taken from a fall. For every hour spent in the area, a creature not acclimated to it makes a Constitution saving throw (DC 8 + the number of hours spent in the area) or gain a level of fatigue (maximum 4 levels of fatigue).</p>",
        crModifier: 2
      },
      lava: {
        name: "A5E.encounterElements.lava",
        description: "<p>A creature that touches lava takes 16 (3d10) ongoing fire damage. When a creature first enters into an area of lava or starts its turn there, it takes 33 (6d10) ongoing fire damage. A creature submerged in lava takes 55 (10d10) ongoing fire damage. This damage persists for 4 rounds after the creature leaves the lava. A creature ends all ongoing damage from lava by using its action to wipe away the molten rock.</p>",
        crModifier: 4
      },
      lowGravity: {
        name: "A5E.encounterElements.lowGravity",
        description: "<p>The ranges of ranged weapons are doubled, as are all jump distances. Falling damage is treated as half the distance in the area. In addition, damage from bludgeoning weapons is reduced by half.</p>",
        crModifier: -1
      },
      magnetizedOre: {
        name: "A5E.encounterElements.magnetizedOre",
        description: `<p>Magnetized ore wreaks havoc on the use of compasses or any natural sense of direction, making both useless within 500 feet.</p>
      <p>While within 50 feet of magnetized ore, a creature wearing heavy armor made from metal or attacking with a metal weapon has disadvantage on its attack rolls, Strength and Dexterity checks, and saving throws made against fatigue.</p>`,
        crModifier: 0.5
      },
      memoryCrystals: {
        name: "A5E.encounterElements.memoryCrystals",
        description: `<p>Recognizing a memory crystal for what it is requires a DC 20 Arcana check. When a creature with prepared spells is within 30 feet of a memory crystal, at the start of its turn it must make a DC 15 spellcasting ability check or lose one randomly determined prepared spell.</p>
      <p>When destroyed (DC 17 Strength check, AC 7, 2 hit points) a memory crystal explodes with dangerous magic in a 10-foot radius. Each creature in the area makes a DC 20 Charisma saving throw, taking 14 (4d6) psychic damage on a failed save, or half as much damage on a successful one.</p>
      <p>An area filled with memory crystals requires a creature to succeed on a DC 8 Acrobatics check at the end of each of its turns to avoid breaking any of the dangerous gemstones.</p>`,
        crModifier: 0.5
      },
      miringGround: {
        name: "A5E.encounterElements.miringGround",
        description: "<p>Sludge, tar, or sufficiently deep and sticky mud can provide real danger to creatures caught in them. Miring ground is difficult terrain. In addition, when a creature starts its turn in miring ground, it begins to sink and makes an Athletics check (DC 12 + 2 per round spent in the area) to continue moving. On a failure, its Speed is reduced by 10 feet. When this reduces a creature’s Speed to 5 feet or less it begins sinking 1 foot deeper into the miring ground at the end of each of its turns. A sinking creature can be freed with an Athletics check equal to the DC of its last failed check against the miring ground. A sinking creature that becomes submerged begins suffocating if it is unable to hold its breath. Any creature trying to aid a sinking creature must have a solid surface to stand on or a fly speed, but can use ropes or similar means to do so at a distance.</p>",
        crModifier: 3
      },
      poisonousPlants: {
        name: "A5E.encounterElements.poisonousPlants",
        description: `<p>Spotting the telltale signs of dangerous vegetation requires a DC 15 Nature check. Poisonous plants can be as sparse as a few shrubs or as pervasive as fields of harmful groundcover.</p>
      <p>When a creature starts its turn within the area or enters the area for the first time on a turn, it makes a DC 10 Constitution saving throw, taking 3 (1d6) poison damage on a failure, or half damage on a success.</p>`,
        crModifier: 1
      },
      rushingLiquid: {
        name: "A5E.encounterElements.rushingLiquid",
        description: "<p>Standing in rushing liquid halves the speed of a creature moving against the current and doubles the speed of creatures moving with it. At the start of each of its turns, a creature in knee-high rushing liquid makes an Acrobatics or Athletics check to keep its footing. On a failure, it is knocked prone and moves a number of feet in the direction of the current equal to the amount it failed the check by (rounded up to the nearest 5 feet). The check is DC 11 if the rushing liquid is knee-high, DC 14 if waist-high, DC 17 if chest-high, and DC 20 if the creature's feet cannot touch the bottom. A creature moving with the current has disadvantage on this check. A creature driven into a solid object by the current (such as a rock) takes damage as if it had fallen a number of feet equal to the distance it was moved by the current (minimum 1d6 bludgeoning, piercing, or slashing damage). Standing up from prone in rushing liquid requires an Acrobatics or Athletics check with a DC equal to DC to keep footing. A creature that loses its footing is considered underwater (see below) until it regains its footing.</p>",
        crModifier: 2
      },
      strongWinds: {
        name: "A5E.encounterElements.strongWinds",
        description: "<p>Ranged weapon attacks and Perception checks that rely on hearing have disadvantage in high winds. In addition, it extinguishes any open flames, disperses fogs and smoke, and forces any flying creature to land before the end of its turn or fall.</p>",
        crModifier: 0.5
      },
      underwater: {
        name: "A5E.encounterElements.underwater",
        description: "<p>A creature that cannot breathe water begins to suffocate underwater once it cannot hold its breath. In addition, creatures without swim speeds have disadvantage on attacks made using any weapon other than a dagger, dueling dagger, javelin, shortsword, spear, or trident. Ranged weapon attacks automatically miss beyond their normal range underwater, and bludgeoning and fire damage are halved. A creature that takes damage while holding its breath underwater must succeed on a concentration check or immediately begin suffocating as if its breath had run out.</p>",
        crModifier: 1
      },
      vacuum: {
        name: "A5E.encounterElements.vacuum",
        description: "<p>An area of vacuum has no air, so creatures that need to breathe must use another source of air or begin to suffocate once they cannot hold their breath. In addition, the area carries no sound, so hearing-based checks made to perceive automatically fail and spells with vocalized components cannot be cast. A creature with its own air supply may cast spells with vocalized components, but still cannot hear. Vacuum is also utterly chilling, dealing 11 (3d6) cold damage to a creature at the start of each of its turns in the area.</p>",
        crModifier: 3
      },
      webs: {
        name: "A5E.encounterElements.webs",
        description: `<p>Whether created by massive insects or swarms of smaller creatures, these sticky strands ensnare and capture creatures that fall afoul of them. An area of webs is difficult terrain, and when a creature starts its turn within the area or enters the area for the first time on a turn, it makes a DC 12 Dexterity saving throw or becomes restrained. Restrained creatures can use an action to make a DC 12 Acrobatics or Athletics check, escaping on a success.</p>
      <p>A 10-foot cube of webs has AC 10, 15 hit points, vulnerability to fire, and immunity to bludgeoning, piercing, and psychic damage.</p>`,
        crModifier: 0.5
      },
      yellowMold: {
        name: "A5E.encounterElements.yellowMold",
        description: `<p>This sickeningly yellow mold only grows in dark places and is extremely sensitive to movement nearby.</p>
      <p>Yellow mold covers a 10-foot radius area. When a creature moves within 30 feet of a patch of yellow mold, at the start of its turn spores are released and it makes a DC 15 Constitution saving throw. On a failure, the creature takes 11 (2d10) ongoing poison damage and becomes poisoned for 1 minute, continuing to take ongoing damage until it is no longer poisoned. At the end of each of its turns, the poisoned creature can repeat the saving throw, ending the effect on itself on a success.</p>
      <p>Yellow mold is destroyed by sunlight or any amount of fire damage.</p>`,
        crModifier: 2
      }
    }
  };
}
u(Bse, "registerEncounterElements");
function qse() {
  return { effectKeyGroups: {
    abilityChecks: {
      label: "A5E.effects.groups.abilityChecks",
      items: [
        "flags.a5e.effects.rollMode.abilityCheck.all",
        "flags.a5e.effects.rollMode.abilityCheck.cha",
        "flags.a5e.effects.rollMode.abilityCheck.con",
        "flags.a5e.effects.rollMode.abilityCheck.dex",
        "flags.a5e.effects.rollMode.abilityCheck.int",
        "flags.a5e.effects.rollMode.abilityCheck.str",
        "flags.a5e.effects.rollMode.abilityCheck.wis",
        "system.abilities.cha.check.bonus",
        "system.abilities.cha.check.expertiseDice",
        "system.abilities.cha.value",
        "system.abilities.con.check.bonus",
        "system.abilities.con.check.expertiseDice",
        "system.abilities.con.value",
        "system.abilities.dex.check.bonus",
        "system.abilities.dex.check.expertiseDice",
        "system.abilities.dex.value",
        "system.abilities.int.check.bonus",
        "system.abilities.int.check.expertiseDice",
        "system.abilities.int.value",
        "system.abilities.str.check.bonus",
        "system.abilities.str.check.expertiseDice",
        "system.abilities.str.value",
        "system.abilities.wis.check.bonus",
        "system.abilities.wis.check.expertiseDice",
        "system.abilities.wis.value"
      ]
    },
    ac: {
      label: "A5E.effects.groups.ac",
      items: [
        "system.attributes.ac.baseFormula",
        "system.attributes.ac.changes.bonuses.value",
        "system.attributes.ac.value"
      ]
    },
    attackRollModes: {
      label: "A5E.effects.groups.attackRollModes",
      items: [
        "flags.a5e.effects.rollMode.attack.all",
        "flags.a5e.effects.rollMode.attack.meleeSpellAttack",
        "flags.a5e.effects.rollMode.attack.meleeWeaponAttack",
        "flags.a5e.effects.rollMode.attack.rangedSpellAttack",
        "flags.a5e.effects.rollMode.attack.rangedWeaponAttack"
      ]
    },
    attunement: {
      label: "A5E.effects.groups.attunement",
      items: ["system.attributes.attunement.current", "system.attributes.attunement.max"]
    },
    bonuses: {
      label: "A5E.effects.groups.bonuses",
      items: [
        "flags.a5e.effects.bonuses.abilities",
        "flags.a5e.effects.bonuses.attacks",
        "flags.a5e.effects.bonuses.damage",
        "flags.a5e.effects.bonuses.healing",
        "flags.a5e.effects.bonuses.skills",
        "system.bonuses.abilities.check",
        "system.bonuses.abilities.save",
        "system.bonuses.abilities.skill",
        "system.bonuses.maneuverDC",
        "system.bonuses.spellDC"
      ]
    },
    conditions: {
      label: "A5E.effects.groups.conditions",
      items: [
        "flags.a5e.effects.statusConditions",
        "system.attributes.corruption",
        "system.attributes.fatigue",
        "system.attributes.inebriated",
        "system.attributes.strife"
      ]
    },
    currency: {
      label: "A5E.effects.groups.currency",
      items: [
        "system.currency.cp",
        "system.currency.ep",
        "system.currency.gp",
        "system.currency.pp",
        "system.currency.sp"
      ]
    },
    creatureTraits: {
      label: "A5E.effects.groups.creatureTraits",
      items: ["system.traits.size", "system.details.creatureTypes", "system.details.isSwarm"]
    },
    deathSaves: {
      label: "A5E.effects.groups.deathSaves",
      items: [
        "flags.a5e.deathSaveThreshold",
        "flags.a5e.effects.rollMode.deathSave",
        "system.attributes.death.failure",
        "system.attributes.death.success"
      ]
    },
    exertion: {
      label: "A5E.effects.groups.exertion",
      items: [
        "system.attributes.exertion.current",
        "system.attributes.exertion.max",
        "system.attributes.exertion.recoverOnRest"
      ]
    },
    hitDice: {
      label: "A5E.effects.groups.hitDice",
      items: [
        "system.attributes.hitDice.d20.current",
        "system.attributes.hitDice.d20.total",
        "system.attributes.hitDice.d12.current",
        "system.attributes.hitDice.d12.total",
        "system.attributes.hitDice.d10.current",
        "system.attributes.hitDice.d10.total",
        "system.attributes.hitDice.d6.current",
        "system.attributes.hitDice.d6.total",
        "system.attributes.hitDice.d8.current",
        "system.attributes.hitDice.d8.total",
        "system.attributes.hitDice.d4.current",
        "system.attributes.hitDice.d4.total"
      ]
    },
    hitPoints: {
      label: "A5E.effects.groups.hitPoints",
      items: [
        "system.attributes.hp.baseMax",
        "system.attributes.hp.bonus",
        "system.attributes.hp.value",
        "system.attributes.hp.max",
        "system.attributes.hp.temp"
      ]
    },
    initiative: {
      label: "A5E.effects.groups.initiative",
      items: [
        "flags.a5e.effects.rollMode.initiative",
        "flags.a5e.effects.bonuses.initiative",
        "system.attributes.initiative.ability",
        "system.attributes.initiative.expertiseDice"
      ]
    },
    movement: {
      label: "A5E.effects.groups.movement",
      items: [
        "flags.a5e.effects.movement.allDistances",
        "flags.a5e.effects.movement.allUnits",
        "system.attributes.movement.burrow.distance",
        "system.attributes.movement.burrow.unit",
        "system.attributes.movement.climb.distance",
        "system.attributes.movement.climb.unit",
        "system.attributes.movement.fly.distance",
        "system.attributes.movement.fly.unit",
        "system.attributes.movement.swim.distance",
        "system.attributes.movement.swim.unit",
        "system.attributes.movement.traits.hover",
        "system.attributes.movement.walk.distance",
        "system.attributes.movement.walk.unit"
      ]
    },
    proficiencies: {
      label: "A5E.effects.groups.proficiencies",
      items: [
        "system.proficiencies.armor",
        "system.proficiencies.languages",
        "system.proficiencies.tools",
        "system.proficiencies.weapons"
      ]
    },
    resistancesVulnerabilitiesImmunities: {
      label: "A5E.effects.groups.resistancesVulnerabilitiesImmunities",
      items: [
        "flags.a5e.effects.conditionImmunities.all",
        "flags.a5e.effects.damageImmunities.all",
        "flags.a5e.effects.damageResistances.all",
        "flags.a5e.effects.damageVulnerabilities.all",
        "system.traits.conditionImmunities",
        "system.traits.damageImmunities",
        "system.traits.damageResistances",
        "system.traits.damageVulnerabilities"
      ]
    },
    resources: {
      label: "A5E.effects.groups.resources",
      items: [
        "system.resources.primary.hideMax",
        "system.resources.primary.label",
        "system.resources.primary.max",
        "system.resources.primary.per",
        "system.resources.primary.recharge.formula",
        "system.resources.primary.recharge.threshold",
        "system.resources.primary.value",
        "system.resources.quaternary.hideMax",
        "system.resources.quaternary.label",
        "system.resources.quaternary.max",
        "system.resources.quaternary.per",
        "system.resources.quaternary.recharge.formula",
        "system.resources.quaternary.recharge.threshold",
        "system.resources.quaternary.value",
        "system.resources.secondary.hideMax",
        "system.resources.secondary.label",
        "system.resources.secondary.max",
        "system.resources.secondary.per",
        "system.resources.secondary.recharge.formula",
        "system.resources.secondary.recharge.threshold",
        "system.resources.secondary.value",
        "system.resources.tertiary.hideMax",
        "system.resources.tertiary.label",
        "system.resources.tertiary.max",
        "system.resources.tertiary.per",
        "system.resources.tertiary.recharge.formula",
        "system.resources.tertiary.recharge.threshold",
        "system.resources.tertiary.value"
      ]
    },
    savingThrows: {
      label: "A5E.effects.groups.savingThrows",
      items: [
        "flags.a5e.effects.rollMode.abilitySave.all",
        "flags.a5e.effects.rollMode.abilitySave.cha",
        "flags.a5e.effects.rollMode.abilitySave.con",
        "flags.a5e.effects.rollMode.abilitySave.dex",
        "flags.a5e.effects.rollMode.abilitySave.int",
        "flags.a5e.effects.rollMode.abilitySave.str",
        "flags.a5e.effects.rollMode.abilitySave.wis",
        "flags.a5e.effects.rollMode.concentration",
        "system.abilities.cha.save.bonus",
        "system.abilities.cha.save.expertiseDice",
        "system.abilities.cha.save.proficient",
        "system.abilities.con.save.bonus",
        "system.abilities.con.save.concentrationBonus",
        "system.abilities.con.save.expertiseDice",
        "system.abilities.con.save.proficient",
        "system.abilities.dex.save.bonus",
        "system.abilities.dex.save.expertiseDice",
        "system.abilities.dex.save.proficient",
        "system.abilities.int.save.bonus",
        "system.abilities.int.save.expertiseDice",
        "system.abilities.int.save.proficient",
        "system.abilities.str.save.bonus",
        "system.abilities.str.save.expertiseDice",
        "system.abilities.str.save.proficient",
        "system.abilities.wis.save.bonus",
        "system.abilities.wis.save.expertiseDice",
        "system.abilities.wis.save.proficient"
      ]
    },
    senses: {
      label: "A5E.effects.groups.senses",
      items: [
        "flags.a5e.effects.senses.allDistances",
        "flags.a5e.effects.senses.allUnits",
        "system.attributes.senses.blindsight.distance",
        "system.attributes.senses.blindsight.unit",
        "system.attributes.senses.blindsight.otherwiseBlind",
        "system.attributes.senses.darkvision.distance",
        "system.attributes.senses.darkvision.unit",
        "system.attributes.senses.tremorsense.distance",
        "system.attributes.senses.tremorsense.unit",
        "system.attributes.senses.truesight.distance",
        "system.attributes.senses.truesight.unit"
      ]
    },
    skills: {
      label: "A5E.effects.groups.skills",
      items: [
        "flags.a5e.effects.rollMode.skillCheck.all",
        "flags.a5e.effects.rollMode.skillCheck.acr",
        "flags.a5e.effects.rollMode.skillCheck.ani",
        "flags.a5e.effects.rollMode.skillCheck.arc",
        "flags.a5e.effects.rollMode.skillCheck.ath",
        "flags.a5e.effects.rollMode.skillCheck.cul",
        "flags.a5e.effects.rollMode.skillCheck.dec",
        "flags.a5e.effects.rollMode.skillCheck.eng",
        "flags.a5e.effects.rollMode.skillCheck.his",
        "flags.a5e.effects.rollMode.skillCheck.ins",
        "flags.a5e.effects.rollMode.skillCheck.inv",
        "flags.a5e.effects.rollMode.skillCheck.itm",
        "flags.a5e.effects.rollMode.skillCheck.med",
        "flags.a5e.effects.rollMode.skillCheck.nat",
        "flags.a5e.effects.rollMode.skillCheck.per",
        "flags.a5e.effects.rollMode.skillCheck.prc",
        "flags.a5e.effects.rollMode.skillCheck.prf",
        "flags.a5e.effects.rollMode.skillCheck.rel",
        "flags.a5e.effects.rollMode.skillCheck.sci",
        "flags.a5e.effects.rollMode.skillCheck.slt",
        "flags.a5e.effects.rollMode.skillCheck.ste",
        "flags.a5e.effects.rollMode.skillCheck.sur",
        "system.skills.acr.ability",
        "system.skills.acr.bonuses.check",
        "system.skills.acr.bonuses.passive",
        "system.skills.acr.expertiseDice",
        "system.skills.acr.minRoll",
        "system.skills.acr.proficient",
        "system.skills.acr.specialties",
        "system.skills.acr.value",
        "system.skills.ani.ability",
        "system.skills.ani.bonuses.check",
        "system.skills.ani.bonuses.passive",
        "system.skills.ani.expertiseDice",
        "system.skills.ani.minRoll",
        "system.skills.ani.proficient",
        "system.skills.ani.specialties",
        "system.skills.ani.value",
        "system.skills.arc.ability",
        "system.skills.arc.bonuses.check",
        "system.skills.arc.bonuses.passive",
        "system.skills.arc.expertiseDice",
        "system.skills.arc.minRoll",
        "system.skills.arc.proficient",
        "system.skills.arc.specialties",
        "system.skills.arc.value",
        "system.skills.ath.ability",
        "system.skills.ath.bonuses.check",
        "system.skills.ath.bonuses.passive",
        "system.skills.ath.expertiseDice",
        "system.skills.ath.minRoll",
        "system.skills.ath.proficient",
        "system.skills.ath.specialties",
        "system.skills.ath.value",
        "system.skills.cul.ability",
        "system.skills.cul.bonuses.check",
        "system.skills.cul.bonuses.passive",
        "system.skills.cul.expertiseDice",
        "system.skills.cul.minRoll",
        "system.skills.cul.proficient",
        "system.skills.cul.specialties",
        "system.skills.cul.value",
        "system.skills.dec.ability",
        "system.skills.dec.bonuses.check",
        "system.skills.dec.bonuses.passive",
        "system.skills.dec.expertiseDice",
        "system.skills.dec.minRoll",
        "system.skills.dec.proficient",
        "system.skills.dec.specialties",
        "system.skills.dec.value",
        "system.skills.eng.ability",
        "system.skills.eng.bonuses.check",
        "system.skills.eng.bonuses.passive",
        "system.skills.eng.expertiseDice",
        "system.skills.eng.minRoll",
        "system.skills.eng.proficient",
        "system.skills.eng.specialties",
        "system.skills.eng.value",
        "system.skills.his.ability",
        "system.skills.his.bonuses.check",
        "system.skills.his.bonuses.passive",
        "system.skills.his.expertiseDice",
        "system.skills.his.minRoll",
        "system.skills.his.proficient",
        "system.skills.his.specialties",
        "system.skills.his.value",
        "system.skills.ins.ability",
        "system.skills.ins.bonuses.check",
        "system.skills.ins.bonuses.passive",
        "system.skills.ins.expertiseDice",
        "system.skills.ins.minRoll",
        "system.skills.ins.proficient",
        "system.skills.ins.specialties",
        "system.skills.ins.value",
        "system.skills.itm.ability",
        "system.skills.itm.bonuses.check",
        "system.skills.itm.bonuses.passive",
        "system.skills.itm.expertiseDice",
        "system.skills.itm.minRoll",
        "system.skills.itm.proficient",
        "system.skills.itm.specialties",
        "system.skills.itm.value",
        "system.skills.inv.ability",
        "system.skills.inv.bonuses.check",
        "system.skills.inv.bonuses.passive",
        "system.skills.inv.expertiseDice",
        "system.skills.inv.minRoll",
        "system.skills.inv.proficient",
        "system.skills.inv.specialties",
        "system.skills.inv.value",
        "system.skills.med.ability",
        "system.skills.med.bonuses.check",
        "system.skills.med.bonuses.passive",
        "system.skills.med.expertiseDice",
        "system.skills.med.minRoll",
        "system.skills.med.proficient",
        "system.skills.med.specialties",
        "system.skills.med.value",
        "system.skills.nat.ability",
        "system.skills.nat.bonuses.check",
        "system.skills.nat.bonuses.passive",
        "system.skills.nat.expertiseDice",
        "system.skills.nat.minRoll",
        "system.skills.nat.proficient",
        "system.skills.nat.specialties",
        "system.skills.nat.value",
        "system.skills.prc.ability",
        "system.skills.prc.bonuses.check",
        "system.skills.prc.bonuses.passive",
        "system.skills.prc.expertiseDice",
        "system.skills.prc.minRoll",
        "system.skills.prc.proficient",
        "system.skills.prc.specialties",
        "system.skills.prc.value",
        "system.skills.prf.ability",
        "system.skills.prf.bonuses.check",
        "system.skills.prf.bonuses.passive",
        "system.skills.prf.expertiseDice",
        "system.skills.prf.minRoll",
        "system.skills.prf.proficient",
        "system.skills.prf.specialties",
        "system.skills.prf.value",
        "system.skills.per.ability",
        "system.skills.per.bonuses.check",
        "system.skills.per.bonuses.passive",
        "system.skills.per.expertiseDice",
        "system.skills.per.minRoll",
        "system.skills.per.proficient",
        "system.skills.per.specialties",
        "system.skills.per.value",
        "system.skills.rel.ability",
        "system.skills.rel.bonuses.check",
        "system.skills.rel.bonuses.passive",
        "system.skills.rel.expertiseDice",
        "system.skills.rel.minRoll",
        "system.skills.rel.proficient",
        "system.skills.rel.specialties",
        "system.skills.rel.value",
        "system.skills.sci.ability",
        "system.skills.sci.bonuses.check",
        "system.skills.sci.bonuses.passive",
        "system.skills.sci.expertiseDice",
        "system.skills.sci.minRoll",
        "system.skills.sci.proficient",
        "system.skills.sci.specialties",
        "system.skills.sci.value",
        "system.skills.slt.ability",
        "system.skills.slt.bonuses.check",
        "system.skills.slt.bonuses.passive",
        "system.skills.slt.expertiseDice",
        "system.skills.slt.minRoll",
        "system.skills.slt.proficient",
        "system.skills.slt.specialties",
        "system.skills.slt.value",
        "system.skills.ste.ability",
        "system.skills.ste.bonuses.check",
        "system.skills.ste.bonuses.passive",
        "system.skills.ste.expertiseDice",
        "system.skills.ste.minRoll",
        "system.skills.ste.proficient",
        "system.skills.ste.specialties",
        "system.skills.ste.value",
        "system.skills.sur.ability",
        "system.skills.sur.bonuses.check",
        "system.skills.sur.bonuses.passive",
        "system.skills.sur.expertiseDice",
        "system.skills.sur.minRoll",
        "system.skills.sur.proficient",
        "system.skills.sur.specialties",
        "system.skills.sur.value"
      ]
    },
    spellResources: {
      label: "A5E.effects.groups.spellResources",
      items: [
        "system.spellResources.points.current",
        "system.spellResources.points.max",
        "system.spellResources.slots.1.current",
        "system.spellResources.slots.1.max",
        "system.spellResources.slots.2.current",
        "system.spellResources.slots.2.max",
        "system.spellResources.slots.3.current",
        "system.spellResources.slots.3.max",
        "system.spellResources.slots.4.current",
        "system.spellResources.slots.4.max",
        "system.spellResources.slots.5.current",
        "system.spellResources.slots.5.max",
        "system.spellResources.slots.6.current",
        "system.spellResources.slots.6.max",
        "system.spellResources.slots.7.current",
        "system.spellResources.slots.7.max",
        "system.spellResources.slots.8.current",
        "system.spellResources.slots.8.max",
        "system.spellResources.slots.9.current",
        "system.spellResources.slots.9.max"
      ]
    },
    token: {
      label: "A5E.effects.groups.token",
      items: ["@token.width", "@token.height"]
    },
    tokenLight: {
      label: "A5E.effects.groups.tokenLight",
      items: [
        "@token.light.alpha",
        "@token.light.angle",
        "@token.light.animation.intensity",
        "@token.light.animation.reverse",
        "@token.light.animation.speed",
        "@token.light.animation.type",
        "@token.light.attenuation",
        "@token.light.bright",
        "@token.light.color",
        "@token.light.coloration",
        "@token.light.contrast",
        "@token.light.darkness.min",
        "@token.light.darkness.max",
        "@token.light.dim",
        "@token.light.luminosity",
        "@token.light.negative",
        "@token.light.saturation",
        "@token.light.shadows"
      ]
    },
    tokenTexture: {
      label: "A5E.effects.groups.tokenTexture",
      items: ["@token.texture.src", "@token.scaleX", "@token.scaleY"]
    },
    other: {
      label: "A5E.effects.groups.other",
      items: []
    }
  } };
}
u(qse, "registerEffectGroupConfig");
function Gse() {
  return { effectsKeyLocalizations: {
    "flags.a5e.deathSaveThreshold": "A5E.effects.keys.flags.deathSaveThreshold",
    "flags.a5e.effects.bonuses.abilities": "A5E.effects.keys.bonuses.ability",
    "flags.a5e.effects.bonuses.attacks": "A5E.effects.keys.bonuses.attacks",
    "flags.a5e.effects.bonuses.damage": "A5E.effects.keys.bonuses.damage",
    "flags.a5e.effects.bonuses.healing": "A5E.effects.keys.bonuses.healing",
    "flags.a5e.effects.bonuses.initiative": "A5E.effects.keys.bonuses.initiative",
    "flags.a5e.effects.bonuses.skills": "A5E.effects.keys.bonuses.skill",
    "flags.a5e.effects.conditionImmunities.all": "A5E.effects.keys.flags.conditionImmunities.all",
    "flags.a5e.effects.damageImmunities.all": "A5E.effects.keys.flags.damageImmunities.all",
    "flags.a5e.effects.damageResistances.all": "A5E.effects.keys.flags.damageResistances.all",
    "flags.a5e.effects.damageVulnerabilities.all": "A5E.effects.keys.flags.damageVulnerabilities.all",
    "flags.a5e.effects.movement.allDistances": "A5E.effects.keys.flags.movement.allDistances",
    "flags.a5e.effects.movement.allUnits": "A5E.effects.keys.flags.movement.allUnits",
    "flags.a5e.effects.expertiseDie": "A5E.effects.keys.flags.expertiseDie",
    "flags.a5e.effects.statusConditions": "A5E.effects.keys.flags.statusConditions",
    "flags.a5e.effects.grants.rollMode.attack.all": "A5E.effects.keys.flags.grantsRollMode.all",
    "flags.a5e.effects.grants.rollMode.attack.meleeSpellAttack": "A5E.effects.keys.flags.grantsRollMode.meleeSpellAttack",
    "flags.a5e.effects.grants.rollMode.attack.meleeWeaponAttack": "A5E.effects.keys.flags.grantsRollMode.meleeWeaponAttack",
    "flags.a5e.effects.grants.rollMode.attack.rangedSpellAttack": "A5E.effects.keys.flags.grantsRollMode.rangedSpellAttack",
    "flags.a5e.effects.grants.rollMode.attack.rangedWeaponAttack": "A5E.effects.keys.flags.grantsRollMode.rangedWeaponAttack",
    "flags.a5e.effects.rollMode.abilityCheck.all": "A5E.effects.keys.flags.rollMode.abilityChecks.all",
    "flags.a5e.effects.rollMode.abilityCheck.cha": "A5E.effects.keys.flags.rollMode.abilityChecks.cha",
    "flags.a5e.effects.rollMode.abilityCheck.con": "A5E.effects.keys.flags.rollMode.abilityChecks.con",
    "flags.a5e.effects.rollMode.abilityCheck.dex": "A5E.effects.keys.flags.rollMode.abilityChecks.dex",
    "flags.a5e.effects.rollMode.abilityCheck.int": "A5E.effects.keys.flags.rollMode.abilityChecks.int",
    "flags.a5e.effects.rollMode.abilityCheck.str": "A5E.effects.keys.flags.rollMode.abilityChecks.str",
    "flags.a5e.effects.rollMode.abilityCheck.wis": "A5E.effects.keys.flags.rollMode.abilityChecks.wis",
    "flags.a5e.effects.rollMode.abilitySave.all": "A5E.effects.keys.flags.rollMode.savingThrows.all",
    "flags.a5e.effects.rollMode.abilitySave.cha": "A5E.effects.keys.flags.rollMode.savingThrows.cha",
    "flags.a5e.effects.rollMode.abilitySave.con": "A5E.effects.keys.flags.rollMode.savingThrows.con",
    "flags.a5e.effects.rollMode.abilitySave.dex": "A5E.effects.keys.flags.rollMode.savingThrows.dex",
    "flags.a5e.effects.rollMode.abilitySave.int": "A5E.effects.keys.flags.rollMode.savingThrows.int",
    "flags.a5e.effects.rollMode.abilitySave.str": "A5E.effects.keys.flags.rollMode.savingThrows.str",
    "flags.a5e.effects.rollMode.abilitySave.wis": "A5E.effects.keys.flags.rollMode.savingThrows.wis",
    "flags.a5e.effects.rollMode.attack.all": "A5E.effects.keys.flags.rollMode.attack.all",
    "flags.a5e.effects.rollMode.attack.meleeSpellAttack": "A5E.effects.keys.flags.rollMode.attack.meleeSpellAttack",
    "flags.a5e.effects.rollMode.attack.meleeWeaponAttack": "A5E.effects.keys.flags.rollMode.attack.meleeWeaponAttack",
    "flags.a5e.effects.rollMode.attack.rangedSpellAttack": "A5E.effects.keys.flags.rollMode.attack.rangedSpellAttack",
    "flags.a5e.effects.rollMode.attack.rangedWeaponAttack": "A5E.effects.keys.flags.rollMode.attack.rangedWeaponAttack",
    "flags.a5e.effects.rollMode.concentration": "A5E.effects.keys.flags.rollMode.concentration",
    "flags.a5e.effects.rollMode.deathSave": "A5E.effects.keys.flags.rollMode.deathSave",
    "flags.a5e.effects.rollMode.initiative": "A5E.effects.keys.flags.rollMode.initiative",
    "flags.a5e.effects.rollMode.skillCheck.all": "A5E.effects.keys.flags.rollMode.skillChecks.all",
    "flags.a5e.effects.rollMode.skillCheck.acr": "A5E.effects.keys.flags.rollMode.skillChecks.acr",
    "flags.a5e.effects.rollMode.skillCheck.ani": "A5E.effects.keys.flags.rollMode.skillChecks.ani",
    "flags.a5e.effects.rollMode.skillCheck.arc": "A5E.effects.keys.flags.rollMode.skillChecks.arc",
    "flags.a5e.effects.rollMode.skillCheck.ath": "A5E.effects.keys.flags.rollMode.skillChecks.ath",
    "flags.a5e.effects.rollMode.skillCheck.cul": "A5E.effects.keys.flags.rollMode.skillChecks.cul",
    "flags.a5e.effects.rollMode.skillCheck.dec": "A5E.effects.keys.flags.rollMode.skillChecks.dec",
    "flags.a5e.effects.rollMode.skillCheck.eng": "A5E.effects.keys.flags.rollMode.skillChecks.eng",
    "flags.a5e.effects.rollMode.skillCheck.his": "A5E.effects.keys.flags.rollMode.skillChecks.his",
    "flags.a5e.effects.rollMode.skillCheck.ins": "A5E.effects.keys.flags.rollMode.skillChecks.ins",
    "flags.a5e.effects.rollMode.skillCheck.inv": "A5E.effects.keys.flags.rollMode.skillChecks.inv",
    "flags.a5e.effects.rollMode.skillCheck.itm": "A5E.effects.keys.flags.rollMode.skillChecks.itm",
    "flags.a5e.effects.rollMode.skillCheck.med": "A5E.effects.keys.flags.rollMode.skillChecks.med",
    "flags.a5e.effects.rollMode.skillCheck.nat": "A5E.effects.keys.flags.rollMode.skillChecks.nat",
    "flags.a5e.effects.rollMode.skillCheck.per": "A5E.effects.keys.flags.rollMode.skillChecks.per",
    "flags.a5e.effects.rollMode.skillCheck.prc": "A5E.effects.keys.flags.rollMode.skillChecks.prc",
    "flags.a5e.effects.rollMode.skillCheck.prf": "A5E.effects.keys.flags.rollMode.skillChecks.prf",
    "flags.a5e.effects.rollMode.skillCheck.rel": "A5E.effects.keys.flags.rollMode.skillChecks.rel",
    "flags.a5e.effects.rollMode.skillCheck.slt": "A5E.effects.keys.flags.rollMode.skillChecks.slt",
    "flags.a5e.effects.rollMode.skillCheck.ste": "A5E.effects.keys.flags.rollMode.skillChecks.ste",
    "flags.a5e.effects.rollMode.skillCheck.sur": "A5E.effects.keys.flags.rollMode.skillChecks.sur",
    "flags.a5e.effects.senses.allDistances": "A5E.effects.keys.flags.senses.allDistances",
    "flags.a5e.effects.senses.allUnits": "A5E.effects.keys.flags.senses.allUnits",
    "system.abilities.cha.check.bonus": "A5E.effects.keys.abilities.charismaCheckBonus",
    "system.abilities.cha.check.expertiseDice": "A5E.effects.keys.abilities.charismaCheckExpertiseDice",
    "system.abilities.cha.save.bonus": "A5E.effects.keys.abilities.charismaSaveBonus",
    "system.abilities.cha.save.expertiseDice": "A5E.effects.keys.abilities.charismaSaveExpertiseDice",
    "system.abilities.cha.save.proficient": "A5E.effects.keys.abilities.charismaSaveProficiency",
    "system.abilities.cha.value": "A5E.effects.keys.abilities.charismaValue",
    "system.abilities.con.check.bonus": "A5E.effects.keys.abilities.constitutionCheckBonus",
    "system.abilities.con.check.expertiseDice": "A5E.effects.keys.abilities.constitutionCheckExpertiseDice",
    "system.abilities.con.save.bonus": "A5E.effects.keys.abilities.constitutionSaveBonus",
    "system.abilities.con.save.concentrationBonus": "A5E.effects.keys.abilities.constitutionSaveConcentrationBonus",
    "system.abilities.con.save.expertiseDice": "A5E.effects.keys.abilities.constitutionSaveExpertiseDice",
    "system.abilities.con.save.proficient": "A5E.effects.keys.abilities.constitutionSaveProficiency",
    "system.abilities.con.value": "A5E.effects.keys.abilities.constitutionValue",
    "system.abilities.dex.check.bonus": "A5E.effects.keys.abilities.dexterityCheckBonus",
    "system.abilities.dex.check.expertiseDice": "A5E.effects.keys.abilities.dexterityCheckExpertiseDice",
    "system.abilities.dex.save.bonus": "A5E.effects.keys.abilities.dexteritySaveBonus",
    "system.abilities.dex.save.expertiseDice": "A5E.effects.keys.abilities.dexteritySaveExpertiseDice",
    "system.abilities.dex.save.proficient": "A5E.effects.keys.abilities.dexteritySaveProficiency",
    "system.abilities.dex.value": "A5E.effects.keys.abilities.dexterityValue",
    "system.abilities.int.check.bonus": "A5E.effects.keys.abilities.intelligenceCheckBonus",
    "system.abilities.int.check.expertiseDice": "A5E.effects.keys.abilities.intelligenceCheckExpertiseDice",
    "system.abilities.int.save.bonus": "A5E.effects.keys.abilities.intelligenceSaveBonus",
    "system.abilities.int.save.expertiseDice": "A5E.effects.keys.abilities.intelligenceSaveExpertiseDice",
    "system.abilities.int.save.proficient": "A5E.effects.keys.abilities.intelligenceSaveProficiency",
    "system.abilities.int.value": "A5E.effects.keys.abilities.intelligenceValue",
    "system.abilities.str.check.bonus": "A5E.effects.keys.abilities.strengthCheckBonus",
    "system.abilities.str.check.expertiseDice": "A5E.effects.keys.abilities.strengthCheckExpertiseDice",
    "system.abilities.str.save.bonus": "A5E.effects.keys.abilities.strengthSaveBonus",
    "system.abilities.str.save.expertiseDice": "A5E.effects.keys.abilities.strengthSaveExpertiseDice",
    "system.abilities.str.save.proficient": "A5E.effects.keys.abilities.strengthSaveProficiency",
    "system.abilities.str.value": "A5E.effects.keys.abilities.strengthValue",
    "system.abilities.wis.check.bonus": "A5E.effects.keys.abilities.wisdomCheckBonus",
    "system.abilities.wis.check.expertiseDice": "A5E.effects.keys.abilities.wisdomCheckExpertiseDice",
    "system.abilities.wis.save.bonus": "A5E.effects.keys.abilities.wisdomSaveBonus",
    "system.abilities.wis.save.expertiseDice": "A5E.effects.keys.abilities.wisdomSaveExpertiseDice",
    "system.abilities.wis.save.proficient": "A5E.effects.keys.abilities.wisdomSaveProficiency",
    "system.abilities.wis.value": "A5E.effects.keys.abilities.wisdomValue",
    "system.attributes.ac.baseFormula": "A5E.effects.keys.armorClass.baseFormula",
    "system.attributes.ac.changes.bonuses.value": "A5E.effects.keys.armorClass.bonuses",
    "system.attributes.ac.value": "A5E.effects.keys.armorClass.value",
    "system.attributes.attunement.current": "A5E.effects.keys.attunementCurrent",
    "system.attributes.attunement.max": "A5E.effects.keys.attunementMax",
    "system.attributes.casterLevel": "A5E.effects.keys.casterLevel",
    "system.attributes.corruption": "A5E.effects.keys.corruption",
    "system.attributes.death.failure": "A5E.effects.keys.deathSaveFailures",
    "system.attributes.death.success": "A5E.effects.keys.deathSaveSuccesses",
    "system.attributes.exertion.current": "A5E.effects.keys.exertionCurrent",
    "system.attributes.exertion.max": "A5E.effects.keys.exertionMax",
    "system.attributes.exertion.recoverOnRest": "A5E.effects.keys.recoverExertionOnShortRest",
    "system.attributes.fatigue": "A5E.effects.keys.fatigue",
    "system.attributes.hitDice.d20.current": "A5E.effects.keys.hitDice.d20Current",
    "system.attributes.hitDice.d20.total": "A5E.effects.keys.hitDice.d20Max",
    "system.attributes.hitDice.d12.current": "A5E.effects.keys.hitDice.d12Current",
    "system.attributes.hitDice.d12.total": "A5E.effects.keys.hitDice.d12Max",
    "system.attributes.hitDice.d10.current": "A5E.effects.keys.hitDice.d10Current",
    "system.attributes.hitDice.d10.total": "A5E.effects.keys.hitDice.d10Max",
    "system.attributes.hitDice.d6.current": "A5E.effects.keys.hitDice.d6Current",
    "system.attributes.hitDice.d6.total": "A5E.effects.keys.hitDice.d6Max",
    "system.attributes.hitDice.d8.current": "A5E.effects.keys.hitDice.d8Current",
    "system.attributes.hitDice.d8.total": "A5E.effects.keys.hitDice.d8Max",
    "system.attributes.hitDice.d4.current": "A5E.effects.keys.hitDice.d4Current",
    "system.attributes.hitDice.d4.total": "A5E.effects.keys.hitDice.d4Max",
    "system.attributes.hp.baseMax": "A5E.effects.keys.hitPoints.baseMax",
    "system.attributes.hp.bonus": "A5E.effects.keys.hitPoints.bonus",
    "system.attributes.hp.value": "A5E.effects.keys.hitPoints.current",
    "system.attributes.hp.max": "A5E.effects.keys.hitPoints.max",
    "system.attributes.hp.temp": "A5E.effects.keys.hitPoints.temp",
    "system.attributes.inebriated": "A5E.effects.keys.inebriated",
    "system.attributes.initiative.ability": "A5E.effects.keys.initiativeAbility",
    "system.attributes.initiative.expertiseDice": "A5E.effects.keys.initiativeExpertiseDice",
    "system.attributes.inspiration": "A5E.effects.keys.inspiration",
    "system.attributes.maneuverDC": "A5E.effects.keys.maneuverDC",
    "system.attributes.movement.burrow.distance": "A5E.effects.keys.movement.burrowDistance",
    "system.attributes.movement.burrow.unit": "A5E.effects.keys.movement.burrowUnit",
    "system.attributes.movement.climb.distance": "A5E.effects.keys.movement.climbDistance",
    "system.attributes.movement.climb.unit": "A5E.effects.keys.movement.climbUnit",
    "system.attributes.movement.fly.distance": "A5E.effects.keys.movement.flyDistance",
    "system.attributes.movement.fly.unit": "A5E.effects.keys.movement.flyUnit",
    "system.attributes.movement.swim.distance": "A5E.effects.keys.movement.swimDistance",
    "system.attributes.movement.swim.unit": "A5E.effects.keys.movement.swimUnit",
    "system.attributes.movement.traits.hover": "A5E.effects.keys.movement.hover",
    "system.attributes.movement.walk.distance": "A5E.effects.keys.movement.walkDistance",
    "system.attributes.movement.walk.unit": "A5E.effects.keys.movement.walkUnit",
    "system.attributes.prof": "A5E.effects.keys.proficiencyBonus",
    "system.attributes.senses.blindsight.distance": "A5E.effects.keys.vision.blindsightDistance",
    "system.attributes.senses.blindsight.unit": "A5E.effects.keys.vision.blindsightUnit",
    "system.attributes.senses.blindsight.otherwiseBlind": "A5E.effects.keys.vision.blindsightOtherwiseBlind",
    "system.attributes.senses.darkvision.distance": "A5E.effects.keys.vision.darkvisionDistance",
    "system.attributes.senses.darkvision.unit": "A5E.effects.keys.vision.darkvisionUnit",
    "system.attributes.senses.tremorsense.distance": "A5E.effects.keys.vision.tremorsenseDistance",
    "system.attributes.senses.tremorsense.unit": "A5E.effects.keys.vision.tremorsenseUnit",
    "system.attributes.senses.truesight.distance": "A5E.effects.keys.vision.truesightDistance",
    "system.attributes.senses.truesight.unit": "A5E.effects.keys.vision.truesightUnit",
    "system.attributes.spellcasting": "A5E.effects.keys.spellcastingAbility",
    "system.attributes.spellDC": "A5E.effects.keys.spellDC",
    "system.attributes.strife": "A5E.effects.keys.strife",
    "system.bonuses.abilities.check": "A5E.effects.keys.bonuses.check",
    "system.bonuses.abilities.save": "A5E.effects.keys.bonuses.save",
    "system.bonuses.abilities.skill": "A5E.effects.keys.bonuses.skill",
    "system.bonuses.maneuverDC": "A5E.effects.keys.bonuses.maneuverDC",
    "system.bonuses.spellDC": "A5E.effects.keys.bonuses.spellDC",
    "system.currency.cp": "A5E.effects.keys.currency.cp",
    "system.currency.ep": "A5E.effects.keys.currency.ep",
    "system.currency.gp": "A5E.effects.keys.currency.gp",
    "system.currency.pp": "A5E.effects.keys.currency.pp",
    "system.currency.sp": "A5E.effects.keys.currency.sp",
    "system.details.creatureTypes": "A5E.effects.keys.details.creatureTypes",
    "system.details.cr": "A5E.effects.keys.details.cr",
    "system.details.elite": "A5E.effects.keys.details.elite",
    "system.details.isSwarm": "A5E.effects.keys.details.isSwarm",
    "system.proficiencies.armor": "A5E.effects.keys.proficiencies.armor",
    "system.proficiencies.languages": "A5E.effects.keys.proficiencies.languages",
    "system.proficiencies.tools": "A5E.effects.keys.proficiencies.tools",
    "system.proficiencies.weapons": "A5E.effects.keys.proficiencies.weapons",
    "system.resources.primary.hideMax": "A5E.effects.keys.resources.primary.hideMax",
    "system.resources.primary.label": "A5E.effects.keys.resources.primary.label",
    "system.resources.primary.max": "A5E.effects.keys.resources.primary.max",
    "system.resources.primary.per": "A5E.effects.keys.resources.primary.per",
    "system.resources.primary.recharge.formula": "A5E.effects.keys.resources.primary.rechargeFormula",
    "system.resources.primary.recharge.threshold": "A5E.effects.keys.resources.primary.rechargeThreshold",
    "system.resources.primary.value": "A5E.effects.keys.resources.primary.value",
    "system.resources.quaternary.hideMax": "A5E.effects.keys.resources.quaternary.hideMax",
    "system.resources.quaternary.label": "A5E.effects.keys.resources.quaternary.label",
    "system.resources.quaternary.max": "A5E.effects.keys.resources.quaternary.max",
    "system.resources.quaternary.per": "A5E.effects.keys.resources.quaternary.per",
    "system.resources.quaternary.recharge.formula": "A5E.effects.keys.resources.quaternary.rechargeFormula",
    "system.resources.quaternary.recharge.threshold": "A5E.effects.keys.resources.quaternary.rechargeThreshold",
    "system.resources.quaternary.value": "A5E.effects.keys.resources.quaternary.value",
    "system.resources.secondary.hideMax": "A5E.effects.keys.resources.secondary.hideMax",
    "system.resources.secondary.label": "A5E.effects.keys.resources.secondary.label",
    "system.resources.secondary.max": "A5E.effects.keys.resources.secondary.max",
    "system.resources.secondary.per": "A5E.effects.keys.resources.secondary.per",
    "system.resources.secondary.recharge.formula": "A5E.effects.keys.resources.secondary.rechargeFormula",
    "system.resources.secondary.recharge.threshold": "A5E.effects.keys.resources.secondary.rechargeThreshold",
    "system.resources.secondary.value": "A5E.effects.keys.resources.secondary.value",
    "system.resources.tertiary.hideMax": "A5E.effects.keys.resources.tertiary.hideMax",
    "system.resources.tertiary.label": "A5E.effects.keys.resources.tertiary.label",
    "system.resources.tertiary.max": "A5E.effects.keys.resources.tertiary.max",
    "system.resources.tertiary.per": "A5E.effects.keys.resources.tertiary.per",
    "system.resources.tertiary.recharge.formula": "A5E.effects.keys.resources.tertiary.rechargeFormula",
    "system.resources.tertiary.recharge.threshold": "A5E.effects.keys.resources.tertiary.rechargeThreshold",
    "system.resources.tertiary.value": "A5E.effects.keys.resources.tertiary.value",
    "system.skills.acr.ability": "A5E.effects.keys.skills.acr.defaultAbility",
    "system.skills.acr.bonuses.check": "A5E.effects.keys.skills.acr.checkBonus",
    "system.skills.acr.bonuses.passive": "A5E.effects.keys.skills.acr.passiveBonus",
    "system.skills.acr.expertiseDice": "A5E.effects.keys.skills.acr.expertiseDice",
    "system.skills.acr.minRoll": "A5E.effects.keys.skills.acr.minRoll",
    "system.skills.acr.proficient": "A5E.effects.keys.skills.acr.proficient",
    "system.skills.acr.specialties": "A5E.effects.keys.skills.acr.specialties",
    "system.skills.acr.value": "A5E.effects.keys.skills.acr.value",
    "system.skills.ani.ability": "A5E.effects.keys.skills.ani.defaultAbility",
    "system.skills.ani.bonuses.check": "A5E.effects.keys.skills.ani.checkBonus",
    "system.skills.ani.bonuses.passive": "A5E.effects.keys.skills.ani.passiveBonus",
    "system.skills.ani.expertiseDice": "A5E.effects.keys.skills.ani.expertiseDice",
    "system.skills.ani.minRoll": "A5E.effects.keys.skills.ani.minRoll",
    "system.skills.ani.proficient": "A5E.effects.keys.skills.ani.proficient",
    "system.skills.ani.specialties": "A5E.effects.keys.skills.ani.specialties",
    "system.skills.ani.value": "A5E.effects.keys.skills.ani.value",
    "system.skills.arc.ability": "A5E.effects.keys.skills.arc.defaultAbility",
    "system.skills.arc.bonuses.check": "A5E.effects.keys.skills.arc.checkBonus",
    "system.skills.arc.bonuses.passive": "A5E.effects.keys.skills.arc.passiveBonus",
    "system.skills.arc.expertiseDice": "A5E.effects.keys.skills.arc.expertiseDice",
    "system.skills.arc.minRoll": "A5E.effects.keys.skills.arc.minRoll",
    "system.skills.arc.proficient": "A5E.effects.keys.skills.arc.proficient",
    "system.skills.arc.specialties": "A5E.effects.keys.skills.arc.specialties",
    "system.skills.arc.value": "A5E.effects.keys.skills.arc.value",
    "system.skills.ath.ability": "A5E.effects.keys.skills.ath.defaultAbility",
    "system.skills.ath.bonuses.check": "A5E.effects.keys.skills.ath.checkBonus",
    "system.skills.ath.bonuses.passive": "A5E.effects.keys.skills.ath.passiveBonus",
    "system.skills.ath.expertiseDice": "A5E.effects.keys.skills.ath.expertiseDice",
    "system.skills.ath.minRoll": "A5E.effects.keys.skills.ath.minRoll",
    "system.skills.ath.proficient": "A5E.effects.keys.skills.ath.proficient",
    "system.skills.ath.specialties": "A5E.effects.keys.skills.ath.specialties",
    "system.skills.ath.value": "A5E.effects.keys.skills.ath.value",
    "system.skills.cul.ability": "A5E.effects.keys.skills.cul.defaultAbility",
    "system.skills.cul.bonuses.check": "A5E.effects.keys.skills.cul.checkBonus",
    "system.skills.cul.bonuses.passive": "A5E.effects.keys.skills.cul.passiveBonus",
    "system.skills.cul.expertiseDice": "A5E.effects.keys.skills.cul.expertiseDice",
    "system.skills.cul.minRoll": "A5E.effects.keys.skills.cul.minRoll",
    "system.skills.cul.proficient": "A5E.effects.keys.skills.cul.proficient",
    "system.skills.cul.specialties": "A5E.effects.keys.skills.cul.specialties",
    "system.skills.cul.value": "A5E.effects.keys.skills.cul.value",
    "system.skills.dec.ability": "A5E.effects.keys.skills.dec.defaultAbility",
    "system.skills.dec.bonuses.check": "A5E.effects.keys.skills.dec.checkBonus",
    "system.skills.dec.bonuses.passive": "A5E.effects.keys.skills.dec.passiveBonus",
    "system.skills.dec.expertiseDice": "A5E.effects.keys.skills.dec.expertiseDice",
    "system.skills.dec.minRoll": "A5E.effects.keys.skills.dec.minRoll",
    "system.skills.dec.proficient": "A5E.effects.keys.skills.dec.proficient",
    "system.skills.dec.specialties": "A5E.effects.keys.skills.dec.specialties",
    "system.skills.dec.value": "A5E.effects.keys.skills.dec.value",
    "system.skills.eng.ability": "A5E.effects.keys.skills.eng.defaultAbility",
    "system.skills.eng.bonuses.check": "A5E.effects.keys.skills.eng.checkBonus",
    "system.skills.eng.bonuses.passive": "A5E.effects.keys.skills.eng.passiveBonus",
    "system.skills.eng.expertiseDice": "A5E.effects.keys.skills.eng.expertiseDice",
    "system.skills.eng.minRoll": "A5E.effects.keys.skills.eng.minRoll",
    "system.skills.eng.proficient": "A5E.effects.keys.skills.eng.proficient",
    "system.skills.eng.specialties": "A5E.effects.keys.skills.eng.specialties",
    "system.skills.eng.value": "A5E.effects.keys.skills.eng.value",
    "system.skills.his.ability": "A5E.effects.keys.skills.his.defaultAbility",
    "system.skills.his.bonuses.check": "A5E.effects.keys.skills.his.checkBonus",
    "system.skills.his.bonuses.passive": "A5E.effects.keys.skills.his.passiveBonus",
    "system.skills.his.expertiseDice": "A5E.effects.keys.skills.his.expertiseDice",
    "system.skills.his.minRoll": "A5E.effects.keys.skills.his.minRoll",
    "system.skills.his.proficient": "A5E.effects.keys.skills.his.proficient",
    "system.skills.his.specialties": "A5E.effects.keys.skills.his.specialties",
    "system.skills.his.value": "A5E.effects.keys.skills.his.value",
    "system.skills.ins.ability": "A5E.effects.keys.skills.ins.defaultAbility",
    "system.skills.ins.bonuses.check": "A5E.effects.keys.skills.ins.checkBonus",
    "system.skills.ins.bonuses.passive": "A5E.effects.keys.skills.ins.passiveBonus",
    "system.skills.ins.expertiseDice": "A5E.effects.keys.skills.ins.expertiseDice",
    "system.skills.ins.minRoll": "A5E.effects.keys.skills.ins.minRoll",
    "system.skills.ins.proficient": "A5E.effects.keys.skills.ins.proficient",
    "system.skills.ins.specialties": "A5E.effects.keys.skills.ins.specialties",
    "system.skills.ins.value": "A5E.effects.keys.skills.ins.value",
    "system.skills.itm.ability": "A5E.effects.keys.skills.itm.defaultAbility",
    "system.skills.itm.bonuses.check": "A5E.effects.keys.skills.itm.checkBonus",
    "system.skills.itm.bonuses.passive": "A5E.effects.keys.skills.itm.passiveBonus",
    "system.skills.itm.expertiseDice": "A5E.effects.keys.skills.itm.expertiseDice",
    "system.skills.itm.minRoll": "A5E.effects.keys.skills.itm.minRoll",
    "system.skills.itm.proficient": "A5E.effects.keys.skills.itm.proficient",
    "system.skills.itm.specialties": "A5E.effects.keys.skills.itm.specialties",
    "system.skills.itm.value": "A5E.effects.keys.skills.itm.value",
    "system.skills.inv.ability": "A5E.effects.keys.skills.inv.defaultAbility",
    "system.skills.inv.bonuses.check": "A5E.effects.keys.skills.inv.checkBonus",
    "system.skills.inv.bonuses.passive": "A5E.effects.keys.skills.inv.passiveBonus",
    "system.skills.inv.expertiseDice": "A5E.effects.keys.skills.inv.expertiseDice",
    "system.skills.inv.minRoll": "A5E.effects.keys.skills.inv.minRoll",
    "system.skills.inv.proficient": "A5E.effects.keys.skills.inv.proficient",
    "system.skills.inv.specialties": "A5E.effects.keys.skills.inv.specialties",
    "system.skills.inv.value": "A5E.effects.keys.skills.inv.value",
    "system.skills.med.ability": "A5E.effects.keys.skills.med.defaultAbility",
    "system.skills.med.bonuses.check": "A5E.effects.keys.skills.med.checkBonus",
    "system.skills.med.bonuses.passive": "A5E.effects.keys.skills.med.passiveBonus",
    "system.skills.med.expertiseDice": "A5E.effects.keys.skills.med.expertiseDice",
    "system.skills.med.minRoll": "A5E.effects.keys.skills.med.minRoll",
    "system.skills.med.proficient": "A5E.effects.keys.skills.med.proficient",
    "system.skills.med.specialties": "A5E.effects.keys.skills.med.specialties",
    "system.skills.med.value": "A5E.effects.keys.skills.med.value",
    "system.skills.nat.ability": "A5E.effects.keys.skills.nat.defaultAbility",
    "system.skills.nat.bonuses.check": "A5E.effects.keys.skills.nat.checkBonus",
    "system.skills.nat.bonuses.passive": "A5E.effects.keys.skills.nat.passiveBonus",
    "system.skills.nat.expertiseDice": "A5E.effects.keys.skills.nat.expertiseDice",
    "system.skills.nat.minRoll": "A5E.effects.keys.skills.nat.minRoll",
    "system.skills.nat.proficient": "A5E.effects.keys.skills.nat.proficient",
    "system.skills.nat.specialties": "A5E.effects.keys.skills.nat.specialties",
    "system.skills.nat.value": "A5E.effects.keys.skills.nat.value",
    "system.skills.prc.ability": "A5E.effects.keys.skills.prc.defaultAbility",
    "system.skills.prc.bonuses.check": "A5E.effects.keys.skills.prc.checkBonus",
    "system.skills.prc.bonuses.passive": "A5E.effects.keys.skills.prc.passiveBonus",
    "system.skills.prc.expertiseDice": "A5E.effects.keys.skills.prc.expertiseDice",
    "system.skills.prc.minRoll": "A5E.effects.keys.skills.prc.minRoll",
    "system.skills.prc.proficient": "A5E.effects.keys.skills.prc.proficient",
    "system.skills.prc.specialties": "A5E.effects.keys.skills.prc.specialties",
    "system.skills.prc.value": "A5E.effects.keys.skills.prc.value",
    "system.skills.prf.ability": "A5E.effects.keys.skills.prf.defaultAbility",
    "system.skills.prf.bonuses.check": "A5E.effects.keys.skills.prf.checkBonus",
    "system.skills.prf.bonuses.passive": "A5E.effects.keys.skills.prf.passiveBonus",
    "system.skills.prf.expertiseDice": "A5E.effects.keys.skills.prf.expertiseDice",
    "system.skills.prf.minRoll": "A5E.effects.keys.skills.prf.minRoll",
    "system.skills.prf.proficient": "A5E.effects.keys.skills.prf.proficient",
    "system.skills.prf.specialties": "A5E.effects.keys.skills.prf.specialties",
    "system.skills.prf.value": "A5E.effects.keys.skills.prf.value",
    "system.skills.per.ability": "A5E.effects.keys.skills.per.defaultAbility",
    "system.skills.per.bonuses.check": "A5E.effects.keys.skills.per.checkBonus",
    "system.skills.per.bonuses.passive": "A5E.effects.keys.skills.per.passiveBonus",
    "system.skills.per.expertiseDice": "A5E.effects.keys.skills.per.expertiseDice",
    "system.skills.per.minRoll": "A5E.effects.keys.skills.per.minRoll",
    "system.skills.per.proficient": "A5E.effects.keys.skills.per.proficient",
    "system.skills.per.specialties": "A5E.effects.keys.skills.per.specialties",
    "system.skills.per.value": "A5E.effects.keys.skills.per.value",
    "system.skills.rel.ability": "A5E.effects.keys.skills.rel.defaultAbility",
    "system.skills.rel.bonuses.check": "A5E.effects.keys.skills.rel.checkBonus",
    "system.skills.rel.bonuses.passive": "A5E.effects.keys.skills.rel.passiveBonus",
    "system.skills.rel.expertiseDice": "A5E.effects.keys.skills.rel.expertiseDice",
    "system.skills.rel.minRoll": "A5E.effects.keys.skills.rel.minRoll",
    "system.skills.rel.proficient": "A5E.effects.keys.skills.rel.proficient",
    "system.skills.rel.specialties": "A5E.effects.keys.skills.rel.specialties",
    "system.skills.rel.value": "A5E.effects.keys.skills.rel.value",
    "system.skills.slt.ability": "A5E.effects.keys.skills.slt.defaultAbility",
    "system.skills.slt.bonuses.check": "A5E.effects.keys.skills.slt.checkBonus",
    "system.skills.slt.bonuses.passive": "A5E.effects.keys.skills.slt.passiveBonus",
    "system.skills.slt.expertiseDice": "A5E.effects.keys.skills.slt.expertiseDice",
    "system.skills.slt.minRoll": "A5E.effects.keys.skills.slt.minRoll",
    "system.skills.slt.proficient": "A5E.effects.keys.skills.slt.proficient",
    "system.skills.slt.specialties": "A5E.effects.keys.skills.slt.specialties",
    "system.skills.slt.value": "A5E.effects.keys.skills.slt.value",
    "system.skills.ste.ability": "A5E.effects.keys.skills.ste.defaultAbility",
    "system.skills.ste.bonuses.check": "A5E.effects.keys.skills.ste.checkBonus",
    "system.skills.ste.bonuses.passive": "A5E.effects.keys.skills.ste.passiveBonus",
    "system.skills.ste.expertiseDice": "A5E.effects.keys.skills.ste.expertiseDice",
    "system.skills.ste.minRoll": "A5E.effects.keys.skills.ste.minRoll",
    "system.skills.ste.proficient": "A5E.effects.keys.skills.ste.proficient",
    "system.skills.ste.specialties": "A5E.effects.keys.skills.ste.specialties",
    "system.skills.ste.value": "A5E.effects.keys.skills.ste.value",
    "system.skills.sur.ability": "A5E.effects.keys.skills.sur.defaultAbility",
    "system.skills.sur.bonuses.check": "A5E.effects.keys.skills.sur.checkBonus",
    "system.skills.sur.bonuses.passive": "A5E.effects.keys.skills.sur.passiveBonus",
    "system.skills.sur.expertiseDice": "A5E.effects.keys.skills.sur.expertiseDice",
    "system.skills.sur.minRoll": "A5E.effects.keys.skills.sur.minRoll",
    "system.skills.sur.proficient": "A5E.effects.keys.skills.sur.proficient",
    "system.skills.sur.specialties": "A5E.effects.keys.skills.sur.specialties",
    "system.skills.sur.value": "A5E.effects.keys.skills.sur.value",
    "system.spellResources.points.current": "A5E.effects.keys.spellResources.currentSpellPoints",
    "system.spellResources.points.max": "A5E.effects.keys.spellResources.maxSpellPoints",
    "system.spellResources.slots.1.current": "A5E.effects.keys.spellResources.currentLevel1Slots",
    "system.spellResources.slots.1.max": "A5E.effects.keys.spellResources.maxLevel1Slots",
    "system.spellResources.slots.2.current": "A5E.effects.keys.spellResources.currentLevel2Slots",
    "system.spellResources.slots.2.max": "A5E.effects.keys.spellResources.maxLevel2Slots",
    "system.spellResources.slots.3.current": "A5E.effects.keys.spellResources.currentLevel3Slots",
    "system.spellResources.slots.3.max": "A5E.effects.keys.spellResources.maxLevel3Slots",
    "system.spellResources.slots.4.current": "A5E.effects.keys.spellResources.currentLevel4Slots",
    "system.spellResources.slots.4.max": "A5E.effects.keys.spellResources.maxLevel4Slots",
    "system.spellResources.slots.5.current": "A5E.effects.keys.spellResources.currentLevel5Slots",
    "system.spellResources.slots.5.max": "A5E.effects.keys.spellResources.maxLevel5Slots",
    "system.spellResources.slots.6.current": "A5E.effects.keys.spellResources.currentLevel6Slots",
    "system.spellResources.slots.6.max": "A5E.effects.keys.spellResources.maxLevel6Slots",
    "system.spellResources.slots.7.current": "A5E.effects.keys.spellResources.currentLevel7Slots",
    "system.spellResources.slots.7.max": "A5E.effects.keys.spellResources.maxLevel7Slots",
    "system.spellResources.slots.8.current": "A5E.effects.keys.spellResources.currentLevel8Slots",
    "system.spellResources.slots.8.max": "A5E.effects.keys.spellResources.maxLevel8Slots",
    "system.spellResources.slots.9.current": "A5E.effects.keys.spellResources.currentLevel9Slots",
    "system.spellResources.slots.9.max": "A5E.effects.keys.spellResources.maxLevel9Slots",
    "system.supply": "A5E.effects.keys.supply",
    "system.traits.conditionImmunities": "A5E.effects.keys.traits.conditionImmunities",
    "system.traits.damageImmunities": "A5E.effects.keys.traits.damageImmunities",
    "system.traits.damageResistances": "A5E.effects.keys.traits.damageResistances",
    "system.traits.damageVulnerabilities": "A5E.effects.keys.traits.damageVulnerabilities",
    "system.traits.size": "A5E.effects.keys.traits.size",
    "@token.light.alpha": "A5E.effects.keys.token.light.alpha",
    "@token.light.angle": "A5E.effects.keys.token.light.angle",
    "@token.light.animation.intensity": "A5E.effects.keys.token.light.animation.intensity",
    "@token.light.animation.reverse": "A5E.effects.keys.token.light.animation.reverse",
    "@token.light.animation.speed": "A5E.effects.keys.token.light.animation.speed",
    "@token.light.animation.type": "A5E.effects.keys.token.light.animation.type",
    "@token.light.attenuation": "A5E.effects.keys.token.light.attenuation",
    "@token.light.bright": "A5E.effects.keys.token.light.bright",
    "@token.light.color": "A5E.effects.keys.token.light.color",
    "@token.light.coloration": "A5E.effects.keys.token.light.coloration",
    "@token.light.contrast": "A5E.effects.keys.token.light.contrast",
    "@token.light.darkness.min": "A5E.effects.keys.token.light.darkness.min",
    "@token.light.darkness.max": "A5E.effects.keys.token.light.darkness.max",
    "@token.light.dim": "A5E.effects.keys.token.light.dim",
    "@token.light.luminosity": "A5E.effects.keys.token.light.luminosity",
    "@token.light.saturation": "A5E.effects.keys.token.light.saturation",
    "@token.light.shadows": "A5E.effects.keys.token.light.shadows",
    "@token.light.negative": "A5E.effects.keys.token.light.negative",
    "@token.texture.src": "A5E.effects.keys.token.texture.src",
    "@token.texture.scaleX": "A5E.effects.keys.token.texture.scaleX",
    "@token.texture.scaleY": "A5E.effects.keys.token.texture.scaleY",
    "@token.width": "A5E.effects.keys.token.width",
    "@token.height": "A5E.effects.keys.token.height"
  } };
}
u(Gse, "registerEffectLocalizationConfig");
function zse(i) {
  const e = {};
  Object.entries(i.abilityActivationTypes).forEach(([t, s]) => {
    e[t] = {
      label: s,
      key: "system.activation.type",
      type: "action",
      truthValue: "or"
    };
  }), i.filters = {
    features: {
      activationCost: {
        label: "A5E.FilterLabelActivationCost",
        filters: { ...e }
      }
    },
    maneuvers: {
      activationCost: {
        label: "A5E.FilterLabelActivationCost",
        filters: { ...e }
      },
      traditions: {
        label: "A5E.FilterLabelManueverTraditions",
        filters: {}
      },
      miscellaneous: {
        label: "A5E.FilterLabelMiscellaneous",
        filters: {
          concentration: {
            label: "A5E.ConditionConcentration",
            key: "system.concentration",
            type: "boolean"
          },
          stance: {
            label: "Stance",
            key: "system.isStance",
            type: "boolean"
          }
        }
      }
    },
    objects: {
      activationCost: {
        label: "A5E.FilterLabelActivationCost",
        filters: { ...e }
      },
      rarity: {
        label: "A5E.FilterLabelRarity",
        filters: {}
      },
      miscellaneous: {
        label: "A5E.FilterLabelMiscellaneous",
        filters: {
          attuned: { label: "A5E.Attuned", key: "system.attuned", type: "boolean" },
          bulky: { label: "A5E.ItemBulky", key: "system.bulky", type: "boolean" },
          2: { label: "A5E.ItemEquipped", key: "system.equippedState", type: "value" },
          // For Equipped State
          plotItem: { label: "A5E.PlotItem", key: "system.plotItem", type: "boolean" },
          requiresAttunement: {
            label: "A5E.AttunementRequired",
            key: "system.requiredAttunement",
            type: "boolean"
          }
        }
      }
    },
    spells: {
      activationCost: {
        label: "A5E.FilterLabelActivationCost",
        filters: { ...e }
      },
      components: {
        label: "A5E.FilterLabelSpellComponents",
        filters: {
          material: {
            label: "A5E.SpellComponentMaterial",
            key: "system.components.material",
            type: "boolean"
          },
          seen: {
            label: "A5E.SpellComponentSeen",
            key: "system.components.seen",
            type: "boolean"
          },
          vocalized: {
            label: "A5E.SpellComponentVocalized",
            key: "system.components.vocalized",
            type: "boolean"
          }
        }
      },
      miscellaneous: {
        label: "A5E.FilterLabelMiscellaneous",
        filters: {
          concentration: {
            label: "A5E.ConditionConcentration",
            key: "system.concentration",
            type: "boolean"
          },
          ritual: {
            label: "A5E.SpellRitual",
            key: "system.ritual",
            type: "boolean"
          },
          prepared: {
            label: "A5E.SpellPrepared",
            key: "system.prepared",
            type: "boolean"
          }
        }
      },
      primarySpellSchools: {
        label: "A5E.FilterLabelPrimarySpellSchools",
        filters: {}
      }
    }
  }, Object.entries(i.maneuverTraditions).forEach(([t, s]) => {
    i.filters.maneuvers.traditions.filters[t] = {
      label: s,
      key: "system.tradition",
      type: "value",
      truthValue: "or"
    };
  }), Object.entries(i.itemRarity).forEach(([t, s]) => {
    i.filters.objects.rarity.filters[t] = {
      label: s,
      key: "system.rarity",
      type: "value"
    };
  }), Object.entries(i.spellSchools.primary).forEach(([t, s]) => {
    i.filters.spells.primarySpellSchools.filters[t] = {
      label: s,
      key: "system.schools.primary",
      type: "value",
      truthValue: "or"
    };
  });
}
u(zse, "registerFilterConfig");
function Hse() {
  return {
    itemGrants: {
      ability: "A5E.grants.headings.ability",
      attack: "A5E.grants.headings.attack",
      damage: "A5E.grants.headings.damage",
      exertion: "A5E.grants.headings.exertion",
      expertiseDice: "A5E.grants.headings.expertiseDice",
      feature: "A5E.grants.headings.feature",
      healing: "A5E.grants.headings.healing",
      hitPoint: "A5E.grants.headings.hitPoint",
      item: "A5E.grants.headings.item",
      initiative: "A5E.grants.headings.initiative",
      movement: "A5E.grants.headings.movement",
      proficiency: "A5E.grants.headings.proficiency",
      rollOverride: "A5E.grants.headings.rollOverride",
      senses: "A5E.grants.headings.senses",
      skill: "A5E.grants.headings.skill",
      skillSpecialty: "A5E.grants.headings.skillSpecialty",
      trait: "A5E.grants.headings.trait"
    }
  };
}
u(Hse, "registerGrantsConfig");
function Use() {
  return {
    moduleIncompatibilities: {
      "a5e-aces-necromancy-vol-1": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-arcane-sniper": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-concentrator": {
        reason: "The A5e concentrator module is no longer working correctly, and its functionality will soon be part of the core system.",
        priority: "medium"
      },
      "a5e-confidence-mage": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-dnd5e-srd-content": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-extra-credits": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-fancy-compendia": {
        reason: "The updated compendium sheets are now included in the A5e system without any need for a module and include several new features. We highly recommend you disable this module to take full advantage of those new features.",
        priority: "medium"
      },
      "a5e-fiery-justice": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-field-engineer": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-moar-complete": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-mortalist": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-motif-classes": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-multiclassers-manual": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-secrets-of-the-selkies": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-sinuous-sentinels": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-spells-from-the-forgotten-vault": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-spiritualist": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-thematic-toolkit-arcane-avenger": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-thematic-toolkit-burning-gloom": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-thematic-toolkit-carry-the-darkness": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-thematic-toolkit-cultist": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-thematic-toolkit-hazardous-knowledge": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-thematic-toolkit-itinerant": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-thematic-toolkit-judge-jury-and-executioner": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-thematic-toolkit-master-of-ceremonies": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-thematic-toolkit-scrapper": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-thematic-toolkit-storyteller": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-thematic-toolkit-thunder-of-war": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-thematic-toolkit-venomous-shadow": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-toil-and-trouble": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      "a5e-venture-forth": {
        reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
        priority: "low"
      },
      dae: {
        reason: "All of DAE's features are already part of the A5e system's Active Effects implementation. Using DAE will give you a worse experience than having it turned off.",
        priority: "high"
      },
      "gamemaster-title-editor": {
        reason: "The system already provides settings to configure a GM's title, so this module is unnecessary in the A5e system. It may also conflict with the system's built-in configuration options.",
        priority: "medium"
      },
      "party-overview": {
        reason: "The system already includes an interface to display summary statistics for an adventuring party that provides far more functionality than the Party Overview module.",
        priority: "low"
      }
    }
  };
}
u(Use, "registerModuleIncompatibilities");
const Vse = [
  "DICE_ROLL_MODES",
  "abilities",
  "abilityAbbreviations",
  "abilityActivationTypes",
  "abilityActivationTypesPlural",
  "actionOptions",
  "actorSizes",
  "ammunitionProperties",
  "areaTypes",
  "armor",
  "armorModes",
  "armorProperties",
  "attackTypes",
  "characterClasses",
  "classSpellLists",
  "classes",
  "classes5e",
  "conditions",
  "creatureTypes",
  "damageTypes",
  "distanceAbbreviations",
  "distanceUnits",
  "effectsKeyLocalizations",
  "featureTypes",
  "healingTypes",
  "itemRarity",
  "itemTypes",
  "languages",
  "maneuverDegrees",
  "maneuverTraditions",
  "materialProperties",
  "movement",
  "movementAbbreviations",
  "objectTypes",
  "objectTypesPlural",
  "rangeDescriptors",
  "resourceRecoveryOptions",
  "rollModes",
  "saveDCOptions",
  "senses",
  "shieldProperties",
  "shieldTypes",
  "skills",
  "skillSpecialties.acr",
  "skillSpecialties.ani",
  "skillSpecialties.arc",
  "skillSpecialties.ath",
  "skillSpecialties.cul",
  "skillSpecialties.dec",
  "skillSpecialties.eng",
  "skillSpecialties.his",
  "skillSpecialties.ins",
  "skillSpecialties.itm",
  "skillSpecialties.inv",
  "skillSpecialties.med",
  "skillSpecialties.nat",
  "skillSpecialties.prc",
  "skillSpecialties.prf",
  "skillSpecialties.per",
  "skillSpecialties.rel",
  "skillSpecialties.slt",
  "skillSpecialties.ste",
  "skillSpecialties.sur",
  "spellComponents",
  "spellComponentAbbreviations",
  "spellConsumerModes",
  "spellLevels",
  "spellSchools.primary",
  "spellSchools.secondary",
  "targetTypes",
  "targetTypesPlural",
  "timePeriods",
  "timePeriodsPlural",
  "visionUnits",
  "tools.artisansTools",
  "tools.gamingSets",
  "tools.musicalInstruments",
  "tools.miscellaneous",
  "tools.vehicles",
  "toolsPlural.artisansTools",
  "toolsPlural.gamingSets",
  "toolsPlural.musicalInstruments",
  "toolsPlural.miscellaneous",
  "toolsPlural.vehicles",
  "weapons.simple",
  "weapons.martial",
  "weapons.rare",
  "weaponsPlural.simple",
  "weaponsPlural.martial",
  "weaponsPlural.rare",
  "weaponProperties"
];
function Wse() {
  return {
    premiumContent: {
      acesAdventuringGuides: {
        name: "Ace's Adventuring Guides",
        releases: [
          {
            title: "Ace's Guide to Necromancy",
            url: "https://bit.ly/3TWSVkh"
          }
        ]
      },
      anthonyAlipio: {
        name: "Anthony Alipio",
        releases: [
          {
            title: "The Sugar Crumb Fairy",
            url: "https://bit.ly/3Zs8nI4"
          },
          {
            title: "Til Undeath Do Us Part",
            url: "https://bit.ly/3SBRDwn"
          }
        ]
      },
      dmSarah: {
        name: "DM Sarah",
        releases: [
          {
            title: "Stranger Sights: Challenges for 5e and Advanced 5e",
            url: "https://bit.ly/3zR5Uf0"
          }
        ]
      },
      enPublishing: {
        name: "EN Publishing",
        releases: [
          {
            title: "Memories of Holdenshire",
            url: "https://bit.ly/3A8wlgq"
          }
        ]
      },
      joshGentry: {
        name: "Josh Gentry",
        releases: [
          {
            title: "Crests of Destiny",
            url: "https://bit.ly/3T1BE7O"
          },
          {
            title: "Dose of Dungeonpunk - The Talos Heritage",
            url: "https://bit.ly/3fe9CaB"
          },
          {
            title: "Slice of Psionics - The Elan Heritage",
            url: "https://bit.ly/3CDh3R1"
          }
        ]
      },
      loottheboss: {
        name: "LootTheBoss",
        releases: [
          {
            title: "Advanced Artificers",
            url: "https://www.drivethrurpg.com/en/product/459022/advanced-artificers?affiliate_id=1388381"
          }
        ]
      },
      plantWitchPress: {
        name: "Plant Witch Press",
        releases: [
          {
            title: "Toil and Trouble",
            url: "https://bit.ly/3HE10VQ"
          },
          {
            title: "Hearth & Home",
            url: "https://www.drivethrurpg.com/en/product/488835/Hearth--Home-Cozy-Cottage-Origins?affiliate_id=1388381"
          }
        ]
      },
      purpleMartinGames: {
        name: "Purple Martin Games",
        releases: [
          {
            title: "MoAR: Battlemages",
            url: "https://bit.ly/41HQd4G"
          },
          {
            title: "MoAR: Complete",
            url: "https://bit.ly/4b7Fsyi"
          },
          {
            title: "MoAR: Elements",
            url: "https://bit.ly/3XIvKfE"
          },
          {
            title: "MoAR: Intrigue",
            url: "https://bit.ly/3uIMyFQ"
          },
          {
            title: "MoAR: Light & Dark",
            url: "https://bit.ly/3T9pQ3s"
          },
          {
            title: "MoAR: Wilderness",
            url: "https://bit.ly/3xisyKN"
          },
          {
            title: "Thematic Toolkit: Folk of the Court",
            url: "https://bit.ly/48SVn1R"
          },
          {
            title: "Thematic Toolkit: Itinerant",
            url: "https://bit.ly/3Sidh7p"
          }
        ]
      },
      roguesCollection: {
        name: "The Rogue's Collection",
        releases: [
          {
            title: "Eclipsa Records - Armaments: Confidential",
            url: "https://bit.ly/3Om8W1y"
          },
          {
            title: "Legends of Strength",
            url: "https://bit.ly/3UnXINY"
          },
          {
            title: "Primal Sorcery",
            url: "https://bit.ly/3SBPS24"
          }
        ]
      },
      rollThemBones: {
        name: "Roll them Bones",
        releases: [
          {
            title: "Extra Credit and Deeper Mysteries",
            url: "https://bit.ly/47UnJaV"
          }
        ]
      },
      speaksAndSpells: {
        name: "Speaks & Spells Publishing",
        releases: [
          {
            title: "The Arcane Exterminator: An Artificer Archetype and Magic Item Compendium",
            url: "https://bit.ly/49fTzA3"
          }
        ]
      },
      steampunkette: {
        name: "Steampunkette",
        releases: [
          {
            title: "Paranormal Power",
            url: "https://bit.ly/49bS1XH"
          }
        ]
      },
      wolfworksPress: {
        name: "Wolfworks Press",
        releases: [
          {
            title: "Handbook of Heritages",
            url: "https://bit.ly/3PPfarX"
          }
        ]
      }
    },
    products: {
      acesAdventuringGuideToNecromancy: {
        abbreviation: "AAGtN",
        affiliate: !0,
        publisher: "acesAdventuringGuides",
        systems: ["a5e"],
        title: "Ace's Adventuring Guide to Necromancy",
        url: "https://bit.ly/4bez8oK"
      },
      acesAdventuringGuideToNecromancySupplement: {
        abbreviation: "AAGtN:S",
        affiliate: !0,
        publisher: "acesAdventuringGuides",
        systems: ["a5e"],
        title: "Ace's Adventuring Guide to Necromancy: A Supplement",
        url: "https://bit.ly/3HQ17gV"
      },
      advancedArtificers: {
        abbreviation: "AA",
        affiliate: !0,
        publisher: "loottheboss",
        systems: ["a5e"],
        title: "Advanced Artificers",
        url: "https://www.drivethrurpg.com/en/product/459022/advanced-artificers?affiliate_id=1388381"
      },
      adventurersGuide: {
        abbreviation: "AG",
        affiliate: !0,
        publisher: "enPublishing",
        systems: ["a5e"],
        title: "Level Up: Adventurer's Guide",
        url: "https://bit.ly/3w15Iua"
      },
      adventuresInZeitgeist: {
        abbreviation: "AiZ",
        affiliate: !0,
        publisher: "enPublishing",
        systems: ["a5e"],
        title: "Level Up: Adventures in ZEITGEIST",
        url: "https://bit.ly/3u99LnT"
      },
      agentOfTheMagus: {
        abbreviation: "AotM",
        affiliate: !1,
        publisher: "ravine",
        systems: ["a5e"],
        title: "Agent of the Magus",
        url: "https://ravine.itch.io/a5e-subclass01-magus"
      },
      arcaneSniper: {
        abbreviation: "AS",
        affiliate: !0,
        publisher: "purpleMartinGames",
        systems: ["a5e"],
        title: "Arcane Sniper",
        url: "https://bit.ly/3I3t0SW"
      },
      confidenceMage: {
        abbreviation: "ConfMage",
        affiliate: !0,
        publisher: "purpleMartinGames",
        systems: ["a5e"],
        title: "Confidence Mage",
        url: "https://preview.drivethrurpg.com/en/product/403897/confidence-mage-a5e?affiliate_id=1388381"
      },
      deepMagic1: {
        abbreviation: "DM Vol.1",
        affiliate: !0,
        publisher: "koboldPress",
        systems: ["5e"],
        title: "Deep Magic Volume 1",
        url: "https://bit.ly/3TfgMvP"
      },
      deepMagic2: {
        abbreviation: "DM Vol.2",
        affiliate: !1,
        publisher: "koboldPress",
        systems: ["5e"],
        title: "Deep Magic Volume 2",
        url: "https://bit.ly/3v2z4Zf"
      },
      doseOfDungeonpunk: {
        abbreviation: "DOD:TH",
        affiliate: !0,
        publisher: "joshGentry",
        systems: ["a5e"],
        title: "Dose of Dungeonpunk - The Talos Heritage",
        url: "https://bit.ly/4bo5FsM"
      },
      dungeonDelversGuide: {
        abbreviation: "DDG",
        affiliate: !0,
        publisher: "enPublishing",
        systems: ["a5e"],
        title: "Level Up: Dungeon Delver's Guide",
        url: "https://bit.ly/4bLImsK"
      },
      extraCreditAndDeeperMysteries: {
        abbreviation: "ECaDM",
        affiliate: !0,
        publisher: "rollThemBones",
        systems: ["a5e"],
        title: "Extra Credit and Deeper Mysteries",
        url: "https://bit.ly/47UnJaV"
      },
      fieldEngineer: {
        abbreviation: "FE",
        affiliate: !0,
        publisher: "purpleMartinGames",
        systems: ["a5e"],
        title: "Field Engineer",
        url: "https://bit.ly/49D4FPF"
      },
      fieryJustice: {
        abbreviation: "FJ",
        affiliate: !0,
        publisher: "purpleMartinGames",
        systems: ["a5e"],
        title: "Fiery Justice",
        url: "https://preview.drivethrurpg.com/en/product/409471/fiery-justice-a5e?affiliate_id=1388381"
      },
      gpg0: {
        abbreviation: "GPG #0",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #0",
        url: "https://bit.ly/3HMhZW5"
      },
      gpg1: {
        abbreviation: "GPG #1",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #1",
        url: "https://bit.ly/48YR8BZ"
      },
      gpg2: {
        abbreviation: "GPG #2",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #2",
        url: "https://bit.ly/49hj181"
      },
      gpg3: {
        abbreviation: "GPG #3",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #3",
        url: "https://bit.ly/49elHTS"
      },
      gpg4: {
        abbreviation: "GPG #4",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #4",
        url: "https://bit.ly/4bo5Vbe"
      },
      gpg5: {
        abbreviation: "GPG #5",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #5",
        url: "https://bit.ly/3uuw1sx"
      },
      gpg6: {
        abbreviation: "GPG #6",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #6",
        url: "https://bit.ly/3SquHyB"
      },
      gpg7: {
        abbreviation: "GPG #7",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #7",
        url: "https://bit.ly/4bEHc2h"
      },
      gpg8: {
        abbreviation: "GPG #8",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #8",
        url: "https://bit.ly/3SNRHrB"
      },
      gpg9: {
        abbreviation: "GPG #9",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #9",
        url: "https://bit.ly/3OvH2k2"
      },
      gpg10: {
        abbreviation: "GPG #10",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #10",
        url: "https://bit.ly/42JSXR0"
      },
      gpg11: {
        abbreviation: "GPG #11",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #11",
        url: "https://bit.ly/3OsnMnu"
      },
      gpg12: {
        abbreviation: "GPG #12",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #12",
        url: "https://bit.ly/3uI2SKn"
      },
      gpg13: {
        abbreviation: "GPG #13",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #13",
        url: "https://bit.ly/3T1ABHU"
      },
      gpg14: {
        abbreviation: "GPG #14",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #14",
        url: "https://bit.ly/49kSzLo"
      },
      gpg15: {
        abbreviation: "GPG #15",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #15",
        url: "https://bit.ly/49kSzLo"
      },
      gpg16: {
        abbreviation: "GPG #16",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #16",
        url: "https://bit.ly/3IqpKBv"
      },
      gpg17: {
        abbreviation: "GPG #17",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #17",
        url: "https://bit.ly/3uHrm6p"
      },
      gpg18: {
        abbreviation: "GPG #18",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #18",
        url: "https://bit.ly/48pPGaX"
      },
      gpg19: {
        abbreviation: "GPG #19",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #19",
        url: "https://bit.ly/4blqODO"
      },
      gpg20: {
        abbreviation: "GPG #20",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #20",
        url: "https://bit.ly/49OPl2F"
      },
      gpg21: {
        abbreviation: "GPG #21",
        affiliate: !0,
        publisher: "enPublishing",
        series: "gatePassGazette",
        systems: ["a5e"],
        title: "Level Up: Gate Pass Gazette Issue #21",
        url: "https://bit.ly/4c1jnCf"
      },
      hakansPamphlet: {
        abbreviation: "HPtAW",
        affiliate: !1,
        publisher: "ravine",
        systems: ["a5e"],
        title: "Hakan's Pamphlet to Arcane Weaponry",
        url: "https://ravine.itch.io/a5e-spells01-arcaneweapon"
      },
      hearthAndHome: {
        abbreviation: "HaH",
        affiliate: !0,
        publisher: "plantWitchPress",
        systems: ["a5e"],
        title: "Hearth & Home",
        url: "https://www.drivethrurpg.com/en/product/488835/Hearth--Home-Cozy-Cottage-Origins?affiliate_id=1388381"
      },
      heroesOldAndNew: {
        abbreviation: "HOaN",
        affiliate: !0,
        publisher: "rollThemBones",
        systems: ["a5e"],
        title: "Heroes Old and New",
        url: "https://bit.ly/3UevPrJ"
      },
      moarComplete: {
        abbreviation: "MoAR",
        affiliate: !0,
        publisher: "purpleMartinGames",
        systems: ["a5e"],
        title: "Manual of Adventurous Resources: Complete",
        url: "https://bit.ly/4b7Fsyi"
      },
      monstrousMenagerie: {
        abbreviation: "MoMe",
        affiliate: !0,
        publisher: "enPublishing",
        systems: ["a5e"],
        title: "Level Up: Monstrous Menagerie",
        url: "https://bit.ly/3T1jeqJ"
      },
      mortalist: {
        abbreviation: "Mort",
        affiliate: !0,
        publisher: "purpleMartinGames",
        systems: ["a5e"],
        title: "Mortalist",
        url: "https://bit.ly/3I6n4Zj"
      },
      motifClasses: {
        abbreviation: "SA:MC",
        affiliate: !0,
        publisher: "purpleMartinGames",
        systems: ["a5e"],
        title: "System Architecture: Motif Classes",
        url: "https://bit.ly/4bgzU4N"
      },
      multiclassersManual: {
        abbreviation: "MulMan Vol. 1",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "multiclassersManual",
        systems: ["a5e"],
        title: "Multiclasser's Manual, Volume 1",
        url: "https://bit.ly/3JZTA08"
      },
      mysteriousAndMarvelousMiscellanea: {
        abbreviation: "MMM",
        affiliate: !0,
        publisher: "rollThemBones",
        systems: ["a5e"],
        title: "Mysterious and Marvelous Miscellanea",
        url: "https://bit.ly/42fLLM8"
      },
      paradigmsOfSkill: {
        abbreviation: "PoS",
        affiliate: !0,
        publisher: "plantWitchPress",
        systems: ["a5e"],
        title: "Paradigms of Skill",
        url: "https://bit.ly/3TvtZRl"
      },
      planestridersJournal: {
        abbreviation: "PJ",
        affiliate: !0,
        publisher: "enPublishing",
        systems: ["a5e"],
        title: "Planestrider's Journal",
        url: ""
      },
      ridingParsnip: {
        abbreviation: "RP",
        affiliate: !0,
        publisher: "purpleMartinGames",
        systems: ["a5e"],
        title: "Riding Parsnip",
        url: "https://bit.ly/3xh28Nk"
      },
      secretsOfTheSelkies: {
        abbreviation: "SotS",
        affiliate: !0,
        publisher: "speaksAndSpells",
        systems: ["a5e"],
        title: "Secrets of the Selkies",
        url: "https://bit.ly/3USEOix"
      },
      sinuousSentinels: {
        abbreviation: "SinSen",
        affiliate: !0,
        publisher: "purpleMartinGames",
        systems: ["a5e"],
        title: "Sinuous Sentinels",
        url: "https://bit.ly/3SSNXoy"
      },
      spellsFromTheForgottenVault: {
        abbreviation: "SftFV",
        affiliate: !0,
        publisher: "purpleMartinGames",
        systems: ["a5e"],
        title: "Spells from the Forgotten Vault",
        url: "https://bit.ly/3T8o5GU"
      },
      spiritualist: {
        abbreviation: "Spirit",
        affiliate: !0,
        publisher: "purpleMartinGames",
        systems: ["a5e"],
        title: "Spiritualist",
        url: "https://preview.drivethrurpg.com/en/product/424846/spiritualist-a5e?affiliate_id=1388381"
      },
      strangerSights: {
        abbreviation: "SS",
        affiliate: !0,
        publisher: "dmSarah",
        systems: ["a5e"],
        title: "Stranger Sights: Challenges for 5e and Advanced 5e",
        url: "https://bit.ly/3SmPaEv"
      },
      theHauntingOfCalrowRuins: {
        abbreviation: "THoCR",
        affiliate: !1,
        publisher: "enPublishing",
        systems: ["a5e"],
        title: "The Haunting of Calrow Ruins",
        url: "https://enpublishingrpg.com/products/the-haunting-of-calrow-ruins"
      },
      thematicToolkitArcaneAvenger: {
        abbreviation: "TT:AA",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Arcane Avenger",
        url: "https://preview.drivethrurpg.com/en/product/392599/thematic-toolkit-arcane-avenger-a5e?affiliate_id=1388381"
      },
      thematicToolkitBurningGloom: {
        abbreviation: "TT:BG",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Burning Gloom",
        url: "https://bit.ly/48XRLfm"
      },
      thematicToolkitCarryTheDarkness: {
        abbreviation: "TT:CtD",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Carry the Darkness",
        url: "https://bit.ly/480m03Y"
      },
      thematicToolkitCultist: {
        abbreviation: "TT:Cult",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Cultist",
        url: "https://preview.drivethrurpg.com/en/product/392588/thematic-toolkit-cultist-a5e?affiliate_id=1388381"
      },
      thematicToolkitFolkOfTheCourt: {
        abbreviation: "TT:FotC",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Folk of the Court",
        url: "https://bit.ly/48SVn1R"
      },
      thematicToolkitHazardousKnowledge: {
        abbreviation: "TT:HK",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Hazardous Knowledge",
        url: "https://bit.ly/4d7WzRz"
      },
      thematicToolkitItinerant: {
        abbreviation: "TT:Itin",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Itinerant",
        url: "https://bit.ly/3Sidh7p"
      },
      thematicToolkitJudgeJuryAndExecutioner: {
        abbreviation: "TT:JJE",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Judge, Jury, and Executioner",
        url: "https://bit.ly/42OmyZC"
      },
      thematicToolkitMasterOfCeremonies: {
        abbreviation: "TT:MoC",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Master of Ceremonies",
        url: "https://preview.drivethrurpg.com/en/product/422460/thematic-toolkit-master-of-ceremonies-a5e?affiliate_id=1388381"
      },
      thematicToolkitScrapper: {
        abbreviation: "TT:Scrap",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Scrapper",
        url: "https://preview.drivethrurpg.com/en/product/412017/thematic-toolkit-scrapper-a5e?affiliate_id=1388381"
      },
      thematicToolkitStoryteller: {
        abbreviation: "TT:Story",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Storyteller",
        url: "https://preview.drivethrurpg.com/en/product/407903/thematic-toolkit-storyteller-a5e?affiliate_id=1388381"
      },
      thematicToolkitThunderOfWar: {
        abbreviation: "TT:ToW",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Thunder of War",
        url: "https://preview.drivethrurpg.com/en/product/404207/thematic-toolkit-thunder-of-war-a5e?affiliate_id=1388381"
      },
      thematicToolkitVenomousShadow: {
        abbreviation: "TT:VS",
        affiliate: !0,
        publisher: "purpleMartinGames",
        series: "thematicToolkit",
        systems: ["a5e"],
        title: "Thematic Toolkit: Venomous Shadow",
        url: "https://preview.drivethrurpg.com/en/product/400541/thematic-toolkit-venomous-shadow-a5e?affiliate_id=1388381"
      },
      theErrantSeer: {
        abbreviation: "TES",
        affiliate: !1,
        publisher: "ravine",
        systems: ["a5e"],
        title: "The Errant Seer",
        url: "https://ravine.itch.io/a5e-subclass03-errant-seer"
      },
      theRuinStrider: {
        abbreviation: "TRS",
        affiliate: !1,
        publisher: "ravine",
        systems: ["a5e"],
        title: "The Ruin Stider",
        url: "https://ravine.itch.io/a5e-subclass02-ruin-strider"
      },
      theSpellbreaker: {
        abbreviation: "TS",
        affiliate: !1,
        publisher: "ravine",
        systems: ["a5e"],
        title: "The Spellbreaker",
        url: "https://ravine.itch.io/a5e-subclass04-spellbreaker"
      },
      toilAndTrouble: {
        abbreviation: "TaT",
        affiliate: !0,
        publisher: "plantWitchPress",
        systems: ["a5e"],
        title: "Toil and Trouble",
        url: "https://bit.ly/3HE10VQ"
      },
      toSaveAKingdom: {
        abbreviation: "TSaK",
        affiliate: !0,
        publisher: "enPublishing",
        systems: ["a5e"],
        title: "Level Up: To Save a Kingdom",
        url: "https://bit.ly/42iQKvN"
      },
      trialsAndTreasures: {
        abbreviation: "T&T",
        affiliate: !0,
        publisher: "enPublishing",
        systems: ["a5e"],
        title: "Level Up: Trials and Treasures",
        url: "https://bit.ly/3w8ha7b"
      },
      ventureForth: {
        abbreviation: "VF",
        affiliate: !0,
        publisher: "speaksAndSpells",
        systems: ["a5e"],
        title: "Venture Forth",
        url: "https://bit.ly/49prJRm"
      },
      voidrunnersCodex: {
        abbreviation: "VRC",
        affiliate: !0,
        publisher: "enPublishing",
        systems: ["a5e"],
        title: "Voidrunner's Codex",
        url: ""
      }
    }
  };
}
u(Wse, "registerPremiumContentConfig");
function Kse() {
  return {
    publishers: {
      acesAdventuringGuides: "Ace's Adventuring Guides",
      anthonyAlipio: "Anthony Alipio",
      dmSarah: "DM Sarah",
      enPublishing: "EN Publishing",
      joshGentry: "Josh Gentry",
      koboldPress: "Kobold Press",
      loottheboss: "LootTheBoss",
      plantWitchPress: "Plant Witch Press",
      purpleMartinGames: "Purple Martin Games",
      ravine: "Ravine",
      rollThemBones: "Roll them Bones Gaming",
      roguesCollection: "The Rogue's Collection",
      speaksAndSpells: "Speaks and Spells Publishing",
      steampunkette: "Steampunkette",
      wolfworksPress: "Wolfworks Press"
    }
  };
}
u(Kse, "registerPublisherConfig");
function Yse() {
  return {
    reducerSortMap: {
      features: {
        legendaryAction: 0,
        naturalWeapon: 1,
        class: 2,
        knack: 3,
        feat: 4,
        heritage: 5,
        culture: 6,
        background: 7,
        destiny: 8,
        boon: 9,
        other: 10
      },
      objects: {
        weapon: 0,
        armor: 1,
        shield: 2,
        ammunition: 3,
        container: 4,
        consumable: 5,
        tool: 6,
        jewelry: 7,
        clothing: 8,
        miscellaneous: 9
      }
    }
  };
}
u(Yse, "registerReducerConfig");
function Xse() {
  return {
    refreshableSettings: /* @__PURE__ */ new Set(["automatedConditions"])
  };
}
u(Xse, "registerSettingsConfig");
const Jse = {
  ADD: 1,
  OVERRIDE: 2
}, Zse = [
  0,
  300,
  900,
  2700,
  6500,
  14e3,
  23e3,
  34e3,
  48e3,
  64e3,
  85e3,
  1e5,
  12e4,
  14e4,
  165e3,
  195e3,
  225e3,
  265e3,
  305e3,
  355e3
], Qse = {
  0: 10,
  "1/8": 25,
  "1/4": 50,
  "1/2": 100,
  1: 200,
  2: 450,
  3: 700,
  4: 1100,
  5: 1800,
  6: 2300,
  7: 2900,
  8: 3900,
  9: 5e3,
  10: 5900,
  11: 7200,
  12: 8400,
  13: 1e4,
  14: 11500,
  15: 13e3,
  16: 15e3,
  17: 18e3,
  18: 2e4,
  19: 22e3,
  20: 25e3,
  21: 33e3,
  22: 41e3,
  23: 5e4,
  24: 62e3,
  25: 75e3,
  26: 9e4,
  27: 105e3,
  28: 12e4,
  29: 135e3,
  30: 155e3
}, xse = {
  INTACT: 0,
  DAMAGED: 1,
  BROKEN: 2
}, ene = {
  blindroll: "A5E.diceRollModes.blind",
  gmroll: "A5E.diceRollModes.gm",
  publicroll: "A5E.diceRollModes.public",
  selfroll: "A5E.diceRollModes.self"
}, tne = {
  NOT_CARRIED: 0,
  CARRIED: 1,
  EQUIPPED: 2
}, sne = {
  UNPREPARED: 0,
  PREPARED: 1,
  ALWAYS_PREPARED: 2
}, nne = {
  NORMAL: 0,
  ADVANTAGE: 1,
  DISADVANTAGE: -1
}, PB = {
  str: "A5E.abilities.strength",
  dex: "A5E.abilities.dexterity",
  con: "A5E.abilities.constitution",
  int: "A5E.abilities.intelligence",
  wis: "A5E.abilities.wisdom",
  cha: "A5E.abilities.charisma"
}, ine = {
  str: "A5E.abilities.abbreviations.strength",
  dex: "A5E.abilities.abbreviations.dexterity",
  con: "A5E.abilities.abbreviations.constitution",
  int: "A5E.abilities.abbreviations.intelligence",
  wis: "A5E.abilities.abbreviations.wisdom",
  cha: "A5E.abilities.abbreviations.charisma"
}, lne = {
  action: "A5E.ActionActivationAction",
  bonusAction: "A5E.ActionActivationBonusAction",
  day: "A5E.DurationDay",
  hour: "A5E.DurationHour",
  lairAction: "A5E.ActionActivationLairAction",
  legendaryAction: "A5E.ActionActivationLegendaryAction",
  minute: "A5E.DurationMinute",
  none: "A5E.ActionActivationNone",
  objectInteraction: "A5E.ActionActivationObjectInteraction",
  reaction: "A5E.ActionActivationReaction",
  special: "A5E.ActionActivationSpecial"
}, rne = {
  action: "A5E.ActionActivationActionPlural",
  bonusAction: "A5E.ActionActivationBonusActionPlural",
  day: "A5E.DurationDayPlural",
  hour: "A5E.DurationHourPlural",
  lairAction: "A5E.ActionActivationLairActionPlural",
  legendaryAction: "A5E.ActionActivationLegendaryActionPlural",
  minute: "A5E.DurationMinutePlural",
  none: "A5E.ActionActivationNone",
  objectInteraction: "A5E.ActionActivationObjectInteractionPlural",
  reaction: "A5E.ActionActivationReaction",
  special: "A5E.ActionActivationSpecial"
}, one = {
  abilityCheck: "A5E.ActionOptionAbilityCheck",
  attack: "A5E.ActionOptionAttack",
  damage: "A5E.ActionOptionDamage",
  healing: "A5E.ActionOptionHealing",
  savingThrow: "A5E.ActionOptionSavingThrow"
}, ane = {
  tiny: "A5E.SizeTiny",
  sm: "A5E.SizeSmall",
  med: "A5E.SizeMedium",
  lg: "A5E.SizeLarge",
  huge: "A5E.SizeHuge",
  grg: "A5E.SizeGargantuan",
  titan: "A5E.SizeTitanic"
}, cne = [
  "archetype",
  "background",
  "class",
  "culture",
  "destiny",
  "heritage"
], une = {
  chaotic: "Chaotic",
  evil: "Evil",
  good: "Good",
  lawful: "Lawful",
  neutral: "Neutral"
}, fne = {
  explosive: "A5E.AmmunitionPropertyExplosive",
  flaming: "A5E.AmmunitionPropertyFlaming",
  punching: "A5E.AmmunitionPropertyPunching"
}, dne = {
  armor: "A5E.armorClass.appliedArmorTypes.armor",
  underarmor: "A5E.armorClass.appliedArmorTypes.underarmor"
}, pne = {
  circle: '<i class="fa-regular fa-circle"></i>',
  cone: '<i class="fa-solid fa-wifi"></i>',
  cube: '<i class="fa-solid fa-cube"></i>',
  cylinder: '<i class="fa-solid fa-circle"></i>',
  emanation: '<i class="fa-regular fa-circle-dot"></i>',
  line: '<i class="fa-solid fa-grip-lines"></i>',
  sphere: '<i class="fa-solid fa-meteor"></i>',
  square: '<i class="fa-regular fa-square-full"></i>',
  wall: '<i class="fa-solid fa-road-spikes"></i>'
}, mne = {
  circle: "A5E.AreaCircle",
  cone: "A5E.AreaCone",
  cube: "A5E.AreaCube",
  cylinder: "A5E.AreaCylinder",
  emanation: "A5E.AreaEmanation",
  line: "A5E.AreaLine",
  sphere: "A5E.AreaSphere",
  square: "A5E.AreaSquare",
  wall: "A5E.AreaWall"
}, hne = {
  circle: "circle",
  cone: "cone",
  cube: "rect",
  cylinder: "circle",
  line: "ray",
  sphere: "circle",
  square: "rect"
}, gne = {
  light: "A5E.ArmorLight",
  medium: "A5E.ArmorMedium",
  heavy: "A5E.ArmorHeavy",
  shield: "A5E.ArmorShield"
}, bne = {
  1: "A5E.armorClass.modes.add",
  2: "A5E.armorClass.modes.override"
}, _ne = {
  biosensors: "A5E.ArmorModBiosensors",
  dronePort: "A5E.ArmorModDronePort",
  environmentalRecycling: "A5E.ArmorModEnvironmentalRecycling",
  floodlights: "A5E.ArmorModFloodlights",
  gliderWings: "A5E.ArmorModGliderWings",
  grapplingHook: "A5E.ArmorModGrapplingHook",
  groundAnchors: "A5E.ArmorModGroundAnchors",
  hazmatSealing: "A5E.ArmorModHazmatSealing",
  improvedColdShielding: "A5E.ArmorModImprovedColdShielding",
  improvedHeatShielding: "A5E.ArmorModImprovedHeatShielding",
  improvedWeaponHatch: "A5E.ArmorModImprovedWeaponHatch",
  integratedFirstAid: "A5E.ArmorModIntegratedFirstAid",
  integratedJetpack: "A5E.ArmorModIntegratedJetpack",
  integratedTool: "A5E.ArmorModIntegratedTool",
  kineticAssistance: "A5E.ArmorModKineticAssistance",
  massJammer: "A5E.ArmorModMassJammer",
  mindshielding: "A5E.ArmorModMindshielding",
  nightvisionGoggles: "A5E.ArmorModNightvisionGoggles",
  personalJammer: "A5E.ArmorModPersonalJammer",
  pocket: "A5E.ArmorModPocket",
  powerClaw: "A5E.ArmorModPowerClaw",
  rechargePort: "A5E.ArmorModRechargePort",
  reconApparatus: "A5E.ArmorModReconApparatus",
  repairKit: "A5E.ArmorModRepairKit",
  secondaryArmorPlating: "A5E.ArmorModSecondaryArmorPlating",
  weaponHatch: "A5E.ArmorModWeaponHatch"
}, yne = {
  camouflaged: "A5E.ArmorPropertyCamouflaged",
  cloaking: "A5E.ArmorPropertyCloaking",
  coldShielding: "A5E.ArmorPropertyColdShielding",
  greased: "A5E.ArmorPropertyGreased",
  heatShielding: "A5E.ArmorPropertyHeatShielding",
  mirrored: "A5E.ArmorPropertyMirrored",
  shearThickening: "A5E.ArmorPropertyShearThickening",
  spiked: "A5E.ArmorPropertySpiked",
  stealthy: "A5E.objectProperties.stealthy",
  storage: "A5E.objectProperties.storage"
}, vne = {
  light: "A5E.ArmorLight",
  medium: "A5E.ArmorMedium",
  heavy: "A5E.ArmorHeavy",
  shield: "A5E.ArmorShieldPlural"
}, kne = {
  meleeWeaponAttack: "A5E.AttackTypeMeleeWeapon",
  rangedWeaponAttack: "A5E.AttackTypeRangedWeapon",
  meleeSpellAttack: "A5E.AttackTypeMeleeSpell",
  rangedSpellAttack: "A5E.AttackTypeRangedSpell"
}, wne = {
  tiny: 0.5,
  sm: 1,
  med: 1,
  lg: 2,
  huge: 4,
  grg: 8,
  titan: 16
}, $ne = {
  bulk: "A5E.CapacityTypeBulk",
  count: "A5E.CapacityTypeCount",
  weight: "A5E.CapacityTypeWeight"
}, Ane = [
  "abilityCheck",
  "hitDice",
  "item",
  "rollTableOutput",
  "savingThrow",
  "skillCheck"
], Ene = {
  blinded: "A5E.ConditionBlinded",
  bloodied: "A5E.ConditionBloodied",
  charmed: "A5E.ConditionCharmed",
  confused: "A5E.ConditionConfused",
  corruption: "A5E.ConditionCorruption",
  dazzled: "A5E.ConditionDazzled",
  deafened: "A5E.ConditionDeafened",
  doomed: "A5E.ConditionDoomed",
  encumbered: "A5E.ConditionEncumbered",
  enervated: "A5E.ConditionEnervated",
  fatigue: "A5E.ConditionFatigue",
  fixated: "A5E.ConditionFixated",
  frightened: "A5E.ConditionFrightened",
  grappled: "A5E.ConditionGrappled",
  hungover: "A5E.ConditionHungover",
  incapacitated: "A5E.ConditionIncapacitated",
  inebriated: "A5E.ConditionInebriated",
  invisible: "A5E.ConditionInvisible",
  paralyzed: "A5E.ConditionParalyzed",
  petrified: "A5E.ConditionPetrified",
  poisoned: "A5E.ConditionPoisoned",
  prone: "A5E.ConditionProne",
  rattled: "A5E.ConditionRattled",
  restrained: "A5E.ConditionRestrained",
  slowed: "A5E.ConditionSlowed",
  strife: "A5E.ConditionStrife",
  stunned: "A5E.ConditionStunned",
  unconscious: "A5E.ConditionUnconscious"
}, Sne = {
  aberration: "A5E.CreatureAberration",
  beast: "A5E.CreatureBeast",
  celestial: "A5E.CreatureCelestial",
  construct: "A5E.CreatureConstruct",
  dragon: "A5E.CreatureDragon",
  elemental: "A5E.CreatureElemental",
  fey: "A5E.CreatureFey",
  fiend: "A5E.CreatureFiend",
  giant: "A5E.CreatureGiant",
  humanoid: "A5E.CreatureHumanoid",
  monstrosity: "A5E.CreatureMonstrosity",
  ooze: "A5E.CreatureOoze",
  plant: "A5E.CreaturePlant",
  undead: "A5E.CreatureUndead"
}, Cne = {
  0: "A5E.damagedState.intact",
  1: "A5E.damagedState.damaged",
  2: "A5E.damagedState.broken"
}, Tne = {
  cantrip: "A5E.scaling.modes.cantrip",
  spellLevel: "A5E.scaling.modes.spellLevel",
  spellPoints: "A5E.scaling.modes.spellPoints",
  artifactCharges: "A5E.scaling.modes.artifactCharges",
  actionUses: "A5E.scaling.modes.actionUses",
  itemUses: "A5E.scaling.modes.itemUses"
}, One = {
  cantrip: "A5E.scaling.modes.cantrip",
  spellLevel: "A5E.scaling.modes.spellLevel",
  spellPoints: "A5E.scaling.modes.spellPoints",
  artifactCharges: "A5E.scaling.modes.artifactCharges",
  actionUses: "A5E.scaling.modes.actionUses",
  itemUses: "A5E.scaling.modes.itemUses"
}, Dne = {
  acid: "A5E.damageTypes.acid",
  bludgeoning: "A5E.damageTypes.bludgeoning",
  cold: "A5E.damageTypes.cold",
  fire: "A5E.damageTypes.fire",
  force: "A5E.damageTypes.force",
  lightning: "A5E.damageTypes.lightning",
  necrotic: "A5E.damageTypes.necrotic",
  piercing: "A5E.damageTypes.piercing",
  poison: "A5E.damageTypes.poison",
  psychic: "A5E.damageTypes.psychic",
  radiant: "A5E.damageTypes.radiant",
  slashing: "A5E.damageTypes.slashing",
  thunder: "A5E.damageTypes.thunder"
}, Ine = {
  acid: "#a9b920",
  bludgeoning: "#b9a137",
  cold: "#99d9d9",
  fire: "#f18131",
  force: "#6f599a",
  lightning: "#f9d130",
  necrotic: "#7a7e88",
  piercing: "#c13129",
  poison: "#a140a1",
  psychic: "#f95889",
  radiant: "#dfa6df",
  slashing: "#b8b8d0",
  thunder: "#e2c269"
}, Pne = {
  inventory: "a5e.a5e-adventuring-gear",
  maneuvers: "a5e.a5e-maneuvers",
  spells: "a5e.a5e-spells"
}, Mne = {
  0: "A5E.equippedState.notCarried",
  1: "A5E.equippedState.carried",
  2: "A5E.equippedState.equipped"
}, Fne = {
  0: 0,
  1: 4,
  2: 6,
  3: 8,
  4: 10,
  5: 12,
  6: 20
}, Rne = {
  background: "A5E.FeatureBackground",
  boon: "A5E.FeatureBoon",
  class: "A5E.FeatureClass",
  culture: "A5E.FeatureCulture",
  destiny: "A5E.FeatureDestiny",
  feat: "A5E.FeatureFeat",
  heritage: "A5E.FeatureHeritage",
  knack: "A5E.FeatureKnack",
  legendaryAction: "A5E.FeatureLegendaryAction",
  naturalWeapon: "A5E.FeatureNaturalWeapon",
  other: "A5E.FeatureOther"
}, Nne = {
  healing: "A5E.Healing",
  temporaryHealing: "A5E.HealingTemporary"
}, jne = {
  healing: "#eeee9b",
  temporaryHealing: "#2fa6b1"
}, Lne = {
  mundane: "A5E.itemRarities.mundane",
  common: "A5E.itemRarities.common",
  uncommon: "A5E.itemRarities.uncommon",
  rare: "A5E.itemRarities.rare",
  veryRare: "A5E.itemRarities.veryRare",
  legendary: "A5E.itemRarities.legendary",
  artifact: "A5E.itemRarities.artifact"
}, Bne = {
  archaic: "A5E.itemTechLevels.archaic",
  standard: "A5E.itemTechLevels.standard",
  advanced: "A5E.itemTechLevels.advanced"
}, qne = {
  background: "TYPES.Item.background",
  culture: "TYPES.Item.culture",
  destiny: "TYPES.Item.destiny",
  feature: "TYPES.Item.feature",
  maneuver: "TYPES.Item.maneuver",
  object: "TYPES.Item.object",
  spell: "TYPES.Item.spell"
}, Gne = {
  bulk: "Bulk"
}, zne = {
  adept: "Practiced Technique",
  artificer: "Field Discovery",
  artificerrevised: "Field Discovery",
  bard: "Adventuring Trick",
  berserker: "Developed Talent",
  bloodblade: "Esoteric Arts",
  cleric: "Sign of Faith",
  druid: "Secret of Nature",
  elementalist: "Elemental Adaptation",
  fighter: "Soldiering Knack",
  herald: "Divine Lesson",
  marshal: "Lesson of War",
  psion: "Cognitive Discoveries",
  psyknight: "Psychic Isometrics",
  ranger: "Exploration Knack",
  rogue: "Skill Trick",
  savant: "Clever Scheme",
  scholar: "Scholarly Discovery",
  scientist: "Scientific Praxes",
  scout: "Clever Trick",
  sorcerer: "Arcane Innovation",
  trooper: "Drill",
  warlock: "Secret of Arcana",
  wielder: "Artifact Whisper",
  witch: "Magical Mystery",
  wizard: "Elective Study"
}, Hne = {
  abyssal: "A5E.languages.abyssal",
  aquan: "A5E.languages.aquan",
  auran: "A5E.languages.auran",
  boggard: "A5E.languages.boggard",
  celestial: "A5E.languages.celestial",
  common: "A5E.languages.common",
  deep: "A5E.languages.deepSpeech",
  draconic: "A5E.languages.draconic",
  druidic: "A5E.languages.druidic",
  dwarvish: "A5E.languages.dwarvish",
  elvish: "A5E.languages.elvish",
  giant: "A5E.languages.giant",
  gnoll: "A5E.languages.gnoll",
  gnomish: "A5E.languages.gnomish",
  goblin: "A5E.languages.goblin",
  grimlock: "A5E.languages.grimlock",
  grippli: "A5E.languages.grippli",
  halfling: "A5E.languages.halfling",
  ignan: "A5E.languages.ignan",
  infernal: "A5E.languages.infernal",
  machine: "A5E.languages.machine",
  minotaur: "A5E.languages.minotaur",
  mycelial: "A5E.languages.mycelial",
  orc: "A5E.languages.orc",
  primordial: "A5E.languages.primordial",
  sylvan: "A5E.languages.sylvan",
  terran: "A5E.languages.terran",
  cant: "A5E.languages.thievesCant",
  undercommon: "A5E.languages.undercommon"
}, Une = {
  0: "A5E.ManeuverBasic",
  1: "A5E.ManeuverDegree1",
  2: "A5E.ManeuverDegree2",
  3: "A5E.ManeuverDegree3",
  4: "A5E.ManeuverDegree4",
  5: "A5E.ManeuverDegree5"
}, Vne = {
  aceStarfighter: "A5E.maneuverTraditions.aceStarfighter",
  adamantMountain: "A5E.maneuverTraditions.adamantMountain",
  arcaneArtillery: "A5E.maneuverTraditions.arcaneArtillery",
  arcaneKnight: "A5E.maneuverTraditions.arcaneKnight",
  awakenedMind: "A5E.maneuverTraditions.awakenedMind",
  beastUnity: "A5E.maneuverTraditions.beastUnity",
  bitingZephyr: "A5E.maneuverTraditions.bitingZephyr",
  blazingStarglaive: "A5E.maneuverTraditions.blazingStarglaive",
  comedicJabs: "A5E.maneuverTraditions.comedicJabs",
  cuttingOmen: "A5E.maneuverTraditions.cuttingOmen",
  eldritchBlackguard: "A5E.maneuverTraditions.eldritchBlackguard",
  gallantHeart: "A5E.maneuverTraditions.gallantHeart",
  grindingCog: "A5E.maneuverTraditions.grindingCog",
  mindfulBody: "A5E.maneuverTraditions.mindfulBody",
  mirrorsGlint: "A5E.maneuverTraditions.mirrorsGlint",
  mistAndShade: "A5E.maneuverTraditions.mistAndShade",
  rapidCurrent: "A5E.maneuverTraditions.rapidCurrent",
  razorsEdge: "A5E.maneuverTraditions.razorsEdge",
  sanctifiedSteel: "A5E.maneuverTraditions.sanctifiedSteel",
  sanguineKnot: "A5E.maneuverTraditions.sanguineKnot",
  selflessSentinel: "A5E.maneuverTraditions.selflessSentinel",
  spiritedSteed: "A5E.maneuverTraditions.spiritedSteed",
  temperedIron: "A5E.maneuverTraditions.temperedIron",
  toothAndClaw: "A5E.maneuverTraditions.toothAndClaw",
  unendingWheel: "A5E.maneuverTraditions.unendingWheel",
  viciousVein: "A5E.maneuverTraditions.viciousVein",
  vipersFangs: "A5E.maneuverTraditions.vipersFangs"
}, Wne = {
  comfortable: "A5E.MaterialPropertyComfortable",
  feybane: "A5E.MaterialPropertyFeybane",
  flaw: "A5E.MaterialPropertyFlaw",
  fortified: "A5E.MaterialPropertyFortified",
  hackable: "A5E.MaterialPropertyHackable",
  hardy: "A5E.MaterialPropertyHardy",
  highQuality: "A5E.MaterialPropertyHighQuality",
  lightweight: "A5E.MaterialPropertyLightweight",
  lowMaintenance: "A5E.MaterialPropertyLowMaintenance",
  rust: "A5E.MaterialPropertyRust",
  silvered: "A5E.MaterialPropertySilvered",
  spacefaring: "A5E.MaterialPropertySpacefaring",
  underarmor: "A5E.MaterialPropertyUnderarmor",
  weighty: "A5E.MaterialPropertyWeighty",
  wild: "A5E.MaterialPropertyWild"
}, Kne = {
  bludgeoning: "A5E.damageTypes.bludgeoning",
  piercing: "A5E.damageTypes.piercing",
  slashing: "A5E.damageTypes.slashing"
}, Yne = {
  0: "Ignore",
  1: "1",
  2: "2",
  3: "3",
  4: "4",
  5: "5",
  6: "6"
}, Xne = {
  walk: "A5E.MovementWalkingSpeed",
  burrow: "A5E.MovementBurrowingSpeed",
  climb: "A5E.MovementClimbingSpeed",
  fly: "A5E.MovementFlyingSpeed",
  swim: "A5E.MovementSwimmingSpeed"
}, Jne = {
  walk: "A5E.MovementWalkingSpeedAbbr",
  burrow: "A5E.MovementBurrowingSpeedAbbr",
  climb: "A5E.MovementClimbingSpeedAbbr",
  fly: "A5E.MovementFlyingSpeedAbbr",
  swim: "A5E.MovementSwimmingSpeedAbbr"
}, MB = {
  feet: "A5E.DistanceUnitFeet",
  miles: "A5E.DistanceUnitMiles",
  meters: "A5E.DistanceUnitMeters",
  kilometers: "A5E.DistanceUnitKilometers"
}, Zne = {
  feet: "A5E.DistanceFeetAbbr",
  miles: "A5E.DistanceMilesAbbr",
  meters: "A5E.DistanceMetersAbbr",
  kilometers: "A5E.DistanceKilometersAbbr"
}, Qne = {
  ...MB,
  unlimited: "A5E.RangeUnlimited"
}, xne = {
  armor: "A5E.ObjectTypeArmor",
  ammunition: "A5E.ObjectTypeAmmunition",
  clothing: "A5E.ObjectTypeClothing",
  consumable: "A5E.ObjectTypeConsumable",
  container: "A5E.ObjectTypeContainer",
  helm: "A5E.ObjectTypeHelm",
  jewelry: "A5E.ObjectTypeJewelry",
  miscellaneous: "A5E.ObjectTypeMiscellaneous",
  shield: "A5E.ObjectTypeShield",
  tool: "A5E.ObjectTypeTool",
  weapon: "A5E.ObjectTypeWeapon"
}, eie = {
  armor: "A5E.ObjectTypeArmorPlural",
  ammunition: "A5E.ObjectTypeAmmunition",
  clothing: "A5E.ObjectTypeClothing",
  consumable: "A5E.ObjectTypeConsumablePlural",
  container: "A5E.ObjectTypeContainerPlural",
  helm: "A5E.ObjectTypeHelmPlural",
  jewelry: "A5E.ObjectTypeJewelry",
  miscellaneous: "A5E.ObjectTypeMiscellaneous",
  shield: "A5E.ObjectTypeShieldPlural",
  tool: "A5E.ObjectTypeToolPlural",
  weapon: "A5E.ObjectTypeWeaponPlural"
}, tie = {
  0: "A5E.preparedState.unprepared",
  1: "A5E.preparedState.prepared",
  2: "A5E.preparedState.alwaysPrepared"
}, sie = {
  dynakinetic: "A5E.PsionicDisciplineDynakinetic",
  kinesthetic: "A5E.PsionicDisciplineKinesthetic",
  telekinetic: "A5E.PsionicDisciplineTelekinetic",
  telepathic: "A5E.PsionicDisciplineTelepathic"
}, nie = {
  self: "A5E.RangeSelf",
  touch: "A5E.RangeTouch",
  fiveFeet: "A5E.RangeFiveFeet",
  short: "A5E.RangeShort",
  medium: "A5E.RangeMedium",
  long: "A5E.RangeLong",
  other: "A5E.RangeOther"
}, iie = {
  self: "A5E.RangeSelf",
  touch: "A5E.RangeTouch",
  fiveFeet: 5,
  short: 30,
  medium: 60,
  long: 120
}, lie = {
  forge: "A5E.repairTools.forge",
  engineersToolbox: "A5E.repairTools.engineersToolbox",
  notRepairable: "A5E.repairTools.notRepairable",
  sewingKit: "A5E.repairTools.sewingKit",
  smithsTools: "A5E.repairTools.smithsTools"
}, rie = {
  shortRest: "A5E.RestShort",
  longRest: "A5E.RestLong",
  recharge: "A5E.ItemRecharge",
  round: "A5E.DurationRound",
  turn: "A5E.DurationTurn",
  minute: "A5E.DurationMinute",
  hour: "A5E.DurationHour",
  day: "A5E.DurationDay",
  week: "A5E.DurationWeek",
  month: "A5E.DurationMonth",
  year: "A5E.DurationYear"
}, oie = {
  normal: "A5E.RollModeNormal",
  advantage: "A5E.RollModeAdvantage",
  disadvantage: "A5E.RollModeDisadvantage"
}, aie = {
  abilityCheck: "Ability Check",
  attack: "Attack",
  damage: "Damage",
  healing: "Healing",
  generic: "Generic",
  savingThrow: "Saving Throw",
  skillCheck: "Skill Check",
  toolCheck: "ToolCheck"
}, cie = {
  spellcasting: "A5E.SpellDC",
  maneuver: "A5E.ManeuverDC",
  ...PB,
  custom: "A5E.Custom"
}, uie = {
  blindsight: "A5E.SenseBlindsight",
  darkvision: "A5E.SenseDarkvision",
  tremorsense: "A5E.SenseTremorsense",
  truesight: "A5E.SenseTruesight"
}, fie = {
  0: {
    attackBonus: 5,
    cost: "10 gp",
    craftingComponent: "Magical inks",
    saveDC: 13,
    rarity: "common"
  },
  1: {
    attackBonus: 5,
    cost: "25 gp",
    craftingComponent: "Magical inks",
    saveDC: 13,
    rarity: "common"
  },
  2: {
    attackBonus: 5,
    cost: "75 gp",
    craftingComponent: "Magical inks",
    saveDC: 13,
    rarity: "common"
  },
  3: {
    attackBonus: 7,
    cost: "175 gp",
    craftingComponent: "Dire wolf hide",
    saveDC: 15,
    rarity: "uncommon"
  },
  4: {
    attackBonus: 7,
    cost: "500 gp",
    craftingComponent: "Dire wolf hide",
    saveDC: 15,
    rarity: "uncommon"
  },
  5: {
    attackBonus: 9,
    cost: "1250 gp",
    craftingComponent: "Parchment infused with planar energy",
    saveDC: 17,
    rarity: "rare"
  },
  6: {
    attackBonus: 9,
    cost: "3000 gp",
    craftingComponent: "Parchment infused with planar energy",
    saveDC: 17,
    rarity: "rare"
  },
  7: {
    attackBonus: 10,
    cost: "8000 gp",
    craftingComponent: "Blank pages from a lich's spellbook",
    saveDC: 18,
    rarity: "veryRare"
  },
  8: {
    attackBonus: 10,
    cost: "20000 gp",
    craftingComponent: "Blank pages from a lich's spellbook",
    saveDC: 18,
    rarity: "veryRare"
  },
  9: {
    attackBonus: 11,
    cost: "55000 gp",
    craftingComponent: "Parchment made from a dragon's hide",
    saveDC: 19,
    rarity: "legendary"
  }
}, die = {
  handsFree: "A5E.shieldProperties.handsFree",
  mirrored: "A5E.shieldProperties.mirrored",
  spikes: "A5E.shieldProperties.spikes"
}, pie = {
  light: "A5E.ShieldTypeLight",
  medium: "A5E.ShieldTypeMedium",
  heavy: "A5E.ShieldTypeHeavy",
  tower: "A5E.ShieldTypeTower"
}, mie = {
  light: 1,
  medium: 2,
  heavy: 2,
  tower: 2
}, hie = {
  innate: "A5E.spellBook.types.innate",
  prepared: "A5E.spellBook.types.prepared",
  pact: "A5E.spellBook.types.pact",
  points: "A5E.spellBook.types.points",
  ritual: "A5E.spellBook.types.ritual"
}, gie = {
  vocalized: "A5E.SpellComponentVocalized",
  seen: "A5E.SpellComponentSeen",
  material: "A5E.SpellComponentMaterial"
}, bie = {
  vocalized: "A5E.SpellComponentVocalizedAbbr",
  seen: "A5E.SpellComponentSeenAbbr",
  material: "A5E.SpellComponentMaterialAbbr"
}, _ie = {
  0: "A5E.SpellLevel0",
  1: "A5E.SpellLevel1",
  2: "A5E.SpellLevel2",
  3: "A5E.SpellLevel3",
  4: "A5E.SpellLevel4",
  5: "A5E.SpellLevel5",
  6: "A5E.SpellLevel6",
  7: "A5E.SpellLevel7",
  8: "A5E.SpellLevel8",
  9: "A5E.SpellLevel9"
}, yie = {
  0: 0,
  1: 2,
  2: 3,
  3: 5,
  4: 6,
  5: 7,
  6: 9,
  7: 10,
  8: 11,
  9: 13
}, vie = {
  primary: {
    abjuration: "A5E.SpellSchoolAbjuration",
    conjuration: "A5E.SpellSchoolConjuration",
    divination: "A5E.SpellSchoolDivination",
    enchantment: "A5E.SpellSchoolEnchantment",
    evocation: "A5E.SpellSchoolEvocation",
    illusion: "A5E.SpellSchoolIllusion",
    necromancy: "A5E.SpellSchoolNecromancy",
    transmutation: "A5E.SpellSchoolTransmutation"
  },
  secondary: {
    acid: "A5E.SpellSchoolAcid",
    affliction: "A5E.SpellSchoolAffliction",
    air: "A5E.SpellSchoolAir",
    arcane: "A5E.SpellSchoolArcane",
    architecture: "A5E.SpellSchoolArchitecture",
    attack: "A5E.SpellSchoolAttack",
    beasts: "A5E.SpellSchoolBeasts",
    chaos: "A5E.SpellSchoolChaos",
    cold: "A5E.SpellSchoolCold",
    communication: "A5E.SpellSchoolCommunication",
    compulsion: "A5E.SpellSchoolCompulsion",
    control: "A5E.SpellSchoolControl",
    displacement: "A5E.SpellSchoolDisplacement",
    divine: "A5E.SpellSchoolDivine",
    dragon: "A5E.SpellSchoolDragon",
    earth: "A5E.SpellSchoolEarth",
    enhancement: "A5E.SpellSchoolEnhancement",
    evil: "A5E.SpellSchoolEvil",
    fear: "A5E.SpellSchoolFear",
    fire: "A5E.SpellSchoolFire",
    force: "A5E.SpellSchoolForce",
    good: "A5E.SpellSchoolGood",
    healing: "A5E.SpellSchoolHealing",
    hearth: "A5E.SpellSchoolHearth",
    knowledge: "A5E.SpellSchoolKnowledge",
    law: "A5E.SpellSchoolLaw",
    lightning: "A5E.SpellSchoolLightning",
    movement: "A5E.SpellSchoolMovement",
    multiclass: "A5E.SpellSchoolMulticlass",
    nature: "A5E.SpellSchoolNature",
    necrotic: "A5E.SpellSchoolNecrotic",
    negation: "A5E.SpellSchoolNegation",
    obscurement: "A5E.SpellSchoolObscurement",
    planar: "A5E.SpellSchoolPlanar",
    plants: "A5E.SpellSchoolPlants",
    poison: "A5E.SpellSchoolPoison",
    prismatic: "A5E.SpellSchoolPrismatic",
    protection: "A5E.SpellSchoolProtection",
    psionic: "A5E.SpellSchoolPsionic",
    psychic: "A5E.SpellSchoolPsychic",
    radiant: "A5E.SpellSchoolRadiant",
    scrying: "A5E.SpellSchoolScrying",
    senses: "A5E.SpellSchoolSenses",
    shadow: "A5E.SpellSchoolShadow",
    shapechanging: "A5E.SpellSchoolShapechanging",
    sound: "A5E.SpellSchoolSound",
    storm: "A5E.SpellSchoolStorm",
    summoning: "A5E.SpellSchoolSummoning",
    technological: "A5E.SpellSchoolTechnological",
    telepathy: "A5E.SpellSchoolTelepathy",
    teleportation: "A5E.SpellSchoolTeleportation",
    terrain: "A5E.SpellSchoolTerrain",
    thunder: "A5E.SpellSchoolThunder",
    time: "A5E.SpellSchoolTime",
    transformation: "A5E.SpellSchoolTransformation",
    unarmed: "A5E.SpellSchoolUnarmed",
    undead: "A5E.SpellSchoolUndead",
    utility: "A5E.SpellSchoolUtility",
    water: "A5E.SpellSchoolWater",
    weaponry: "A5E.SpellSchoolWeaponry",
    weather: "A5E.SpellSchoolWeather"
  }
}, kie = {
  acr: "A5E.skills.acrobatics",
  ani: "A5E.skills.animalHandling",
  arc: "A5E.skills.arcana",
  ath: "A5E.skills.athletics",
  cul: "A5E.skills.culture",
  dec: "A5E.skills.deception",
  eng: "A5E.skills.engineering",
  his: "A5E.skills.history",
  ins: "A5E.skills.insight",
  itm: "A5E.skills.intimidation",
  inv: "A5E.skills.investigation",
  med: "A5E.skills.medicine",
  nat: "A5E.skills.nature",
  prc: "A5E.skills.perception",
  prf: "A5E.skills.performance",
  per: "A5E.skills.persuasion",
  rel: "A5E.skills.religion",
  sci: "A5E.skills.science",
  slt: "A5E.skills.sleightOfHand",
  ste: "A5E.skills.stealth",
  sur: "A5E.skills.survival"
}, wie = {
  acr: "Compendium.a5e.a5e-roll-tables.RollTable.8q8hhm2qxxpzqety",
  ani: "Compendium.a5e.a5e-roll-tables.RollTable.vmf9w8gtsdi2h45n",
  arc: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  ath: "Compendium.a5e.a5e-roll-tables.RollTable.8q8hhm2qxxpzqety",
  cul: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  dec: "Compendium.a5e.a5e-roll-tables.RollTable.vmf9w8gtsdi2h45n",
  eng: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  his: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  ins: "Compendium.a5e.a5e-roll-tables.RollTable.vmf9w8gtsdi2h45n",
  itm: "Compendium.a5e.a5e-roll-tables.RollTable.vmf9w8gtsdi2h45n",
  inv: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  med: "Compendium.a5e.a5e-roll-tables.RollTable.66wtmckaxsjl2cay",
  nat: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  prc: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  prf: "Compendium.a5e.a5e-roll-tables.RollTable.vmf9w8gtsdi2h45n",
  per: "Compendium.a5e.a5e-roll-tables.RollTable.vmf9w8gtsdi2h45n",
  rel: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  slt: "Compendium.a5e.a5e-roll-tables.RollTable.8q8hhm2qxxpzqety",
  ste: "Compendium.a5e.a5e-roll-tables.RollTable.8q8hhm2qxxpzqety",
  sur: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz"
}, $ie = {
  acr: "Compendium.a5e.a5e-roll-tables.RollTable.sckaut8fmaq8l120",
  ani: "Compendium.a5e.a5e-roll-tables.RollTable.3m0vyh75nnlj42ja",
  arc: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  ath: "Compendium.a5e.a5e-roll-tables.RollTable.sckaut8fmaq8l120",
  cul: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  dec: "Compendium.a5e.a5e-roll-tables.RollTable.3m0vyh75nnlj42ja",
  eng: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  his: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  ins: "Compendium.a5e.a5e-roll-tables.RollTable.3m0vyh75nnlj42ja",
  itm: "Compendium.a5e.a5e-roll-tables.RollTable.3m0vyh75nnlj42ja",
  inv: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  med: "Compendium.a5e.a5e-roll-tables.RollTable.ihsspmdmmpj8cyk8",
  nat: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  prc: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  prf: "Compendium.a5e.a5e-roll-tables.RollTable.3m0vyh75nnlj42ja",
  per: "Compendium.a5e.a5e-roll-tables.RollTable.3m0vyh75nnlj42ja",
  rel: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  slt: "Compendium.a5e.a5e-roll-tables.RollTable.sckaut8fmaq8l120",
  ste: "Compendium.a5e.a5e-roll-tables.RollTable.sckaut8fmaq8l120",
  sur: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng"
}, Aie = {
  acr: "dex",
  ani: "wis",
  arc: "int",
  ath: "str",
  cul: "int",
  dec: "cha",
  eng: "int",
  his: "int",
  ins: "wis",
  itm: "cha",
  inv: "int",
  med: "wis",
  nat: "int",
  prc: "wis",
  prf: "cha",
  per: "cha",
  rel: "int",
  sci: "int",
  slt: "dex",
  ste: "dex",
  sur: "wis"
}, Eie = {
  acr: {
    balancing: "A5E.skillSpecialties.balancing",
    escapeArtistry: "A5E.skillSpecialties.escapeArtistry",
    swinging: "A5E.skillSpecialties.swinging",
    tumbling: "A5E.skillSpecialties.tumbling"
  },
  ani: {
    calming: "A5E.skillSpecialties.calming",
    driving: "A5E.skillSpecialties.driving",
    farming: "A5E.skillSpecialties.farming",
    riding: "A5E.skillSpecialties.riding",
    training: "A5E.skillSpecialties.training"
  },
  arc: {
    aberrations: "A5E.skillSpecialties.aberrations",
    artifacts: "A5E.skillSpecialties.artifacts",
    constructs: "A5E.skillSpecialties.constructs",
    detection: "A5E.skillSpecialties.detection",
    dragons: "A5E.skillSpecialties.dragons",
    elementals: "A5E.skillSpecialties.elementals",
    fey: "A5E.skillSpecialties.fey",
    forbiddenKnowledge: "A5E.skillSpecialties.forbiddenKnowledge",
    monstrosities: "A5E.skillSpecialties.monstrosities",
    oozes: "A5E.skillSpecialties.oozes",
    thePlanes: "A5E.skillSpecialties.thePlanes",
    psionics: "A5E.skillSpecialties.psionics",
    psionicItems: "A5E.skillSpecialties.psionicItems",
    psionicCreatures: "A5E.skillSpecialties.psionicCreatures"
  },
  ath: {
    climbing: "A5E.skillSpecialties.climbing",
    diving: "A5E.skillSpecialties.diving",
    jumping: "A5E.skillSpecialties.jumping",
    lifting: "A5E.skillSpecialties.lifting",
    martialArts: "A5E.skillSpecialties.martialArts",
    running: "A5E.skillSpecialties.running",
    swimming: "A5E.skillSpecialties.swimming",
    throwing: "A5E.skillSpecialties.throwing",
    zeroG: "A5E.skillSpecialties.zeroG"
  },
  cul: {
    courtlyManners: "A5E.skillSpecialties.courtlyManners",
    cuisine: "A5E.skillSpecialties.cuisine",
    etiquette: "A5E.skillSpecialties.etiquette",
    fencingProtocol: "A5E.skillSpecialties.fencingProtocol",
    laws: "A5E.skillSpecialties.laws",
    linguistics: "A5E.skillSpecialties.linguistics",
    regionalGoods: "A5E.skillSpecialties.regionalGoods",
    streetwise: "A5E.skillSpecialties.streetwise",
    trade: "A5E.skillSpecialties.trade"
  },
  dec: {
    boasting: "A5E.skillSpecialties.boasting",
    ciphers: "A5E.skillSpecialties.ciphers",
    concealingEmotions: "A5E.skillSpecialties.concealingEmotions",
    liesOfOmission: "A5E.skillSpecialties.liesOfOmission",
    mimicry: "A5E.skillSpecialties.mimicry"
  },
  eng: {
    architecture: "A5E.skillSpecialties.architecture",
    chemistry: "A5E.skillSpecialties.chemistry",
    explosives: "A5E.skillSpecialties.explosives",
    gadgetry: "A5E.skillSpecialties.gadgetry",
    mathematics: "A5E.skillSpecialties.mathematics",
    mechanicalTraps: "A5E.skillSpecialties.mechanicalTraps",
    plumbing: "A5E.skillSpecialties.plumbing",
    robotics: "A5E.skillSpecialties.robotics",
    siegecraft: "A5E.skillSpecialties.siegecraft",
    starships: "A5E.skillSpecialties.starships",
    starshipEngines: "A5E.skillSpecialties.starshipEngines",
    starshipShields: "A5E.skillSpecialties.starshipShields",
    weaponry: "A5E.skillSpecialties.weaponry"
  },
  his: {
    arts: "A5E.skillSpecialties.arts",
    empires: "A5E.skillSpecialties.empires",
    genealogy: "A5E.skillSpecialties.genealogy",
    legends: "A5E.skillSpecialties.legends",
    militaryHistory: "A5E.skillSpecialties.militaryHistory",
    wars: "A5E.skillSpecialties.wars"
  },
  ins: {
    detectingLies: "A5E.skillSpecialties.detectingLies",
    readingEmotions: "A5E.skillSpecialties.readingEmotions",
    sensingMotives: "A5E.skillSpecialties.sensingMotives"
  },
  itm: {
    authority: "A5E.skillSpecialties.authority",
    ferocity: "A5E.skillSpecialties.ferocity",
    interrogation: "A5E.skillSpecialties.interrogation",
    subtleThreats: "A5E.skillSpecialties.subtleThreats",
    weaponDisplays: "A5E.skillSpecialties.weaponDisplays"
  },
  inv: {
    appraisal: "A5E.skillSpecialties.appraisal",
    deciphering: "A5E.skillSpecialties.deciphering",
    forensics: "A5E.skillSpecialties.forensics",
    gatheringRumors: "A5E.skillSpecialties.gatheringRumors",
    research: "A5E.skillSpecialties.research",
    sensors: "A5E.skillSpecialties.sensors",
    trapfinding: "A5E.skillSpecialties.trapfinding"
  },
  med: {
    animals: "A5E.skillSpecialties.animals",
    autopsy: "A5E.skillSpecialties.autopsy",
    diseases: "A5E.skillSpecialties.diseases",
    drugs: "A5E.skillSpecialties.drugs",
    herbalism: "A5E.skillSpecialties.herbalism",
    mentalHealth: "A5E.skillSpecialties.mentalHealth",
    poisons: "A5E.skillSpecialties.poisons",
    xenobiology: "A5E.skillSpecialties.xenobiology"
  },
  nat: {
    astronomy: "A5E.skillSpecialties.astronomy",
    beastLore: "A5E.skillSpecialties.beastLore",
    farming: "A5E.skillSpecialties.farming",
    fey: "A5E.skillSpecialties.fey",
    plantLore: "A5E.skillSpecialties.plantLore",
    weather: "A5E.skillSpecialties.weather"
  },
  prc: {
    farsight: "A5E.skillSpecialties.farsight",
    invisibleObjects: "A5E.skillSpecialties.invisibleObjects",
    listening: "A5E.skillSpecialties.listening",
    scent: "A5E.skillSpecialties.scent"
  },
  prf: {
    acting: "A5E.skillSpecialties.acting",
    composing: "A5E.skillSpecialties.composing",
    dancing: "A5E.skillSpecialties.dancing",
    fineArt: "A5E.skillSpecialties.fineArt",
    singing: "A5E.skillSpecialties.singing",
    speaking: "A5E.skillSpecialties.speaking",
    writing: "A5E.skillSpecialties.writing"
  },
  per: {
    bribery: "A5E.skillSpecialties.bribery",
    flattery: "A5E.skillSpecialties.flattery",
    leadership: "A5E.skillSpecialties.leadership",
    negotiation: "A5E.skillSpecialties.negotiation",
    peacemaking: "A5E.skillSpecialties.peacemaking"
  },
  rel: {
    alignment: "A5E.skillSpecialties.alignment",
    celestials: "A5E.skillSpecialties.celestials",
    cults: "A5E.skillSpecialties.cults",
    fiends: "A5E.skillSpecialties.fiends",
    gods: "A5E.skillSpecialties.gods",
    holySymbols: "A5E.skillSpecialties.holySymbols",
    morality: "A5E.skillSpecialties.morality",
    prophecy: "A5E.skillSpecialties.prophecy",
    relics: "A5E.skillSpecialties.relics",
    undead: "A5E.skillSpecialties.undead"
  },
  sci: {
    astronomy: "A5E.skillSpecialties.astronomy",
    chemistry: "A5E.skillSpecialties.chemistry",
    earthScience: "A5E.skillSpecialties.earthScience",
    mathematics: "A5E.skillSpecialties.mathematics",
    physics: "A5E.skillSpecialties.physics",
    technobabble: "A5E.skillSpecialties.technobabble"
  },
  slt: {
    distraction: "A5E.skillSpecialties.distraction",
    legerdemain: "A5E.skillSpecialties.legerdemain",
    pickpocketing: "A5E.skillSpecialties.pickpocketing"
  },
  ste: {
    anonymity: "A5E.skillSpecialties.anonymity",
    camouflage: "A5E.skillSpecialties.camouflage",
    casing: "A5E.skillSpecialties.casing"
  },
  sur: {
    astrogation: "A5E.skillSpecialties.astrogation",
    dungeoneering: "A5E.skillSpecialties.dungeoneering",
    foraging: "A5E.skillSpecialties.foraging",
    hunting: "A5E.skillSpecialties.hunting",
    tracking: "A5E.skillSpecialties.tracking",
    wayfinding: "A5E.skillSpecialties.wayfinding"
  }
}, Sie = {
  self: "A5E.TargetSelf",
  creature: "A5E.TargetCreature",
  object: "A5E.TargetObject",
  creatureObject: "A5E.TargetCreatureObject",
  other: "A5E.TargetOther"
}, Cie = {
  self: "A5E.TargetSelf",
  creature: "A5E.TargetCreaturePlural",
  object: "A5E.TargetObjectPlural",
  creatureObject: "A5E.TargetCreatureObjectPlural",
  other: "A5E.TargetOther"
}, Tie = {
  abyss: "A5E.terrainTypes.abyss",
  astralPlane: "A5E.terrainTypes.astralPlane",
  caverns: "A5E.terrainTypes.caverns",
  desert: "A5E.terrainTypes.desert",
  etherealPlane: "A5E.terrainTypes.etherealPlane",
  forest: "A5E.terrainTypes.forest",
  grassland: "A5E.terrainTypes.grassland",
  hell: "A5E.terrainTypes.hell",
  hills: "A5E.terrainTypes.hills",
  jungle: "A5E.terrainTypes.jungle",
  laboratory: "A5E.terrainTypes.laboratory",
  mountains: "A5E.terrainTypes.mountains",
  planeOfAir: "A5E.terrainTypes.planeOfAir",
  planeOfEarth: "A5E.terrainTypes.planeOfEarth",
  planeOfFire: "A5E.terrainTypes.planeOfFire",
  planeOfWater: "A5E.terrainTypes.planeOfWater",
  ruin: "A5E.terrainTypes.ruin",
  settlement: "A5E.terrainTypes.settlement",
  sewer: "A5E.terrainTypes.sewer",
  swamp: "A5E.terrainTypes.swamp",
  temple: "A5E.terrainTypes.temple",
  theBleakGate: "A5E.terrainTypes.theBleakGate",
  theDreaming: "A5E.terrainTypes.theDreaming",
  tomb: "A5E.terrainTypes.tomb",
  tundra: "A5E.terrainTypes.tundra",
  underland: "A5E.terrainTypes.underland",
  water: "A5E.terrainTypes.water"
}, Oie = {
  instantaneous: "A5E.DurationInstantaneous",
  round: "A5E.DurationRound",
  turn: "A5E.DurationTurn",
  second: "A5E.DurationSecond",
  minute: "A5E.DurationMinute",
  hour: "A5E.DurationHour",
  day: "A5E.DurationDay",
  week: "A5E.DurationWeek",
  month: "A5E.DurationMonth",
  year: "A5E.DurationYear",
  permanent: "A5E.DurationPermanent",
  special: "A5E.DurationSpecial"
}, Iie = {
  instantaneous: "A5E.DurationInstantaneous",
  round: "A5E.DurationRoundPlural",
  turn: "A5E.DurationTurnPlural",
  second: "A5E.DurationSecondPlural",
  minute: "A5E.DurationMinutePlural",
  hour: "A5E.DurationHourPlural",
  day: "A5E.DurationDayPlural",
  week: "A5E.DurationWeekPlural",
  month: "A5E.DurationMonthPlural",
  year: "A5E.DurationYearPlural",
  permanent: "A5E.DurationPermanent",
  special: "A5E.DurationSpecial"
}, Pie = {
  tiny: 0.5,
  sm: 1,
  med: 1,
  lg: 2,
  huge: 3,
  grg: 4,
  titan: 5
}, Mie = {
  damage: 16711680,
  healing: 65280,
  temp: 6737151
}, Fie = {
  artisansTools: "A5E.ToolsArtisanTools",
  gamingSets: "A5E.ToolsGamingSets",
  musicalInstruments: "A5E.MusicalInstruments",
  miscellaneous: "A5E.ToolsMiscellaneous",
  specialist: "A5E.ToolsSpecialist",
  vehicles: "A5E.ToolsVehicles",
  other: "A5E.ToolsOther"
}, Rie = {
  artisansTools: {
    alchemistsSupplies: "A5E.ToolAlchemistsSupplies",
    bookbindersKit: "A5E.ToolBookbindersKit",
    brewersSupplies: "A5E.ToolBrewersSupplies",
    calligraphersSupplies: "A5E.ToolCalligraphersSupplies",
    carpentersTools: "A5E.ToolCarpentersTools",
    cartographersTools: "A5E.ToolCartographersTools",
    cobblersTools: "A5E.ToolCobblersTools",
    cooksUtensils: "A5E.ToolCooksUtensils",
    glassblowersTools: "A5E.ToolGlassblowersTools",
    jewelersTools: "A5E.ToolJewelersTools",
    leatherworkersTools: "A5E.ToolLeatherworkersTools",
    masonsTools: "A5E.ToolMasonsTools",
    paintersSupplies: "A5E.ToolPaintersSupplies",
    pottersTools: "A5E.ToolPottersTools",
    tinkersTools: "A5E.ToolTinkersTools",
    weaversTools: "A5E.ToolWeaversTools",
    woodcarversTools: "A5E.ToolWoodcarversTools"
  },
  gamingSets: {
    diceSet: "A5E.ToolDiceSet",
    boardGameSet: "A5E.ToolBoardGameSet",
    playingCardSet: "A5E.ToolPlayingCardSet"
  },
  musicalInstruments: {
    acousticGuitar: "A5E.InstrumentAcousticGuitar",
    bagpipes: "A5E.InstrumentBagpipes",
    casaba: "A5E.InstrumentCasaba",
    castanet: "A5E.InstrumentCastanet",
    drum: "A5E.InstrumentDrum",
    dulcimer: "A5E.InstrumentDulcimer",
    electricGuitar: "A5E.InstrumentElectricGuitar",
    flute: "A5E.InstrumentFlute",
    harmonica: "A5E.InstrumentHarmonica",
    harp: "A5E.InstrumentHarp",
    horn: "A5E.InstrumentHorn",
    keytar: "A5E.InstrumentKeytar",
    lute: "A5E.InstrumentLute",
    lyre: "A5E.InstrumentLyre",
    maraca: "A5E.InstrumentMaraca",
    ocarina: "A5E.InstrumentOcarina",
    panFlute: "A5E.InstrumentPanFlute",
    saxophone: "A5E.InstrumentSaxophone",
    shawm: "A5E.InstrumentShawm",
    theremin: "A5E.InstrumentTheremin",
    trombone: "A5E.InstrumentTrombone",
    viol: "A5E.InstrumentViol",
    violin: "A5E.InstrumentViolin"
  },
  miscellaneous: {
    disguiseKit: "A5E.ToolDisguiseKit",
    forgeryKit: "A5E.ToolForgeryKit",
    herbalismKit: "A5E.ToolHerbalismKit",
    navigatorsTools: "A5E.ToolNavigatorsTools",
    poisonersKit: "A5E.ToolPoisonersKit",
    sewingKit: "A5E.ToolSewingKit",
    smithsTools: "A5E.ToolSmithsTools",
    thievesTools: "A5E.ToolThievesTools",
    computers: "A5E.ToolComputers"
  },
  specialist: {
    computerTechnicianKit: "A5E.ToolComputerTechnicianKit",
    cyberneticsKit: "A5E.ToolCyberneticsKit",
    engineersToolbox: "A5E.ToolEngineersToolbox",
    fieldLaboratory: "A5E.ToolFieldLaboratory",
    hackingTool: "A5E.ToolHackingTool",
    medicalPouch: "A5E.ToolMedicalPouch",
    multiScanner: "A5E.ToolMultiScanner"
  },
  vehicles: {
    landVehicles: "A5E.VehicleLand",
    waterVehicles: "A5E.VehicleWater",
    airVehicles: "A5E.VehicleAir",
    spaceVehicles: "A5E.VehicleSpace"
  }
}, Nie = {
  artisansTools: {
    alchemistsSupplies: "A5E.ToolAlchemistsSupplies",
    bookbindersKit: "A5E.ToolBookbindersKitPlural",
    brewersSupplies: "A5E.ToolBrewersSupplies",
    calligraphersSupplies: "A5E.ToolCalligraphersSupplies",
    carpentersTools: "A5E.ToolCarpentersTools",
    cartographersTools: "A5E.ToolCartographersTools",
    cobblersTools: "A5E.ToolCobblersTools",
    cooksUtensils: "A5E.ToolCooksUtensils",
    glassblowersTools: "A5E.ToolGlassblowersTools",
    jewelersTools: "A5E.ToolJewelersTools",
    leatherworkersTools: "A5E.ToolLeatherworkersTools",
    masonsTools: "A5E.ToolMasonsTools",
    paintersSupplies: "A5E.ToolPaintersSupplies",
    pottersTools: "A5E.ToolPottersTools",
    tinkersTools: "A5E.ToolTinkersTools",
    weaversTools: "A5E.ToolWeaversTools",
    woodcarversTools: "A5E.ToolWoodcarversTools"
  },
  gamingSets: {
    diceSet: "A5E.ToolDiceSetPlural",
    boardGameSet: "A5E.ToolBoardGameSetPlural",
    playingCardSet: "A5E.ToolPlayingCardSetPlural"
  },
  musicalInstruments: {
    acousticGuitar: "A5E.InstrumentAcousticGuitarPlural",
    bagpipes: "A5E.InstrumentBagpipesPlural",
    casaba: "A5E.InstrumentCasabaPlural",
    castanet: "A5E.InstrumentCastanetPlural",
    drum: "A5E.InstrumentDrumPlural",
    dulcimer: "A5E.InstrumentDulcimerPlural",
    electricGuitar: "A5E.InstrumentElectricGuitarPlural",
    flute: "A5E.InstrumentFlutePlural",
    harmonica: "A5E.InstrumentHarmonicaPlural",
    harp: "A5E.InstrumentHarpPlural",
    horn: "A5E.InstrumentHornPlural",
    keytar: "A5E.InstrumentKeytarPlural",
    lute: "A5E.InstrumentLutePlural",
    lyre: "A5E.InstrumentLyrePlural",
    maraca: "A5E.InstrumentMaracaPlural",
    ocarina: "A5E.InstrumentOcarinaPlural",
    panFlute: "A5E.InstrumentPanFlutePlural",
    saxophone: "A5E.InstrumentSaxophonePlural",
    shawm: "A5E.InstrumentShawmPlural",
    theremin: "A5E.InstrumentTheremin",
    trombone: "A5E.InstrumentTrombonePlural",
    viol: "A5E.InstrumentViolPlural",
    violin: "A5E.InstrumentViolinPlural"
  },
  miscellaneous: {
    disguiseKit: "A5E.ToolDisguiseKitPlural",
    forgeryKit: "A5E.ToolForgeryKitPlural",
    herbalismKit: "A5E.ToolHerbalismKitPlural",
    navigatorsTools: "A5E.ToolNavigatorsToolsPlural",
    poisonersKit: "A5E.ToolPoisonersKitPlural",
    sewingKit: "A5E.ToolSewingKitPlural",
    smithsTools: "A5E.ToolSmithsToolsPlural",
    thievesTools: "A5E.ToolThievesToolsPlural"
  },
  specialist: {
    computerTechnicianKit: "A5E.ToolComputerTechnicianKitPlural",
    cyberneticsKit: "A5E.ToolCyberneticsKitPlural",
    engineersToolbox: "A5E.ToolEngineersToolboxPlural",
    fieldLaboratory: "A5E.ToolFieldLaboratoryPlural",
    hackingTool: "A5E.ToolHackingToolPlural",
    medicalPouch: "A5E.ToolMedicalPouchPlural",
    multiScanner: "A5E.ToolMultiScannerPlural"
  },
  vehicles: {
    landVehicles: "A5E.VehicleLandPlural",
    waterVehicles: "A5E.VehicleWaterPlural",
    airVehicles: "A5E.VehicleAirPlural",
    spaceVehicles: "A5E.VehicleSpacePlural"
  }
}, jie = {
  simple: "A5E.WeaponsSimple",
  martial: "A5E.WeaponsMartial",
  rare: "A5E.WeaponsRare",
  miscellaneous: "A5E.WeaponsMiscellaneous",
  other: "A5E.WeaponsOther"
}, Lie = {
  simple: {
    blaster: "A5E.WeaponBlaster",
    blowgun: "A5E.WeaponBlowgun",
    club: "A5E.WeaponClub",
    dagger: "A5E.WeaponDagger",
    handaxe: "A5E.WeaponHandaxe",
    heavyCrossbow: "A5E.WeaponHeavyCrossbow",
    joltPistol: "A5E.WeaponJoltPistol",
    greatclub: "A5E.WeaponGreatclub",
    laserPistol: "A5E.WeaponLaserPistol",
    lightCrossbow: "A5E.WeaponLightCrossbow",
    mace: "A5E.WeaponMace",
    quarterstaff: "A5E.WeaponQuarterstaff",
    shockMace: "A5E.WeaponShockMace",
    sickle: "A5E.WeaponSickle",
    sling: "A5E.WeaponSling",
    slugger: "A5E.WeaponSlugger",
    sonicMaul: "A5E.WeaponSonicMaul",
    spear: "A5E.WeaponSpear",
    stunStick: "A5E.WeaponStunStick",
    tacticalBaton: "A5E.WeaponTacticalBaton"
  },
  martial: {
    bastardSword: "A5E.WeaponBastardSword",
    battleaxe: "A5E.WeaponBattleaxe",
    battleGauntlet: "A5E.WeaponBattleGauntlet",
    bioChakram: "A5E.WeaponBioChakram",
    brassKnuckles: "A5E.WeaponBrassKnuckles",
    combatChainsaw: "A5E.WeaponCombatChainsaw",
    combatKnife: "A5E.WeaponCombatKnife",
    compositeBow: "A5E.WeaponCompositeBow",
    dart: "A5E.WeaponDart",
    duelingDagger: "A5E.WeaponDuelingDagger",
    duelingSword: "A5E.WeaponDuelingSword",
    electroHalberd: "A5E.WeaponElectroHalberd",
    energyCrossbow: "A5E.WeaponEnergyCrossbow",
    flail: "A5E.WeaponFlail",
    flameBracer: "A5E.WeaponFlameBracer",
    flamethrower: "A5E.WeaponFlamethrower",
    garotte: "A5E.WeaponGarotte",
    glaive: "A5E.WeaponGlaive",
    greataxe: "A5E.WeaponGreataxe",
    greatsword: "A5E.WeaponGreatsword",
    grenadeLauncher: "A5E.WeaponGrenadeLauncher",
    halberd: "A5E.WeaponHalberd",
    handCrossbow: "A5E.WeaponHandCrossbow",
    hypodermicPistol: "A5E.WeaponHypodermicPistol",
    ionCannon: "A5E.WeaponIonCannon",
    javelin: "A5E.WeaponJavelin",
    lance: "A5E.WeaponLance",
    lightHammer: "A5E.WeaponLightHammer",
    longbow: "A5E.WeaponLongbow",
    longspear: "A5E.WeaponLongspear",
    longsword: "A5E.WeaponLongsword",
    maul: "A5E.WeaponMaul",
    monoWhip: "A5E.WeaponMonoWhip",
    morningstar: "A5E.WeaponMorningstar",
    net: "A5E.WeaponNet",
    netcaster: "A5E.WeaponNetcaster",
    pike: "A5E.WeaponPike",
    plasmaSword: "A5E.WeaponPlasmaSword",
    polaronGatlingGun: "A5E.WeaponPolaronGatlingGun",
    pulseRifle: "A5E.WeaponPulseRifle",
    punchingDagger: "A5E.WeaponPunchingDagger",
    rapier: "A5E.WeaponRapier",
    saber: "A5E.WeaponSaber",
    scimitar: "A5E.WeaponScimitar",
    scythe: "A5E.WeaponScythe",
    shortbow: "A5E.WeaponShortbow",
    shortsword: "A5E.WeaponShortsword",
    shotgun: "A5E.WeaponShotgun",
    slugRifle: "A5E.WeaponSlugRifle",
    sniperRifle: "A5E.WeaponSniperRifle",
    spearThrower: "A5E.WeaponSpearThrower",
    throwingDagger: "A5E.WeaponThrowingDagger",
    tkGauntlet: "A5E.WeaponTKGauntlet",
    trident: "A5E.WeaponTrident",
    vibroknife: "A5E.WeaponVibroknife",
    viperRetainer: "A5E.WeaponViperRetainer",
    warhammer: "A5E.WeaponWarhammer",
    warPick: "A5E.WeaponWarPick",
    whip: "A5E.WeaponWhip"
  },
  rare: {
    assassinsGauntlet: "A5E.WeaponAssassinsGauntlet",
    battleBook: "A5E.WeaponBattleBook",
    bootDagger: "A5E.WeaponBootDagger",
    carbine: "A5E.WeaponCarbine",
    doubleWeapon: "A5E.WeaponDoubleWeapon",
    gearedSlingshot: "A5E.WeaponGearedSlingshot",
    mercurialMaul: "A5E.WeaponMercurialMaul",
    musket: "A5E.WeaponMusket",
    pistol: "A5E.WeaponPistol",
    ratchetingCrossbow: "A5E.WeaponRatchetingCrossbow",
    revolver: "A5E.WeaponRevolver",
    ringBlade: "A5E.WeaponRingBlade",
    shotgun: "A5E.WeaponShotgun",
    spikedChain: "A5E.WeaponSpikedChain",
    swordPistol: "A5E.WeaponSwordPistol"
  },
  miscellaneous: {
    improvised: "A5E.WeaponImprovised",
    starship: "A5E.WeaponStarship"
  }
}, Bie = {
  simple: {
    blaster: "A5E.WeaponBlasterPlural",
    blowgun: "A5E.WeaponBlowgunPlural",
    club: "A5E.WeaponClubPlural",
    dagger: "A5E.WeaponDaggerPlural",
    handaxe: "A5E.WeaponHandaxePlural",
    heavyCrossbow: "A5E.WeaponHeavyCrossbowPlural",
    joltPistol: "A5E.WeaponJoltPistolPlural",
    greatclub: "A5E.WeaponGreatclubPlural",
    laserPistol: "A5E.WeaponLaserPistolPlural",
    lightCrossbow: "A5E.WeaponLightCrossbowPlural",
    mace: "A5E.WeaponMacePlural",
    quarterstaff: "A5E.WeaponQuarterstaffPlural",
    shockMace: "A5E.WeaponShockMacePlural",
    sickle: "A5E.WeaponSicklePlural",
    sling: "A5E.WeaponSlingPlural",
    slugger: "A5E.WeaponSluggerPlural",
    sonicMaul: "A5E.WeaponSonicMaulPlural",
    spear: "A5E.WeaponSpearPlural",
    stunStick: "A5E.WeaponStunStickPlural",
    tacticalBaton: "A5E.WeaponTacticalBatonPlural"
  },
  martial: {
    bastardSword: "A5E.WeaponBastardSwordPlural",
    battleaxe: "A5E.WeaponBattleaxePlural",
    battleGauntlet: "A5E.WeaponBattleGauntletPlural",
    bioChakram: "A5E.WeaponBioChakramPlural",
    brassKnuckles: "A5E.WeaponBrassKnucklesPlural",
    combatChainsaw: "A5E.WeaponCombatChainsawPlural",
    combatKnife: "A5E.WeaponCombatKnifePlural",
    compositeBow: "A5E.WeaponCompositeBowPlural",
    dart: "A5E.WeaponDartPlural",
    duelingDagger: "A5E.WeaponDuelingDaggerPlural",
    duelingSword: "A5E.WeaponDuelingSwordPlural",
    electroHalberd: "A5E.WeaponElectroHalberdPlural",
    energyCrossbow: "A5E.WeaponEnergyCrossbowPlural",
    flail: "A5E.WeaponFlailPlural",
    flameBracer: "A5E.WeaponFlameBracerPlural",
    flamethrower: "A5E.WeaponFlamethrowerPlural",
    garotte: "A5E.WeaponGarottePlural",
    glaive: "A5E.WeaponGlaivePlural",
    greataxe: "A5E.WeaponGreataxePlural",
    greatsword: "A5E.WeaponGreatswordPlural",
    grenadeLauncher: "A5E.WeaponGrenadeLauncherPlural",
    halberd: "A5E.WeaponHalberdPlural",
    handCrossbow: "A5E.WeaponHandCrossbowPlural",
    hypodermicPistol: "A5E.WeaponHypodermicPistolPlural",
    ionCannon: "A5E.WeaponIonCannonPlural",
    javelin: "A5E.WeaponJavelinPlural",
    lance: "A5E.WeaponLancePlural",
    lightHammer: "A5E.WeaponLightHammerPlural",
    longbow: "A5E.WeaponLongbowPlural",
    longspear: "A5E.WeaponLongspearPlural",
    longsword: "A5E.WeaponLongswordPlural",
    maul: "A5E.WeaponMaulPlural",
    monoWhip: "A5E.WeaponMonoWhipPlural",
    morningstar: "A5E.WeaponMorningstarPlural",
    net: "A5E.WeaponNetPlural",
    netcaster: "A5E.WeaponNetcasterPlural",
    pike: "A5E.WeaponPikePlural",
    plasmaSword: "A5E.WeaponPlasmaSwordPlural",
    polaronGatlingGun: "A5E.WeaponPolaronGatlingGunPlural",
    pulseRifle: "A5E.WeaponPulseRiflePlural",
    punchingDagger: "A5E.WeaponPunchingDaggerPlural",
    rapier: "A5E.WeaponRapierPlural",
    saber: "A5E.WeaponSaberPlural",
    scimitar: "A5E.WeaponScimitarPlural",
    scythe: "A5E.WeaponScythePlural",
    shortbow: "A5E.WeaponShortbowPlural",
    shortsword: "A5E.WeaponShortswordPlural",
    shotgun: "A5E.WeaponShotgunPlural",
    slugRifle: "A5E.WeaponSlugRiflePlural",
    sniperRifle: "A5E.WeaponSniperRiflePlural",
    spearThrower: "A5E.WeaponSpearThrowerPlural",
    throwingDagger: "A5E.WeaponThrowingDaggerPlural",
    tkGauntlet: "A5E.WeaponTKGauntletPlural",
    trident: "A5E.WeaponTridentPlural",
    vibroknife: "A5E.WeaponVibroknifePlural",
    viperRetainer: "A5E.WeaponViperRetainerPlural",
    warhammer: "A5E.WeaponWarhammerPlural",
    warPick: "A5E.WeaponWarPickPlural",
    whip: "A5E.WeaponWhipPlural"
  },
  rare: {
    assassinsGauntlet: "A5E.WeaponAssassinsGauntletPlural",
    battleBook: "A5E.WeaponBattleBookPlural",
    bootDagger: "A5E.WeaponBootDaggerPlural",
    carbine: "A5E.WeaponCarbinePlural",
    doubleWeapon: "A5E.WeaponDoubleWeaponPlural",
    gearedSlingshot: "A5E.WeaponGearedSlingshotPlural",
    mercurialMaul: "A5E.WeaponMercurialMaulPlural",
    musket: "A5E.WeaponMusketPlural",
    pistol: "A5E.WeaponPistolPlural",
    ratchetingCrossbow: "A5E.WeaponRatchetingCrossbowPlural",
    revolver: "A5E.WeaponRevolverPlural",
    ringBlade: "A5E.WeaponRingBladePlural",
    shotgun: "A5E.WeaponShotgunPlural",
    spikedChain: "A5E.WeaponSpikedChainPlural",
    swordPistol: "A5E.WeaponSwordPistolPlural"
  },
  miscellaneous: {
    improvised: "A5E.WeaponImprovisedPlural",
    starship: "A5E.WeaponStarshipPlural"
  }
}, qie = {
  biometric: "A5E.weaponAugments.biometric",
  burst: "A5E.weaponAugments.burst",
  concealed: "A5E.weaponAugments.concealed",
  energy: "Energy",
  longRange: "A5E.weaponAugments.longRange",
  mounted: "A5E.weaponAugments.mounted",
  overkill: "A5E.weaponAugments.overkill",
  repeating: "A5E.weaponAugments.repeating",
  scoped: "A5E.weaponAugments.scoped",
  toggled: "A5E.weaponAugments.toggled"
}, Gie = {
  force: "Force",
  laser: "Laser",
  plasma: "Plasma",
  shock: "Shock",
  sonic: "Sonic"
}, zie = {
  ammunition: "A5E.weaponProperties.ammunition",
  aquatic: "A5E.weaponProperties.aquatic",
  areaFire: "A5E.weaponProperties.areaFire",
  blackPowderPyrotechnics: "A5E.weaponProperties.blackPowderPyrotechnics",
  breaker: "A5E.weaponProperties.breaker",
  burstFire: "A5E.weaponProperties.burstFire",
  clubbing: "A5E.weaponProperties.clubbing",
  compounding: "A5E.weaponProperties.compounding",
  defensive: "A5E.weaponProperties.defensive",
  directFire: "A5E.weaponProperties.directFire",
  dualWielding: "A5E.weaponProperties.dualWielding",
  exotic: "A5E.weaponProperties.exotic",
  finesse: "A5E.weaponProperties.finesse",
  flamboyant: "A5E.weaponProperties.flamboyant",
  guidedFire: "A5E.weaponProperties.guidedFire",
  hailOfLead: "A5E.weaponProperties.hailOfLead",
  handMounted: "A5E.weaponProperties.handMounted",
  heavy: "A5E.weaponProperties.heavy",
  inaccurate: "A5E.weaponProperties.inaccurate",
  indirectFire: "A5E.weaponProperties.indirectFire",
  loading: "A5E.weaponProperties.loading",
  menacing: "A5E.weaponProperties.menacing",
  misfire: "A5E.weaponProperties.misfire",
  mounted: "A5E.weaponProperties.mounted",
  muzzleLoading: "A5E.weaponProperties.muzzleLoading",
  overkill: "A5E.weaponProperties.overkill",
  parrying: "A5E.weaponProperties.parrying",
  parryingImmunity: "A5E.weaponProperties.parryingImmunity",
  punching: "A5E.weaponProperties.punching",
  quickdraw: "A5E.weaponProperties.quickdraw",
  range: "A5E.weaponProperties.range",
  rebounding: "A5E.objectProperties.rebounding",
  reach: "A5E.weaponProperties.reach",
  reload: "A5E.weaponProperties.reload",
  rifled: "A5E.weaponProperties.rifled",
  scatter: "A5E.weaponProperties.scatter",
  shock: "A5E.weaponProperties.shock",
  simple: "A5E.weaponProperties.simple",
  stealthy: "A5E.objectProperties.stealthy",
  storage: "A5E.objectProperties.storage",
  surpriseShot: "A5E.weaponProperties.surpriseShot",
  thrown: "A5E.weaponProperties.thrown",
  triggerCharge: "A5E.weaponProperties.triggerCharge",
  trip: "A5E.weaponProperties.trip",
  twoHanded: "A5E.weaponProperties.twoHanded",
  versatile: "A5E.weaponProperties.versatile",
  vicious: "A5E.weaponProperties.vicious"
}, Hie = {
  wood: "Wood",
  stone: "Stone"
}, Uie = {
  light: "Light",
  medium: "Medium",
  heavy: "Heavy"
}, Vie = {
  d6: "d6",
  d8: "d8",
  d10: "d10",
  d12: "d12"
}, Il = {
  // Constants
  ARMOR_MODES: Jse,
  CHARACTER_EXP_LEVELS: Zse,
  CR_EXP_LEVELS: Qse,
  DAMAGED_STATES: xse,
  DICE_ROLL_MODES: ene,
  EQUIPPED_STATES: tne,
  PREPARED_STATES: sne,
  ROLL_MODE: nne,
  // Config Objects
  abilities: PB,
  abilityAbbreviations: ine,
  abilityActivationTypes: lne,
  abilityActivationTypesPlural: rne,
  actionOptions: one,
  actorSizes: ane,
  originItemTypes: cne,
  alignments: une,
  ammunitionProperties: fne,
  appliedArmorTypes: dne,
  areaIcons: pne,
  areaTypes: mne,
  areaTemplates: hne,
  armor: gne,
  armorModes: bne,
  armorMods: _ne,
  armorProperties: yne,
  armorPlural: vne,
  attackTypes: kne,
  carryCapacityMultiplier: wne,
  capacityTypes: $ne,
  chatCardTypes: Ane,
  conditions: Ene,
  creatureTypes: Sne,
  damagedStates: Cne,
  baseScalingModes: Tne,
  targetScalingModes: One,
  damageTypes: Dne,
  damageColors: Ine,
  defaultActorImportCompendia: Pne,
  equippedStates: Mne,
  expertiseDiceSidesMap: Fne,
  featureTypes: Rne,
  healingTypes: Nne,
  healingColors: jne,
  itemRarity: Lne,
  itemTechLevels: Bne,
  itemTypes: qne,
  inventoryFilters: Gne,
  knackTypes: zne,
  languages: Hne,
  maneuverDegrees: Une,
  maneuverTraditions: Vne,
  materialProperties: Wne,
  flaws: Kne,
  modPorts: Yne,
  movement: Xne,
  movementAbbreviations: Jne,
  distanceUnits: MB,
  distanceAbbreviations: Zne,
  visionUnits: Qne,
  objectTypes: xne,
  objectTypesPlural: eie,
  preparedStates: tie,
  psionicDisciplines: sie,
  rangeDescriptors: nie,
  rangeValues: iie,
  repairTools: lie,
  resourceRecoveryOptions: rie,
  rollModes: oie,
  rollTypes: aie,
  saveDCOptions: cie,
  senses: uie,
  scrollData: fie,
  shieldProperties: die,
  shieldTypes: pie,
  shieldBaseACBonus: mie,
  spellBookTypes: hie,
  spellComponents: gie,
  spellComponentAbbreviations: bie,
  spellLevels: _ie,
  spellLevelCost: yie,
  spellSchools: vie,
  skills: kie,
  skillCriticalTables: wie,
  skillFumbleTables: $ie,
  skillDefaultAbilities: Aie,
  skillSpecialties: Eie,
  targetTypes: Sie,
  targetTypesPlural: Cie,
  terrainTypes: Tie,
  timePeriods: Oie,
  timePeriodsPlural: Iie,
  tokenDimensions: Pie,
  tokenHPColors: Mie,
  toolCategories: Fie,
  tools: Rie,
  toolsPlural: Nie,
  weaponCategories: jie,
  weapons: Lie,
  weaponsPlural: Bie,
  weaponAugments: qie,
  weaponProperties: zie,
  breakerProperties: Hie,
  defensiveProperties: Uie,
  energyProperties: Gie,
  versatileOptions: Vie,
  // Function Properties
  // These are purposefully done first
  ...Lse(),
  ...IG(),
  ...PG(),
  ...Hse(),
  ...CG(),
  ...TG(),
  ...OG(),
  ...DG(),
  ...Bse(),
  ...qse(),
  ...Gse(),
  ...Use(),
  ...Wse(),
  ...Kse(),
  ...Yse(),
  ...Xse(),
  PRELOCALIZED_KEYS: Vse
};
zse(Il);
const UE = class UE extends i1 {
  constructor() {
    super("a5e");
    qe(this, "settingsData");
    this.settingsData = null;
  }
  init() {
    const t = "a5e", s = { client: "client", world: "world" }, n = [
      // Actor Settings
      {
        namespace: t,
        key: "automatePrototypeTokenSize",
        options: {
          name: "A5E.settings.automatePrototypeTokenSize",
          hint: "A5E.settings.hints.automatePrototypeTokenSize",
          scope: "world",
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "blindDeathSaves",
        options: {
          name: "A5E.settings.blindDeathSaves",
          hint: "A5E.settings.hints.blindDeathSaves",
          scope: "world",
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "collapseActionList",
        options: {
          name: "A5E.settings.collapseActionList",
          hint: "A5E.settings.hints.collapseActionList",
          scope: s.client,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "conditionFlowDirection",
        options: {
          name: "Condition Interface Flow Direction",
          hint: "Setting this option to 'Row' causes the conditions to flow alphabetically left to right, row by row. Setting this option 'Column' causes the conditions to flow alphabetically top to bottom, column by column.",
          scope: s.client,
          config: !0,
          default: "column",
          choices: {
            row: "Row",
            column: "Column"
          },
          type: String
        }
      },
      {
        namespace: t,
        key: "currencyWeight",
        options: {
          name: "A5E.settings.trackCurrencyWeight",
          hint: "A5E.settings.hints.trackCurrencyWeight",
          scope: s.world,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideDeleteConfirmation",
        options: {
          name: "A5E.settings.hideDeletionConfirmationDialog",
          hint: "A5E.settings.hints.hideDeletionConfirmationDialog",
          scope: s.client,
          config: !0,
          type: Boolean,
          default: !1
        }
      },
      {
        namespace: t,
        key: "hideActorCompendiumSelectionDialog",
        options: {
          name: "A5E.settings.hideActorCompendiumSelectionDialog",
          hint: "A5E.settings.hints.hideActorCompendiumSelectionDialog",
          scope: s.client,
          config: !0,
          type: Boolean,
          default: !1
        }
      },
      {
        namespace: t,
        key: "itemRightClickConfigure",
        options: {
          name: "A5E.settings.itemRightClickConfigure",
          hint: "A5E.settings.hints.itemRightClickConfigure",
          scope: s.client,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "randomizeNPCHitPoints",
        options: {
          name: "A5E.settings.randomizeNPCHitPoints",
          hint: "A5E.settings.hints.randomizeNPCHitPoints",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "reverseAltBehavior",
        options: {
          name: "A5E.settings.reverseAltBehavior",
          hint: "A5E.settings.hints.reverseAltBehavior",
          scope: s.client,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "reverseInitiativeAltBehavior",
        options: {
          name: "A5E.settings.reverseInitiativeAltBehavior",
          hint: "A5E.settings.hints.reverseInitiativeAltBehavior",
          scope: s.client,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "useNPCExpertisePassiveRulesForCharacters",
        options: {
          name: "A5E.settings.useNPCExpertisePassiveRulesForCharacters",
          hint: "A5E.settings.hints.useNPCExpertisePassiveRulesForCharacters",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      // Canvas Settings
      {
        namespace: t,
        key: "automateVisionRules",
        options: {
          name: "A5E.settings.automateVisionRules",
          hint: "A5E.settings.hints.automateVisionRules",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "visionRulesApplyToCharactersOnly",
        options: {
          name: "A5E.settings.visionRulesApplyToCharactersOnly",
          hint: "A5E.settings.hints.visionRulesApplyToCharactersOnly",
          scope: s.world,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "placeItemTemplateDefault",
        options: {
          name: "A5E.settings.placeItemTemplateDefault",
          hint: "A5E.settings.hints.placeItemTemplateDefault",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      // Effects
      {
        namespace: t,
        key: "automatedConditions",
        options: {
          name: "A5E.settings.automateConditions",
          hint: "A5E.settings.hints.automateConditions",
          scope: s.world,
          config: !0,
          type: Array,
          default: Object.keys(Il.conditions)
        }
      },
      {
        namespace: t,
        key: "automateBloodiedApplication",
        options: {
          name: "A5E.settings.automateBloodiedApplication",
          hint: "A5E.settings.hints.automateBloodiedApplication",
          scope: s.world,
          config: !0,
          type: Boolean,
          default: !0
        }
      },
      {
        namespace: t,
        key: "automateUnconsciousApplication",
        options: {
          name: "A5E.settings.automateUnconsciousApplication",
          hint: "A5E.settings.hints.automateUnconsciousApplication",
          scope: s.world,
          config: !0,
          type: Boolean,
          default: !0
        }
      },
      {
        namespace: t,
        key: "enableRadialEffects",
        options: {
          name: "A5E.settings.enableRadialEffects",
          hint: "A5E.settings.hints.enableRadialEffects",
          scope: s.world,
          config: !0,
          type: Boolean,
          default: !0
        }
      },
      {
        namespace: t,
        key: "customConditionIcons",
        options: {
          name: "A5E.settings.customConditionIcons",
          hint: "A5E.settings.hints.customConditionIcons",
          scope: s.world,
          config: !0,
          type: Object,
          default: {}
        }
      },
      {
        namespace: t,
        key: "effectsPanelIconSize",
        options: {
          name: "A5E.settings.effectsPanelIconSize",
          hint: "A5E.settings.hints.effectsPanelIconSize",
          scope: s.client,
          config: !0,
          type: String,
          choices: {
            small: "A5E.settings.effectsPanelIconSizeSmall",
            medium: "A5E.settings.effectsPanelIconSizeMedium",
            large: "A5E.settings.effectsPanelIconSizeLarge"
          },
          default: "medium"
        }
      },
      {
        namespace: t,
        key: "effectsPanelOffset",
        options: {
          name: "A5E.settings.effectsPanelOffset",
          hint: "A5E.settings.hints.effectsPanelOffset",
          scope: s.client,
          config: !0,
          type: Object,
          default: { top: 0, bottom: 0, right: 0 }
        }
      },
      {
        namespace: t,
        key: "showEffectsPanel",
        options: {
          name: "A5E.settings.showEffectsPanel",
          scope: s.client,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "removeActiveEffectsOnLongRest",
        options: {
          name: "A5E.settings.removeActiveEffectsOnLongRest",
          hint: "A5E.settings.hints.removeActiveEffectsOnLongRest",
          scope: s.world,
          config: !0,
          type: Boolean,
          default: !1
        }
      },
      // Chat Card Settings
      {
        namespace: t,
        key: "enableDamageRollColors",
        options: {
          name: "A5E.settings.enableDamageRollColors",
          hint: "A5E.settings.hints.enableDamageRollColors",
          scope: s.client,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideChatDescriptionsByDefault",
        options: {
          name: "A5E.settings.hideChatDescriptionsByDefault",
          hint: "A5E.settings.hints.hideChatDescriptionsByDefault",
          scope: s.client,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideRandomizedHPRolls",
        options: {
          name: "A5E.settings.hideRandomizedHPRolls",
          hint: "A5E.settings.hints.hideRandomizedHPRolls",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "protectRolls",
        options: {
          name: "A5E.settings.protectRolls",
          hint: "A5E.settings.hints.protectRolls",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "terseRollFormulae",
        options: {
          name: "A5E.settings.terseRollFormulae",
          hint: "A5E.settings.hints.terseRollFormulae",
          scope: s.client,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      // Roll Settings
      {
        namespace: t,
        key: "critCalculationMode",
        options: {
          name: "A5E.settings.critCalculationMode",
          hint: "A5E.settings.hints.critCalculationMode",
          scope: s.world,
          config: !0,
          default: "doubleAllDamage",
          type: String,
          choices: {
            doubleAllDamage: "A5E.settings.critDoubleAllDamage",
            doubleDiceDamage: "A5E.settings.critDoubleDiceDamage",
            doubleDiceQuantity: "A5E.settings.critDoubleDiceQuantity",
            doubleDiceQuantityAndMods: "A5E.settings.critDoubleDiceQuantityAndMods",
            maxDamage: "A5E.settings.critMaxDamage",
            maxDamagePlusRoll: "A5E.settings.critMaxDamagePlusRoll"
          }
        }
      },
      {
        namespace: t,
        key: "preventActionRollOnWarning",
        options: {
          name: "A5E.settings.preventActionRollOnWarning",
          hint: "A5E.settings.hints.preventActionRollOnWarning",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      // 5E Specific Settings
      {
        namespace: t,
        key: "5eStyleDeathSaves",
        options: {
          name: "A5E.settings.5eStyleDeathSaves",
          hint: "A5E.settings.hints.5eStyleDeathSaves",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "5eStyleExpertise",
        options: {
          name: "A5E.settings.5eStyleExpertise",
          hint: "A5E.settings.hints.5eStyleExpertise",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "5eStyleJackOfAllTrades",
        options: {
          name: "A5E.settings.5eStyleJackOfAllTrades",
          hint: "A5E.settings.hints.5eStyleJackOfAllTrades",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideA5eSkills",
        options: {
          name: "A5E.settings.hideA5eSkills",
          hint: "A5E.settings.hints.hideA5eSkills",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideBrokenAndDamaged",
        options: {
          name: "A5E.settings.hideBrokenAndDamaged",
          hint: "A5E.settings.hints.hideBrokenAndDamaged",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideExpertiseDice",
        options: {
          name: "A5E.settings.hideExpertiseDice",
          hint: "A5E.settings.hints.hideExpertiseDice",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideSkillSpecialties",
        options: {
          name: "A5E.settings.hideSkillSpecialties",
          hint: "A5E.settings.hints.hideSkillSpecialties",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideSkillCriticalPrompt",
        options: {
          name: "A5E.settings.hideSkillCriticalPrompt",
          hint: "A5E.settings.hints.hideSkillCriticalPrompt",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "replaceFatigueAndStrife",
        options: {
          name: "A5E.settings.replaceFatigueAndStrife",
          hint: "A5E.settings.hints.replaceFatigueAndStrife",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "simpleInitiative",
        options: {
          name: "A5E.settings.simpleInitiative",
          hint: "A5E.settings.hints.simpleInitiative",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "simpleRests",
        options: {
          name: "A5E.settings.simpleRests",
          hint: "A5E.settings.hints.simpleRests",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      // Party Viewer Settings
      {
        namespace: t,
        key: "playersCanAccessPartyViewer",
        options: {
          name: "A5E.settings.playersCanAccessPartyViewer",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "showActorImagesInPartyViewer",
        options: {
          name: "A5E.settings.showActorImagesInPartyViewer",
          scope: s.client,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      // Misc Settings
      {
        namespace: t,
        key: "autoApplyFancySheets",
        options: {
          name: "A5E.settings.autoApplyFancySheets",
          hint: "A5E.settings.hints.autoApplyFancySheets",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "enableCascadingDamageAndHealing",
        options: {
          name: "A5E.settings.enableCascadingDamageAndHealing",
          hint: "A5E.settings.hints.enableCascadingDamageAndHealing",
          scope: s.world,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "cascadingDamageAndHealingDelay",
        options: {
          name: "A5E.settings.cascadingDamageAndHealingDelay",
          hint: "A5E.settings.hints.cascadingDamageAndHealingDelay",
          scope: s.client,
          config: !0,
          default: 350,
          type: Number
        }
      },
      {
        namespace: t,
        key: "gamemasterTitle",
        options: {
          name: "A5E.settings.gamemasterTitle",
          scope: s.world,
          config: !0,
          default: "Narrator",
          type: String
        }
      },
      {
        namespace: t,
        key: "newActionNameType",
        options: {
          name: "A5E.settings.newActionNameType",
          hint: "A5E.settings.hints.newActionNameType",
          scope: s.world,
          config: !0,
          default: "system",
          type: String
        }
      },
      {
        namespace: t,
        key: "showDescriptionOnLimitedPerms",
        options: {
          name: "A5E.settings.showDescriptionOnLimitedPerms",
          hint: "A5E.settings.hints.showDescriptionOnLimitedPerms",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "skillListFlowDirection",
        options: {
          name: "Skill List Flow Direction",
          hint: "Setting this option to 'Row' causes the skills to flow alphabetically left to right, row by row. Setting this option 'Column' causes the skills to flow alphabetically top to bottom, column by column.",
          scope: s.client,
          config: !0,
          default: "row",
          choices: {
            row: "Row",
            column: "Column"
          },
          type: String
        }
      },
      // VRC Settings
      {
        namespace: t,
        key: "showVRCProficiencies",
        options: {
          name: "A5E.settings.showVRCProficiencies",
          hint: "A5E.settings.hints.showVRCProficiencies",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "showVRCSpecialties",
        options: {
          name: "A5E.settings.showVRCSpecialties",
          hint: "A5E.settings.hints.showVRCSpecialties",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "showVRCSkills",
        options: {
          name: "A5E.settings.showVRCSkills",
          hint: "A5E.settings.hints.showVRCSkills",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "showVRCTechLevel",
        options: {
          name: "A5E.settings.showVRCTechLevel",
          hint: "A5E.settings.hints.showVRCTechLevel",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "showVRCPsionicDisciplines",
        options: {
          name: "A5E.settings.showVRCPsionicDisciplines",
          hint: "A5E.settings.hints.showVRCPsionicDisciplines",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "useCredits",
        options: {
          name: "A5E.settings.useCredits",
          hint: "A5E.settings.hints.useCredits",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "showVRCImplants",
        options: {
          name: "A5E.settings.showVRCImplants",
          hint: "A5E.settings.hints.showVRCImplants",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      // Hidden system settings
      {
        namespace: t,
        key: "systemMigrationVersion",
        options: {
          name: "A5E.settings.systemMigrationVersion",
          scope: s.world,
          config: !1,
          type: String,
          default: ""
        }
      },
      {
        namespace: t,
        key: "worldSchemaVersion",
        options: {
          name: "A5E.settings.worldSchemaVersion",
          scope: s.world,
          config: !1,
          default: tn.LATEST_SCHEMA_VERSION,
          type: Number
        }
      },
      // Encounter builder settings
      {
        namespace: t,
        key: "encounters",
        options: {
          name: "A5e.settings.encounters",
          scope: s.world,
          config: !1,
          type: Object,
          default: {
            encounters: {},
            templates: {}
          }
        }
      },
      // Party Sheet Settings
      {
        namespace: t,
        key: "parties",
        options: {
          name: "A5E.settings.parties",
          scope: s.world,
          config: !1,
          default: {
            "5Di3aRnZbNtrXq0K": {
              name: "New Party",
              actors: [],
              isLocked: !1
            }
          },
          type: Object
        }
      }
    ];
    this.registerAll(n, !1), this.settingsData = n;
  }
};
u(UE, "A5eGameSettings");
let p0 = UE;
const _c = new p0();
function Wie(i, e, t) {
  return i >= 63072e3 ? `${Math.floor(i / 31536e3)} ${K("A5E.DurationYearPlural")}` : i >= 31536e3 ? `1 ${K("A5E.DurationYear")}` : i >= 1209600 ? `${Math.floor(i / 604800)} ${K("A5E.DurationWeekPlural")}` : i > 604800 ? `1 ${K("A5E.DurationWeek")}` : i >= 172800 ? `${Math.floor(i / 86400)} ${K("A5E.DurationDayPlural")}` : i > 7200 ? `${Math.floor(i / 3600)} ${K("A5E.DurationHourPlural")}` : i > 120 ? `${Math.floor(i / 60)} ${K("A5E.DurationMinutePlural")}` : i >= 12 ? `${Math.floor(i / 6)} ${K("A5E.DurationRoundPlural")}` : i >= 6 ? `1 ${K("A5E.DurationRound")}` : i >= 2 ? `${i} ${K("A5E.DurationSecondPlural")}` : i === 1 ? `1 ${K("A5E.DurationSecond")}` : K(e === 0 && t === 1 ? "Start of Turn" : "End of Turn");
}
u(Wie, "getFormattedTimeFromSeconds");
function Kie(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      var o;
      e = E("div"), t = E("li"), s = E("img"), b(s, "class", "a5e-effect-item__icon svelte-s6ct41"), ze(s.src, n = /*img*/
      i[2]) || b(s, "src", n), b(
        s,
        "alt",
        /*name*/
        i[4]
      ), Z(
        s,
        "a5e-effect-item__icon--svg",
        /*img*/
        (o = i[2]) == null ? void 0 : o.endsWith(".svg")
      ), b(t, "class", "a5e-effect-item svelte-s6ct41"), b(
        t,
        "data-tooltip",
        /*tooltip*/
        i[5]
      ), b(t, "data-tooltip-direction", "LEFT"), b(t, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--effect-summary"), G(e, "--strife", "'" + /*strife*/
      i[6] + "'"), G(e, "--fatigue", "'" + /*fatigue*/
      i[8] + "'"), G(
        e,
        "--fatigue-col",
        /*colors*/
        i[11][
          /*fatigue*/
          i[8]
        ]
      ), G(
        e,
        "--strife-col",
        /*colors*/
        i[11][
          /*strife*/
          i[6]
        ]
      ), G(e, "--corruption", "'" + /*corruption*/
      i[9] + "'"), G(
        e,
        "--corruption-col",
        /*colors*/
        i[11][
          /*corruption*/
          i[9]
        ]
      ), G(e, "--inebriated", "'" + /*inebriated*/
      i[7] + "'"), G(
        e,
        "--inebriated-col",
        /*colors*/
        i[11][
          /*inebriated*/
          i[7]
        ]
      ), b(e, "class", "svelte-s6ct41"), Z(e, "linked", !!/*linked*/
      i[1]), Z(
        e,
        "corruption-counter",
        /*conditionId*/
        i[0] === "corruption"
      ), Z(
        e,
        "fatigue-counter",
        /*conditionId*/
        i[0] === "fatigue"
      ), Z(
        e,
        "inebriated-counter",
        /*conditionId*/
        i[0] === "inebriated"
      ), Z(
        e,
        "strife-counter",
        /*conditionId*/
        i[0] === "strife"
      );
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(t, s), l || (r = [
        W(
          t,
          "click",
          /*click_handler*/
          i[15]
        ),
        W(
          t,
          "auxclick",
          /*auxclick_handler*/
          i[16]
        )
      ], l = !0);
    },
    p(o, [a]) {
      var c;
      a & /*img*/
      4 && !ze(s.src, n = /*img*/
      o[2]) && b(s, "src", n), a & /*name*/
      16 && b(
        s,
        "alt",
        /*name*/
        o[4]
      ), a & /*img*/
      4 && Z(
        s,
        "a5e-effect-item__icon--svg",
        /*img*/
        (c = o[2]) == null ? void 0 : c.endsWith(".svg")
      ), a & /*tooltip*/
      32 && b(
        t,
        "data-tooltip",
        /*tooltip*/
        o[5]
      ), a & /*strife*/
      64 && G(e, "--strife", "'" + /*strife*/
      o[6] + "'"), a & /*fatigue*/
      256 && G(e, "--fatigue", "'" + /*fatigue*/
      o[8] + "'"), a & /*fatigue*/
      256 && G(
        e,
        "--fatigue-col",
        /*colors*/
        o[11][
          /*fatigue*/
          o[8]
        ]
      ), a & /*strife*/
      64 && G(
        e,
        "--strife-col",
        /*colors*/
        o[11][
          /*strife*/
          o[6]
        ]
      ), a & /*corruption*/
      512 && G(e, "--corruption", "'" + /*corruption*/
      o[9] + "'"), a & /*corruption*/
      512 && G(
        e,
        "--corruption-col",
        /*colors*/
        o[11][
          /*corruption*/
          o[9]
        ]
      ), a & /*inebriated*/
      128 && G(e, "--inebriated", "'" + /*inebriated*/
      o[7] + "'"), a & /*inebriated*/
      128 && G(
        e,
        "--inebriated-col",
        /*colors*/
        o[11][
          /*inebriated*/
          o[7]
        ]
      ), a & /*linked*/
      2 && Z(e, "linked", !!/*linked*/
      o[1]), a & /*conditionId*/
      1 && Z(
        e,
        "corruption-counter",
        /*conditionId*/
        o[0] === "corruption"
      ), a & /*conditionId*/
      1 && Z(
        e,
        "fatigue-counter",
        /*conditionId*/
        o[0] === "fatigue"
      ), a & /*conditionId*/
      1 && Z(
        e,
        "inebriated-counter",
        /*conditionId*/
        o[0] === "inebriated"
      ), a & /*conditionId*/
      1 && Z(
        e,
        "strife-counter",
        /*conditionId*/
        o[0] === "strife"
      );
    },
    i: se,
    o: se,
    d(o) {
      o && C(e), l = !1, Me(r);
    }
  };
}
u(Kie, "create_fragment$2G");
function Yie(i, e, t) {
  let s, n, l, r, o, a, { actor: c } = e, { description: f } = e, { conditionId: d } = e, { linked: p = null } = e, { img: m } = e, { _id: g } = e, { name: h } = e;
  function _() {
    const q = c == null ? void 0 : c.effects.get(g), U = (q == null ? void 0 : q.duration) ?? {};
    let H = '<p class="u-flex u-gap-xs u-align-center a5e-tag a5e-tag--active a5e-tag--tight">';
    H += '<i class="fa-regular fa-clock"></i>';
    const { startTime: V, seconds: Y, rounds: J, turns: fe } = U;
    if (!Y && !J && !fe)
      return H += "Infinite</p>", H;
    let ke = Y;
    J === 1 && fe === 1 ? ke = 0 : J >= 1 && (ke = J * 6), ke ?? (ke = 0);
    const ee = V + ke - game.time.worldTime;
    return ee <= 0 && !fe ? '<p class="a5e-tag a5e-tag--red a5e-tag--tight">Expired</p>' : (H += `${Y ? "Remaining: " : ""} ${Wie(ee, J, fe)}`, H += "</p>", H);
  }
  u(_, "getEffectDuration");
  function y() {
    let q = '<div class="u-flex u-flex-row-reverse u-gap-md u-text-xs">';
    return q += s, d ? q += `<p class="a5e-tag a5e-tag--active a5e-tag--tight">
                Condition
                </p>` : q += `<p class="a5e-tag a5e-tag--active a5e-tag--tight">
                Active Effect
                </p>`, p && (q += `<p class="a5e-tag a5e-tag--active a5e-tag--tight">
                Applied by: ${M == null ? void 0 : M[p]}
                </p>`), q += "</div>", q;
  }
  u(y, "getEffectNotes");
  function v(q) {
    if (f) return f;
    const { corruption: U, fatigue: H, inebriated: V, strife: Y } = q.system.attributes;
    return d === "corruption" ? K(`A5E.tracks.corruption.hints.${U}`) : h === K("A5E.Exhaustion") ? K(`A5E.tracks.exhaustion.hints.${H}`) : d === "fatigue" ? K(`A5E.tracks.fatigue.hints.${H}`) : d === "inebriated" ? K(`A5E.tracks.inebriated.hints.${V}`) : d === "strife" ? K(`A5E.tracks.strife.hints.${Y}`) : "";
  }
  u(v, "getEffectDescription");
  function k(q) {
    const { corruption: U, fatigue: H, inebriated: V, strife: Y } = q.system.attributes;
    return d === "corruption" ? `${h} (${U}) ` : d === "fatigue" ? `${h} (${H}) ` : d === "inebriated" ? `${h} (${V}) ` : d === "strife" ? `${h} (${Y}) ` : h;
  }
  u(k, "getEffectName");
  function S() {
    return p ? "" : d === "corruption" || d === "fatigue" || d === "inebriated" || d === "strife" ? `
                <small class="a5e-tooltip__note">
                    Right click to remove a level of ${d}.
                </small>
            ` : `
            <small class="a5e-tooltip__note">
                Right click the icon to remove this ${d ? "condition" : "effect"}.
            </small>
        `;
  }
  u(S, "getEffectRemovalNote");
  const D = ft(), I = {
    1: "#919f00",
    2: "#a09200",
    3: "#af8300",
    4: "#bd7100",
    5: "#cb5c00",
    6: "#d63f00",
    7: "#e00006"
  }, { conditions: M } = CONFIG.A5E, L = Hooks.on("updateWorldTime", () => t(14, s = _()));
  Qt(() => Hooks.off("updateWorldTime", L));
  const B = /* @__PURE__ */ u(() => D("increaseCounter", g), "click_handler"), z = /* @__PURE__ */ u(() => p ?? D("deleteEffect", g), "auxclick_handler");
  return i.$$set = (q) => {
    "actor" in q && t(12, c = q.actor), "description" in q && t(13, f = q.description), "conditionId" in q && t(0, d = q.conditionId), "linked" in q && t(1, p = q.linked), "img" in q && t(2, m = q.img), "_id" in q && t(3, g = q._id), "name" in q && t(4, h = q.name);
  }, i.$$.update = () => {
    i.$$.dirty & /*actor*/
    4096 && t(14, s = _()), i.$$.dirty & /*actor*/
    4096 && t(9, n = (c == null ? void 0 : c.system.attributes.corruption) ?? 0), i.$$.dirty & /*actor*/
    4096 && t(8, l = (c == null ? void 0 : c.system.attributes.fatigue) ?? 0), i.$$.dirty & /*actor*/
    4096 && t(7, r = (c == null ? void 0 : c.system.attributes.inebriated) ?? 0), i.$$.dirty & /*actor*/
    4096 && t(6, o = (c == null ? void 0 : c.system.attributes.strife) ?? 0), i.$$.dirty & /*actor, duration*/
    20480 && t(5, a = `
        <h3 class="a5e-tooltip__heading">${k(c)}</h3>
        ${v(c)}
        ${S()}
        ${y()}
    `);
  }, [
    d,
    p,
    m,
    g,
    h,
    a,
    o,
    r,
    l,
    n,
    D,
    I,
    c,
    f,
    s,
    B,
    z
  ];
}
u(Yie, "instance$2x");
const VE = class VE extends re {
  constructor(e) {
    super(), oe(this, e, Yie, Kie, le, {
      actor: 12,
      description: 13,
      conditionId: 0,
      linked: 1,
      img: 2,
      _id: 3,
      name: 4
    });
  }
};
u(VE, "A5EEffectsPanelEffect");
let m0 = VE;
function UP(i, e, t) {
  const s = i.slice();
  return s[21] = e[t].description, s[22] = e[t].flags, s[23] = e[t].img, s[24] = e[t]._id, s[25] = e[t].name, s[26] = e[t].statuses, s;
}
u(UP, "get_each_context$10");
function VP(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r = ue(
    /*effects*/
    i[2]
  );
  const o = /* @__PURE__ */ u((a) => (
    /*_id*/
    a[24]
  ), "get_key");
  for (let a = 0; a < r.length; a += 1) {
    let c = UP(i, r, a), f = o(c);
    n.set(f, s[a] = WP(f, c));
  }
  return {
    c() {
      e = E("article"), t = E("ul");
      for (let a = 0; a < s.length; a += 1)
        s[a].c();
      b(t, "class", "a5e-effect-list svelte-1jhqpi"), b(e, "id", "a5e-effects-panel"), b(e, "class", "a5e-effects-panel svelte-1jhqpi"), G(
        e,
        "--top",
        /*panelTop*/
        i[7] + "px"
      ), G(
        e,
        "--left",
        /*panelLeft*/
        i[6] + "px"
      ), G(
        e,
        "--bottom",
        /*panelBottom*/
        i[5] + "px"
      );
    },
    m(a, c) {
      T(a, e, c), A(e, t);
      for (let f = 0; f < s.length; f += 1)
        s[f] && s[f].m(t, null);
      l = !0;
    },
    p(a, c) {
      c & /*$actor, effects, removeEffect, increaseCounter, maxIconsPerColumn, iconSize*/
      4886 && (r = ue(
        /*effects*/
        a[2]
      ), ae(), s = Lt(s, c, o, 1, a, r, n, t, cn, WP, null, UP), ce()), (!l || c & /*panelTop*/
      128) && G(
        e,
        "--top",
        /*panelTop*/
        a[7] + "px"
      ), (!l || c & /*panelLeft*/
      64) && G(
        e,
        "--left",
        /*panelLeft*/
        a[6] + "px"
      ), (!l || c & /*panelBottom*/
      32) && G(
        e,
        "--bottom",
        /*panelBottom*/
        a[5] + "px"
      );
    },
    i(a) {
      if (!l) {
        for (let c = 0; c < r.length; c += 1)
          w(s[c]);
        l = !0;
      }
    },
    o(a) {
      for (let c = 0; c < s.length; c += 1)
        O(s[c]);
      l = !1;
    },
    d(a) {
      a && C(e);
      for (let c = 0; c < s.length; c += 1)
        s[c].d();
    }
  };
}
u(VP, "create_if_block$1w");
function WP(i, e) {
  var c, f;
  let t, s, n, l, r;
  function o() {
    return (
      /*deleteEffect_handler*/
      e[15](
        /*_id*/
        e[24]
      )
    );
  }
  u(o, "deleteEffect_handler");
  function a() {
    return (
      /*increaseCounter_handler*/
      e[16](
        /*_id*/
        e[24]
      )
    );
  }
  return u(a, "increaseCounter_handler"), s = new m0({
    props: {
      actor: (
        /*$actor*/
        e[1]
      ),
      description: (
        /*description*/
        e[21]
      ),
      img: (
        /*img*/
        e[23]
      ),
      _id: (
        /*_id*/
        e[24]
      ),
      name: (
        /*name*/
        e[25]
      ),
      conditionId: (
        /*statuses*/
        e[26].first()
      ),
      linked: (
        /*flags*/
        ((f = (c = e[22]) == null ? void 0 : c.a5e) == null ? void 0 : f.source) ?? null
      )
    }
  }), s.$on("deleteEffect", o), s.$on("increaseCounter", a), {
    key: i,
    first: null,
    c() {
      t = $e(), n = E("div"), j(s.$$.fragment), G(n, "display", "contents"), G(n, "--icon-size", l = /*effects*/
      e[2].length > /*maxIconsPerColumn*/
      e[12] ? (
        /*iconSize*/
        e[4][0]
      ) : (
        /*iconSize*/
        e[4][1]
      )), this.first = t;
    },
    m(d, p) {
      T(d, t, p), T(d, n, p), R(s, n, null), r = !0;
    },
    p(d, p) {
      var g, h;
      e = d, p & /*effects, iconSize*/
      20 && l !== (l = /*effects*/
      e[2].length > /*maxIconsPerColumn*/
      e[12] ? (
        /*iconSize*/
        e[4][0]
      ) : (
        /*iconSize*/
        e[4][1]
      )) && G(n, "--icon-size", l);
      const m = {};
      p & /*$actor*/
      2 && (m.actor = /*$actor*/
      e[1]), p & /*effects*/
      4 && (m.description = /*description*/
      e[21]), p & /*effects*/
      4 && (m.img = /*img*/
      e[23]), p & /*effects*/
      4 && (m._id = /*_id*/
      e[24]), p & /*effects*/
      4 && (m.name = /*name*/
      e[25]), p & /*effects*/
      4 && (m.conditionId = /*statuses*/
      e[26].first()), p & /*effects*/
      4 && (m.linked = /*flags*/
      ((h = (g = e[22]) == null ? void 0 : g.a5e) == null ? void 0 : h.source) ?? null), s.$set(m);
    },
    i(d) {
      r || (w(s.$$.fragment, d), r = !0);
    },
    o(d) {
      O(s.$$.fragment, d), r = !1;
    },
    d(d) {
      d && C(t), d && s && C(n), N(s, d);
    }
  };
}
u(WP, "create_each_block$10");
function Xie(i) {
  let e, t, s = (
    /*token*/
    i[0] && /*$actor*/
    i[1] && /*effects*/
    i[2].length && VP(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, [l]) {
      /*token*/
      n[0] && /*$actor*/
      n[1] && /*effects*/
      n[2].length ? s ? (s.p(n, l), l & /*token, $actor, effects*/
      7 && w(s, 1)) : (s = VP(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(Xie, "create_fragment$2F");
function Jie() {
  var s;
  const i = parseFloat(((s = document.getElementsByTagName("html").style) == null ? void 0 : s.fontSize) ?? 16), { clientHeight: e } = document.documentElement;
  return (e - 5 - 8 * i - 2.5 * i) / (3.25 * i);
}
u(Jie, "getMaxEffectIconsPerColumn");
function jg(i) {
  return i * parseFloat(getComputedStyle(document.documentElement).fontSize);
}
u(jg, "convertRemToPixels");
function Zie(i) {
  if (i === "small") return ["2rem", "2rem"];
  if (i === "medium") return ["2rem", "2.5rem"];
  if (i === "large") return ["2.5rem", "3rem"];
}
u(Zie, "getIconSize");
function Qie(i, e, t) {
  var z, q;
  let s, n, l, r, o, a, c, f = se, d = /* @__PURE__ */ u(() => (f(), f = Xt(o, (U) => t(1, c = U)), o), "$$subscribe_actor"), p, m;
  i.$$.on_destroy.push(() => f());
  function g(U) {
    var Y, J;
    const H = c.effects.get(U), V = H.statuses;
    if (V.size === 1) {
      if ((Y = M[V.first()]) != null && Y.some((ee) => I.includes(ee))) return;
      const fe = V.first(), ke = H.img;
      return (J = k == null ? void 0 : k.object) == null ? void 0 : J._removeStatusEffect({ id: fe, src: ke });
    }
    H.delete();
  }
  u(g, "removeEffect");
  function h(U) {
    var Y;
    const H = c.effects.get(U), V = H.statuses;
    if (V.size === 1 && ["corruption", "fatigue", "inebriated", "strife"].includes(V.first())) {
      const J = V.first(), fe = H.img;
      return (Y = k == null ? void 0 : k.object) == null ? void 0 : Y._addStatusEffect({ id: J, src: fe });
    }
  }
  u(h, "increaseCounter");
  function _() {
    var U;
    return o == null || o.destroy(), !k || !(k != null && k.actor) ? null : new Zt((k == null ? void 0 : k.actor) ?? ((U = game.user) == null ? void 0 : U.character) ?? null);
  }
  u(_, "getReactiveActor");
  let y = _c.getStore("effectsPanelOffset");
  pe(i, y, (U) => t(14, m = U));
  let v = _c.getStore("effectsPanelIconSize");
  pe(i, v, (U) => t(13, p = U));
  let k = ((z = canvas.tokens.controlled.at(0)) == null ? void 0 : z.document) ?? null;
  const S = Jie(), D = Hooks.on("controlToken", () => {
    var U;
    t(0, k = ((U = canvas.tokens.controlled.at(0)) == null ? void 0 : U.document) ?? null);
  });
  Qt(() => {
    Hooks.off("controlToken", D);
  });
  let I = ((q = k == null ? void 0 : k.object) == null ? void 0 : q._getActiveConditions()) ?? [];
  const M = CONFIG.statusEffects.reduce(
    (U, H) => {
      var V;
      return (V = H == null ? void 0 : H.statuses) != null && V.length && H.statuses.forEach((Y) => {
        U[Y] ?? (U[Y] = []), U[Y].push(H.id);
      }), U;
    },
    {}
  ), L = /* @__PURE__ */ u((U) => g(U), "deleteEffect_handler"), B = /* @__PURE__ */ u((U) => h(U), "increaseCounter_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$panelOffset*/
    16384 && t(7, s = jg(4) + (m.top ?? 0)), i.$$.dirty & /*$panelOffset*/
    16384 && t(6, n = jg(-0.5) - (m.right ?? 0)), i.$$.dirty & /*$panelOffset*/
    16384 && t(5, l = jg(4) + 5 + (m.bottom ?? 0)), i.$$.dirty & /*$panelIconSize*/
    8192 && t(4, r = Zie(p)), i.$$.dirty & /*token*/
    1 && d(t(3, o = _())), i.$$.dirty & /*$actor*/
    2 && t(2, a = [...(c == null ? void 0 : c.temporaryEffects) || []].filter((U) => {
      var H;
      return !((H = U.statuses.first()) != null && H.startsWith("generic"));
    }).sort((U, H) => U.name.localeCompare(H.name)));
  }, [
    k,
    c,
    a,
    o,
    r,
    l,
    n,
    s,
    g,
    h,
    y,
    v,
    S,
    p,
    m,
    L,
    B
  ];
}
u(Qie, "instance$2w");
const WE = class WE extends re {
  constructor(e) {
    super(), oe(this, e, Qie, Xie, le, {});
  }
};
u(WE, "A5EEffectsPanel");
let h0 = WE;
function xie() {
  const i = document.body.querySelector("#ui-right");
  i && new h0({ target: i });
}
u(xie, "renderEffectsPanel");
function ele() {
  (game.settings.get("a5e", "showEffectsPanel") ?? !0) && xie();
}
u(ele, "canvasReady");
function tle(i, e, t) {
  e.fromCompendium || sle(i, t);
}
u(tle, "createActor");
async function sle(i, e) {
  if (game.user.id !== e || i.items.find((l) => l.type === "maneuver" && l.system.degree === 0)) return;
  const n = [
    "Compendium.a5e.a5e-maneuvers.9umrahwm68f81d7l",
    "Compendium.a5e.a5e-maneuvers.jewmp4pzrg9cdui9",
    "Compendium.a5e.a5e-maneuvers.c0bv7fsy2akld5lp",
    "Compendium.a5e.a5e-maneuvers.zzg7j7cb0vkgctwi",
    "Compendium.a5e.a5e-maneuvers.210ihnnejao46r20",
    "Compendium.a5e.a5e-maneuvers.md35qozzy2fxy2o6"
  ];
  try {
    const l = await Promise.all(
      n.map(async (r) => {
        const o = await fromUuid(r);
        return o._stats.compendiumSource = r, o;
      })
    );
    await i.createEmbeddedDocuments("Item", l), console.info(`Added Manuevers to ${i.name}`);
  } catch (l) {
    console.error(l), console.error(`Error while adding Manuevers to ${i.name}`);
  }
}
u(sle, "addBasicManuevers");
async function nle(i, e) {
  var r, o;
  const { actor: t } = i, s = game.users.get(e);
  if (!t || !game.user.isGM || game.user !== s || t.type !== "npc" || !game.settings.get("a5e", "randomizeNPCHitPoints") || (o = (r = t.flags) == null ? void 0 : r.a5e) != null && o.disableRandomizedHP) return;
  const { hitPointFormula: n } = t;
  if (n === null) return;
  const l = new Roll(n);
  game.settings.get("a5e", "hideRandomizedHPRolls") ? await l.evaluate() : await l.toMessage(
    { flavor: `Rolling hit points for ${i.name}.` },
    { rollMode: "gmroll" }
  ), t.update({
    "system.attributes.hp": {
      baseMax: l.total,
      value: l.total
    }
  });
}
u(nle, "rollTokenHitDie");
async function ile(i, e, t) {
  nle(i, t);
}
u(ile, "createToken");
const KE = class KE extends Sn {
  initialize() {
    this.filters.add((e) => e.system.favorite);
  }
};
u(KE, "FavoriteMapReducer");
let g0 = KE;
const YE = class YE extends Sn {
  initialize() {
    this.filters.add(
      (e) => [
        "archetype",
        "feature",
        "background",
        "culture",
        "destiny",
        "heritage",
        "class",
        "subclass"
      ].includes(e.type)
    ), this.sort.set((e, t) => e.sort - t.sort), this._types = {}, Object.keys(CONFIG.A5E.featureTypes).forEach((e) => {
      this._types[e] = this.derived.create(e);
    }), Object.entries(this._types).forEach(([e, t]) => {
      t.filters.add((s) => s.system.featureType === e || s.type === e || s.type === "archetype" && e === "class");
    }), this._types.Uncategorized = this.derived.create("uncategorized"), this._types.Uncategorized.filters.add((e) => e.system.featureType === "");
  }
};
u(YE, "FeatureMapReducer");
let b0 = YE;
const XE = class XE extends Sn {
  initialize() {
    this.filters.add((e) => e.type === "maneuver"), this.sort.set((e, t) => e.sort - t.sort), this._degrees = {}, Object.keys(CONFIG.A5E.maneuverDegrees).forEach((e) => {
      this._degrees[e] = this.derived.create(e);
    }), Object.entries(this._degrees).forEach(([e, t]) => {
      t.filters.add((s) => parseInt(s.system.degree, 10) === Number(e));
    });
  }
};
u(XE, "ManeuverMapReducer");
let _0 = XE;
const JE = class JE extends Sn {
  initialize() {
    this.filters.add((e) => e.type === "object"), this.sort.set((e, t) => e.sort - t.sort), this._types = {}, Object.keys(CONFIG.A5E.objectTypes).forEach((e) => {
      this._types[e] = this.derived.create(e);
    }), Object.entries(this._types).forEach(([e, t]) => {
      if (e === "armor") {
        t.filters.add(
          (s) => !s.system.containerId && ["armor", "shield", "helm"].includes(s.system.objectType)
        );
        return;
      }
      t.filters.add((s) => {
        var n;
        return s.system.objectType === e && !((n = s.system) != null && n.containerId);
      });
    }), delete this._types.shield, delete this._types.helm, this._types.Uncategorized = this.derived.create("uncategorized"), this._types.Uncategorized.filters.add((e) => e.system.objectType === "");
  }
};
u(JE, "ObjectMapReducer");
let y0 = JE;
const ZE = class ZE extends Sn {
  initialize() {
    var t;
    this.filters.add((s) => s.type === "spell"), this.sort.set((s, n) => s.sort - n.sort), this._books = {};
    const e = (t = [...this.data][0]) == null ? void 0 : t.parent;
    e && (this._books.none = this.derived.create("none"), [...e.spellBooks.keys()].forEach((s) => {
      var n;
      (n = this._books)[s] ?? (n[s] = this.derived.create(s));
    }), Object.entries(this._books).forEach(([s, n]) => {
      n.filters.add((l) => (l.system.spellBook ? l.system.spellBook : "none") === s), n._levels = {}, Object.keys(CONFIG.A5E.spellLevels).forEach((l) => {
        n._levels[l] = n.derived.create(l);
      }), Object.entries(n._levels).forEach(([l, r]) => {
        r.filters.add((o) => parseInt(o.system.level, 10) === parseInt(l, 10));
      });
    }));
  }
};
u(ZE, "SpellMapReducer");
let v0 = ZE;
var Vf, Wf, Kf, Yf, Xf, Jf;
const QE = class QE extends Zt {
  constructor(t, s) {
    super(t, s);
    x(this, Vf);
    x(this, Wf);
    x(this, Kf);
    x(this, Yf);
    x(this, Xf);
    x(this, Jf);
    Ae(this, Vf, this.embedded.create(ActiveEffect, $b)), Ae(this, Wf, this.embedded.create(Item, g0)), Ae(this, Kf, this.embedded.create(Item, b0)), Ae(this, Yf, this.embedded.create(Item, _0)), Ae(this, Xf, this.embedded.create(Item, y0)), Ae(this, Jf, this.embedded.create(Item, v0));
  }
  get activeEffects() {
    return P(this, Vf);
  }
  get favorites() {
    return P(this, Wf);
  }
  get features() {
    return P(this, Kf);
  }
  get maneuvers() {
    return P(this, Yf);
  }
  get objects() {
    return P(this, Xf);
  }
  get spells() {
    return P(this, Jf);
  }
};
Vf = new WeakMap(), Wf = new WeakMap(), Kf = new WeakMap(), Yf = new WeakMap(), Xf = new WeakMap(), Jf = new WeakMap(), u(QE, "ActorDocument");
let k0 = QE;
function Xo(i, e) {
  const t = i.overrides ?? {};
  return !!foundry.utils.getProperty(t, e);
}
u(Xo, "determineIfPropertyModifiedByEffect");
function KP(i, e, t) {
  const s = i.slice();
  return s[16] = e[t], s;
}
u(KP, "get_each_context$$");
function YP(i, e, t) {
  const s = i.slice();
  return s[19] = e[t][0], s[20] = e[t][1], s;
}
u(YP, "get_each_context_1$c");
function lle(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input svelte-1x9ef"), b(e, "type", "text"), b(e, "name", "system.bonuses.maneuverDC"), e.value = t = /*$actor*/
      i[0].system.bonuses.maneuverDC, e.disabled = /*disableManeuverDC*/
      i[2];
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*$actor*/
      1 && t !== (t = /*$actor*/
      l[0].system.bonuses.maneuverDC) && e.value !== t && (e.value = t), r & /*disableManeuverDC*/
      4 && (e.disabled = /*disableManeuverDC*/
      l[2]);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(lle, "create_default_slot_3$n");
function rle(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input svelte-1x9ef"), b(e, "type", "text"), b(e, "name", "system.bonuses.spellDC"), e.value = t = /*$actor*/
      i[0].system.bonuses.spellDC, e.disabled = /*disableSpellDC*/
      i[1];
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*$actor*/
      1 && t !== (t = /*$actor*/
      l[0].system.bonuses.spellDC) && e.value !== t && (e.value = t), r & /*disableSpellDC*/
      2 && (e.disabled = /*disableSpellDC*/
      l[1]);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(rle, "create_default_slot_2$q");
function ole(i) {
  let e, t, s, n, l;
  return t = new ie({
    props: {
      heading: "A5E.ManeuverDCBonus",
      showWarning: (
        /*disableManeuverDC*/
        i[2]
      ),
      warning: "A5E.validations.warnings.modifiedByEffect",
      $$slots: { default: [lle] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.SpellDCBonus",
      showWarning: (
        /*disableSpellDC*/
        i[1]
      ),
      warning: "A5E.validations.warnings.modifiedByEffect",
      $$slots: { default: [rle] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("div"), j(t.$$.fragment), s = F(), j(n.$$.fragment), b(e, "class", "global-bonus-container svelte-1x9ef");
    },
    m(r, o) {
      T(r, e, o), R(t, e, null), A(e, s), R(n, e, null), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*disableManeuverDC*/
      4 && (a.showWarning = /*disableManeuverDC*/
      r[2]), o & /*$$scope, $actor, disableManeuverDC*/
      8388613 && (a.$$scope = { dirty: o, ctx: r }), t.$set(a);
      const c = {};
      o & /*disableSpellDC*/
      2 && (c.showWarning = /*disableSpellDC*/
      r[1]), o & /*$$scope, $actor, disableSpellDC*/
      8388611 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(t.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      O(t.$$.fragment, r), O(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && C(e), N(t), N(n);
    }
  };
}
u(ole, "create_default_slot_1$y");
function XP(i) {
  let e, t, s, n, l, r, o, a, c, f, d;
  function p() {
    return (
      /*click_handler*/
      i[11](
        /*id*/
        i[19],
        /*bonusType*/
        i[16]
      )
    );
  }
  u(p, "click_handler");
  function m() {
    return (
      /*click_handler_1*/
      i[12](
        /*id*/
        i[19],
        /*bonusType*/
        i[16]
      )
    );
  }
  u(m, "click_handler_1");
  function g() {
    return (
      /*click_handler_2*/
      i[13](
        /*id*/
        i[19],
        /*bonusType*/
        i[16]
      )
    );
  }
  return u(g, "click_handler_2"), {
    c() {
      e = E("ul"), t = E("li"), s = E("button"), n = F(), l = E("li"), r = E("button"), o = F(), a = E("li"), c = E("button"), b(s, "class", "action-button fas fa-cog svelte-1x9ef"), b(s, "data-tooltip", "A5E.ButtonToolTipConfigure"), b(s, "data-tooltip-direction", "UP"), b(r, "class", "action-button fa-solid fa-clone svelte-1x9ef"), b(r, "data-tooltip", "A5E.ButtonToolTipDuplicate"), b(r, "data-tooltip-direction", "UP"), b(c, "class", "action-button delete-button fas fa-trash svelte-1x9ef"), b(c, "data-tooltip", "A5E.ButtonToolTipDelete"), b(c, "data-tooltip-direction", "UP"), b(e, "class", "bonus-buttons svelte-1x9ef");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(t, s), A(e, n), A(e, l), A(l, r), A(e, o), A(e, a), A(a, c), f || (d = [
        W(s, "click", Ve(p)),
        W(r, "click", Ve(m)),
        W(c, "click", Ve(g))
      ], f = !0);
    },
    p(h, _) {
      i = h;
    },
    d(h) {
      h && C(e), f = !1, Me(d);
    }
  };
}
u(XP, "create_if_block$1v");
function JP(i, e) {
  let t, s, n, l, r, o = (
    /*bonus*/
    (e[20].label || /*getDefaultBonusName*/
    e[5](
      /*bonusType*/
      e[16]
    )) + ""
  ), a, c, f = !Xo(
    /*$actor*/
    e[0],
    `system.bonuses.${/*bonusType*/
    e[16]}.${/*id*/
    e[19]}`
  ), d, p, m, g = f && XP(e);
  function h() {
    return (
      /*auxclick_handler*/
      e[14](
        /*bonusType*/
        e[16],
        /*id*/
        e[19]
      )
    );
  }
  return u(h, "auxclick_handler"), {
    key: i,
    first: null,
    c() {
      t = E("li"), s = E("img"), l = F(), r = E("h3"), a = Q(o), c = F(), g && g.c(), d = F(), b(s, "class", "a5e-item__img"), ze(s.src, n = /*bonus*/
      e[20].img) || b(s, "src", n), b(s, "alt", ""), b(r, "class", "a5e-item__name"), b(t, "class", "a5e-item a5e-item--bonus"), this.first = t;
    },
    m(_, y) {
      T(_, t, y), A(t, s), A(t, l), A(t, r), A(r, a), A(t, c), g && g.m(t, null), A(t, d), p || (m = W(t, "auxclick", h), p = !0);
    },
    p(_, y) {
      e = _, y & /*$actor*/
      1 && !ze(s.src, n = /*bonus*/
      e[20].img) && b(s, "src", n), y & /*$actor*/
      1 && o !== (o = /*bonus*/
      (e[20].label || /*getDefaultBonusName*/
      e[5](
        /*bonusType*/
        e[16]
      )) + "") && be(a, o), y & /*$actor*/
      1 && (f = !Xo(
        /*$actor*/
        e[0],
        `system.bonuses.${/*bonusType*/
        e[16]}.${/*id*/
        e[19]}`
      )), f ? g ? g.p(e, y) : (g = XP(e), g.c(), g.m(t, d)) : g && (g.d(1), g = null);
    },
    d(_) {
      _ && C(t), g && g.d(), p = !1, m();
    }
  };
}
u(JP, "create_each_block_1$c");
function ale(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l = ue(Object.entries(
    /*$actor*/
    i[0].system.bonuses[
      /*bonusType*/
      i[16]
    ] ?? {}
  ));
  const r = /* @__PURE__ */ u((o) => (
    /*id*/
    o[19]
  ), "get_key");
  for (let o = 0; o < l.length; o += 1) {
    let a = YP(i, l, o), c = r(a);
    s.set(c, t[o] = JP(c, a));
  }
  return {
    c() {
      e = E("ul");
      for (let o = 0; o < t.length; o += 1)
        t[o].c();
      n = F(), b(e, "class", "a5e-item-list");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < t.length; c += 1)
        t[c] && t[c].m(e, null);
      T(o, n, a);
    },
    p(o, a) {
      a & /*rightClickConfigure, $actor, bonusCategories, Object, getDefaultBonusName*/
      417 && (l = ue(Object.entries(
        /*$actor*/
        o[0].system.bonuses[
          /*bonusType*/
          o[16]
        ] ?? {}
      )), t = Lt(t, a, r, 1, o, l, s, e, an, JP, null, YP));
    },
    d(o) {
      o && (C(e), C(n));
      for (let a = 0; a < t.length; a += 1)
        t[a].d();
    }
  };
}
u(ale, "create_default_slot$17");
function ZP(i) {
  let e, t, s;
  function n() {
    return (
      /*func*/
      i[15](
        /*bonusType*/
        i[16]
      )
    );
  }
  return u(n, "func"), e = new De({
    props: {
      headerClasses: Object.values(
        /*$actor*/
        i[0].system.bonuses[
          /*bonusType*/
          i[16]
        ] ?? {}
      ).length ? "a5e-section-header--flat-bottom" : "",
      heading: (
        /*getBonusSectionHeader*/
        i[3](
          /*bonusType*/
          i[16]
        )
      ),
      headerButtons: [
        {
          label: (
            /*getAddButtonLabelForBonus*/
            i[4](
              /*bonusType*/
              i[16]
            )
          ),
          handler: n
        }
      ],
      $$slots: { default: [ale] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-gap", "0");
    },
    m(l, r) {
      T(l, t, r), R(e, t, null), s = !0;
    },
    p(l, r) {
      i = l;
      const o = {};
      r & /*$actor*/
      1 && (o.headerClasses = Object.values(
        /*$actor*/
        i[0].system.bonuses[
          /*bonusType*/
          i[16]
        ] ?? {}
      ).length ? "a5e-section-header--flat-bottom" : ""), r & /*$actor*/
      1 && (o.headerButtons = [
        {
          label: (
            /*getAddButtonLabelForBonus*/
            i[4](
              /*bonusType*/
              i[16]
            )
          ),
          handler: n
        }
      ]), r & /*$$scope, $actor*/
      8388609 && (o.$$scope = { dirty: r, ctx: i }), e.$set(o);
    },
    i(l) {
      s || (w(e.$$.fragment, l), s = !0);
    },
    o(l) {
      O(e.$$.fragment, l), s = !1;
    },
    d(l) {
      l && e && C(t), N(e, l);
    }
  };
}
u(ZP, "create_each_block$$");
function cle(i) {
  let e, t, s, n, l;
  t = new De({
    props: {
      heading: "Global Bonuses",
      hint: "All of the fields in this section accept any values valid in roll formulae.",
      $$slots: { default: [ole] },
      $$scope: { ctx: i }
    }
  });
  let r = ue(
    /*bonusCategories*/
    i[7]
  ), o = [];
  for (let c = 0; c < r.length; c += 1)
    o[c] = ZP(KP(i, r, c));
  const a = /* @__PURE__ */ u((c) => O(o[c], 1, 1, () => {
    o[c] = null;
  }), "out");
  return {
    c() {
      e = E("section"), s = E("div"), j(t.$$.fragment), n = F();
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      G(s, "display", "contents"), G(s, "--a5e-section-body-gap", "0.5rem"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--item-list");
    },
    m(c, f) {
      T(c, e, f), A(e, s), R(t, s, null), A(e, n);
      for (let d = 0; d < o.length; d += 1)
        o[d] && o[d].m(e, null);
      l = !0;
    },
    p(c, [f]) {
      const d = {};
      if (f & /*$$scope, disableSpellDC, $actor, disableManeuverDC*/
      8388615 && (d.$$scope = { dirty: f, ctx: c }), t.$set(d), f & /*Object, $actor, bonusCategories, getBonusSectionHeader, getAddButtonLabelForBonus, rightClickConfigure, getDefaultBonusName*/
      441) {
        r = ue(
          /*bonusCategories*/
          c[7]
        );
        let p;
        for (p = 0; p < r.length; p += 1) {
          const m = KP(c, r, p);
          o[p] ? (o[p].p(m, f), w(o[p], 1)) : (o[p] = ZP(m), o[p].c(), w(o[p], 1), o[p].m(e, null));
        }
        for (ae(), p = r.length; p < o.length; p += 1)
          a(p);
        ce();
      }
    },
    i(c) {
      if (!l) {
        w(t.$$.fragment, c);
        for (let f = 0; f < r.length; f += 1)
          w(o[f]);
        l = !0;
      }
    },
    o(c) {
      O(t.$$.fragment, c), o = o.filter(Boolean);
      for (let f = 0; f < o.length; f += 1)
        O(o[f]);
      l = !1;
    },
    d(c) {
      c && C(e), N(t), Le(o, c);
    }
  };
}
u(cle, "create_fragment$2E");
function ule(i, e, t) {
  let s, n, l;
  function r(k) {
    var S;
    return K(((S = CONFIG.A5E.bonusLabels[k]) == null ? void 0 : S.sectionHeader) ?? k);
  }
  u(r, "getBonusSectionHeader");
  function o(k) {
    var S;
    return K(((S = CONFIG.A5E.bonusLabels[k]) == null ? void 0 : S.addButton) ?? k);
  }
  u(o, "getAddButtonLabelForBonus");
  function a(k) {
    var S;
    return K(((S = CONFIG.A5E.bonusLabels[k]) == null ? void 0 : S.defaultName) ?? k);
  }
  u(a, "getDefaultBonusName");
  const c = de("actor");
  pe(i, c, (k) => t(0, l = k));
  const f = Object.keys(CONFIG.A5E.bonusTypes);
  let d = game.settings.get("a5e", "itemRightClickConfigure") ?? !0;
  const p = /* @__PURE__ */ u(({ target: k }) => te(l, k.name, k.value), "change_handler"), m = /* @__PURE__ */ u(({ target: k }) => te(l, k.name, k.value), "change_handler_1"), g = /* @__PURE__ */ u((k, S) => l.configureBonus(k, S), "click_handler"), h = /* @__PURE__ */ u((k, S) => l.duplicateBonus(k, S), "click_handler_1"), _ = /* @__PURE__ */ u((k, S) => l.deleteBonus(k, S), "click_handler_2"), y = /* @__PURE__ */ u((k, S) => {
    d && !Xo(l, `system.bonuses.${k}.${S}`) && l.configureBonus(S, k);
  }, "auxclick_handler"), v = /* @__PURE__ */ u((k) => l.addBonus(k), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(2, s = Xo(l, "system.bonuses.maneuverDC")), i.$$.dirty & /*$actor*/
    1 && t(1, n = Xo(l, "system.bonuses.spellDC"));
  }, [
    l,
    n,
    s,
    r,
    o,
    a,
    c,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    v
  ];
}
u(ule, "instance$2v");
const xE = class xE extends re {
  constructor(e) {
    super(), oe(this, e, ule, cle, le, {});
  }
};
u(xE, "ActorBonusesPage");
let w0 = xE;
function fle(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), e.value = t = /*resource*/
      i[2].label;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      r & /*resource*/
      4 && t !== (t = /*resource*/
      l[2].label) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(fle, "create_default_slot_6$c");
function QP(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.GenericResourceMaxFormula",
      $$slots: { default: [dle] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, resource, $actor, source*/
      4103 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(QP, "create_if_block_1$_");
function dle(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), e.value = t = /*resource*/
      i[2].max;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      r & /*resource*/
      4 && t !== (t = /*resource*/
      l[2].max) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(dle, "create_default_slot_5$e");
function ple(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.GenericResourceHideMax",
      checked: (
        /*resource*/
        i[2].hideMax ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*resource*/
      4 && (l.checked = /*resource*/
      s[2].hideMax ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(ple, "create_default_slot_4$f");
function mle(i) {
  let e, t, s, n, l;
  e = new ie({
    props: {
      heading: "A5E.Label",
      $$slots: { default: [fle] },
      $$scope: { ctx: i }
    }
  });
  let r = !/*resource*/
  i[2].hideMax && QP(i);
  return n = new ie({
    props: {
      $$slots: { default: [ple] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), r && r.c(), s = F(), j(n.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), r && r.m(o, a), T(o, s, a), R(n, o, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, resource, $actor, source*/
      4103 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c), /*resource*/
      o[2].hideMax ? r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce()) : r ? (r.p(o, a), a & /*resource*/
      4 && w(r, 1)) : (r = QP(o), r.c(), w(r, 1), r.m(s.parentNode, s));
      const f = {};
      a & /*$$scope, resource, $actor, source*/
      4103 && (f.$$scope = { dirty: a, ctx: o }), n.$set(f);
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), w(n.$$.fragment, o), l = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(r), O(n.$$.fragment, o), l = !1;
    },
    d(o) {
      o && (C(t), C(s)), N(e, o), r && r.d(o), N(n, o);
    }
  };
}
u(mle, "create_default_slot_3$m");
function xP(i) {
  let e, t, s, n;
  return e = new ie({
    props: {
      heading: "A5E.ItemRechargeFormula",
      $$slots: { default: [hle] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      heading: "A5E.ItemRechargeThreshold",
      $$slots: { default: [gle] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, resource, $actor, source*/
      4103 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, resource, $actor, source*/
      4103 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(xP, "create_if_block$1u");
function hle(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), e.value = t = /*resource*/
      i[2].recharge.formula, b(e, "placeholder", "1d6");
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_2*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*resource*/
      4 && t !== (t = /*resource*/
      l[2].recharge.formula) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(hle, "create_default_slot_2$p");
function gle(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input u-text-center"), b(e, "type", "number"), e.value = t = /*resource*/
      i[2].recharge.threshold;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_3*/
        i[11]
      ), s = !0);
    },
    p(l, r) {
      r & /*resource*/
      4 && t !== (t = /*resource*/
      l[2].recharge.threshold) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(gle, "create_default_slot_1$x");
function ble(i) {
  let e, t, s, n;
  e = new Ke({
    props: {
      heading: "A5E.RecoverResourceAt",
      options: (
        /*recoveryOptions*/
        i[4]
      ),
      selected: (
        /*resource*/
        i[2].per
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[9]
  );
  let l = (
    /*resource*/
    i[2].per === "recharge" && xP(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), l && l.c(), s = $e();
    },
    m(r, o) {
      R(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      const a = {};
      o & /*resource*/
      4 && (a.selected = /*resource*/
      r[2].per), e.$set(a), /*resource*/
      r[2].per === "recharge" ? l ? (l.p(r, o), o & /*resource*/
      4 && w(l, 1)) : (l = xP(r), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ae(), O(l, 1, 1, () => {
        l = null;
      }), ce());
    },
    i(r) {
      n || (w(e.$$.fragment, r), w(l), n = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(l), n = !1;
    },
    d(r) {
      r && (C(t), C(s)), N(e, r), l && l.d(r);
    }
  };
}
u(ble, "create_default_slot$16");
function _le(i) {
  let e, t, s, n, l, r;
  return e = new De({
    props: {
      $$slots: { default: [mle] },
      $$scope: { ctx: i }
    }
  }), n = new De({
    props: {
      heading: "Recovery Configuration",
      $$slots: { default: [ble] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-padding", "0.75rem"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-margin", "0 0 0.25rem 0"), G(l, "display", "contents"), G(l, "--a5e-section-body-gap", "0.75rem"), G(l, "--a5e-section-padding", "0 0.75rem 0.75rem 0.75rem");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), T(o, l, a), R(n, l, null), r = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*$$scope, resource, $actor, source*/
      4103 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const f = {};
      a & /*$$scope, resource, $actor, source*/
      4103 && (f.$$scope = { dirty: a, ctx: o }), n.$set(f);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && C(s), o && e && C(t), N(e, o), o && n && C(l), N(n, o);
    }
  };
}
u(_le, "create_fragment$2D");
function yle(i, e, t) {
  let s, n, { document: l, source: r } = de("#external").application, { document: o = l, source: a = r } = e;
  const c = o;
  pe(i, c, (y) => t(1, n = y));
  const f = Object.entries(CONFIG.A5E.resourceRecoveryOptions), d = /* @__PURE__ */ u(({ target: y }) => te(n, `system.resources.${a}.label`, y.value), "change_handler"), p = /* @__PURE__ */ u(({ target: y }) => {
    hc(y.value), te(n, `system.resources.${a}.max`, y.value);
  }, "change_handler_1"), m = /* @__PURE__ */ u(({ detail: y }) => {
    te(n, `system.resources.${a}.hideMax`, y);
  }, "updateSelection_handler"), g = /* @__PURE__ */ u((y) => te(n, `system.resources.${a}.per`, y.detail), "updateSelection_handler_1"), h = /* @__PURE__ */ u(({ target: y }) => {
    hc(y.value), te(n, `system.resources.${a}.recharge.formula`, y.value);
  }, "change_handler_2"), _ = /* @__PURE__ */ u(({ target: y }) => te(n, `system.resources.${a}.recharge.threshold`, Number(y.value)), "change_handler_3");
  return i.$$set = (y) => {
    "document" in y && t(5, o = y.document), "source" in y && t(0, a = y.source);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, source*/
    3 && t(2, s = n.system.resources[a]);
  }, [
    a,
    n,
    s,
    c,
    f,
    o,
    d,
    p,
    m,
    g,
    h,
    _
  ];
}
u(yle, "instance$2u");
const eS = class eS extends re {
  constructor(e) {
    super(), oe(this, e, yle, _le, le, { document: 5, source: 0 });
  }
};
u(eS, "GenericActorResourceConfigDialog");
let $0 = eS;
function eM(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y = !/*sheetIsLocked*/
  i[2] && !/*isClassResource*/
  i[6] && tM(i), v = (
    /*showRechargeButton*/
    i[5] && sM(i)
  ), k = (
    /*resource*/
    i[0].hideMax && nM(i)
  );
  function S(M, L) {
    return (
      /*resource*/
      M[0].hideMax ? kle : vle
    );
  }
  u(S, "select_block_type");
  let D = S(i), I = D(i);
  return {
    c() {
      e = E("li"), t = E("header"), s = E("input"), o = F(), y && y.c(), a = F(), v && v.c(), c = F(), f = E("div"), k && k.c(), d = F(), p = E("input"), g = F(), I.c(), b(s, "type", "text"), b(s, "name", n = "system.resources." + /*source*/
      i[1] + ".label"), s.value = l = /*resource*/
      i[0].label, b(s, "class", "a5e-input a5e-input--slim resource-label svelte-60zer"), b(s, "placeholder", r = K(`A5E.Resources${/*source*/
      i[1].capitalize()}`)), s.disabled = /*sheetIsLocked*/
      i[2], b(t, "class", "resource-header svelte-60zer"), b(p, "class", "a5e-input a5e-input--inline-item a5e-input--small resource-number-input svelte-60zer"), b(p, "type", "number"), p.value = m = /*resource*/
      i[0].value, b(p, "placeholder", "0"), b(p, "min", "0"), Z(p, "disable-pointer-events", !/*$actor*/
      i[3].isOwner), b(f, "class", "resource-value-container svelte-60zer"), b(e, "class", "resource svelte-60zer");
    },
    m(M, L) {
      T(M, e, L), A(e, t), A(t, s), A(t, o), y && y.m(t, null), A(t, a), v && v.m(t, null), A(e, c), A(e, f), k && k.m(f, null), A(f, d), A(f, p), A(f, g), I.m(f, null), h || (_ = [
        W(
          s,
          "change",
          /*change_handler*/
          i[12]
        ),
        W(
          p,
          "change",
          /*change_handler_1*/
          i[14]
        )
      ], h = !0);
    },
    p(M, L) {
      L & /*source*/
      2 && n !== (n = "system.resources." + /*source*/
      M[1] + ".label") && b(s, "name", n), L & /*resource*/
      1 && l !== (l = /*resource*/
      M[0].label) && s.value !== l && (s.value = l), L & /*source*/
      2 && r !== (r = K(`A5E.Resources${/*source*/
      M[1].capitalize()}`)) && b(s, "placeholder", r), L & /*sheetIsLocked*/
      4 && (s.disabled = /*sheetIsLocked*/
      M[2]), !/*sheetIsLocked*/
      M[2] && !/*isClassResource*/
      M[6] ? y ? y.p(M, L) : (y = tM(M), y.c(), y.m(t, a)) : y && (y.d(1), y = null), /*showRechargeButton*/
      M[5] ? v ? v.p(M, L) : (v = sM(M), v.c(), v.m(t, null)) : v && (v.d(1), v = null), /*resource*/
      M[0].hideMax ? k ? k.p(M, L) : (k = nM(M), k.c(), k.m(f, d)) : k && (k.d(1), k = null), L & /*resource*/
      1 && m !== (m = /*resource*/
      M[0].value) && p.value !== m && (p.value = m), L & /*$actor*/
      8 && Z(p, "disable-pointer-events", !/*$actor*/
      M[3].isOwner), D === (D = S(M)) && I ? I.p(M, L) : (I.d(1), I = D(M), I && (I.c(), I.m(f, null)));
    },
    d(M) {
      M && C(e), y && y.d(), v && v.d(), k && k.d(), I.d(), h = !1, Me(_);
    }
  };
}
u(eM, "create_if_block$1t");
function tM(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = '<i class="fas fa-gear svelte-60zer"></i>', b(e, "class", "resource-setting svelte-60zer");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*configureResource*/
        i[8]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(tM, "create_if_block_4$n");
function sM(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = '<i class="fas fa-dice svelte-60zer"></i>', b(e, "class", "resource-setting svelte-60zer"), b(e, "data-tooltip", "Recharge Resource"), b(e, "data-tooltip-direction", "UP");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler*/
        i[13]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(sM, "create_if_block_3$s");
function nM(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-button resource-btn fas fa-minus svelte-60zer"), b(e, "type", "button"), e.disabled = t = /*resource*/
      i[0].value === 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "click",
        /*decrementResource*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*resource*/
      1 && t !== (t = /*resource*/
      l[0].value === 0) && (e.disabled = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(nM, "create_if_block_2$F");
function vle(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("span"), e.textContent = "/", t = F(), s = E("input"), b(e, "class", "resource-seperator"), b(s, "type", "number"), b(s, "name", n = "system.resources." + /*source*/
      i[1] + ".max"), s.value = l = mt(
        /*resource*/
        i[0].max ?? 0,
        /*$actor*/
        i[3].getRollData()
      ), b(s, "class", "a5e-input a5e-input--inline-item a5e-input--small resource-number-input svelte-60zer"), b(s, "placeholder", "0"), s.disabled = !0;
    },
    m(r, o) {
      T(r, e, o), T(r, t, o), T(r, s, o);
    },
    p(r, o) {
      o & /*source*/
      2 && n !== (n = "system.resources." + /*source*/
      r[1] + ".max") && b(s, "name", n), o & /*resource, $actor*/
      9 && l !== (l = mt(
        /*resource*/
        r[0].max ?? 0,
        /*$actor*/
        r[3].getRollData()
      )) && s.value !== l && (s.value = l);
    },
    d(r) {
      r && (C(e), C(t), C(s));
    }
  };
}
u(vle, "create_else_block$x");
function kle(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-button resource-btn fas fa-plus svelte-60zer"), b(e, "type", "button");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*incrementResource*/
        i[9]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(kle, "create_if_block_1$Z");
function wle(i) {
  let e, t = (
    /*showResource*/
    i[4] && eM(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, [n]) {
      /*showResource*/
      s[4] ? t ? t.p(s, n) : (t = eM(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    i: se,
    o: se,
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(wle, "create_fragment$2C");
function $le(i, e, t) {
  let s, n, l, r, o, a, { resource: c } = e, { source: f } = e;
  const d = de("actor");
  pe(i, d, (I) => t(3, a = I));
  function p() {
    let I = a.dialogs.genericResources[f];
    I || (wo(d, a.dialogs.genericResources[f] = new gi(a, `${a.name}: Generic Resource Dialog`, $0, { source: f }), a), I = a.dialogs.genericResources[f]), I.render(!0);
  }
  u(p, "configureResource");
  function m() {
    t(0, c.value = Math.max(c.value + 1, 0), c), te(a, `system.resources.${f}.value`, Number(c.value));
  }
  u(m, "incrementResource");
  function g() {
    t(0, c.value = Math.max(c.value - 1, 0), c), te(a, `system.resources.${f}.value`, Number(c.value));
  }
  u(g, "decrementResource");
  function h(I) {
    s ? te(a, `system.resources.classResources.${f}`, Number(I)) : te(a, `system.resources.${f}.value`, Number(I));
  }
  u(h, "updateResourceValue");
  function _(I) {
    return !!(!I && !s || I && c.hideMax || I && n !== 0);
  }
  u(_, "determineResourceVisibility");
  function y(I, M) {
    return !M || c.per !== "recharge" ? !1 : c.hideMax ? !0 : c.value < n;
  }
  u(y, "canRecharge");
  const v = ["primary", "secondary", "tertiary", "quaternary"], k = /* @__PURE__ */ u(({ target: I }) => te(a, I.name, I.value), "change_handler"), S = /* @__PURE__ */ u(() => a.rechargeGenericResource(f), "click_handler"), D = /* @__PURE__ */ u(({ target: I }) => h(I.value), "change_handler_1");
  return i.$$set = (I) => {
    "resource" in I && t(0, c = I.resource), "source" in I && t(1, f = I.source);
  }, i.$$.update = () => {
    var I, M;
    i.$$.dirty & /*resource*/
    1 && t(0, c), i.$$.dirty & /*source*/
    2 && t(6, s = !v.includes(f)), i.$$.dirty & /*resource, $actor*/
    9 && (n = mt(c.max, a.getRollData())), i.$$.dirty & /*$actor*/
    8 && t(2, l = a.isOwner ? ((M = (I = a.flags) == null ? void 0 : I.a5e) == null ? void 0 : M.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*$actor, sheetIsLocked*/
    12 && t(5, r = y(a, l)), i.$$.dirty & /*sheetIsLocked*/
    4 && t(4, o = _(l));
  }, [
    c,
    f,
    l,
    a,
    o,
    r,
    s,
    d,
    p,
    m,
    g,
    h,
    k,
    S,
    D
  ];
}
u($le, "instance$2t");
const tS = class tS extends re {
  constructor(e) {
    super(), oe(this, e, $le, wle, le, { resource: 0, source: 1 });
  }
};
u(tS, "GenericActorResource");
let A0 = tS;
const Ml = Mt({ Alt: !1, Control: !1, Shift: !1 });
function ql(i, { reverseAlt: e = !1 } = {}) {
  const { Shift: t, Control: s, Alt: n } = i, l = game.settings.get("a5e", "reverseAltBehavior");
  let r = t ? CONFIG.A5E.ROLL_MODE.ADVANTAGE : CONFIG.A5E.ROLL_MODE.NORMAL;
  r = s ? CONFIG.A5E.ROLL_MODE.DISADVANTAGE : r;
  let o = l ? !n : n;
  return o = e ? !o : o, {
    skipRollDialog: o,
    rollMode: r
  };
}
u(ql, "getKeyPressAsOptions");
function iM(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("i"), b(t, "class", "track-icon track-icon--description-button fa-regular fa-file-lines svelte-1l5hcrc"), b(t, "data-tooltip", s = `Share ${/*action*/
      i[0] ? "Action" : "Item"} Description`), b(t, "data-tooltip-direction", "UP"), b(e, "class", "track svelte-1l5hcrc");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = W(t, "click", Ve(
        /*showDescription*/
        i[5]
      )), n = !0);
    },
    p(r, o) {
      o & /*action*/
      1 && s !== (s = `Share ${/*action*/
      r[0] ? "Action" : "Item"} Description`) && b(t, "data-tooltip", s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(iM, "create_if_block_1$Y");
function lM(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g;
  return {
    c() {
      e = E("div"), t = E("i"), s = F(), n = E("ul"), l = E("li"), r = E("button"), o = F(), a = E("li"), c = E("button"), f = F(), d = E("li"), p = E("button"), b(t, "class", "track-icon fa-solid fa-ellipsis-vertical svelte-1l5hcrc"), b(r, "class", "action-button fas fa-cog svelte-1l5hcrc"), b(r, "data-tooltip", "A5E.ButtonToolTipConfigure"), b(r, "data-tooltip-direction", "UP"), b(c, "class", "action-button fa-solid fa-clone svelte-1l5hcrc"), b(c, "data-tooltip", "A5E.ButtonToolTipDuplicate"), b(c, "data-tooltip-direction", "UP"), b(p, "class", "action-button delete-button fas fa-trash svelte-1l5hcrc"), b(p, "data-tooltip", "A5E.ButtonToolTipDelete"), b(p, "data-tooltip-direction", "UP"), b(n, "class", "track-items svelte-1l5hcrc"), b(e, "class", "track svelte-1l5hcrc");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(e, s), A(e, n), A(n, l), A(l, r), A(n, o), A(n, a), A(a, c), A(n, f), A(n, d), A(d, p), m || (g = [
        W(r, "click", Ve(
          /*onConfigure*/
          i[2]
        )),
        W(c, "click", Ve(
          /*onDuplicate*/
          i[4]
        )),
        W(p, "click", Ve(
          /*onDelete*/
          i[3]
        )),
        W(e, "click", Ve(
          /*click_handler*/
          i[9]
        ))
      ], m = !0);
    },
    p: se,
    d(h) {
      h && C(e), m = !1, Me(g);
    }
  };
}
u(lM, "create_if_block$1s");
function Ale(i) {
  let e, t, s = (
    /*sheetIsLocked*/
    i[1] && iM(i)
  ), n = !/*sheetIsLocked*/
  i[1] && lM(i);
  return {
    c() {
      s && s.c(), e = F(), n && n.c(), t = $e();
    },
    m(l, r) {
      s && s.m(l, r), T(l, e, r), n && n.m(l, r), T(l, t, r);
    },
    p(l, [r]) {
      /*sheetIsLocked*/
      l[1] ? s ? s.p(l, r) : (s = iM(l), s.c(), s.m(e.parentNode, e)) : s && (s.d(1), s = null), /*sheetIsLocked*/
      l[1] ? n && (n.d(1), n = null) : n ? n.p(l, r) : (n = lM(l), n.c(), n.m(t.parentNode, t));
    },
    i: se,
    o: se,
    d(l) {
      l && (C(e), C(t)), s && s.d(l), n && n.d(l);
    }
  };
}
u(Ale, "create_fragment$2B");
function Ele(i, e, t) {
  let s, n, { item: l } = e, { action: r = null } = e;
  async function o() {
    if (r) {
      await l.actions.configure(r);
      return;
    }
    l.configureItem();
  }
  u(o, "onConfigure");
  async function a() {
    let m;
    if (r) {
      await l.actions.remove(r);
      return;
    }
    if (!game.settings.get("a5e", "hideDeleteConfirmation")) {
      const g = new Au(l);
      if (await g.render(!0), m = await g.promise, !m || !m.confirmDeletion) return;
    }
    await game.settings.set("a5e", "hideDeleteConfirmation", (m == null ? void 0 : m.hideDeleteConfirmation) ?? game.settings.get("a5e", "hideDeleteConfirmation")), l.delete();
  }
  u(a, "onDelete");
  async function c() {
    if (r) {
      await l.actions.duplicate(r);
      return;
    }
    l.duplicateItem();
  }
  u(c, "onDuplicate");
  function f() {
    l.shareItemDescription(l.actions.get(r));
  }
  u(f, "showDescription");
  const d = de("actor");
  pe(i, d, (m) => t(8, n = m));
  function p(m) {
    bt.call(this, i, m);
  }
  return u(p, "click_handler"), i.$$set = (m) => {
    "item" in m && t(7, l = m.item), "action" in m && t(0, r = m.action);
  }, i.$$.update = () => {
    var m, g;
    i.$$.dirty & /*$actor*/
    256 && t(1, s = n.isOwner ? ((g = (m = n.flags) == null ? void 0 : m.a5e) == null ? void 0 : g.sheetIsLocked) ?? !0 : !0);
  }, [
    r,
    s,
    o,
    a,
    c,
    f,
    d,
    l,
    n,
    p
  ];
}
u(Ele, "instance$2s");
const sS = class sS extends re {
  constructor(e) {
    super(), oe(this, e, Ele, Ale, le, { item: 7, action: 0 });
  }
};
u(sS, "ItemActionButtons");
let E0 = sS;
function rM(i, e, t) {
  const s = i.slice();
  return s[46] = e[t].name, s[47] = e[t].id, s;
}
u(rM, "get_each_context$_");
function oM(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), t = Q(
        /*activationCost*/
        i[3]
      ), b(e, "class", "action-button action-button--activation-cost svelte-1wowebl"), b(
        e,
        "data-tooltip",
        /*activationCostLabel*/
        i[7]
      ), b(e, "data-tooltip-direction", "UP");
    },
    m(l, r) {
      T(l, e, r), A(e, t), s || (n = W(e, "auxclick", Ve(
        /*onConfigure*/
        i[17]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*activationCost*/
      8 && be(
        t,
        /*activationCost*/
        l[3]
      ), r[0] & /*activationCostLabel*/
      128 && b(
        e,
        "data-tooltip",
        /*activationCostLabel*/
        l[7]
      );
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(oM, "create_if_block_25");
function aM(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "action-button action-button--stance fa-solid fa-street-view svelte-1wowebl"), b(e, "data-tooltip", "A5E.ManeuverIsStance"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(aM, "create_if_block_24");
function cM(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "action-button action-button--bloodied fa-solid fa-droplet svelte-1wowebl"), b(e, "data-tooltip", "A5E.RequiresBloodied"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(cM, "create_if_block_23");
function uM(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fas fa-chevron-down svelte-1wowebl");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(e, "click", Ve(
        /*click_handler_6*/
        i[34]
      )), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(uM, "create_if_block_22");
function fM(i) {
  let e, t, s, n, l = (
    /*containerCapacity*/
    i[6] && dM(i)
  );
  return {
    c() {
      l && l.c(), e = F(), t = E("button"), b(t, "class", "action-button fas fa-chevron-down svelte-1wowebl");
    },
    m(r, o) {
      l && l.m(r, o), T(r, e, o), T(r, t, o), s || (n = W(t, "click", Ve(
        /*click_handler_7*/
        i[35]
      )), s = !0);
    },
    p(r, o) {
      /*containerCapacity*/
      r[6] ? l ? l.p(r, o) : (l = dM(r), l.c(), l.m(e.parentNode, e)) : l && (l.d(1), l = null);
    },
    d(r) {
      r && (C(e), C(t)), l && l.d(r), s = !1, n();
    }
  };
}
u(fM, "create_if_block_20");
function dM(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("span"), t = Q("("), s = Q(
        /*containerCapacity*/
        i[6]
      ), n = Q("%)"), b(e, "data-tooltip", "Capacity"), b(e, "data-tooltip-direction", "UP");
    },
    m(l, r) {
      T(l, e, r), A(e, t), A(e, s), A(e, n);
    },
    p(l, r) {
      r[0] & /*containerCapacity*/
      64 && be(
        s,
        /*containerCapacity*/
        l[6]
      );
    },
    d(l) {
      l && C(e);
    }
  };
}
u(dM, "create_if_block_21");
function pM(i) {
  let e, t, s, n = [], l = /* @__PURE__ */ new Map(), r, o, a, c = ue(
    /*ammunitionItems*/
    i[9]
  );
  const f = /* @__PURE__ */ u((d) => (
    /*id*/
    d[47]
  ), "get_key");
  for (let d = 0; d < c.length; d += 1) {
    let p = rM(i, c, d), m = f(p);
    l.set(m, n[d] = mM(m, p));
  }
  return {
    c() {
      e = E("select"), t = E("option");
      for (let d = 0; d < n.length; d += 1)
        n[d].c();
      t.__value = "", He(t, t.__value), t.selected = s = /*selectedAmmo*/
      i[5] === "", b(e, "id", r = /*$actor*/
      i[4].id + "-" + /*item*/
      i[0].id + "-ammunition"), b(e, "class", "ammunition-selector svelte-1wowebl");
    },
    m(d, p) {
      T(d, e, p), A(e, t);
      for (let m = 0; m < n.length; m += 1)
        n[m] && n[m].m(e, null);
      o || (a = [
        W(t, "click", Ve(
          /*click_handler_1*/
          i[33]
        )),
        W(e, "click", Ve(
          /*click_handler*/
          i[31]
        )),
        W(
          e,
          "change",
          /*updateAmmunition*/
          i[13]
        )
      ], o = !0);
    },
    p(d, p) {
      p[0] & /*selectedAmmo*/
      32 && s !== (s = /*selectedAmmo*/
      d[5] === "") && (t.selected = s), p[0] & /*ammunitionItems, selectedAmmo*/
      544 && (c = ue(
        /*ammunitionItems*/
        d[9]
      ), n = Lt(n, p, f, 1, d, c, l, e, an, mM, null, rM)), p[0] & /*$actor, item*/
      17 && r !== (r = /*$actor*/
      d[4].id + "-" + /*item*/
      d[0].id + "-ammunition") && b(e, "id", r);
    },
    d(d) {
      d && C(e);
      for (let p = 0; p < n.length; p += 1)
        n[p].d();
      o = !1, Me(a);
    }
  };
}
u(pM, "create_if_block_19");
function mM(i, e) {
  let t, s = (
    /*name*/
    e[46] + ""
  ), n, l, r, o, a, c;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = Q(s), l = F(), t.__value = r = /*id*/
      e[47], He(t, t.__value), t.selected = o = /*selectedAmmo*/
      e[5] === /*id*/
      e[47], this.first = t;
    },
    m(f, d) {
      T(f, t, d), A(t, n), A(t, l), a || (c = W(t, "click", Ve(
        /*click_handler_2*/
        e[32]
      )), a = !0);
    },
    p(f, d) {
      e = f, d[0] & /*ammunitionItems*/
      512 && s !== (s = /*name*/
      e[46] + "") && be(n, s), d[0] & /*ammunitionItems*/
      512 && r !== (r = /*id*/
      e[47]) && (t.__value = r, He(t, t.__value)), d[0] & /*selectedAmmo, ammunitionItems*/
      544 && o !== (o = /*selectedAmmo*/
      e[5] === /*id*/
      e[47]) && (t.selected = o);
    },
    d(f) {
      f && C(t), a = !1, c();
    }
  };
}
u(mM, "create_each_block$_");
function Sle(i) {
  let e, t, s = (
    /*hasRecharge*/
    i[14](
      /*item*/
      i[0]
    )
  ), n = s && hM(i);
  return {
    c() {
      e = E("div"), t = E("div"), n && n.c(), b(t, "class", "button-wrapper svelte-1wowebl"), b(e, "class", "indicator-container");
    },
    m(l, r) {
      T(l, e, r), A(e, t), n && n.m(t, null);
    },
    p(l, r) {
      r[0] & /*item*/
      1 && (s = /*hasRecharge*/
      l[14](
        /*item*/
        l[0]
      )), s ? n ? n.p(l, r) : (n = hM(l), n.c(), n.m(t, null)) : n && (n.d(1), n = null);
    },
    d(l) {
      l && C(e), n && n.d();
    }
  };
}
u(Sle, "create_else_block$w");
function Cle(i) {
  var h;
  let e, t, s, n, l, r, o, a = (
    /*hasRecharge*/
    i[14](
      /*item*/
      i[0]
    )
  ), c = (
    /*item*/
    i[0].type === "spell" && gM(i)
  ), f = (
    /*item*/
    (i[0].type === "feature" || /*item*/
    i[0].type === "maneuver") && wM(i)
  ), d = (
    /*flags*/
    (((h = i[12].a5e) == null ? void 0 : h.showFavoritesSection) ?? !0) && AM(i)
  ), p = (
    /*item*/
    i[0].type === "object" && EM(i)
  ), m = (
    /*item*/
    i[0].type === "spell" && TM(i)
  ), g = a && OM(i);
  return {
    c() {
      e = E("div"), c && c.c(), t = F(), f && f.c(), s = F(), n = E("div"), d && d.c(), l = F(), p && p.c(), r = F(), m && m.c(), o = F(), g && g.c(), b(n, "class", "button-wrapper svelte-1wowebl"), b(e, "class", "indicator-wrapper svelte-1wowebl");
    },
    m(_, y) {
      T(_, e, y), c && c.m(e, null), A(e, t), f && f.m(e, null), A(e, s), A(e, n), d && d.m(n, null), A(n, l), p && p.m(n, null), A(n, r), m && m.m(n, null), A(n, o), g && g.m(n, null);
    },
    p(_, y) {
      var v;
      /*item*/
      _[0].type === "spell" ? c ? c.p(_, y) : (c = gM(_), c.c(), c.m(e, t)) : c && (c.d(1), c = null), /*item*/
      _[0].type === "feature" || /*item*/
      _[0].type === "maneuver" ? f ? f.p(_, y) : (f = wM(_), f.c(), f.m(e, s)) : f && (f.d(1), f = null), /*flags*/
      ((v = _[12].a5e) == null ? void 0 : v.showFavoritesSection) ?? !0 ? d ? d.p(_, y) : (d = AM(_), d.c(), d.m(n, l)) : d && (d.d(1), d = null), /*item*/
      _[0].type === "object" ? p ? p.p(_, y) : (p = EM(_), p.c(), p.m(n, r)) : p && (p.d(1), p = null), /*item*/
      _[0].type === "spell" ? m ? m.p(_, y) : (m = TM(_), m.c(), m.m(n, o)) : m && (m.d(1), m = null), y[0] & /*item*/
      1 && (a = /*hasRecharge*/
      _[14](
        /*item*/
        _[0]
      )), a ? g ? g.p(_, y) : (g = OM(_), g.c(), g.m(n, null)) : g && (g.d(1), g = null);
    },
    d(_) {
      _ && C(e), c && c.d(), f && f.d(), d && d.d(), p && p.d(), m && m.d(), g && g.d();
    }
  };
}
u(Cle, "create_if_block_2$E");
function hM(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fas fa-dice svelte-1wowebl"), b(e, "data-tooltip", t = /*rechargeState*/
      i[8] ? "A5E.ButtonToolTipCharged" : "A5E.ButtonToolTipRecharge"), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "active",
        /*rechargeState*/
        i[8]
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = W(e, "click", Ve(
        /*click_handler_14*/
        i[42]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*rechargeState*/
      256 && t !== (t = /*rechargeState*/
      l[8] ? "A5E.ButtonToolTipCharged" : "A5E.ButtonToolTipRecharge") && b(e, "data-tooltip", t), r[0] & /*rechargeState*/
      256 && Z(
        e,
        "active",
        /*rechargeState*/
        l[8]
      );
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(hM, "create_if_block_18");
function gM(i) {
  let e, t, s, n, l, r = (
    /*item*/
    i[0].system.components.vocalized && bM()
  ), o = (
    /*item*/
    i[0].system.components.seen && _M()
  ), a = (
    /*item*/
    i[0].system.components.material && yM()
  ), c = (
    /*item*/
    i[0].system.concentration && vM()
  ), f = (
    /*item*/
    i[0].system.ritual && kM()
  );
  return {
    c() {
      e = E("div"), r && r.c(), t = F(), o && o.c(), s = F(), a && a.c(), n = F(), c && c.c(), l = F(), f && f.c(), b(e, "class", "component-wrapper svelte-1wowebl");
    },
    m(d, p) {
      T(d, e, p), r && r.m(e, null), A(e, t), o && o.m(e, null), A(e, s), a && a.m(e, null), A(e, n), c && c.m(e, null), A(e, l), f && f.m(e, null);
    },
    p(d, p) {
      /*item*/
      d[0].system.components.vocalized ? r || (r = bM(), r.c(), r.m(e, t)) : r && (r.d(1), r = null), /*item*/
      d[0].system.components.seen ? o || (o = _M(), o.c(), o.m(e, s)) : o && (o.d(1), o = null), /*item*/
      d[0].system.components.material ? a || (a = yM(), a.c(), a.m(e, n)) : a && (a.d(1), a = null), /*item*/
      d[0].system.concentration ? c || (c = vM(), c.c(), c.m(e, l)) : c && (c.d(1), c = null), /*item*/
      d[0].system.ritual ? f || (f = kM(), f.c(), f.m(e, null)) : f && (f.d(1), f = null);
    },
    d(d) {
      d && C(e), r && r.d(), o && o.d(), a && a.d(), c && c.d(), f && f.d();
    }
  };
}
u(gM, "create_if_block_12$2");
function bM(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellComponentVocalizedAbbr")}`, b(e, "class", "component svelte-1wowebl"), b(e, "data-tooltip", "A5E.SpellComponentVocalized"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(bM, "create_if_block_17");
function _M(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellComponentSeenAbbr")}`, b(e, "class", "component svelte-1wowebl"), b(e, "data-tooltip", "A5E.SpellComponentSeen"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(_M, "create_if_block_16");
function yM(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellComponentMaterialAbbr")}`, b(e, "class", "component svelte-1wowebl"), b(e, "data-tooltip", "A5E.SpellComponentMaterial"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(yM, "create_if_block_15");
function vM(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellConcentrationAbbr")}`, b(e, "class", "component svelte-1wowebl"), b(e, "data-tooltip", "A5E.SpellConcentration"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(vM, "create_if_block_14");
function kM(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellRitualAbbr")}`, b(e, "class", "component svelte-1wowebl"), b(e, "data-tooltip", "A5E.SpellRitual"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(kM, "create_if_block_13$1");
function wM(i) {
  let e, t = (
    /*item*/
    i[0].system.concentration && $M()
  );
  return {
    c() {
      e = E("div"), t && t.c(), b(e, "class", "component-wrapper svelte-1wowebl");
    },
    m(s, n) {
      T(s, e, n), t && t.m(e, null);
    },
    p(s, n) {
      /*item*/
      s[0].system.concentration ? t || (t = $M(), t.c(), t.m(e, null)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && C(e), t && t.d();
    }
  };
}
u(wM, "create_if_block_10$7");
function $M(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellConcentrationAbbr")}`, b(e, "class", "component svelte-1wowebl"), b(e, "data-tooltip", "A5E.SpellConcentration"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u($M, "create_if_block_11$4");
function AM(i) {
  let e, t, s;
  return {
    c() {
      var n;
      e = E("button"), b(e, "class", "action-button fas fa-star svelte-1wowebl"), b(e, "data-tooltip", "A5E.ButtonToolTipFavorite"), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "active",
        /*item*/
        ((n = i[0].system) == null ? void 0 : n.favorite) ?? !1
      );
    },
    m(n, l) {
      T(n, e, l), t || (s = W(e, "click", Ve(
        /*click_handler_8*/
        i[36]
      )), t = !0);
    },
    p(n, l) {
      var r;
      l[0] & /*item*/
      1 && Z(
        e,
        "active",
        /*item*/
        ((r = n[0].system) == null ? void 0 : r.favorite) ?? !1
      );
    },
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(AM, "create_if_block_9$8");
function EM(i) {
  var o;
  let e, t, s, n = (
    /*item*/
    i[0].system.requiresAttunement && SM(i)
  ), l = !/*item*/
  ((o = i[0].system) != null && o.containerId) && CM(i), r = !/*hideBrokenAndDamaged*/
  i[26] && Tle(i);
  return {
    c() {
      n && n.c(), e = F(), l && l.c(), t = F(), r && r.c(), s = $e();
    },
    m(a, c) {
      n && n.m(a, c), T(a, e, c), l && l.m(a, c), T(a, t, c), r && r.m(a, c), T(a, s, c);
    },
    p(a, c) {
      var f;
      /*item*/
      a[0].system.requiresAttunement ? n ? n.p(a, c) : (n = SM(a), n.c(), n.m(e.parentNode, e)) : n && (n.d(1), n = null), /*item*/
      (f = a[0].system) != null && f.containerId ? l && (l.d(1), l = null) : l ? l.p(a, c) : (l = CM(a), l.c(), l.m(t.parentNode, t)), /*hideBrokenAndDamaged*/
      a[26] || r.p(a, c);
    },
    d(a) {
      a && (C(e), C(t), C(s)), n && n.d(a), l && l.d(a), r && r.d(a);
    }
  };
}
u(EM, "create_if_block_5$g");
function SM(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fa-solid fa-link svelte-1wowebl"), b(e, "data-tooltip", t = /*item*/
      i[0].system.attuned ? K("A5E.ButtonToolTipBreakAttunement", { item: (
        /*item*/
        i[0].name
      ) }) : K("A5E.ButtonToolTipAttune", { item: (
        /*item*/
        i[0].name
      ) })), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "active",
        /*item*/
        i[0].system.attuned
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = W(e, "click", Ve(
        /*click_handler_9*/
        i[37]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*item*/
      1 && t !== (t = /*item*/
      l[0].system.attuned ? K("A5E.ButtonToolTipBreakAttunement", { item: (
        /*item*/
        l[0].name
      ) }) : K("A5E.ButtonToolTipAttune", { item: (
        /*item*/
        l[0].name
      ) })) && b(e, "data-tooltip", t), r[0] & /*item*/
      1 && Z(
        e,
        "active",
        /*item*/
        l[0].system.attuned
      );
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(SM, "create_if_block_8$9");
function CM(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fas svelte-1wowebl"), b(e, "data-tooltip", t = /*equippedStates*/
      i[22][
        /*item*/
        i[0].system.equippedState ?? 0
      ]), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "fa-shield-alt",
        /*item*/
        i[0].system.equippedState === /*EQUIPPED_STATES*/
        i[23].EQUIPPED
      ), Z(
        e,
        "fa-person-carry-box",
        /*item*/
        i[0].system.equippedState === /*EQUIPPED_STATES*/
        i[23].CARRIED
      ), Z(
        e,
        "fa-tents",
        /*item*/
        i[0].system.equippedState === /*EQUIPPED_STATES*/
        i[23].NOT_CARRIED
      ), Z(e, "active", [
        /*EQUIPPED_STATES*/
        i[23].EQUIPPED,
        /*EQUIPPED_STATES*/
        i[23].CARRIED
      ].includes(
        /*item*/
        i[0].system.equippedState
      ));
    },
    m(l, r) {
      T(l, e, r), s || (n = W(e, "click", Ve(
        /*click_handler_10*/
        i[38]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*item*/
      1 && t !== (t = /*equippedStates*/
      l[22][
        /*item*/
        l[0].system.equippedState ?? 0
      ]) && b(e, "data-tooltip", t), r[0] & /*item, EQUIPPED_STATES*/
      8388609 && Z(
        e,
        "fa-shield-alt",
        /*item*/
        l[0].system.equippedState === /*EQUIPPED_STATES*/
        l[23].EQUIPPED
      ), r[0] & /*item, EQUIPPED_STATES*/
      8388609 && Z(
        e,
        "fa-person-carry-box",
        /*item*/
        l[0].system.equippedState === /*EQUIPPED_STATES*/
        l[23].CARRIED
      ), r[0] & /*item, EQUIPPED_STATES*/
      8388609 && Z(
        e,
        "fa-tents",
        /*item*/
        l[0].system.equippedState === /*EQUIPPED_STATES*/
        l[23].NOT_CARRIED
      ), r[0] & /*EQUIPPED_STATES, item*/
      8388609 && Z(e, "active", [
        /*EQUIPPED_STATES*/
        l[23].EQUIPPED,
        /*EQUIPPED_STATES*/
        l[23].CARRIED
      ].includes(
        /*item*/
        l[0].system.equippedState
      ));
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(CM, "create_if_block_7$c");
function Tle(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fas svelte-1wowebl"), b(e, "data-tooltip", t = /*damagedStates*/
      i[20][
        /*item*/
        i[0].system.damagedState ?? 0
      ]), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "fa-heart",
        /*item*/
        i[0].system.damagedState === /*DAMAGED_STATES*/
        i[21].INTACT
      ), Z(
        e,
        "fa-heart-crack",
        /*item*/
        i[0].system.damagedState === /*DAMAGED_STATES*/
        i[21].DAMAGED
      ), Z(
        e,
        "fa-heart-pulse",
        /*item*/
        i[0].system.damagedState === /*DAMAGED_STATES*/
        i[21].BROKEN
      ), Z(e, "active", [
        /*DAMAGED_STATES*/
        i[21].DAMAGED,
        /*DAMAGED_STATES*/
        i[21].BROKEN
      ].includes(
        /*item*/
        i[0].system.damagedState
      ));
    },
    m(l, r) {
      T(l, e, r), s || (n = W(e, "click", Ve(
        /*click_handler_11*/
        i[39]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*item*/
      1 && t !== (t = /*damagedStates*/
      l[20][
        /*item*/
        l[0].system.damagedState ?? 0
      ]) && b(e, "data-tooltip", t), r[0] & /*item, DAMAGED_STATES*/
      2097153 && Z(
        e,
        "fa-heart",
        /*item*/
        l[0].system.damagedState === /*DAMAGED_STATES*/
        l[21].INTACT
      ), r[0] & /*item, DAMAGED_STATES*/
      2097153 && Z(
        e,
        "fa-heart-crack",
        /*item*/
        l[0].system.damagedState === /*DAMAGED_STATES*/
        l[21].DAMAGED
      ), r[0] & /*item, DAMAGED_STATES*/
      2097153 && Z(
        e,
        "fa-heart-pulse",
        /*item*/
        l[0].system.damagedState === /*DAMAGED_STATES*/
        l[21].BROKEN
      ), r[0] & /*DAMAGED_STATES, item*/
      2097153 && Z(e, "active", [
        /*DAMAGED_STATES*/
        l[21].DAMAGED,
        /*DAMAGED_STATES*/
        l[21].BROKEN
      ].includes(
        /*item*/
        l[0].system.damagedState
      ));
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Tle, "create_if_block_6$f");
function TM(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fas svelte-1wowebl"), b(e, "data-tooltip", t = /*preparedStates*/
      i[24][Number(
        /*item*/
        i[0].system.prepared ?? 0
      )]), b(e, "data-tooltip-direction", "UP"), Z(e, "fa-book", [
        /*PREPARED_STATES*/
        i[25].UNPREPARED,
        /*PREPARED_STATES*/
        i[25].PREPARED
      ].includes(Number(
        /*item*/
        i[0].system.prepared ?? 0
      ))), Z(e, "fa-book-sparkles", Number(
        /*item*/
        i[0].system.prepared ?? 0
      ) === /*PREPARED_STATES*/
      i[25].ALWAYS_PREPARED), Z(e, "active", [
        /*PREPARED_STATES*/
        i[25].PREPARED,
        /*PREPARED_STATES*/
        i[25].ALWAYS_PREPARED
      ].includes(Number(
        /*item*/
        i[0].system.prepared ?? 0
      )));
    },
    m(l, r) {
      T(l, e, r), s || (n = W(e, "click", Ve(
        /*click_handler_12*/
        i[40]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*item*/
      1 && t !== (t = /*preparedStates*/
      l[24][Number(
        /*item*/
        l[0].system.prepared ?? 0
      )]) && b(e, "data-tooltip", t), r[0] & /*PREPARED_STATES, item*/
      33554433 && Z(e, "fa-book", [
        /*PREPARED_STATES*/
        l[25].UNPREPARED,
        /*PREPARED_STATES*/
        l[25].PREPARED
      ].includes(Number(
        /*item*/
        l[0].system.prepared ?? 0
      ))), r[0] & /*item, PREPARED_STATES*/
      33554433 && Z(e, "fa-book-sparkles", Number(
        /*item*/
        l[0].system.prepared ?? 0
      ) === /*PREPARED_STATES*/
      l[25].ALWAYS_PREPARED), r[0] & /*PREPARED_STATES, item*/
      33554433 && Z(e, "active", [
        /*PREPARED_STATES*/
        l[25].PREPARED,
        /*PREPARED_STATES*/
        l[25].ALWAYS_PREPARED
      ].includes(Number(
        /*item*/
        l[0].system.prepared ?? 0
      )));
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(TM, "create_if_block_4$m");
function OM(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fas fa-dice svelte-1wowebl"), b(e, "data-tooltip", t = /*rechargeState*/
      i[8] ? "A5E.ButtonToolTipCharged" : "A5E.ButtonToolTipRecharge"), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "active",
        /*rechargeState*/
        i[8]
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = W(e, "click", Ve(
        /*click_handler_13*/
        i[41]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*rechargeState*/
      256 && t !== (t = /*rechargeState*/
      l[8] ? "A5E.ButtonToolTipCharged" : "A5E.ButtonToolTipRecharge") && b(e, "data-tooltip", t), r[0] & /*rechargeState*/
      256 && Z(
        e,
        "active",
        /*rechargeState*/
        l[8]
      );
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(OM, "create_if_block_3$r");
function DM(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "number-input svelte-1wowebl"), b(t, "id", s = /*actor*/
      i[18].id + "-" + /*item*/
      i[0].id + "-quantity"), b(t, "type", "number"), b(t, "name", "system.quantity"), t.value = n = /*item*/
      i[0].system.quantity, b(t, "min", "0"), b(e, "class", "quantity-wrapper svelte-1wowebl");
    },
    m(o, a) {
      T(o, e, a), A(e, t), l || (r = [
        W(t, "click", Ve(
          /*click_handler_3*/
          i[30]
        )),
        W(
          t,
          "change",
          /*updateField*/
          i[15]
        )
      ], l = !0);
    },
    p(o, a) {
      a[0] & /*item*/
      1 && s !== (s = /*actor*/
      o[18].id + "-" + /*item*/
      o[0].id + "-quantity") && b(t, "id", s), a[0] & /*item*/
      1 && n !== (n = /*item*/
      o[0].system.quantity) && t.value !== n && (t.value = n);
    },
    d(o) {
      o && C(e), l = !1, Me(r);
    }
  };
}
u(DM, "create_if_block_1$X");
function IM(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g;
  return {
    c() {
      e = E("div"), t = E("input"), o = F(), a = E("span"), a.textContent = "/", c = F(), f = E("input"), b(t, "class", "number-input svelte-1wowebl"), b(t, "id", s = /*actor*/
      i[18].id + "-" + /*item*/
      i[0].id + "-current-uses"), b(t, "type", "number"), b(t, "name", n = /*isClassResource*/
      i[11] ? `${/*uses*/
      i[10][
        /*usesType*/
        i[27]
      ].updatePath}` : `${/*uses*/
      i[10][
        /*usesType*/
        i[27]
      ].updatePath}.value`), t.value = l = /*uses*/
      i[10][
        /*usesType*/
        i[27]
      ].value, b(t, "min", "0"), b(t, "max", r = /*uses*/
      i[10][
        /*usesType*/
        i[27]
      ].max), b(f, "class", "number-input svelte-1wowebl"), b(f, "type", "number"), b(f, "name", d = /*uses*/
      i[10][
        /*usesType*/
        i[27]
      ].updatePath + ".max"), f.value = p = /*uses*/
      i[10][
        /*usesType*/
        i[27]
      ].max, f.disabled = !0, b(e, "class", "uses-wrapper svelte-1wowebl");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(e, o), A(e, a), A(e, c), A(e, f), m || (g = [
        W(t, "click", Ve(
          /*click_handler_4*/
          i[29]
        )),
        W(
          t,
          "change",
          /*updateUsesValue*/
          i[16]
        ),
        W(f, "click", Ve(
          /*click_handler_5*/
          i[28]
        ))
      ], m = !0);
    },
    p(h, _) {
      _[0] & /*item*/
      1 && s !== (s = /*actor*/
      h[18].id + "-" + /*item*/
      h[0].id + "-current-uses") && b(t, "id", s), _[0] & /*isClassResource, uses*/
      3072 && n !== (n = /*isClassResource*/
      h[11] ? `${/*uses*/
      h[10][
        /*usesType*/
        h[27]
      ].updatePath}` : `${/*uses*/
      h[10][
        /*usesType*/
        h[27]
      ].updatePath}.value`) && b(t, "name", n), _[0] & /*uses*/
      1024 && l !== (l = /*uses*/
      h[10][
        /*usesType*/
        h[27]
      ].value) && t.value !== l && (t.value = l), _[0] & /*uses*/
      1024 && r !== (r = /*uses*/
      h[10][
        /*usesType*/
        h[27]
      ].max) && b(t, "max", r), _[0] & /*uses*/
      1024 && d !== (d = /*uses*/
      h[10][
        /*usesType*/
        h[27]
      ].updatePath + ".max") && b(f, "name", d), _[0] & /*uses*/
      1024 && p !== (p = /*uses*/
      h[10][
        /*usesType*/
        h[27]
      ].max) && f.value !== p && (f.value = p);
    },
    d(h) {
      h && C(e), m = !1, Me(g);
    }
  };
}
u(IM, "create_if_block$1r");
function Ole(i) {
  var q, U, H, V, Y, J, fe, ke, ee;
  let e, t, s = (
    /*action*/
    (((q = i[1]) == null ? void 0 : q.name) ?? /*item*/
    i[0].name) + ""
  ), n, l, r, o, a, c, f, d = dd(
    /*item*/
    i[0],
    /*action*/
    i[1]
  ), p, m, g, h, _ = (
    /*activationCost*/
    i[3] && /*item*/
    (((U = i[0].actions) == null ? void 0 : U.count) === 1 || /*action*/
    i[1]) && oM(i)
  ), y = !/*action*/
  i[1] && /*item*/
  i[0].system.isStance && aM(), v = !/*action*/
  i[1] && /*item*/
  i[0].system.requiresBloodied && cM(), k = !/*action*/
  i[1] && /*item*/
  ((H = i[0].actions) == null ? void 0 : H.count) > 1 && uM(i), S = (
    /*item*/
    ((Y = (V = i[0]) == null ? void 0 : V.system) == null ? void 0 : Y.objectType) === "container" && fM(i)
  ), D = d && pM(i);
  function I(ne, Ee) {
    return (
      /*action*/
      ne[1] ? Sle : Cle
    );
  }
  u(I, "select_block_type");
  let M = I(i), L = M(i), B = !/*actionId*/
  i[2] && /*item*/
  ((J = i[0]) == null ? void 0 : J.type) === "object" && DM(i), z = (!/*actionId*/
  i[2] && /*item*/
  ((ke = (fe = i[0].system) == null ? void 0 : fe.uses) == null ? void 0 : ke.max) || /*action*/
  i[1] && /*action*/
  ((ee = i[1].uses) == null ? void 0 : ee.max)) && IM(i);
  return {
    c() {
      e = E("div"), t = E("div"), n = Q(s), l = F(), _ && _.c(), r = F(), y && y.c(), o = F(), v && v.c(), a = F(), k && k.c(), c = F(), S && S.c(), f = F(), D && D.c(), p = F(), L.c(), m = F(), B && B.c(), g = F(), z && z.c(), h = $e(), b(t, "class", "name svelte-1wowebl"), b(e, "class", "name-wrapper svelte-1wowebl"), Z(e, "name-wrapper--ammunition", dd(
        /*item*/
        i[0],
        /*action*/
        i[1]
      ));
    },
    m(ne, Ee) {
      T(ne, e, Ee), A(e, t), A(t, n), A(t, l), _ && _.m(t, null), A(t, r), y && y.m(t, null), A(t, o), v && v.m(t, null), A(t, a), k && k.m(t, null), A(t, c), S && S.m(t, null), A(e, f), D && D.m(e, null), T(ne, p, Ee), L.m(ne, Ee), T(ne, m, Ee), B && B.m(ne, Ee), T(ne, g, Ee), z && z.m(ne, Ee), T(ne, h, Ee);
    },
    p(ne, Ee) {
      var Pe, ye, me, Ce, Je, Ne, Re, ge, je;
      Ee[0] & /*action, item*/
      3 && s !== (s = /*action*/
      (((Pe = ne[1]) == null ? void 0 : Pe.name) ?? /*item*/
      ne[0].name) + "") && be(n, s), /*activationCost*/
      ne[3] && /*item*/
      (((ye = ne[0].actions) == null ? void 0 : ye.count) === 1 || /*action*/
      ne[1]) ? _ ? _.p(ne, Ee) : (_ = oM(ne), _.c(), _.m(t, r)) : _ && (_.d(1), _ = null), !/*action*/
      ne[1] && /*item*/
      ne[0].system.isStance ? y || (y = aM(), y.c(), y.m(t, o)) : y && (y.d(1), y = null), !/*action*/
      ne[1] && /*item*/
      ne[0].system.requiresBloodied ? v || (v = cM(), v.c(), v.m(t, a)) : v && (v.d(1), v = null), !/*action*/
      ne[1] && /*item*/
      ((me = ne[0].actions) == null ? void 0 : me.count) > 1 ? k ? k.p(ne, Ee) : (k = uM(ne), k.c(), k.m(t, c)) : k && (k.d(1), k = null), /*item*/
      ((Je = (Ce = ne[0]) == null ? void 0 : Ce.system) == null ? void 0 : Je.objectType) === "container" ? S ? S.p(ne, Ee) : (S = fM(ne), S.c(), S.m(t, null)) : S && (S.d(1), S = null), Ee[0] & /*item, action*/
      3 && (d = dd(
        /*item*/
        ne[0],
        /*action*/
        ne[1]
      )), d ? D ? D.p(ne, Ee) : (D = pM(ne), D.c(), D.m(e, null)) : D && (D.d(1), D = null), Ee[0] & /*item, action*/
      3 && Z(e, "name-wrapper--ammunition", dd(
        /*item*/
        ne[0],
        /*action*/
        ne[1]
      )), M === (M = I(ne)) && L ? L.p(ne, Ee) : (L.d(1), L = M(ne), L && (L.c(), L.m(m.parentNode, m))), !/*actionId*/
      ne[2] && /*item*/
      ((Ne = ne[0]) == null ? void 0 : Ne.type) === "object" ? B ? B.p(ne, Ee) : (B = DM(ne), B.c(), B.m(g.parentNode, g)) : B && (B.d(1), B = null), !/*actionId*/
      ne[2] && /*item*/
      ((ge = (Re = ne[0].system) == null ? void 0 : Re.uses) != null && ge.max) || /*action*/
      ne[1] && /*action*/
      ((je = ne[1].uses) != null && je.max) ? z ? z.p(ne, Ee) : (z = IM(ne), z.c(), z.m(h.parentNode, h)) : z && (z.d(1), z = null);
    },
    i: se,
    o: se,
    d(ne) {
      ne && (C(e), C(p), C(m), C(g), C(h)), _ && _.d(), y && y.d(), v && v.d(), k && k.d(), S && S.d(), D && D.d(), L.d(ne), B && B.d(ne), z && z.d(ne);
    }
  };
}
u(Ole, "create_fragment$2A");
function Dle(i, e) {
  var s, n, l, r;
  let t = e;
  if (!i.actions || ((s = i.actions) == null ? void 0 : s.count) === 0) return "";
  switch (((n = i.actions) == null ? void 0 : n.count) === 1 && (t = i.actions.first), (l = t == null ? void 0 : t.activation) == null ? void 0 : l.type) {
    case "action":
      return "A";
    case "bonusAction":
      return "B";
    case "legendaryAction":
      const o = (r = t == null ? void 0 : t.activation) == null ? void 0 : r.cost;
      return o === 1 || o === 0 ? "L" : `${o}L`;
    case "reaction":
      return "R";
    default:
      return "";
  }
}
u(Dle, "getActivationCost");
function Ile(i, e, t) {
  var n, l;
  let s = e;
  switch (((n = i.actions) == null ? void 0 : n.count) === 1 && (s = i.actions.first), t) {
    case "A":
      return "Action";
    case "B":
      return "Bonus Action";
    case "L":
      return "Legendary Action";
    case "R":
      return (l = s == null ? void 0 : s.activation) != null && l.reactionTrigger ? `Reaction (${s.activation.reactionTrigger})` : "Reaction";
    default:
      return "";
  }
}
u(Ile, "getActivationCostLabel");
function Ple(i, e) {
  var n, l;
  let t = e;
  if (!i.actions || ((n = i.actions) == null ? void 0 : n.count) === 0) return "";
  ((l = i.actions) == null ? void 0 : l.count) === 1 && (t = i.actions.first);
  const s = Object.entries((t == null ? void 0 : t.consumers) ?? {}).find(([r, o]) => (o == null ? void 0 : o.type) === "ammunition");
  return s ? s[1].itemId : "";
}
u(Ple, "getSelectedAmmo");
function dd(i, e) {
  let t = e;
  return !i.actions || i.actions.count === 0 ? !1 : (i.actions.count === 1 && (t = i.actions.first), Object.entries((t == null ? void 0 : t.consumers) ?? {}).filter(([s, n]) => (n == null ? void 0 : n.type) === "ammunition").length);
}
u(dd, "hasAmmunition");
function Mle(i, e, t) {
  let s, n, l, r, o, a, c, f, d, p, { item: m } = e, { action: g } = e, { actionId: h } = e;
  function _(Ge) {
    var Fe, xe, vt;
    let Se = h;
    const _e = (xe = (Fe = Ge.target) == null ? void 0 : Fe.selectedOptions[0]) == null ? void 0 : xe.value;
    if (!m.actions || m.actions.count === 0) return;
    m.actions.count === 1 && (Se = m.actions.keys()[0]);
    const [we] = Object.entries(((vt = m.actions.get(Se || "")) == null ? void 0 : vt.consumers) ?? {}).find(([ps, As]) => (As == null ? void 0 : As.type) === "ammunition");
    we && te(m, `system.actions.${Se}.consumers.${we}.itemId`, _e);
  }
  u(_, "updateAmmunition");
  function y(Ge) {
    var Se, _e, we;
    return h && g ? ((Se = g.uses) == null ? void 0 : Se.per) === "recharge" : ((we = (_e = Ge.system) == null ? void 0 : _e.uses) == null ? void 0 : we.per) === "recharge";
  }
  u(y, "hasRecharge");
  function v(Ge) {
    Ge.preventDefault();
    const { target: Se } = Ge;
    te(m, Se.name, Number(Se.value));
  }
  u(v, "updateField");
  function k(Ge) {
    Ge.preventDefault();
    const { target: Se } = Ge;
    te(n ? p : m, Se.name, Number(Se.value));
  }
  u(k, "updateUsesValue");
  function S() {
    var Se, _e;
    if (!fe) return;
    if (h) {
      (Se = m.actions) == null || Se.configure(h);
      return;
    }
    const Ge = [...m.actions.keys() ?? []].at(0);
    if (!Ge) {
      m.configureItem();
      return;
    }
    (_e = m.actions) == null || _e.configure(Ge);
  }
  u(S, "onConfigure");
  function D(Ge) {
    var _e, we;
    if (!Ge.isType("object") || ((_e = Ge.system) == null ? void 0 : _e.objectType) !== "container") return 0;
    const Se = (we = Ge.containerItems) == null ? void 0 : we.capacity().then((Fe) => t(6, f = Fe.percentage)).catch((Fe) => console.error(Fe));
    return (Se == null ? void 0 : Se.percentage) ?? 0;
  }
  u(D, "getCapacity");
  function I() {
    var _e, we, Fe, xe, vt, ps, As, zs, sn;
    const Ge = {
      action: {
        value: g ? (_e = g.uses) == null ? void 0 : _e.value : 0,
        max: g ? mt(((we = g.uses) == null ? void 0 : we.max) ?? 0, p.getRollData(m)) : 0,
        updatePath: `system.actions.${h}.uses`
      },
      item: {
        value: ((xe = (Fe = m.system) == null ? void 0 : Fe.uses) == null ? void 0 : xe.value) ?? 0,
        max: mt(((ps = (vt = m.system) == null ? void 0 : vt.uses) == null ? void 0 : ps.max) ?? 0, p.getRollData(m)),
        updatePath: "system.uses"
      }
    }, Se = J === "action" && g ? ((As = g.uses) == null ? void 0 : As.max) ?? "" : ((zs = m.system.uses) == null ? void 0 : zs.max) ?? "";
    if (!Se) return Ge;
    if (t(11, n = j5(Se)), n) {
      const ws = (sn = new RegExp(/@classResources.(\S+)/gm).exec(Se)) == null ? void 0 : sn[1];
      if (!ws) return Ge;
      const _i = foundry.utils.getProperty(p._source, `system.resources.classResources.${ws}`) ?? mt(Se, p.getRollData(m));
      Ge[J].value = _i, Ge[J].updatePath = `system.resources.classResources.${ws}`;
    }
    return Ge;
  }
  u(I, "generateUsesConfig");
  const M = de("actor");
  pe(i, M, (Ge) => t(4, p = Ge));
  const L = ft(), { damagedStates: B, DAMAGED_STATES: z, equippedStates: q, EQUIPPED_STATES: U, preparedStates: H, PREPARED_STATES: V } = CONFIG.A5E;
  let Y = game.settings.get("a5e", "hideBrokenAndDamaged"), J = h ? "action" : "item", fe = game.settings.get("a5e", "itemRightClickConfigure") ?? !1;
  function ke(Ge) {
    bt.call(this, i, Ge);
  }
  u(ke, "click_handler_5");
  function ee(Ge) {
    bt.call(this, i, Ge);
  }
  u(ee, "click_handler_4");
  function ne(Ge) {
    bt.call(this, i, Ge);
  }
  u(ne, "click_handler_3");
  function Ee(Ge) {
    bt.call(this, i, Ge);
  }
  u(Ee, "click_handler");
  function Pe(Ge) {
    bt.call(this, i, Ge);
  }
  u(Pe, "click_handler_2");
  function ye(Ge) {
    bt.call(this, i, Ge);
  }
  u(ye, "click_handler_1");
  const me = /* @__PURE__ */ u(() => {
    L("toggleActionList");
  }, "click_handler_6"), Ce = /* @__PURE__ */ u(() => {
    L("toggleContainer");
  }, "click_handler_7"), Je = /* @__PURE__ */ u(() => m.toggleFavorite(), "click_handler_8"), Ne = /* @__PURE__ */ u(() => m.toggleAttunement(), "click_handler_9"), Re = /* @__PURE__ */ u(() => m.toggleEquippedState(), "click_handler_10"), ge = /* @__PURE__ */ u(() => m.toggleDamagedState(), "click_handler_11"), je = /* @__PURE__ */ u(() => m.togglePrepared(), "click_handler_12"), Be = /* @__PURE__ */ u(() => m.recharge(h, o), "click_handler_13"), Ze = /* @__PURE__ */ u(() => m.recharge(h, o), "click_handler_14");
  return i.$$set = (Ge) => {
    "item" in Ge && t(0, m = Ge.item), "action" in Ge && t(1, g = Ge.action), "actionId" in Ge && t(2, h = Ge.actionId);
  }, i.$$.update = () => {
    var Ge, Se, _e, we, Fe, xe;
    i.$$.dirty[0] & /*$actor*/
    16 && t(12, s = p.flags), i.$$.dirty[0] & /*$actor, item, action*/
    19 && t(10, l = I()), i.$$.dirty[0] & /*$actor*/
    16 && t(9, r = p.items.filter((vt) => vt.isType("object") && vt.system.objectType === "ammunition").map((vt) => ({ name: vt.name, id: vt.id })).sort((vt, ps) => vt.name.toLowerCase().localeCompare(ps.name.toLowerCase()))), i.$$.dirty[0] & /*actionId, action, item*/
    7 && t(8, o = h ? ((Ge = g.uses) == null ? void 0 : Ge.max) == ((Se = g.uses) == null ? void 0 : Se.value) : ((we = (_e = m.system) == null ? void 0 : _e.uses) == null ? void 0 : we.max) == ((xe = (Fe = m.system) == null ? void 0 : Fe.uses) == null ? void 0 : xe.value)), i.$$.dirty[0] & /*item, action*/
    3 && t(3, a = Dle(m, g)), i.$$.dirty[0] & /*item, action, activationCost*/
    11 && t(7, c = Ile(m, g, a)), i.$$.dirty[0] & /*item*/
    1 && t(6, f = D(m)), i.$$.dirty[0] & /*item, action*/
    3 && t(5, d = Ple(m, g));
  }, t(11, n = !1), [
    m,
    g,
    h,
    a,
    p,
    d,
    f,
    c,
    o,
    r,
    l,
    n,
    s,
    _,
    y,
    v,
    k,
    S,
    M,
    L,
    B,
    z,
    q,
    U,
    H,
    V,
    Y,
    J,
    ke,
    ee,
    ne,
    Ee,
    Pe,
    ye,
    me,
    Ce,
    Je,
    Ne,
    Re,
    ge,
    je,
    Be,
    Ze
  ];
}
u(Mle, "instance$2r");
const nS = class nS extends re {
  constructor(e) {
    super(), oe(this, e, Mle, Ole, le, { item: 0, action: 1, actionId: 2 }, null, [-1, -1]);
  }
};
u(nS, "ItemInnerWrapper");
let S0 = nS;
function PM(i, e, t) {
  const s = i.slice();
  return s[28] = e[t][0], s[29] = e[t][1], s;
}
u(PM, "get_each_context$Z");
function MM(i, e, t) {
  const s = i.slice();
  return s[28] = e[t][0], s[3] = e[t][1], s;
}
u(MM, "get_each_context_1$b");
function FM(i) {
  let e, t;
  return e = new E0({
    props: {
      action: (
        /*actionId*/
        i[2]
      ),
      item: (
        /*item*/
        i[1]
      )
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*actionId*/
      4 && (l.action = /*actionId*/
      s[2]), n[0] & /*item*/
      2 && (l.item = /*item*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(FM, "create_if_block_6$e");
function RM(i) {
  let e, t, s, n, l, r;
  const o = [Rle, Fle], a = [];
  function c(f, d) {
    return d[0] & /*item*/
    2 && (t = null), t == null && (t = !!(!/*isGM*/
    f[15] && /*item*/
    f[1].isType("object") && /*item*/
    f[1].system.unidentified)), t ? 0 : 1;
  }
  return u(c, "select_block_type"), s = c(i, [-1, -1]), n = a[s] = o[s](i), {
    c() {
      e = E("div"), n.c(), b(e, "class", "description-wrapper svelte-1tdpf4q");
    },
    m(f, d) {
      T(f, e, d), a[s].m(e, null), r = !0;
    },
    p(f, d) {
      let p = s;
      s = c(f, d), s === p ? a[s].p(f, d) : (ae(), O(a[p], 1, 1, () => {
        a[p] = null;
      }), ce(), n = a[s], n ? n.p(f, d) : (n = a[s] = o[s](f), n.c()), w(n, 1), n.m(e, null));
    },
    i(f) {
      r || (w(n), f && ks(() => {
        r && (l || (l = yr(e, hu, {}, !0)), l.run(1));
      }), r = !0);
    },
    o(f) {
      O(n), f && (l || (l = yr(e, hu, {}, !1)), l.run(0)), r = !1;
    },
    d(f) {
      f && C(e), a[s].d(), f && l && l.end();
    }
  };
}
u(RM, "create_if_block_2$D");
function Fle(i) {
  let e = Object.values(
    /*summaryData*/
    i[6]
  ).some(Boolean), t, s, n, l, r = e && NM(i);
  return {
    c() {
      r && r.c(), t = F(), s = new bn(!1), n = $e(), s.a = n;
    },
    m(o, a) {
      r && r.m(o, a), T(o, t, a), s.m(
        /*description*/
        i[9],
        o,
        a
      ), T(o, n, a), l = !0;
    },
    p(o, a) {
      a[0] & /*summaryData*/
      64 && (e = Object.values(
        /*summaryData*/
        o[6]
      ).some(Boolean)), e ? r ? (r.p(o, a), a[0] & /*summaryData*/
      64 && w(r, 1)) : (r = NM(o), r.c(), w(r, 1), r.m(t.parentNode, t)) : r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce()), (!l || a[0] & /*description*/
      512) && s.p(
        /*description*/
        o[9]
      );
    },
    i(o) {
      l || (w(r), l = !0);
    },
    o(o) {
      O(r), l = !1;
    },
    d(o) {
      o && (C(t), C(n), s.d()), r && r.d(o);
    }
  };
}
u(Fle, "create_else_block$v");
function Rle(i) {
  let e, t = (
    /*item*/
    (i[1].system.unidentifiedDescription ?? K("A5E.NoUnidentifiedDescription")) + ""
  ), s;
  return {
    c() {
      e = new bn(!1), s = $e(), e.a = s;
    },
    m(n, l) {
      e.m(t, n, l), T(n, s, l);
    },
    p(n, l) {
      l[0] & /*item*/
      2 && t !== (t = /*item*/
      (n[1].system.unidentifiedDescription ?? K("A5E.NoUnidentifiedDescription")) + "") && e.p(t);
    },
    i: se,
    o: se,
    d(n) {
      n && (C(s), e.d());
    }
  };
}
u(Rle, "create_if_block_3$q");
function NM(i) {
  let e, t, s, n, l;
  e = new pc({
    props: { summaryData: (
      /*summaryData*/
      i[6]
    ) }
  });
  let r = (
    /*description*/
    i[9] && jM()
  );
  return {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), r && r.c(), n = $e(), G(t, "display", "contents"), G(t, "--margin-bottom", "0.375rem");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a[0] & /*summaryData*/
      64 && (c.summaryData = /*summaryData*/
      o[6]), e.$set(c), /*description*/
      o[9] ? r || (r = jM(), r.c(), r.m(n.parentNode, n)) : r && (r.d(1), r = null);
    },
    i(o) {
      l || (w(e.$$.fragment, o), l = !0);
    },
    o(o) {
      O(e.$$.fragment, o), l = !1;
    },
    d(o) {
      o && (C(s), C(n)), o && e && C(t), N(e, o), r && r.d(o);
    }
  };
}
u(NM, "create_if_block_4$l");
function jM(i) {
  let e;
  return {
    c() {
      e = E("hr"), b(e, "class", "a5e-rule"), G(e, "margin-block", "0.5rem");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(jM, "create_if_block_5$f");
function LM(i) {
  var o, a;
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l = ue([.../*item*/
  ((a = (o = i[1]) == null ? void 0 : o.actions) == null ? void 0 : a.entries()) ?? []]);
  const r = /* @__PURE__ */ u((c) => (
    /*id*/
    c[28]
  ), "get_key");
  for (let c = 0; c < l.length; c += 1) {
    let f = MM(i, l, c), d = r(f);
    s.set(d, t[c] = BM(d, f));
  }
  return {
    c() {
      e = E("ul");
      for (let c = 0; c < t.length; c += 1)
        t[c].c();
      b(e, "class", "a5e-item-list a5e-item-list--sub-items");
    },
    m(c, f) {
      T(c, e, f);
      for (let d = 0; d < t.length; d += 1)
        t[d] && t[d].m(e, null);
      n = !0;
    },
    p(c, f) {
      var d, p;
      f[0] & /*item*/
      2 && (l = ue([.../*item*/
      ((p = (d = c[1]) == null ? void 0 : d.actions) == null ? void 0 : p.entries()) ?? []]), ae(), t = Lt(t, f, r, 1, c, l, s, e, cn, BM, null, MM), ce());
    },
    i(c) {
      if (!n) {
        for (let f = 0; f < l.length; f += 1)
          w(t[f]);
        n = !0;
      }
    },
    o(c) {
      for (let f = 0; f < t.length; f += 1)
        O(t[f]);
      n = !1;
    },
    d(c) {
      c && C(e);
      for (let f = 0; f < t.length; f += 1)
        t[f].d();
    }
  };
}
u(LM, "create_if_block_1$W");
function BM(i, e) {
  let t, s, n;
  return s = new L5({
    props: {
      item: (
        /*item*/
        e[1]
      ),
      action: (
        /*action*/
        e[3]
      ),
      actionId: (
        /*id*/
        e[28]
      )
    }
  }), {
    key: i,
    first: null,
    c() {
      t = $e(), j(s.$$.fragment), this.first = t;
    },
    m(l, r) {
      T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      e = l;
      const o = {};
      r[0] & /*item*/
      2 && (o.item = /*item*/
      e[1]), r[0] & /*item*/
      2 && (o.action = /*action*/
      e[3]), r[0] & /*item*/
      2 && (o.actionId = /*id*/
      e[28]), s.$set(o);
    },
    i(l) {
      n || (w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(s, l);
    }
  };
}
u(BM, "create_each_block_1$b");
function qM(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l = ue(
    /*containerItems*/
    i[4]
  );
  const r = /* @__PURE__ */ u((o) => (
    /*id*/
    o[28]
  ), "get_key");
  for (let o = 0; o < l.length; o += 1) {
    let a = PM(i, l, o), c = r(a);
    s.set(c, t[o] = GM(c, a));
  }
  return {
    c() {
      e = E("ul");
      for (let o = 0; o < t.length; o += 1)
        t[o].c();
      b(e, "class", "a5e-item-list a5e-item-list--sub-items");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < t.length; c += 1)
        t[c] && t[c].m(e, null);
      n = !0;
    },
    p(o, a) {
      a[0] & /*containerItems*/
      16 && (l = ue(
        /*containerItems*/
        o[4]
      ), ae(), t = Lt(t, a, r, 1, o, l, s, e, cn, GM, null, PM), ce());
    },
    i(o) {
      if (!n) {
        for (let a = 0; a < l.length; a += 1)
          w(t[a]);
        n = !0;
      }
    },
    o(o) {
      for (let a = 0; a < t.length; a += 1)
        O(t[a]);
      n = !1;
    },
    d(o) {
      o && C(e);
      for (let a = 0; a < t.length; a += 1)
        t[a].d();
    }
  };
}
u(qM, "create_if_block$1q");
function GM(i, e) {
  let t, s, n;
  return s = new L5({ props: { item: (
    /*child*/
    e[29]
  ) } }), {
    key: i,
    first: null,
    c() {
      t = $e(), j(s.$$.fragment), this.first = t;
    },
    m(l, r) {
      T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      e = l;
      const o = {};
      r[0] & /*containerItems*/
      16 && (o.item = /*child*/
      e[29]), s.$set(o);
    },
    i(l) {
      n || (w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(s, l);
    }
  };
}
u(GM, "create_each_block$Z");
function Nle(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k;
  f = new S0({
    props: {
      actionId: (
        /*actionId*/
        i[2]
      ),
      action: (
        /*action*/
        i[3]
      ),
      item: (
        /*item*/
        i[1]
      )
    }
  }), f.$on(
    "toggleActionList",
    /*toggleActionList_handler*/
    i[21]
  ), f.$on(
    "toggleContainer",
    /*toggleContainer_handler*/
    i[22]
  );
  let S = (
    /*$actor*/
    i[5].isOwner && FM(i)
  ), D = (
    /*showDescription*/
    i[0] && RM(i)
  ), I = (
    /*showActionList*/
    i[8] && LM(i)
  ), M = (
    /*showContainerItems*/
    i[7] && qM(i)
  );
  return {
    c() {
      var L, B, z;
      e = E("li"), t = E("button"), s = E("img"), r = F(), o = E("img"), c = F(), j(f.$$.fragment), d = F(), S && S.c(), m = F(), D && D.c(), g = F(), I && I.c(), h = F(), M && M.c(), _ = $e(), b(s, "class", "a5e-item__image"), ze(s.src, n = /*action*/
      ((L = i[3]) == null ? void 0 : L.img) ?? /*item*/
      i[1].img ?? "icons/svg/item-bag.svg") || b(s, "src", n), b(s, "alt", l = /*action*/
      ((B = i[3]) == null ? void 0 : B.name) ?? /*item*/
      i[1].name), b(o, "class", "a5e-item__image--die"), ze(o.src, a = "/icons/svg/d20.svg") || b(o, "src", a), b(o, "alt", "Roll"), b(t, "class", "a5e-item__roll-button svelte-1tdpf4q"), Z(
        t,
        "a5e-item__roll-button--shift",
        /*$pressedKeysStore*/
        i[10].Shift
      ), Z(
        t,
        "a5e-item__roll-button--ctrl",
        /*$pressedKeysStore*/
        i[10].Control
      ), Z(t, "disable-pointer-events", !/*$actor*/
      i[5].isOwner), b(e, "class", "a5e-item"), b(e, "draggable", "true"), b(e, "data-document-uuid", p = /*item*/
      i[1].uuid), Z(e, "a5e-item--highlight", Number(
        /*item*/
        i[1].system.prepared ?? 0
      ) === /*A5E*/
      i[12].PREPARED_STATES.PREPARED || /*item*/
      i[1].system.equippedState === /*A5E*/
      i[12].EQUIPPED_STATES.EQUIPPED && !/*item*/
      ((z = i[1].system) != null && z.containerId)), Z(e, "a5e-item--purple-highlight", Number(
        /*item*/
        i[1].system.prepared ?? 0
      ) === /*A5E*/
      i[12].PREPARED_STATES.ALWAYS_PREPARED), Z(
        e,
        "a5e-item--red-highlight",
        /*item*/
        i[1].system.requiresBloodied
      );
    },
    m(L, B) {
      T(L, e, B), A(e, t), A(t, s), A(t, r), A(t, o), A(e, c), R(f, e, null), A(e, d), S && S.m(e, null), T(L, m, B), D && D.m(L, B), T(L, g, B), I && I.m(L, B), T(L, h, B), M && M.m(L, B), T(L, _, B), y = !0, v || (k = [
        W(t, "click", Ve(
          /*click_handler*/
          i[20]
        )),
        W(
          e,
          "dragstart",
          /*onDragStart*/
          i[18]
        ),
        W(e, "drop", Ve(st(
          /*drop_handler*/
          i[23]
        ))),
        W(
          e,
          "click",
          /*click_handler_1*/
          i[24]
        ),
        W(
          e,
          "auxclick",
          /*auxclick_handler*/
          i[25]
        )
      ], v = !0);
    },
    p(L, B) {
      var q, U, H;
      (!y || B[0] & /*action, item*/
      10 && !ze(s.src, n = /*action*/
      ((q = L[3]) == null ? void 0 : q.img) ?? /*item*/
      L[1].img ?? "icons/svg/item-bag.svg")) && b(s, "src", n), (!y || B[0] & /*action, item*/
      10 && l !== (l = /*action*/
      ((U = L[3]) == null ? void 0 : U.name) ?? /*item*/
      L[1].name)) && b(s, "alt", l), (!y || B[0] & /*$pressedKeysStore*/
      1024) && Z(
        t,
        "a5e-item__roll-button--shift",
        /*$pressedKeysStore*/
        L[10].Shift
      ), (!y || B[0] & /*$pressedKeysStore*/
      1024) && Z(
        t,
        "a5e-item__roll-button--ctrl",
        /*$pressedKeysStore*/
        L[10].Control
      ), (!y || B[0] & /*$actor*/
      32) && Z(t, "disable-pointer-events", !/*$actor*/
      L[5].isOwner);
      const z = {};
      B[0] & /*actionId*/
      4 && (z.actionId = /*actionId*/
      L[2]), B[0] & /*action*/
      8 && (z.action = /*action*/
      L[3]), B[0] & /*item*/
      2 && (z.item = /*item*/
      L[1]), f.$set(z), /*$actor*/
      L[5].isOwner ? S ? (S.p(L, B), B[0] & /*$actor*/
      32 && w(S, 1)) : (S = FM(L), S.c(), w(S, 1), S.m(e, null)) : S && (ae(), O(S, 1, 1, () => {
        S = null;
      }), ce()), (!y || B[0] & /*item*/
      2 && p !== (p = /*item*/
      L[1].uuid)) && b(e, "data-document-uuid", p), (!y || B[0] & /*item, A5E*/
      4098) && Z(e, "a5e-item--highlight", Number(
        /*item*/
        L[1].system.prepared ?? 0
      ) === /*A5E*/
      L[12].PREPARED_STATES.PREPARED || /*item*/
      L[1].system.equippedState === /*A5E*/
      L[12].EQUIPPED_STATES.EQUIPPED && !/*item*/
      ((H = L[1].system) != null && H.containerId)), (!y || B[0] & /*item, A5E*/
      4098) && Z(e, "a5e-item--purple-highlight", Number(
        /*item*/
        L[1].system.prepared ?? 0
      ) === /*A5E*/
      L[12].PREPARED_STATES.ALWAYS_PREPARED), (!y || B[0] & /*item*/
      2) && Z(
        e,
        "a5e-item--red-highlight",
        /*item*/
        L[1].system.requiresBloodied
      ), /*showDescription*/
      L[0] ? D ? (D.p(L, B), B[0] & /*showDescription*/
      1 && w(D, 1)) : (D = RM(L), D.c(), w(D, 1), D.m(g.parentNode, g)) : D && (ae(), O(D, 1, 1, () => {
        D = null;
      }), ce()), /*showActionList*/
      L[8] ? I ? (I.p(L, B), B[0] & /*showActionList*/
      256 && w(I, 1)) : (I = LM(L), I.c(), w(I, 1), I.m(h.parentNode, h)) : I && (ae(), O(I, 1, 1, () => {
        I = null;
      }), ce()), /*showContainerItems*/
      L[7] ? M ? (M.p(L, B), B[0] & /*showContainerItems*/
      128 && w(M, 1)) : (M = qM(L), M.c(), w(M, 1), M.m(_.parentNode, _)) : M && (ae(), O(M, 1, 1, () => {
        M = null;
      }), ce());
    },
    i(L) {
      y || (w(f.$$.fragment, L), w(S), w(D), w(I), w(M), y = !0);
    },
    o(L) {
      O(f.$$.fragment, L), O(S), O(D), O(I), O(M), y = !1;
    },
    d(L) {
      L && (C(e), C(m), C(g), C(h), C(_)), N(f), S && S.d(), D && D.d(L), I && I.d(L), M && M.d(L), v = !1, Me(k);
    }
  };
}
u(Nle, "create_fragment$2z");
function jle(i, e, t) {
  var Y, J;
  let s, n, l, r, o, a, c, f;
  pe(i, Ml, (fe) => t(10, f = fe));
  let { item: d } = e, { action: p = null } = e, { actionId: m = null } = e, { showDescription: g = !1 } = e;
  const h = de("actor");
  pe(i, h, (fe) => t(5, c = fe));
  const { A5E: _ } = CONFIG, y = ft();
  let v = ((Y = game.settings) == null ? void 0 : Y.get("a5e", "itemRightClickConfigure")) ?? !1, k = (J = game.user) == null ? void 0 : J.isGM;
  function S(fe, ke, ee) {
    var ne, Ee;
    return fe ? !1 : ((ne = ke.actions) == null ? void 0 : ne.count) < 2 ? [...((Ee = ke.actions) == null ? void 0 : Ee.values()) ?? []].some((Pe) => {
      var ye, me;
      return ((ye = Pe.uses) == null ? void 0 : ye.value) || ((me = Pe.uses) == null ? void 0 : me.max);
    }) : !(ke.getFlag("a5e", "showActionList") === !1 || game.settings.get("a5e", "collapseActionList") && ee);
  }
  u(S, "determineActionListVisibility");
  function D() {
    const fe = ql(f);
    d.activate(m, fe);
  }
  u(D, "onItemActivate");
  async function I() {
    var fe;
    if (m) {
      (fe = d.actions) == null || fe.configure(m);
      return;
    }
    d.configureItem();
  }
  u(I, "onConfigure");
  function M(fe) {
    var ee;
    const ke = d.toDragData();
    if (ke)
      return ke.actorId = d == null ? void 0 : d.parent.id, m && (ke.actionId = m), (ee = fe.dataTransfer) == null ? void 0 : ee.setData("text/plain", JSON.stringify(ke));
  }
  u(M, "onDragStart");
  async function L(fe) {
    return await TextEditor.enrichHTML(
      m && p ? p.description : fe.system.description,
      {
        async: !0,
        secrets: fe.isOwner,
        relativeTo: fe,
        rollData: (c == null ? void 0 : c.getRollData(fe)) ?? {}
      }
    ) ?? K("A5E.NoDescription");
  }
  u(L, "getDescription");
  const B = /* @__PURE__ */ u(({ target: fe }) => {
    fe == null || fe.blur(), D();
  }, "click_handler"), z = /* @__PURE__ */ u(() => {
    t(8, r = !r), d.setFlag("a5e", "showActionList", r);
  }, "toggleActionList_handler"), q = /* @__PURE__ */ u(() => {
    t(7, o = !o), d.setFlag("a5e", "showContainer", o);
  }, "toggleContainer_handler"), U = /* @__PURE__ */ u((fe) => y("dropObject", fe), "drop_handler"), H = /* @__PURE__ */ u(() => {
    t(0, g = !g);
  }, "click_handler_1"), V = /* @__PURE__ */ u(() => {
    v && I();
  }, "auxclick_handler");
  return i.$$set = (fe) => {
    "item" in fe && t(1, d = fe.item), "action" in fe && t(3, p = fe.action), "actionId" in fe && t(2, m = fe.actionId), "showDescription" in fe && t(0, g = fe.showDescription);
  }, i.$$.update = () => {
    var fe, ke;
    i.$$.dirty[0] & /*item, $actor*/
    34 && t(4, s = ((d == null ? void 0 : d.contents) ?? []).reduce(
      (ee, ne) => {
        var Ee;
        return !ne || ((Ee = ne.parent) == null ? void 0 : Ee.id) !== c.id || ee.push([(ne == null ? void 0 : ne.id) ?? foundry.utils.randomID(), ne]), ee;
      },
      []
    )), i.$$.dirty[0] & /*item*/
    2 && t(9, n = L(d).then((ee) => t(9, n = ee)).catch((ee) => t(9, n = ee))), i.$$.dirty[0] & /*$actor*/
    32 && t(19, l = c.isOwner ? ((ke = (fe = c.flags) == null ? void 0 : fe.a5e) == null ? void 0 : ke.sheetIsLocked) ?? !0 : !0), i.$$.dirty[0] & /*action, item, sheetIsLocked*/
    524298 && t(8, r = S(p, d, l)), i.$$.dirty[0] & /*item, containerItems*/
    18 && t(7, o = d.getFlag("a5e", "showContainer") ?? s.length > 0), i.$$.dirty[0] & /*item, action*/
    10 && t(6, a = nd(d, p));
  }, [
    g,
    d,
    m,
    p,
    s,
    c,
    a,
    o,
    r,
    n,
    f,
    h,
    _,
    y,
    v,
    k,
    D,
    I,
    M,
    l,
    B,
    z,
    q,
    U,
    H,
    V
  ];
}
u(jle, "instance$2q");
var Va;
let L5 = (Va = class extends re {
  constructor(e) {
    super(), oe(
      this,
      e,
      jle,
      Nle,
      le,
      {
        item: 1,
        action: 3,
        actionId: 2,
        showDescription: 0
      },
      null,
      [-1, -1]
    );
  }
}, u(Va, "Item"), Va);
function zM(i, e, t) {
  const s = i.slice();
  s[12] = e[t];
  const n = (
    /*slot*/
    s[12] > /*spellResources*/
    s[2].slots[
      /*level*/
      s[0].toString()
    ].current
  );
  return s[13] = n, s;
}
u(zM, "get_each_context$Y");
function HM(i) {
  let e;
  function t(l, r) {
    return (
      /*sheetIsLocked*/
      l[1] ? Ble : Lle
    );
  }
  u(t, "select_block_type");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("div"), n.c(), b(e, "class", "spell-slot-wrapper svelte-26h8qx"), Z(
        e,
        "spell-slot-wrapper--locked",
        /*sheetIsLocked*/
        i[1]
      );
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null))), r & /*sheetIsLocked*/
      2 && Z(
        e,
        "spell-slot-wrapper--locked",
        /*sheetIsLocked*/
        l[1]
      );
    },
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(HM, "create_if_block$1p");
function Lle(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("input"), n = Q(`
            /
            `), l = E("input"), b(e, "class", "number-input svelte-26h8qx"), b(e, "type", "number"), b(e, "name", t = "system.spellResources.slots." + /*level*/
      i[0] + ".current"), e.value = s = /*spellResources*/
      i[2].slots[
        /*level*/
        i[0].toString()
      ].current, b(e, "placeholder", "0"), b(e, "min", "0"), Z(e, "disable-pointer-events", !/*$actor*/
      i[3].isOwner), b(l, "class", "number-input svelte-26h8qx"), b(l, "type", "number"), l.value = /*maxSpellSlots*/
      i[4], b(l, "placeholder", "0"), b(l, "min", "0");
    },
    m(a, c) {
      T(a, e, c), T(a, n, c), T(a, l, c), r || (o = [
        W(
          e,
          "change",
          /*change_handler*/
          i[9]
        ),
        W(
          l,
          "change",
          /*change_handler_1*/
          i[10]
        )
      ], r = !0);
    },
    p(a, c) {
      c & /*level*/
      1 && t !== (t = "system.spellResources.slots." + /*level*/
      a[0] + ".current") && b(e, "name", t), c & /*spellResources, level*/
      5 && s !== (s = /*spellResources*/
      a[2].slots[
        /*level*/
        a[0].toString()
      ].current) && e.value !== s && (e.value = s), c & /*$actor*/
      8 && Z(e, "disable-pointer-events", !/*$actor*/
      a[3].isOwner), c & /*maxSpellSlots*/
      16 && l.value !== /*maxSpellSlots*/
      a[4] && (l.value = /*maxSpellSlots*/
      a[4]);
    },
    d(a) {
      a && (C(e), C(n), C(l)), r = !1, Me(o);
    }
  };
}
u(Lle, "create_else_block$u");
function Ble(i) {
  let e, t = ue(Array.from({ length: (
    /*maxSpellSlots*/
    i[4]
  ) }, VM)), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = UM(zM(i, t, n));
  return {
    c() {
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      e = $e();
    },
    m(n, l) {
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(n, l);
      T(n, e, l);
    },
    p(n, l) {
      if (l & /*Array, maxSpellSlots, spellResources, level, $actor, updateSpellSlots*/
      157) {
        t = ue(Array.from({ length: (
          /*maxSpellSlots*/
          n[4]
        ) }, VM));
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = zM(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = UM(o), s[r].c(), s[r].m(e.parentNode, e));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(Ble, "create_if_block_1$V");
function UM(i) {
  let e, t, s;
  function n() {
    return (
      /*click_handler*/
      i[8](
        /*slot*/
        i[12]
      )
    );
  }
  return u(n, "click_handler"), {
    c() {
      e = E("button"), e.innerHTML = '<i class="a5e-spell-slot__icon fa-solid fa-star svelte-26h8qx"></i> ', b(e, "class", "a5e-spell-slot svelte-26h8qx"), Z(
        e,
        "a5e-spell-slot--expended",
        /*slotExpended*/
        i[13]
      ), Z(e, "disable-pointer-events", !/*$actor*/
      i[3].isOwner);
    },
    m(l, r) {
      T(l, e, r), t || (s = W(e, "click", n), t = !0);
    },
    p(l, r) {
      i = l, r & /*Array, maxSpellSlots, spellResources, level*/
      21 && Z(
        e,
        "a5e-spell-slot--expended",
        /*slotExpended*/
        i[13]
      ), r & /*$actor*/
      8 && Z(e, "disable-pointer-events", !/*$actor*/
      i[3].isOwner);
    },
    d(l) {
      l && C(e), t = !1, s();
    }
  };
}
u(UM, "create_each_block$Y");
function qle(i) {
  let e, t = (
    /*level*/
    i[0] && /*level*/
    i[0] !== "0" && HM(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, [n]) {
      /*level*/
      s[0] && /*level*/
      s[0] !== "0" ? t ? t.p(s, n) : (t = HM(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    i: se,
    o: se,
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(qle, "create_fragment$2y");
const VM = /* @__PURE__ */ u((i, e) => e + 1, "func$4");
function Gle(i, e, t) {
  let s, n, l, r, { level: o = 0 } = e;
  const a = de("actor");
  pe(i, a, (h) => t(3, r = h));
  function c() {
    var h, _, y;
    return r.type !== "character" ? (h = s.slots[o.toString()]) == null ? void 0 : h.max : n ? (_ = s.slots[o.toString()]) == null ? void 0 : _.max : (y = s.slots[o.toString()]) == null ? void 0 : y.override;
  }
  u(c, "getMaxSpellSlots");
  function f(h) {
    const _ = r.type === "character" ? `system.spellResources.slots.${o}.override` : `system.spellResources.slots.${o}.max`;
    te(r, _, h);
  }
  u(f, "updateSpellSlotMax");
  function d(h, _) {
    let y = _;
    _ <= s.slots[h.toString()].current && (y = _ - 1), r.update({
      [`system.spellResources.slots.${h}.current`]: y
    });
  }
  u(d, "updateSpellSlots");
  const p = /* @__PURE__ */ u((h) => d(o, h), "click_handler"), m = /* @__PURE__ */ u(({ target: h }) => te(r, h.name, Number(h.value)), "change_handler"), g = /* @__PURE__ */ u(({ target: h }) => f(Number(h.value)), "change_handler_1");
  return i.$$set = (h) => {
    "level" in h && t(0, o = h.level);
  }, i.$$.update = () => {
    var h, _;
    i.$$.dirty & /*$actor*/
    8 && t(2, s = r.system.spellResources), i.$$.dirty & /*$actor*/
    8 && t(1, n = r.isOwner ? ((_ = (h = r.flags) == null ? void 0 : h.a5e) == null ? void 0 : _.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*spellResources, sheetIsLocked*/
    6 && t(4, l = c());
  }, [
    o,
    n,
    s,
    r,
    l,
    a,
    f,
    d,
    p,
    m,
    g
  ];
}
u(Gle, "instance$2p");
const iS = class iS extends re {
  constructor(e) {
    super(), oe(this, e, Gle, qle, le, { level: 0 });
  }
};
u(iS, "SpellSlots");
let C0 = iS;
function WM(i, e, t) {
  const s = i.slice();
  return s[19] = e[t], s;
}
u(WM, "get_each_context$X");
function KM(i) {
  let e, t, s, n, l, r, o, a, c, f, d = (
    /*icon*/
    i[0] && YM(i)
  );
  function p(S, D) {
    return (
      /*type*/
      S[4] === "favorites" ? Hle : zle
    );
  }
  u(p, "select_block_type");
  let m = p(i), g = m(i), h = (
    /*type*/
    i[4] === "spellLevels" && /*showSpellSlots*/
    i[9] && XM(i)
  ), _ = (
    /*type*/
    i[4] === "spellLevels" && /*showArtifactCharges*/
    i[5] && JM(i)
  ), y = (
    /*type*/
    i[4] === "spellLevels" && /*showSpellPoints*/
    i[8] && ZM(i)
  ), v = (
    /*showQuantity*/
    i[7] && QM()
  ), k = (
    /*showUses*/
    i[10] && xM()
  );
  return {
    c() {
      e = E("header"), t = E("h3"), s = E("div"), d && d.c(), n = F(), g.c(), l = F(), h && h.c(), r = F(), _ && _.c(), o = F(), y && y.c(), a = F(), v && v.c(), c = F(), k && k.c(), b(t, "class", "a5e-section-header__heading a5e-section-header__heading--name svelte-1yybusz"), b(e, "class", "a5e-section-header a5e-section-header--item-list"), G(
        e,
        "--a5e-section-heading-template-areas",
        /*headingTemplateConfiguration*/
        i[12].areas
      ), G(
        e,
        "--a5e-section-heading-template-columns",
        /*headingTemplateConfiguration*/
        i[12].columns
      ), Z(e, "a5e-section-header--flat-bottom", [.../*items*/
      i[3]].length);
    },
    m(S, D) {
      T(S, e, D), A(e, t), A(t, s), d && d.m(s, null), A(s, n), g.m(s, null), A(t, l), h && h.m(t, null), A(t, r), _ && _.m(t, null), A(t, o), y && y.m(t, null), A(e, a), v && v.m(e, null), A(e, c), k && k.m(e, null), f = !0;
    },
    p(S, D) {
      /*icon*/
      S[0] ? d ? d.p(S, D) : (d = YM(S), d.c(), d.m(s, n)) : d && (d.d(1), d = null), m === (m = p(S)) && g ? g.p(S, D) : (g.d(1), g = m(S), g && (g.c(), g.m(s, null))), /*type*/
      S[4] === "spellLevels" && /*showSpellSlots*/
      S[9] ? h ? (h.p(S, D), D & /*type, showSpellSlots*/
      528 && w(h, 1)) : (h = XM(S), h.c(), w(h, 1), h.m(t, r)) : h && (ae(), O(h, 1, 1, () => {
        h = null;
      }), ce()), /*type*/
      S[4] === "spellLevels" && /*showArtifactCharges*/
      S[5] ? _ ? _.p(S, D) : (_ = JM(S), _.c(), _.m(t, o)) : _ && (_.d(1), _ = null), /*type*/
      S[4] === "spellLevels" && /*showSpellPoints*/
      S[8] ? y ? y.p(S, D) : (y = ZM(S), y.c(), y.m(t, null)) : y && (y.d(1), y = null), /*showQuantity*/
      S[7] ? v || (v = QM(), v.c(), v.m(e, c)) : v && (v.d(1), v = null), /*showUses*/
      S[10] ? k || (k = xM(), k.c(), k.m(e, null)) : k && (k.d(1), k = null), (!f || D & /*headingTemplateConfiguration*/
      4096) && G(
        e,
        "--a5e-section-heading-template-areas",
        /*headingTemplateConfiguration*/
        S[12].areas
      ), (!f || D & /*headingTemplateConfiguration*/
      4096) && G(
        e,
        "--a5e-section-heading-template-columns",
        /*headingTemplateConfiguration*/
        S[12].columns
      ), (!f || D & /*items*/
      8) && Z(e, "a5e-section-header--flat-bottom", [.../*items*/
      S[3]].length);
    },
    i(S) {
      f || (w(h), f = !0);
    },
    o(S) {
      O(h), f = !1;
    },
    d(S) {
      S && C(e), d && d.d(), g.d(), h && h.d(), _ && _.d(), y && y.d(), v && v.d(), k && k.d();
    }
  };
}
u(KM, "create_if_block$1o");
function YM(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", t = di(
        /*icon*/
        i[0]
      ) + " svelte-1yybusz");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*icon*/
      1 && t !== (t = di(
        /*icon*/
        s[0]
      ) + " svelte-1yybusz") && b(e, "class", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(YM, "create_if_block_7$b");
function zle(i) {
  let e = K(
    /*A5E*/
    (i[15][
      /*type*/
      i[4]
    ] ?? {})[
      /*label*/
      i[1]
    ] ?? /*label*/
    i[1]
  ) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*type, label*/
      18 && e !== (e = K(
        /*A5E*/
        (s[15][
          /*type*/
          s[4]
        ] ?? {})[
          /*label*/
          s[1]
        ] ?? /*label*/
        s[1]
      ) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(zle, "create_else_block$t");
function Hle(i) {
  let e = K(
    /*label*/
    i[1]
  ) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*label*/
      2 && e !== (e = K(
        /*label*/
        s[1]
      ) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(Hle, "create_if_block_6$d");
function XM(i) {
  let e, t;
  return e = new C0({ props: { level: (
    /*level*/
    i[2]
  ) } }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*level*/
      4 && (l.level = /*level*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(XM, "create_if_block_5$e");
function JM(i) {
  var s;
  let e = K("A5E.ArtifactChargesCost", {
    cost: (
      /*A5E*/
      ((s = i[15].WIELDER_ARTIFACT_CHARGES[
        /*level*/
        i[2]
      ]) == null ? void 0 : s.charges) ?? 0
    )
  }) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(n, l) {
      T(n, t, l);
    },
    p(n, l) {
      var r;
      l & /*level*/
      4 && e !== (e = K("A5E.ArtifactChargesCost", {
        cost: (
          /*A5E*/
          ((r = n[15].WIELDER_ARTIFACT_CHARGES[
            /*level*/
            n[2]
          ]) == null ? void 0 : r.charges) ?? 0
        )
      }) + "") && be(t, e);
    },
    d(n) {
      n && C(t);
    }
  };
}
u(JM, "create_if_block_4$k");
function ZM(i) {
  let e = K("A5E.SpellPointsCost", {
    cost: (
      /*A5E*/
      i[15].spellLevelCost[
        /*level*/
        i[2]
      ]
    )
  }) + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*level*/
      4 && e !== (e = K("A5E.SpellPointsCost", {
        cost: (
          /*A5E*/
          s[15].spellLevelCost[
            /*level*/
            s[2]
          ]
        )
      }) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(ZM, "create_if_block_3$p");
function QM(i) {
  let e;
  return {
    c() {
      e = E("h3"), e.textContent = "Quantity", b(e, "class", "a5e-section-header__heading a5e-section-header__heading--center a5e-section-header__heading--quantity svelte-1yybusz");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(QM, "create_if_block_2$C");
function xM(i) {
  let e;
  return {
    c() {
      e = E("h3"), e.textContent = "Uses", b(e, "class", "a5e-section-header__heading a5e-section-header__heading--center a5e-section-header__heading--uses svelte-1yybusz");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(xM, "create_if_block_1$U");
function eF(i, e) {
  let t, s, n, l, r, o;
  return s = new L5({
    props: {
      item: (
        /*item*/
        e[19]
      ),
      showDescription: (
        /*showDescription*/
        e[6]
      )
    }
  }), s.$on(
    "dropObject",
    /*dropObject_handler*/
    e[17]
  ), {
    key: i,
    first: null,
    c() {
      t = $e(), n = E("div"), j(s.$$.fragment), G(n, "display", "contents"), G(n, "--itemTemplateAreas", l = /*itemTemplateConfiguration*/
      e[11].areas), G(n, "--itemTemplateColumns", r = /*itemTemplateConfiguration*/
      e[11].columns), this.first = t;
    },
    m(a, c) {
      T(a, t, c), T(a, n, c), R(s, n, null), o = !0;
    },
    p(a, c) {
      e = a, c & /*itemTemplateConfiguration*/
      2048 && l !== (l = /*itemTemplateConfiguration*/
      e[11].areas) && G(n, "--itemTemplateAreas", l), c & /*itemTemplateConfiguration*/
      2048 && r !== (r = /*itemTemplateConfiguration*/
      e[11].columns) && G(n, "--itemTemplateColumns", r);
      const f = {};
      c & /*items*/
      8 && (f.item = /*item*/
      e[19]), c & /*showDescription*/
      64 && (f.showDescription = /*showDescription*/
      e[6]), s.$set(f);
    },
    i(a) {
      o || (w(s.$$.fragment, a), o = !0);
    },
    o(a) {
      O(s.$$.fragment, a), o = !1;
    },
    d(a) {
      a && C(t), a && s && C(n), N(s, a);
    }
  };
}
u(eF, "create_each_block$X");
function Ule(i) {
  let e, t, s, n = [], l = /* @__PURE__ */ new Map(), r, o = !/*type*/
  (i[4] === "featureTypes" && /*$actor*/
  i[13].type === "npc") && KM(i), a = ue([.../*items*/
  i[3]]);
  const c = /* @__PURE__ */ u((f) => {
    var d;
    return (
      /*item*/
      (d = f[19]) == null ? void 0 : d.id
    );
  }, "get_key");
  for (let f = 0; f < a.length; f += 1) {
    let d = WM(i, a, f), p = c(d);
    l.set(p, n[f] = eF(p, d));
  }
  return {
    c() {
      e = E("section"), o && o.c(), t = F(), s = E("ul");
      for (let f = 0; f < n.length; f += 1)
        n[f].c();
      b(s, "class", "a5e-item-list"), b(e, "class", "category-container");
    },
    m(f, d) {
      T(f, e, d), o && o.m(e, null), A(e, t), A(e, s);
      for (let p = 0; p < n.length; p += 1)
        n[p] && n[p].m(s, null);
      r = !0;
    },
    p(f, [d]) {
      /*type*/
      f[4] === "featureTypes" && /*$actor*/
      f[13].type === "npc" ? o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce()) : o ? (o.p(f, d), d & /*type, $actor*/
      8208 && w(o, 1)) : (o = KM(f), o.c(), w(o, 1), o.m(e, t)), d & /*items, showDescription, onDropObject, itemTemplateConfiguration*/
      67656 && (a = ue([.../*items*/
      f[3]]), ae(), n = Lt(n, d, c, 1, f, a, l, s, cn, eF, null, WM), ce());
    },
    i(f) {
      if (!r) {
        w(o);
        for (let d = 0; d < a.length; d += 1)
          w(n[d]);
        r = !0;
      }
    },
    o(f) {
      O(o);
      for (let d = 0; d < n.length; d += 1)
        O(n[d]);
      r = !1;
    },
    d(f) {
      f && C(e), o && o.d();
      for (let d = 0; d < n.length; d += 1)
        n[d].d();
    }
  };
}
u(Ule, "create_fragment$2x");
function Vle(i, e) {
  let t = "name", s = "1fr";
  return i ? e ? (t = "name quantity uses", s = "1fr 4rem 6.25rem") : (t = "name uses", s = "1fr 6.25rem") : e && (t = "name quantity", s = "1fr 4rem"), t += " menu", s += " 2rem", { areas: `"${t}"`, columns: s };
}
u(Vle, "getHeadingTemplateConfiguration");
function Wle(i, e) {
  let t = "icon name indicators", s = "min-content 1fr min-content";
  return i ? e ? (t = "icon name indicators quantity uses", s = "min-content 1fr min-content 4rem 6.25rem") : (t = "icon name indicators uses", s = "min-content 1fr min-content 6.25rem") : e && (t = "icon name indicators quantity", s = "min-content 1fr min-content 4rem"), t += " menu", s += " 2rem", { areas: `"${t}"`, columns: s };
}
u(Wle, "getItemTemplateConfiguration");
function Kle(i, e, t) {
  let s, n, l, { icon: r = null } = e, { label: o } = e, { level: a = 0 } = e, { items: c } = e, { type: f } = e, { showArtifactCharges: d = !1 } = e, { showDescription: p = !1 } = e, { showQuantity: m = !1 } = e, { showSpellPoints: g = !1 } = e, { showSpellSlots: h = !1 } = e, { showUses: _ = !1 } = e;
  const y = de("actor");
  pe(i, y, (I) => t(13, l = I));
  const v = de("sheet"), { A5E: k } = CONFIG;
  async function S(I, M) {
    var V;
    const L = JSON.parse(I.dataTransfer.getData("text/plain")).uuid, B = await fromUuid(L), q = I.target.closest(".a5e-item").getAttribute("data-document-uuid"), U = await fromUuid(q);
    if (((V = U == null ? void 0 : U.system) == null ? void 0 : V.objectType) === "container") {
      v._onDrop(I, { containerUuid: U.uuid });
      return;
    }
    if (!M.includes(B)) return v._onDrop(I);
    const H = SortingHelpers.performIntegerSort(B, { target: U, siblings: M });
    l.updateEmbeddedDocuments("Item", H.map(({ target: Y, update: J }) => ({ _id: Y.id, sort: J.sort })));
  }
  u(S, "onDropObject");
  const D = /* @__PURE__ */ u(({ detail: I }) => S(I, [...c]), "dropObject_handler");
  return i.$$set = (I) => {
    "icon" in I && t(0, r = I.icon), "label" in I && t(1, o = I.label), "level" in I && t(2, a = I.level), "items" in I && t(3, c = I.items), "type" in I && t(4, f = I.type), "showArtifactCharges" in I && t(5, d = I.showArtifactCharges), "showDescription" in I && t(6, p = I.showDescription), "showQuantity" in I && t(7, m = I.showQuantity), "showSpellPoints" in I && t(8, g = I.showSpellPoints), "showSpellSlots" in I && t(9, h = I.showSpellSlots), "showUses" in I && t(10, _ = I.showUses);
  }, i.$$.update = () => {
    i.$$.dirty & /*showUses, showQuantity*/
    1152 && t(12, s = Vle(_, m)), i.$$.dirty & /*showUses, showQuantity*/
    1152 && t(11, n = Wle(_, m));
  }, [
    r,
    o,
    a,
    c,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    n,
    s,
    l,
    y,
    k,
    S,
    D
  ];
}
u(Kle, "instance$2o");
const lS = class lS extends re {
  constructor(e) {
    super(), oe(this, e, Kle, Ule, le, {
      icon: 0,
      label: 1,
      level: 2,
      items: 3,
      type: 4,
      showArtifactCharges: 5,
      showDescription: 6,
      showQuantity: 7,
      showSpellPoints: 8,
      showSpellSlots: 9,
      showUses: 10
    });
  }
};
u(lS, "ItemCategory");
let $r = lS;
function nl(i) {
  return ((i == null ? void 0 : i.toString()) ?? "").replaceAll("-", "−");
}
u(nl, "replaceHyphenWithMinusSign");
function tF(i) {
  let e, t, s = _u(
    /*skill*/
    i[2].expertiseDice,
    !1
  ) + "", n, l;
  return {
    c() {
      e = E("span"), t = Q("("), n = Q(s), l = Q(")"), b(e, "class", "u-text-xs");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(e, n), A(e, l);
    },
    p(r, o) {
      o & /*skill*/
      4 && s !== (s = _u(
        /*skill*/
        r[2].expertiseDice,
        !1
      ) + "") && be(n, s);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(tF, "create_if_block_2$B");
function sF(i) {
  let e, t, s = (
    /*skill*/
    i[2].passive + ""
  ), n, l, r;
  return {
    c() {
      e = E("span"), t = Q("("), n = Q(s), l = Q(")"), b(e, "class", "skill__passive svelte-15dni4w"), b(e, "data-tooltip", r = K("A5E.SkillPassiveScore", {
        skill: (
          /*skills*/
          i[13][
            /*key*/
            i[1]
          ]
        )
      })), b(e, "data-tooltip-direction", "UP");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, n), A(e, l);
    },
    p(o, a) {
      a & /*skill*/
      4 && s !== (s = /*skill*/
      o[2].passive + "") && be(n, s), a & /*key*/
      2 && r !== (r = K("A5E.SkillPassiveScore", {
        skill: (
          /*skills*/
          o[13][
            /*key*/
            o[1]
          ]
        )
      })) && b(e, "data-tooltip", r);
    },
    d(o) {
      o && C(e);
    }
  };
}
u(sF, "create_if_block_1$T");
function nF(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "fas fa-cog skill__config-button svelte-15dni4w"), b(e, "data-tooltip", t = K("A5E.SkillConfigurationTooltip", {
        skill: (
          /*skills*/
          i[13][
            /*key*/
            i[1]
          ]
        )
      })), b(e, "data-tooltip-direction", "UP");
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "click",
        /*click_handler*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*key*/
      2 && t !== (t = K("A5E.SkillConfigurationTooltip", {
        skill: (
          /*skills*/
          l[13][
            /*key*/
            l[1]
          ]
        )
      })) && b(e, "data-tooltip", t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(nF, "create_if_block$1n");
function Yle(i) {
  var M;
  let e, t, s, n, l, r, o, a = (
    /*skills*/
    i[13][
      /*key*/
      i[1]
    ] + ""
  ), c, f, d, p, m, g = nl(
    /*showDeterministicBonus*/
    i[14] ? (
      /*skillBonus*/
      i[7] + /*abilityBonus*/
      i[8]
    ) : (
      /*skillBonus*/
      i[7]
    )
  ) + "", h, _, y, v, k, S = (
    /*skill*/
    i[2].expertiseDice && !/*hideExpertiseDice*/
    i[12] && tF(i)
  ), D = (
    /*$actor*/
    (((M = i[4].flags.a5e) == null ? void 0 : M.showPassiveScores) ?? !0) && sF(i)
  ), I = !/*sheetIsLocked*/
  i[5] && nF(i);
  return {
    c() {
      e = E("li"), t = E("button"), s = F(), n = E("button"), r = F(), o = E("h3"), c = Q(a), f = F(), S && S.c(), d = F(), p = E("div"), m = E("span"), h = Q(g), _ = F(), D && D.c(), y = F(), I && I.c(), b(t, "class", "skill__proficiency-icon svelte-15dni4w"), b(
        t,
        "data-tooltip",
        /*proficiencyTooltip*/
        i[6]
      ), b(t, "data-tooltip-direction", "UP"), Z(
        t,
        "fa-solid",
        /*proficiencyLevel*/
        i[3]
      ), Z(t, "fa-regular", !/*proficiencyLevel*/
      i[3]), Z(
        t,
        "skill__proficiency-icon--expertise",
        /*proficiencyLevel*/
        i[3] === "expertise"
      ), Z(
        t,
        "skill__proficiency-icon--jack",
        /*proficiencyLevel*/
        i[3] === "jack"
      ), Z(
        t,
        "skill__proficiency-icon--proficient",
        /*proficiencyLevel*/
        i[3] === "proficient"
      ), Z(
        t,
        "skill__proficiency-icon--locked",
        /*sheetIsLocked*/
        i[5]
      ), Z(
        t,
        "fa-award",
        /*proficiencyLevel*/
        i[3] === "expertise"
      ), Z(
        t,
        "fa-star-half-stroke",
        /*proficiencyLevel*/
        i[3] === "jack"
      ), Z(t, "fa-star", !/*proficiencyLevel*/
      i[3] || /*proficiencyLevel*/
      i[3] === "proficient"), b(n, "for", l = /*$actor*/
      i[4].id + "-" + /*key*/
      i[1] + "-proficient"), b(n, "class", "fa-solid fa-dice-d20 skill__roll-icon svelte-15dni4w"), Z(
        n,
        "skill__roll-icon--shift",
        /*$pressedKeysStore*/
        i[9].Shift
      ), Z(
        n,
        "skill__roll-icon--ctrl",
        /*$pressedKeysStore*/
        i[9].Control
      ), b(o, "class", "skill__name svelte-15dni4w"), Z(o, "disable-pointer-events", !/*$actor*/
      i[4].isOwner), b(m, "class", "skill__mod svelte-15dni4w"), b(p, "class", "skill__mod-wrapper svelte-15dni4w"), b(e, "class", "skill svelte-15dni4w"), Z(
        e,
        "skill--column-flow",
        /*columnFlow*/
        i[0]
      );
    },
    m(L, B) {
      T(L, e, B), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), A(o, c), A(o, f), S && S.m(o, null), A(e, d), A(e, p), A(p, m), A(m, h), A(p, _), D && D.m(p, null), A(e, y), I && I.m(e, null), v || (k = [
        W(
          t,
          "click",
          /*updateSkillProficiency*/
          i[10]
        ),
        W(o, "click", function() {
          $t(
            /*$actor*/
            i[4].rollSkillCheck(
              /*key*/
              i[1],
              ql(
                /*$pressedKeysStore*/
                i[9]
              )
            )
          ) && i[4].rollSkillCheck(
            /*key*/
            i[1],
            ql(
              /*$pressedKeysStore*/
              i[9]
            )
          ).apply(this, arguments);
        })
      ], v = !0);
    },
    p(L, [B]) {
      var z;
      i = L, B & /*proficiencyTooltip*/
      64 && b(
        t,
        "data-tooltip",
        /*proficiencyTooltip*/
        i[6]
      ), B & /*proficiencyLevel*/
      8 && Z(
        t,
        "fa-solid",
        /*proficiencyLevel*/
        i[3]
      ), B & /*proficiencyLevel*/
      8 && Z(t, "fa-regular", !/*proficiencyLevel*/
      i[3]), B & /*proficiencyLevel*/
      8 && Z(
        t,
        "skill__proficiency-icon--expertise",
        /*proficiencyLevel*/
        i[3] === "expertise"
      ), B & /*proficiencyLevel*/
      8 && Z(
        t,
        "skill__proficiency-icon--jack",
        /*proficiencyLevel*/
        i[3] === "jack"
      ), B & /*proficiencyLevel*/
      8 && Z(
        t,
        "skill__proficiency-icon--proficient",
        /*proficiencyLevel*/
        i[3] === "proficient"
      ), B & /*sheetIsLocked*/
      32 && Z(
        t,
        "skill__proficiency-icon--locked",
        /*sheetIsLocked*/
        i[5]
      ), B & /*proficiencyLevel*/
      8 && Z(
        t,
        "fa-award",
        /*proficiencyLevel*/
        i[3] === "expertise"
      ), B & /*proficiencyLevel*/
      8 && Z(
        t,
        "fa-star-half-stroke",
        /*proficiencyLevel*/
        i[3] === "jack"
      ), B & /*proficiencyLevel*/
      8 && Z(t, "fa-star", !/*proficiencyLevel*/
      i[3] || /*proficiencyLevel*/
      i[3] === "proficient"), B & /*$actor, key*/
      18 && l !== (l = /*$actor*/
      i[4].id + "-" + /*key*/
      i[1] + "-proficient") && b(n, "for", l), B & /*$pressedKeysStore*/
      512 && Z(
        n,
        "skill__roll-icon--shift",
        /*$pressedKeysStore*/
        i[9].Shift
      ), B & /*$pressedKeysStore*/
      512 && Z(
        n,
        "skill__roll-icon--ctrl",
        /*$pressedKeysStore*/
        i[9].Control
      ), B & /*key*/
      2 && a !== (a = /*skills*/
      i[13][
        /*key*/
        i[1]
      ] + "") && be(c, a), /*skill*/
      i[2].expertiseDice && !/*hideExpertiseDice*/
      i[12] ? S ? S.p(i, B) : (S = tF(i), S.c(), S.m(o, null)) : S && (S.d(1), S = null), B & /*$actor*/
      16 && Z(o, "disable-pointer-events", !/*$actor*/
      i[4].isOwner), B & /*skillBonus, abilityBonus*/
      384 && g !== (g = nl(
        /*showDeterministicBonus*/
        i[14] ? (
          /*skillBonus*/
          i[7] + /*abilityBonus*/
          i[8]
        ) : (
          /*skillBonus*/
          i[7]
        )
      ) + "") && be(h, g), /*$actor*/
      ((z = i[4].flags.a5e) == null ? void 0 : z.showPassiveScores) ?? !0 ? D ? D.p(i, B) : (D = sF(i), D.c(), D.m(p, null)) : D && (D.d(1), D = null), /*sheetIsLocked*/
      i[5] ? I && (I.d(1), I = null) : I ? I.p(i, B) : (I = nF(i), I.c(), I.m(e, null)), B & /*columnFlow*/
      1 && Z(
        e,
        "skill--column-flow",
        /*columnFlow*/
        i[0]
      );
    },
    i: se,
    o: se,
    d(L) {
      L && C(e), S && S.d(), D && D.d(), I && I.d(), v = !1, Me(k);
    }
  };
}
u(Yle, "create_fragment$2w");
function Xle(i, e) {
  var s;
  const t = (s = i.flags.a5e) == null ? void 0 : s.jackOfAllTrades;
  if (e.proficient === 2) return "expertise";
  if (e.proficient) return "proficient";
  if (t) return "jack";
}
u(Xle, "getProficiencyLevel");
function Jle(i, e, t) {
  var D, I;
  let s, n, l, r, o, a, c;
  pe(i, Ml, (M) => t(9, c = M));
  let { columnFlow: f } = e, { key: d } = e, { skill: p } = e;
  function m(M) {
    switch (M) {
      case "expertise":
        return "A5E.ProficiencyExpertise";
      case "jack":
        return "A5E.ProficiencyJack";
      case "proficient":
        return "A5E.ProficiencyProficient";
      default:
        return null;
    }
  }
  u(m, "getProficiencyTooltip");
  function g() {
    const M = p.proficient;
    let L;
    game.settings.get("a5e", "5eStyleExpertise") ? M === 2 ? L = 0 : M ? L = 2 : L = 1 : M ? L = 0 : L = 1, a.update({
      [`system.skills.${d}.proficient`]: L
    });
  }
  u(g, "updateSkillProficiency");
  function h() {
    const M = p.deterministicBonus;
    if (k)
      return M;
    const L = mt(a.BonusesManager.getAbilityBonusesFormula(p.ability, "check"), a.getRollData());
    return M - L;
  }
  u(h, "getSkillBonus");
  const _ = de("actor");
  pe(i, _, (M) => t(4, a = M));
  const y = game.settings.get("a5e", "hideExpertiseDice"), { skills: v } = CONFIG.A5E;
  let k = ((I = (D = a.flags) == null ? void 0 : D.a5e) == null ? void 0 : I.includeAbilityModifiersForSkills) ?? !0;
  const S = /* @__PURE__ */ u(() => a.configureSkill({ skillKey: d }), "click_handler");
  return i.$$set = (M) => {
    "columnFlow" in M && t(0, f = M.columnFlow), "key" in M && t(1, d = M.key), "skill" in M && t(2, p = M.skill);
  }, i.$$.update = () => {
    var M, L;
    i.$$.dirty & /*$actor, skill*/
    20 && t(8, s = a.system.abilities[p.ability].check.mod), i.$$.dirty & /*$actor*/
    16 && t(7, n = h()), i.$$.dirty & /*$actor, skill*/
    20 && t(3, l = Xle(a, p)), i.$$.dirty & /*proficiencyLevel*/
    8 && t(6, r = m(l)), i.$$.dirty & /*$actor*/
    16 && t(5, o = a.isOwner ? ((L = (M = a.flags) == null ? void 0 : M.a5e) == null ? void 0 : L.sheetIsLocked) ?? !0 : !0);
  }, [
    f,
    d,
    p,
    l,
    a,
    o,
    r,
    n,
    s,
    c,
    g,
    _,
    y,
    v,
    k,
    S
  ];
}
u(Jle, "instance$2n");
const rS = class rS extends re {
  constructor(e) {
    super(), oe(this, e, Jle, Yle, le, { columnFlow: 0, key: 1, skill: 2 });
  }
};
u(rS, "Skill");
let T0 = rS;
function iF(i, e, t) {
  const s = i.slice();
  return s[12] = e[t][0], s[13] = e[t][1], s[15] = t, s;
}
u(iF, "get_each_context$W");
function lF(i, e, t) {
  const s = i.slice();
  s[16] = e[t][0], s[13] = e[t][1];
  const n = (
    /*getSkillSpecialties*/
    s[3](
      /*skillKey*/
      s[16],
      /*skill*/
      s[13]
    )
  );
  s[17] = n;
  const l = K(
    /*A5E*/
    s[6].skills[
      /*skillKey*/
      s[16]
    ]
  );
  return s[18] = l, s;
}
u(lF, "get_each_context_1$a");
function rF(i, e, t) {
  const s = i.slice();
  return s[21] = e[t], s;
}
u(rF, "get_each_context_2$1");
function oF(i) {
  let e, t, s;
  return e = new ie({
    props: {
      $$slots: { default: [Zle] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-background", "rgba(0, 0, 0, 0.05)"), G(t, "--a5e-field-wrapper-border", "1px solid #ccc"), G(t, "--a5e-field-wrapper-padding", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, skills*/
      16777217 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(oF, "create_if_block$1m");
function aF(i) {
  let e, t = (
    /*skillName*/
    i[18] + ""
  ), s, n, l, r, o = ue(
    /*specialties*/
    i[17]
  ), a = [];
  for (let c = 0; c < o.length; c += 1)
    a[c] = cF(rF(i, o, c));
  return {
    c() {
      e = E("dt"), s = Q(t), n = F(), l = E("dd");
      for (let c = 0; c < a.length; c += 1)
        a[c].c();
      r = F(), b(e, "class", "a5e-skill-specialties__skill"), b(l, "class", "a5e-skill-specialties__list");
    },
    m(c, f) {
      T(c, e, f), A(e, s), A(e, n), T(c, l, f);
      for (let d = 0; d < a.length; d += 1)
        a[d] && a[d].m(l, null);
      A(l, r);
    },
    p(c, f) {
      if (f & /*skills*/
      1 && t !== (t = /*skillName*/
      c[18] + "") && be(s, t), f & /*A5E, Object, skills, getSkillSpecialties, rollSkillCheckWithSpecialty*/
      89) {
        o = ue(
          /*specialties*/
          c[17]
        );
        let d;
        for (d = 0; d < o.length; d += 1) {
          const p = rF(c, o, d);
          a[d] ? a[d].p(p, f) : (a[d] = cF(p), a[d].c(), a[d].m(l, r));
        }
        for (; d < a.length; d += 1)
          a[d].d(1);
        a.length = o.length;
      }
    },
    d(c) {
      c && (C(e), C(l)), Le(a, c);
    }
  };
}
u(aF, "create_if_block_1$S");
function cF(i) {
  let e, t = (
    /*specialty*/
    i[21] + ""
  ), s, n, l, r;
  function o() {
    return (
      /*click_handler*/
      i[8](
        /*skillKey*/
        i[16]
      )
    );
  }
  return u(o, "click_handler"), {
    c() {
      e = E("button"), s = Q(t), b(e, "class", "a5e-skill-specialties__list-item"), b(e, "data-tooltip", n = "Roll " + /*skillName*/
      i[18] + " check with " + /*specialty*/
      i[21] + " specialty"), b(e, "data-tooltip-direction", "UP");
    },
    m(a, c) {
      T(a, e, c), A(e, s), l || (r = W(e, "click", o), l = !0);
    },
    p(a, c) {
      i = a, c & /*skills*/
      1 && t !== (t = /*specialty*/
      i[21] + "") && be(s, t), c & /*skills*/
      1 && n !== (n = "Roll " + /*skillName*/
      i[18] + " check with " + /*specialty*/
      i[21] + " specialty") && b(e, "data-tooltip", n);
    },
    d(a) {
      a && C(e), l = !1, r();
    }
  };
}
u(cF, "create_each_block_2$1");
function uF(i) {
  let e, t = (
    /*specialties*/
    i[17].length && aF(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*specialties*/
      s[17].length ? t ? t.p(s, n) : (t = aF(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(uF, "create_each_block_1$a");
function Zle(i) {
  let e, t, s, n = ue(Object.entries(
    /*skills*/
    i[0]
  )), l = [];
  for (let r = 0; r < n.length; r += 1)
    l[r] = uF(lF(i, n, r));
  return {
    c() {
      e = E("h3"), e.textContent = "Skill Specialties", t = F(), s = E("dl");
      for (let r = 0; r < l.length; r += 1)
        l[r].c();
      b(e, "class", "a5e-skill-specialties-heading svelte-1cgmfh0"), b(s, "class", "a5e-skill-specialties");
    },
    m(r, o) {
      T(r, e, o), T(r, t, o), T(r, s, o);
      for (let a = 0; a < l.length; a += 1)
        l[a] && l[a].m(s, null);
    },
    p(r, o) {
      if (o & /*getSkillSpecialties, Object, skills, A5E, rollSkillCheckWithSpecialty*/
      89) {
        n = ue(Object.entries(
          /*skills*/
          r[0]
        ));
        let a;
        for (a = 0; a < n.length; a += 1) {
          const c = lF(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = uF(c), l[a].c(), l[a].m(s, null));
        }
        for (; a < l.length; a += 1)
          l[a].d(1);
        l.length = n.length;
      }
    },
    d(r) {
      r && (C(e), C(t), C(s)), Le(l, r);
    }
  };
}
u(Zle, "create_default_slot$15");
function fF(i) {
  let e, t;
  return e = new T0({
    props: {
      key: (
        /*key*/
        i[12]
      ),
      skill: (
        /*skill*/
        i[13]
      ),
      columnFlow: (
        /*skillListFlowDirection*/
        i[1] === "column"
      )
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skills*/
      1 && (l.key = /*key*/
      s[12]), n & /*skills*/
      1 && (l.skill = /*skill*/
      s[13]), n & /*skillListFlowDirection*/
      2 && (l.columnFlow = /*skillListFlowDirection*/
      s[1] === "column"), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(fF, "create_each_block$W");
function Qle(i) {
  let e, t, s, n, l = (
    /*showSpecialties*/
    i[2] && oF(i)
  ), r = ue(Object.entries(
    /*skills*/
    i[0]
  )), o = [];
  for (let c = 0; c < r.length; c += 1)
    o[c] = fF(iF(i, r, c));
  const a = /* @__PURE__ */ u((c) => O(o[c], 1, 1, () => {
    o[c] = null;
  }), "out");
  return {
    c() {
      e = E("div"), l && l.c(), t = F(), s = E("ul");
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      b(s, "class", "skills-container svelte-1cgmfh0"), Z(
        s,
        "skills-container--column-flow",
        /*skillListFlowDirection*/
        i[1] === "column"
      ), b(e, "class", "skill-page-wrapper svelte-1cgmfh0");
    },
    m(c, f) {
      T(c, e, f), l && l.m(e, null), A(e, t), A(e, s);
      for (let d = 0; d < o.length; d += 1)
        o[d] && o[d].m(s, null);
      n = !0;
    },
    p(c, [f]) {
      if (/*showSpecialties*/
      c[2] ? l ? (l.p(c, f), f & /*showSpecialties*/
      4 && w(l, 1)) : (l = oF(c), l.c(), w(l, 1), l.m(e, t)) : l && (ae(), O(l, 1, 1, () => {
        l = null;
      }), ce()), f & /*Object, skills, skillListFlowDirection*/
      3) {
        r = ue(Object.entries(
          /*skills*/
          c[0]
        ));
        let d;
        for (d = 0; d < r.length; d += 1) {
          const p = iF(c, r, d);
          o[d] ? (o[d].p(p, f), w(o[d], 1)) : (o[d] = fF(p), o[d].c(), w(o[d], 1), o[d].m(s, null));
        }
        for (ae(), d = r.length; d < o.length; d += 1)
          a(d);
        ce();
      }
      (!n || f & /*skillListFlowDirection*/
      2) && Z(
        s,
        "skills-container--column-flow",
        /*skillListFlowDirection*/
        c[1] === "column"
      );
    },
    i(c) {
      if (!n) {
        w(l);
        for (let f = 0; f < r.length; f += 1)
          w(o[f]);
        n = !0;
      }
    },
    o(c) {
      O(l), o = o.filter(Boolean);
      for (let f = 0; f < o.length; f += 1)
        O(o[f]);
      n = !1;
    },
    d(c) {
      c && C(e), l && l.d(), Le(o, c);
    }
  };
}
u(Qle, "create_fragment$2v");
function xle(i, e, t) {
  let s, n, l, r;
  function o(h) {
    return game.settings.get("a5e", "hideSkillSpecialties") ? !1 : Object.values(h).some((_) => _.specialties.length);
  }
  u(o, "determineWhetherToShowSkillSpecialties");
  function a(h) {
    const _ = { ...h };
    return game.settings.get("a5e", "hideA5eSkills") && (delete _.cul, delete _.eng), game.settings.get("a5e", "showVRCSkills") || delete _.sci, _;
  }
  u(a, "getSkills");
  function c(h, _) {
    const y = _.specialties;
    return !Array.isArray(y) || !(y != null && y.length) ? [] : y.sort((v, k) => v.toLowerCase().localeCompare(k.toLowerCase())).map((v) => m[h] ? m[h][v] ?? v : v);
  }
  u(c, "getSkillSpecialties");
  function f(h) {
    const _ = r.system.skills[h].expertiseDice;
    r.rollSkillCheck(h, { expertiseDice: _ + 1 });
  }
  u(f, "rollSkillCheckWithSpecialty");
  const d = de("actor");
  pe(i, d, (h) => t(7, r = h));
  const { A5E: p } = CONFIG, { skillSpecialties: m } = p, g = /* @__PURE__ */ u((h) => f(h), "click_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    128 && t(0, s = a(r.system.skills)), i.$$.dirty & /*skills*/
    1 && t(2, n = o(s));
  }, t(1, l = game.settings.get("a5e", "skillListFlowDirection")), [
    s,
    l,
    n,
    c,
    f,
    d,
    p,
    r,
    g
  ];
}
u(xle, "instance$2m");
const oS = class oS extends re {
  constructor(e) {
    super(), oe(this, e, xle, Qle, le, {});
  }
};
u(oS, "ActorSkillsPage");
let Dp = oS;
function Gl(i) {
  return [...i].some((e) => {
    var t, s, n;
    return (s = (t = e == null ? void 0 : e.system) == null ? void 0 : t.uses) != null && s.max ? !0 : (n = e == null ? void 0 : e.actions) == null ? void 0 : n.values().some((l) => {
      var r;
      return (r = l == null ? void 0 : l.uses) == null ? void 0 : r.max;
    });
  });
}
u(Gl, "usesRequired");
function Ip(i) {
  return [...i].some((e) => e.type === "object");
}
u(Ip, "quantityRequired");
function dF(i, e, t) {
  const s = i.slice();
  return s[9] = e[t][0], s[10] = e[t][1], s;
}
u(dF, "get_each_context$V");
function pF(i) {
  let e, t, s = ue(Object.entries(
    /*resources*/
    i[0]
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = mF(dF(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("ol");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "resources-container svelte-1cma5in");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o & /*Object, resources*/
      1) {
        s = ue(Object.entries(
          /*resources*/
          r[0]
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = dF(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = mF(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(pF, "create_if_block_1$R");
function mF(i) {
  let e, t;
  return e = new A0({
    props: {
      resource: (
        /*resource*/
        i[10]
      ),
      source: (
        /*source*/
        i[9]
      )
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*resources*/
      1 && (l.resource = /*resource*/
      s[10]), n & /*resources*/
      1 && (l.source = /*source*/
      s[9]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(mF, "create_each_block$V");
function ere(i) {
  let e, t;
  return e = new Dp({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p: se,
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(ere, "create_else_block$s");
function tre(i) {
  let e, t, s;
  return t = new $r({
    props: {
      label: "A5E.FavoriteItems",
      icon: "fas fa-star a5e-section-header__icon",
      items: [.../*$favorites*/
      i[5]].sort(hF),
      type: "favorites",
      showQuantity: (
        /*showQuantity*/
        i[2]
      ),
      showUses: (
        /*showUses*/
        i[3]
      )
    }
  }), {
    c() {
      e = E("section"), j(t.$$.fragment), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--item-list");
    },
    m(n, l) {
      T(n, e, l), R(t, e, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$favorites*/
      32 && (r.items = [.../*$favorites*/
      n[5]].sort(hF)), l & /*showQuantity*/
      4 && (r.showQuantity = /*showQuantity*/
      n[2]), l & /*showUses*/
      8 && (r.showUses = /*showUses*/
      n[3]), t.$set(r);
    },
    i(n) {
      s || (w(t.$$.fragment, n), s = !0);
    },
    o(n) {
      O(t.$$.fragment, n), s = !1;
    },
    d(n) {
      n && C(e), N(t);
    }
  };
}
u(tre, "create_if_block$1l");
function sre(i) {
  var f;
  let e, t, s, n, l, r = !/*flags*/
  (((f = i[4].a5e) == null ? void 0 : f.hideGenericResources) ?? /*$actor*/
  i[1].type === "npc") && pF(i);
  const o = [tre, ere], a = [];
  function c(d, p) {
    var m;
    return (
      /*flags*/
      ((m = d[4].a5e) == null ? void 0 : m.showFavoritesSection) ?? !0 ? 0 : 1
    );
  }
  return u(c, "select_block_type"), t = c(i), s = a[t] = o[t](i), {
    c() {
      r && r.c(), e = F(), s.c(), n = $e();
    },
    m(d, p) {
      r && r.m(d, p), T(d, e, p), a[t].m(d, p), T(d, n, p), l = !0;
    },
    p(d, [p]) {
      var g;
      /*flags*/
      ((g = d[4].a5e) == null ? void 0 : g.hideGenericResources) ?? /*$actor*/
      d[1].type === "npc" ? r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce()) : r ? (r.p(d, p), p & /*flags, $actor*/
      18 && w(r, 1)) : (r = pF(d), r.c(), w(r, 1), r.m(e.parentNode, e));
      let m = t;
      t = c(d), t === m ? a[t].p(d, p) : (ae(), O(a[m], 1, 1, () => {
        a[m] = null;
      }), ce(), s = a[t], s ? s.p(d, p) : (s = a[t] = o[t](d), s.c()), w(s, 1), s.m(n.parentNode, n));
    },
    i(d) {
      l || (w(r), w(s), l = !0);
    },
    o(d) {
      O(r), O(s), l = !1;
    },
    d(d) {
      d && (C(e), C(n)), r && r.d(d), a[t].d(d);
    }
  };
}
u(sre, "create_fragment$2u");
const hF = /* @__PURE__ */ u((i, e) => i.sort - e.sort, "func$3");
function nre(i, e, t) {
  let s, n, l, { resources: r } = e;
  const o = de("actor");
  pe(i, o, (p) => t(1, l = p));
  const { favorites: a } = o;
  pe(i, a, (p) => t(5, n = p));
  let c = Ip(n), f = Gl(n);
  const d = a.subscribe((p) => {
    t(2, c = Ip(n)), t(3, f = Gl(n));
  });
  return Qt(() => {
    d();
  }), i.$$set = (p) => {
    "resources" in p && t(0, r = p.resources);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    2 && t(0, r = l.system.resources), i.$$.dirty & /*$actor*/
    2 && t(4, s = l.flags);
  }, [r, l, c, f, s, n, o, a];
}
u(nre, "instance$2l");
const aS = class aS extends re {
  constructor(e) {
    super(), oe(this, e, nre, sre, le, { resources: 0 });
  }
};
u(aS, "ActorCorePage");
let O0 = aS;
function gF(i, e, t) {
  const s = i.slice();
  return s[7] = e[t][0], s[8] = e[t][1], s;
}
u(gF, "get_each_context$U");
function bF(i) {
  let e, t;
  return e = new Ll({
    props: {
      $$slots: { default: [ire] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(bF, "create_if_block_1$Q");
function ire(i) {
  let e, t, s, n, l, r;
  return e = new Nl({ props: { reducerType: Lg } }), s = new jl({
    props: {
      reducerType: Lg,
      documentName: "ActiveEffect"
    }
  }), l = new Tn({
    props: {
      reducerType: Lg,
      documentName: "ActiveEffect"
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), R(s, o, a), T(o, n, a), R(l, o, a), r = !0;
    },
    p: se,
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(s.$$.fragment, o), O(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (C(t), C(n)), N(e, o), N(s, o), N(l, o);
    }
  };
}
u(ire, "create_default_slot$14");
function _F(i) {
  let e, t;
  return e = new Eu({
    props: {
      label: (
        /*subTypes*/
        i[4][
          /*label*/
          i[7]
        ]
      ),
      effects: (
        /*effects*/
        i[8]
      )
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$activeEffects*/
      2 && (l.label = /*subTypes*/
      s[4][
        /*label*/
        s[7]
      ]), n & /*$activeEffects*/
      2 && (l.effects = /*effects*/
      s[8]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(_F, "create_if_block$1k");
function yF(i) {
  let e, t, s = (
    /*effects*/
    i[8].length && _F(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*effects*/
      n[8].length ? s ? (s.p(n, l), l & /*$activeEffects*/
      2 && w(s, 1)) : (s = _F(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(yF, "create_each_block$U");
function lre(i) {
  let e, t, s, n = (
    /*$actor*/
    i[0].isOwner && bF(i)
  ), l = ue(Object.entries(
    /*$activeEffects*/
    i[1]._types
  )), r = [];
  for (let a = 0; a < l.length; a += 1)
    r[a] = yF(gF(i, l, a));
  const o = /* @__PURE__ */ u((a) => O(r[a], 1, 1, () => {
    r[a] = null;
  }), "out");
  return {
    c() {
      n && n.c(), e = F(), t = E("section");
      for (let a = 0; a < r.length; a += 1)
        r[a].c();
      b(t, "class", "a5e-page-wrapper a5e-page-wrapper--item-list");
    },
    m(a, c) {
      n && n.m(a, c), T(a, e, c), T(a, t, c);
      for (let f = 0; f < r.length; f += 1)
        r[f] && r[f].m(t, null);
      s = !0;
    },
    p(a, [c]) {
      if (/*$actor*/
      a[0].isOwner ? n ? (n.p(a, c), c & /*$actor*/
      1 && w(n, 1)) : (n = bF(a), n.c(), w(n, 1), n.m(e.parentNode, e)) : n && (ae(), O(n, 1, 1, () => {
        n = null;
      }), ce()), c & /*subTypes, Object, $activeEffects*/
      18) {
        l = ue(Object.entries(
          /*$activeEffects*/
          a[1]._types
        ));
        let f;
        for (f = 0; f < l.length; f += 1) {
          const d = gF(a, l, f);
          r[f] ? (r[f].p(d, c), w(r[f], 1)) : (r[f] = yF(d), r[f].c(), w(r[f], 1), r[f].m(t, null));
        }
        for (ae(), f = l.length; f < r.length; f += 1)
          o(f);
        ce();
      }
    },
    i(a) {
      if (!s) {
        w(n);
        for (let c = 0; c < l.length; c += 1)
          w(r[c]);
        s = !0;
      }
    },
    o(a) {
      O(n), r = r.filter(Boolean);
      for (let c = 0; c < r.length; c += 1)
        O(r[c]);
      s = !1;
    },
    d(a) {
      a && (C(e), C(t)), n && n.d(a), Le(r, a);
    }
  };
}
u(lre, "create_fragment$2t");
const Lg = "activeEffects";
function rre(i, e, t) {
  let s, n;
  const l = de("actor");
  pe(i, l, (f) => t(0, s = f));
  const { activeEffects: r } = l;
  pe(i, r, (f) => t(1, n = f));
  const { A5E: o, statusEffects: a } = CONFIG, c = o.activeEffectTypes;
  return [s, n, l, r, c];
}
u(rre, "instance$2k");
const cS = class cS extends re {
  constructor(e) {
    super(), oe(this, e, rre, lre, le, {});
  }
};
u(cS, "ActorEffectsPage");
let D0 = cS;
function vF(i, e = "inclusive") {
  return e === "exclusive" ? (t) => !foundry.utils.getProperty(t, i) : (t) => foundry.utils.getProperty(t, i);
}
u(vF, "booleanFilter$1");
function kF(i, e, t = "inclusive") {
  return t === "exclusive" ? (s) => foundry.utils.getProperty(s, i) != e : (s) => foundry.utils.getProperty(s, i) == e;
}
u(kF, "valueBasedFilter");
function wF(i, e, t = "inclusive") {
  return /* @__PURE__ */ u((n) => {
    var r;
    const l = (r = n.actions) == null ? void 0 : r.activationTypes;
    return l ? t === "exclusive" ? l.some((o) => e != o) : l.some((o) => e == o) : !1;
  }, "filter");
}
u(wF, "actionBasedFilter");
function $F(i, e, t) {
  var o, a;
  const s = [...i.filters].reduce((c, f) => {
    var d;
    return (d = f == null ? void 0 : f.id) != null && d.includes(`${e}-`) && c.push(f.id), c;
  }, []);
  i.filters.removeById(...s);
  const n = Object.values(CONFIG.A5E.filters[e]).reduce(
    (c, f) => ({ ...c, ...f.filters }),
    {}
  ), l = [], r = [];
  (o = t == null ? void 0 : t.inclusive) == null || o.forEach((c) => {
    const { key: f, type: d, truthValue: p } = n[c];
    let m;
    if (d === "boolean") m = vF(f);
    else if (d === "value") m = kF(f, c);
    else if (d === "action") m = wF(f, c);
    else return;
    p === "or" ? r.push(m) : l.push({
      id: `${e}-${c}`,
      filter: m
    });
  }), (a = t == null ? void 0 : t.exclusive) == null || a.forEach((c) => {
    const { key: f, type: d } = n[c];
    let p;
    if (d === "boolean") p = vF(f, "exclusive");
    else if (d === "value") p = kF(f, c, "exclusive");
    else if (d === "action") p = wF(f, c, "exclusive");
    else return;
    l.push({
      id: `${e}-${c}`,
      filter: p
    });
  }), i.filters.add(...l), r.length && i.filters.add({
    id: `${e}-or`,
    filter: /* @__PURE__ */ u((c) => r.some((f) => f(c)), "filter")
  });
}
u($F, "updateFilters");
function AF(i, e, t) {
  const s = i.slice();
  return s[9] = e[t][0], s[10] = e[t][1], s;
}
u(AF, "get_each_context$T");
function EF(i) {
  let e, t, s;
  return e = new po({
    props: {
      active: (
        /*selected*/
        i[3][0].includes(
          /*value*/
          i[9]
        )
      ),
      orange: (
        /*selected*/
        i[3][1].includes(
          /*value*/
          i[9]
        ) && /*color*/
        i[0] === "orange"
      ),
      red: (
        /*selected*/
        i[3][1].includes(
          /*value*/
          i[9]
        ) && /*color*/
        i[0] === "red"
      ),
      label: (
        /*label*/
        i[10]
      ),
      value: (
        /*value*/
        i[9]
      )
    }
  }), e.$on(
    "tagToggle",
    /*tagToggle_handler*/
    i[6]
  ), e.$on(
    "tagToggleAux",
    /*tagToggleAux_handler*/
    i[7]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--color-hover", "black");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*selected, options*/
      12 && (r.active = /*selected*/
      n[3][0].includes(
        /*value*/
        n[9]
      )), l & /*selected, options, color*/
      13 && (r.orange = /*selected*/
      n[3][1].includes(
        /*value*/
        n[9]
      ) && /*color*/
      n[0] === "orange"), l & /*selected, options, color*/
      13 && (r.red = /*selected*/
      n[3][1].includes(
        /*value*/
        n[9]
      ) && /*color*/
      n[0] === "red"), l & /*options*/
      4 && (r.label = /*label*/
      n[10]), l & /*options*/
      4 && (r.value = /*value*/
      n[9]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(EF, "create_each_block$T");
function SF(i) {
  let e, t = K(
    /*hint*/
    i[1]
  ) + "", s;
  return {
    c() {
      e = E("p"), s = Q(t), b(e, "class", "hint svelte-1fnlno3");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*hint*/
      2 && t !== (t = K(
        /*hint*/
        n[1]
      ) + "") && be(s, t);
    },
    d(n) {
      n && C(e);
    }
  };
}
u(SF, "create_if_block$1j");
function ore(i) {
  let e, t, s, n, l = ue(
    /*options*/
    i[2]
  ), r = [];
  for (let c = 0; c < l.length; c += 1)
    r[c] = EF(AF(i, l, c));
  const o = /* @__PURE__ */ u((c) => O(r[c], 1, 1, () => {
    r[c] = null;
  }), "out");
  let a = (
    /*hint*/
    i[1] && SF(i)
  );
  return {
    c() {
      e = E("ul");
      for (let c = 0; c < r.length; c += 1)
        r[c].c();
      t = F(), a && a.c(), s = $e(), b(e, "class", "u-flex u-flex-wrap u-gap-sm u-list-style-none u-m-0 u-p-0 u-text-xs u-w-full ");
    },
    m(c, f) {
      T(c, e, f);
      for (let d = 0; d < r.length; d += 1)
        r[d] && r[d].m(e, null);
      T(c, t, f), a && a.m(c, f), T(c, s, f), n = !0;
    },
    p(c, [f]) {
      if (f & /*selected, options, color, updateSelection*/
      29) {
        l = ue(
          /*options*/
          c[2]
        );
        let d;
        for (d = 0; d < l.length; d += 1) {
          const p = AF(c, l, d);
          r[d] ? (r[d].p(p, f), w(r[d], 1)) : (r[d] = EF(p), r[d].c(), w(r[d], 1), r[d].m(e, null));
        }
        for (ae(), d = l.length; d < r.length; d += 1)
          o(d);
        ce();
      }
      /*hint*/
      c[1] ? a ? a.p(c, f) : (a = SF(c), a.c(), a.m(s.parentNode, s)) : a && (a.d(1), a = null);
    },
    i(c) {
      if (!n) {
        for (let f = 0; f < l.length; f += 1)
          w(r[f]);
        n = !0;
      }
    },
    o(c) {
      r = r.filter(Boolean);
      for (let f = 0; f < r.length; f += 1)
        O(r[f]);
      n = !1;
    },
    d(c) {
      c && (C(e), C(t), C(s)), Le(r, c), a && a.d(c);
    }
  };
}
u(ore, "create_fragment$2s");
function are(i, e, t) {
  let { auxEnabled: s = !0 } = e, { color: n = "orange" } = e, { hint: l = "" } = e, { options: r = [] } = e, { selected: o = [[], []] } = e;
  function a(p, m = !1) {
    let g = o.map((h) => new Set(h));
    g[0].has(p) ? (g[0].delete(p), g[1].add(p)) : g[1].has(p) ? g[1].delete(p) : s && m ? g[1].add(p) : g[0].add(p), g = g.map((h) => [...h]), c("updateSelection", g);
  }
  u(a, "updateSelection");
  const c = ft(), f = /* @__PURE__ */ u(({ detail: p }) => a(p), "tagToggle_handler"), d = /* @__PURE__ */ u(({ detail: p }) => a(p, !0), "tagToggleAux_handler");
  return i.$$set = (p) => {
    "auxEnabled" in p && t(5, s = p.auxEnabled), "color" in p && t(0, n = p.color), "hint" in p && t(1, l = p.hint), "options" in p && t(2, r = p.options), "selected" in p && t(3, o = p.selected);
  }, [
    n,
    l,
    r,
    o,
    a,
    s,
    f,
    d
  ];
}
u(are, "instance$2j");
const uS = class uS extends re {
  constructor(e) {
    super(), oe(this, e, are, ore, le, {
      auxEnabled: 5,
      color: 0,
      hint: 1,
      options: 2,
      selected: 3
    });
  }
};
u(uS, "MultiStateCheckBoxGroup");
let Pp = uS;
function CF(i, e, t) {
  const s = i.slice();
  return s[16] = e[t].label, s[17] = e[t].filters, s;
}
u(CF, "get_each_context$S");
function TF(i) {
  var m, g;
  let e, t, s, n, l, r, o, a, c, f, d;
  function p() {
    return (
      /*click_handler*/
      i[11](
        /*filters*/
        i[17]
      )
    );
  }
  return u(p, "click_handler"), a = new Pp({
    props: {
      options: Object.entries(
        /*filters*/
        i[17]
      ).map(dre),
      selected: [
        /*activeFilters*/
        ((m = i[0]) == null ? void 0 : m.inclusive) ?? [],
        /*activeFilters*/
        ((g = i[0]) == null ? void 0 : g.exclusive) ?? []
      ]
    }
  }), a.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), {
    c() {
      e = E("section"), t = E("header"), s = E("h3"), s.textContent = `${K(
        /*label*/
        i[16]
      )}`, n = F(), l = E("button"), l.textContent = `${K("A5E.ButtonToggleAll")}`, r = F(), o = E("div"), j(a.$$.fragment), b(s, "class", "u-text-sm u-text-bold"), b(l, "class", "filter-button u-text-xs svelte-yirv3j"), b(t, "class", "u-align-center u-flex u-gap-lg"), b(o, "class", "filters u-text-xs u-w-full svelte-yirv3j"), b(e, "class", "filter-section svelte-yirv3j");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(t, s), A(t, n), A(t, l), A(e, r), A(e, o), R(a, o, null), c = !0, f || (d = W(l, "click", Ve(p)), f = !0);
    },
    p(h, _) {
      var v, k;
      i = h;
      const y = {};
      _ & /*activeFilters*/
      1 && (y.selected = [
        /*activeFilters*/
        ((v = i[0]) == null ? void 0 : v.inclusive) ?? [],
        /*activeFilters*/
        ((k = i[0]) == null ? void 0 : k.exclusive) ?? []
      ]), a.$set(y);
    },
    i(h) {
      c || (w(a.$$.fragment, h), c = !0);
    },
    o(h) {
      O(a.$$.fragment, h), c = !1;
    },
    d(h) {
      h && C(e), N(a), f = !1, d();
    }
  };
}
u(TF, "create_each_block$S");
function cre(i) {
  let e, t, s, n, l = ue(
    /*filterSections*/
    i[7]
  ), r = [];
  for (let a = 0; a < l.length; a += 1)
    r[a] = TF(CF(i, l, a));
  const o = /* @__PURE__ */ u((a) => O(r[a], 1, 1, () => {
    r[a] = null;
  }), "out");
  return {
    c() {
      e = E("article");
      for (let a = 0; a < r.length; a += 1)
        r[a].c();
      t = F(), s = E("div"), s.textContent = "Hint: Right-click a filter to quickly remove it from the selection.", b(s, "class", "hint svelte-yirv3j"), b(e, "class", "filter-box svelte-yirv3j");
    },
    m(a, c) {
      T(a, e, c);
      for (let f = 0; f < r.length; f += 1)
        r[f] && r[f].m(e, null);
      A(e, t), A(e, s), n = !0;
    },
    p(a, c) {
      if (c & /*Object, filterSections, activeFilters, onUpdateFilters, toggleAll*/
      225) {
        l = ue(
          /*filterSections*/
          a[7]
        );
        let f;
        for (f = 0; f < l.length; f += 1) {
          const d = CF(a, l, f);
          r[f] ? (r[f].p(d, c), w(r[f], 1)) : (r[f] = TF(d), r[f].c(), w(r[f], 1), r[f].m(e, t));
        }
        for (ae(), f = l.length; f < r.length; f += 1)
          o(f);
        ce();
      }
    },
    i(a) {
      if (!n) {
        for (let c = 0; c < l.length; c += 1)
          w(r[c]);
        n = !0;
      }
    },
    o(a) {
      r = r.filter(Boolean);
      for (let c = 0; c < r.length; c += 1)
        O(r[c]);
      n = !1;
    },
    d(a) {
      a && C(e), Le(r, a);
    }
  };
}
u(cre, "create_default_slot_1$w");
function ure(i) {
  let e, t;
  return e = new Sp({
    props: {
      $$slots: { default: [cre] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, activeFilters*/
      1048577 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(ure, "create_default_slot$13");
function fre(i) {
  let e, t, s, n;
  return t = new Ep({
    props: {
      title: "Filters",
      icon: "fas fa-filter",
      $$slots: { default: [ure] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("span"), s = E("div"), j(t.$$.fragment), G(s, "display", "contents"), G(s, "--tjs-icon-button-background-hover", "none"), G(s, "--tjs-icon-button-background-focus", "none"), G(s, "--tjs-icon-button-background-focus-visible", "none"), G(s, "--tjs-icon-button-background-selected", "none"), G(s, "--tjs-icon-button-text-shadow-hover", "none"), G(s, "--tjs-icon-button-text-shadow-focus", "none"), G(s, "--tjs-icon-button-transition", "var(--a5e-transition-standard)"), G(s, "--tjs-icon-button-diameter", "1.1rem"), G(s, "--tjs-icon-button-border-radius", "0"), b(e, "class", "filter-hints svelte-yirv3j"), b(
        e,
        "data-tooltip",
        /*filterTooltip*/
        i[3]
      ), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "filter-hints--green",
        /*numInclusiveFilters*/
        i[2]
      ), Z(
        e,
        "filter-hints--red",
        /*numExclusiveFilters*/
        i[1]
      );
    },
    m(l, r) {
      T(l, e, r), A(e, s), R(t, s, null), n = !0;
    },
    p(l, [r]) {
      const o = {};
      r & /*$$scope, activeFilters*/
      1048577 && (o.$$scope = { dirty: r, ctx: l }), t.$set(o), (!n || r & /*filterTooltip*/
      8) && b(
        e,
        "data-tooltip",
        /*filterTooltip*/
        l[3]
      ), (!n || r & /*numInclusiveFilters*/
      4) && Z(
        e,
        "filter-hints--green",
        /*numInclusiveFilters*/
        l[2]
      ), (!n || r & /*numExclusiveFilters*/
      2) && Z(
        e,
        "filter-hints--red",
        /*numExclusiveFilters*/
        l[1]
      );
    },
    i(l) {
      n || (w(t.$$.fragment, l), n = !0);
    },
    o(l) {
      O(t.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(e), N(t);
    }
  };
}
u(fre, "create_fragment$2r");
const dre = /* @__PURE__ */ u(([i, { label: e }]) => [i, e], "func$2");
function pre(i, e, t) {
  let s, n, l, r, { reducerId: o = "" } = e, { reducerType: a } = e, { reducer: c = null } = e;
  const f = de("actor");
  pe(i, f, (k) => t(13, r = k)), c || (c = f[a]);
  function d(k, S) {
    return k && S ? `Inclusive Filters: ${k} &nbsp;&nbsp;|&nbsp;&nbsp; Exclusive Filers: ${S}` : k ? `Inclusive Filters: ${k}` : S ? `Exclusive Filters: ${S}` : null;
  }
  u(d, "getFilterTooltip");
  function p(k, S) {
    r.setFlag("a5e", h, {
      inclusive: k,
      exclusive: S
    }), t(0, _.inclusive = k, _), t(0, _.exclusive = S, _), $F(c, a, _);
  }
  u(p, "onUpdateFilters");
  function m(k) {
    var I, M;
    k = Object.keys(k);
    const S = (I = _ == null ? void 0 : _.inclusive) == null ? void 0 : I.filter((L) => k.includes(L));
    if (gu(S, k)) {
      const L = (M = _ == null ? void 0 : _.inclusive) == null ? void 0 : M.filter((B) => !k.includes(B));
      return p(L, []);
    }
    const D = /* @__PURE__ */ new Set([...k, ..._ == null ? void 0 : _.inclusive]);
    return p([...D], []);
  }
  u(m, "toggleAll");
  const g = Object.values(CONFIG.A5E.filters[a] ?? {}), h = o ? `filters.${a}.${o}` : `filters.${a}`;
  let _ = r.getFlag("a5e", h) ?? {};
  $F(c, a, _);
  const y = /* @__PURE__ */ u((k) => m(k), "click_handler"), v = /* @__PURE__ */ u(({ detail: k }) => p(k[0], k[1]), "updateSelection_handler");
  return i.$$set = (k) => {
    "reducerId" in k && t(9, o = k.reducerId), "reducerType" in k && t(10, a = k.reducerType), "reducer" in k && t(8, c = k.reducer);
  }, i.$$.update = () => {
    var k, S;
    i.$$.dirty & /*activeFilters*/
    1 && t(2, s = ((k = _ == null ? void 0 : _.inclusive) == null ? void 0 : k.length) ?? 0), i.$$.dirty & /*activeFilters*/
    1 && t(1, n = ((S = _ == null ? void 0 : _.exclusive) == null ? void 0 : S.length) ?? 0), i.$$.dirty & /*numInclusiveFilters, numExclusiveFilters*/
    6 && t(3, l = d(s, n));
  }, [
    _,
    n,
    s,
    l,
    f,
    p,
    m,
    g,
    c,
    o,
    a,
    y,
    v
  ];
}
u(pre, "instance$2i");
const fS = class fS extends re {
  constructor(e) {
    super(), oe(this, e, pre, fre, le, {
      reducerId: 9,
      reducerType: 10,
      reducer: 8
    });
  }
};
u(fS, "Filter");
let yc = fS;
function mre(i) {
  let e, t, s;
  return e = new mc({
    props: {
      title: "Show Description",
      icon: "fa-solid fa-info-circle",
      onPress: (
        /*func*/
        i[1]
      )
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--tjs-icon-button-background-hover", "none"), G(t, "--tjs-icon-button-background-focus", "none"), G(t, "--tjs-icon-button-background-focus-visible", "none"), G(t, "--tjs-icon-button-background-selected", "none"), G(t, "--tjs-icon-button-text-shadow-hover", "none"), G(t, "--tjs-icon-button-text-shadow-focus", "none"), G(t, "--tjs-icon-button-transition", "var(--a5e-transition-standard)"), G(t, "--tjs-icon-button-diameter", "1.1rem"), G(t, "--tjs-icon-button-border-radius", "0");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p: se,
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(mre, "create_fragment$2q");
function hre(i) {
  const e = ft();
  return [e, /* @__PURE__ */ u(() => e("updateSelection"), "func")];
}
u(hre, "instance$2h");
const dS = class dS extends re {
  constructor(e) {
    super(), oe(this, e, hre, mre, le, {});
  }
};
u(dS, "ShowDescription");
let vc = dS;
function gre(i) {
  let e, t;
  const s = (
    /*#slots*/
    i[1].default
  ), n = Gt(
    s,
    i,
    /*$$scope*/
    i[0],
    null
  );
  return {
    c() {
      e = E("footer"), n && n.c(), b(e, "class", "tab-footer svelte-v205um");
    },
    m(l, r) {
      T(l, e, r), n && n.m(e, null), t = !0;
    },
    p(l, [r]) {
      n && n.p && (!t || r & /*$$scope*/
      1) && Ht(
        n,
        s,
        l,
        /*$$scope*/
        l[0],
        t ? zt(
          s,
          /*$$scope*/
          l[0],
          r,
          null
        ) : Ut(
          /*$$scope*/
          l[0]
        ),
        null
      );
    },
    i(l) {
      t || (w(n, l), t = !0);
    },
    o(l) {
      O(n, l), t = !1;
    },
    d(l) {
      l && C(e), n && n.d(l);
    }
  };
}
u(gre, "create_fragment$2p");
function bre(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e;
  return i.$$set = (l) => {
    "$$scope" in l && t(0, n = l.$$scope);
  }, [n, s];
}
u(bre, "instance$2g");
const pS = class pS extends re {
  constructor(e) {
    super(), oe(this, e, bre, gre, le, {});
  }
};
u(pS, "TabFooter");
let kc = pS;
function OF(i, e, t) {
  const s = i.slice();
  return s[15] = e[t][0], s[16] = e[t][1], s;
}
u(OF, "get_each_context$R");
function DF(i) {
  let e, t;
  return e = new Ll({
    props: {
      $$slots: { default: [_re] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, menuList, showDescription*/
      524324 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(DF, "create_if_block_3$o");
function _re(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return e = new Nl({ props: { reducerType: pd } }), s = new vc({}), s.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[9]
  ), l = new jl({ props: { reducerType: pd } }), o = new yc({ props: { reducerType: pd } }), c = new Tn({
    props: {
      reducerType: pd,
      menuList: (
        /*menuList*/
        i[5]
      )
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment);
    },
    m(d, p) {
      R(e, d, p), T(d, t, p), R(s, d, p), T(d, n, p), R(l, d, p), T(d, r, p), R(o, d, p), T(d, a, p), R(c, d, p), f = !0;
    },
    p(d, p) {
      const m = {};
      p & /*menuList*/
      32 && (m.menuList = /*menuList*/
      d[5]), c.$set(m);
    },
    i(d) {
      f || (w(e.$$.fragment, d), w(s.$$.fragment, d), w(l.$$.fragment, d), w(o.$$.fragment, d), w(c.$$.fragment, d), f = !0);
    },
    o(d) {
      O(e.$$.fragment, d), O(s.$$.fragment, d), O(l.$$.fragment, d), O(o.$$.fragment, d), O(c.$$.fragment, d), f = !1;
    },
    d(d) {
      d && (C(t), C(n), C(r), C(a)), N(e, d), N(s, d), N(l, d), N(o, d), N(c, d);
    }
  };
}
u(_re, "create_default_slot_1$v");
function yre(i) {
  let e, t, s = ue(
    /*sortedFeatures*/
    i[4]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = PF(OF(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o & /*sortedFeatures, showDescription, showUses*/
      28) {
        s = ue(
          /*sortedFeatures*/
          r[4]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = OF(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = PF(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(yre, "create_else_block$r");
function vre(i) {
  let e, t;
  return e = new $r({
    props: {
      showDescription: (
        /*showDescription*/
        i[2]
      ),
      label: "",
      items: (
        /*$features*/
        i[0]
      ),
      showUses: (
        /*showUses*/
        i[3]
      ),
      type: "featureTypes"
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*showDescription*/
      4 && (l.showDescription = /*showDescription*/
      s[2]), n & /*$features*/
      1 && (l.items = /*$features*/
      s[0]), n & /*showUses*/
      8 && (l.showUses = /*showUses*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(vre, "create_if_block_1$P");
function IF(i) {
  let e, t;
  return e = new $r({
    props: {
      label: (
        /*label*/
        i[15]
      ),
      items: (
        /*items*/
        i[16]
      ),
      showDescription: (
        /*showDescription*/
        i[2]
      ),
      showUses: (
        /*showUses*/
        i[3]
      ),
      type: "featureTypes"
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*sortedFeatures*/
      16 && (l.label = /*label*/
      s[15]), n & /*sortedFeatures*/
      16 && (l.items = /*items*/
      s[16]), n & /*showDescription*/
      4 && (l.showDescription = /*showDescription*/
      s[2]), n & /*showUses*/
      8 && (l.showUses = /*showUses*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(IF, "create_if_block_2$A");
function PF(i) {
  let e, t, s = (
    /*items*/
    i[16].length && IF(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*items*/
      n[16].length ? s ? (s.p(n, l), l & /*sortedFeatures*/
      16 && w(s, 1)) : (s = IF(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(PF, "create_each_block$R");
function MF(i) {
  let e, t, s, n, l, r, o, a = (
    /*favorPoints*/
    i[6].max + ""
  ), c, f, d;
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.FavorPoints")}`, s = F(), n = E("input"), r = Q(`
            /
            `), o = E("span"), c = Q(a), b(t, "class", "u-mb-0 u-text-sm u-text-bold"), b(n, "class", "a5e-footer-group__input svelte-1yf5iz"), b(n, "type", "number"), b(n, "name", "system.attributes.favorPoints.current"), n.value = l = /*favorPoints*/
      i[6].current, b(n, "placeholder", "0"), b(n, "min", "0"), Z(n, "disable-pointer-events", !/*$actor*/
      i[1].isOwner), b(o, "class", "a5e-footer-group__value"), b(e, "class", "u-flex u-align-center u-gap-md");
    },
    m(p, m) {
      T(p, e, m), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), A(o, c), f || (d = W(
        n,
        "change",
        /*change_handler*/
        i[10]
      ), f = !0);
    },
    p(p, m) {
      m & /*favorPoints*/
      64 && l !== (l = /*favorPoints*/
      p[6].current) && n.value !== l && (n.value = l), m & /*$actor*/
      2 && Z(n, "disable-pointer-events", !/*$actor*/
      p[1].isOwner), m & /*favorPoints*/
      64 && a !== (a = /*favorPoints*/
      p[6].max + "") && be(c, a);
    },
    d(p) {
      p && C(e), f = !1, d();
    }
  };
}
u(MF, "create_if_block$1i");
function kre(i) {
  let e, t = (
    /*$actor*/
    i[1].type === "character" && MF(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*$actor*/
      s[1].type === "character" ? t ? t.p(s, n) : (t = MF(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(kre, "create_default_slot$12");
function wre(i) {
  let e, t, s, n, l, r, o, a, c, f, d = (
    /*$actor*/
    i[1].isOwner && DF(i)
  );
  const p = [vre, yre], m = [];
  function g(h, _) {
    return (
      /*$actor*/
      h[1].type === "npc" ? 0 : 1
    );
  }
  return u(g, "select_block_type"), s = g(i), n = m[s] = p[s](i), r = new kc({
    props: {
      $$slots: { default: [kre] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      d && d.c(), e = F(), t = E("section"), n.c(), l = F(), o = E("div"), j(r.$$.fragment), a = F(), c = E("footer"), b(t, "class", "a5e-page-wrapper a5e-page-wrapper--item-list"), G(o, "display", "contents"), G(o, "--padding-right", "1rem"), b(c, "class", "features-footer");
    },
    m(h, _) {
      d && d.m(h, _), T(h, e, _), T(h, t, _), m[s].m(t, null), T(h, l, _), T(h, o, _), R(r, o, null), T(h, a, _), T(h, c, _), f = !0;
    },
    p(h, [_]) {
      /*$actor*/
      h[1].isOwner ? d ? (d.p(h, _), _ & /*$actor*/
      2 && w(d, 1)) : (d = DF(h), d.c(), w(d, 1), d.m(e.parentNode, e)) : d && (ae(), O(d, 1, 1, () => {
        d = null;
      }), ce());
      let y = s;
      s = g(h), s === y ? m[s].p(h, _) : (ae(), O(m[y], 1, 1, () => {
        m[y] = null;
      }), ce(), n = m[s], n ? n.p(h, _) : (n = m[s] = p[s](h), n.c()), w(n, 1), n.m(t, null));
      const v = {};
      _ & /*$$scope, favorPoints, $actor*/
      524354 && (v.$$scope = { dirty: _, ctx: h }), r.$set(v);
    },
    i(h) {
      f || (w(d), w(n), w(r.$$.fragment, h), f = !0);
    },
    o(h) {
      O(d), O(n), O(r.$$.fragment, h), f = !1;
    },
    d(h) {
      h && (C(e), C(t), C(l), C(a), C(c)), d && d.d(h), m[s].d(), h && r && C(o), N(r, h);
    }
  };
}
u(wre, "create_fragment$2o");
const pd = "features";
function $re(i, e, t) {
  let s, n, l, r, o;
  const a = de("actor");
  pe(i, a, (v) => t(1, o = v));
  const { features: c } = a;
  pe(i, c, (v) => t(0, r = v));
  const { A5E: f } = CONFIG, d = f.featureTypes, p = CONFIG.A5E.reducerSortMap.features;
  let m = !1, g = Gl(c);
  const h = c.subscribe((v) => {
    t(3, g = Gl(c));
  });
  Qt(() => {
    h();
  });
  const _ = /* @__PURE__ */ u(() => t(2, m = !m), "updateSelection_handler"), y = /* @__PURE__ */ u(({ target: v }) => te(o, v.name, Number(v.value)), "change_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    2 && t(6, s = o.system.attributes.favorPoints), i.$$.dirty & /*$features*/
    1 && t(4, l = Object.entries(r._types).sort((v, k) => p[v[0]] - p[k[0]]));
  }, t(5, n = Object.entries(d)), [
    r,
    o,
    m,
    g,
    l,
    n,
    s,
    a,
    c,
    _,
    y
  ];
}
u($re, "instance$2f");
const mS = class mS extends re {
  constructor(e) {
    super(), oe(this, e, $re, wre, le, {});
  }
};
u(mS, "ActorFeaturesPage");
let I0 = mS;
function FF(i, e, t) {
  const s = i.slice();
  return s[24] = e[t][0], s[25] = e[t][1], s;
}
u(FF, "get_each_context$Q");
function RF(i) {
  let e, t, s, n, l = (
    /*attunement*/
    i[7].current + ""
  ), r, o, a, c, f, d, p, m = K("A5E.Supply") + "", g, h, _, y;
  function v(D, I) {
    return (
      /*sheetIsLocked*/
      D[8] ? Are : Ere
    );
  }
  u(v, "select_block_type");
  let k = v(i), S = k(i);
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.Attunement")}`, s = F(), n = E("span"), r = Q(l), o = Q(`
            /
            `), a = E("input"), f = F(), d = E("div"), p = E("h3"), g = Q(m), h = F(), S.c(), b(t, "class", "footer-shield-header svelte-1hrnm5e"), b(n, "class", "a5e-footer-group__value a5e-footer-group__value--attunement"), b(a, "class", "shield-input a5e-footer-group__input svelte-1hrnm5e"), b(a, "type", "number"), b(a, "name", "system.attributes.attunement.max"), a.value = c = /*attunement*/
      i[7].max, b(a, "placeholder", "0"), b(a, "min", "0"), b(a, "max", "9"), a.disabled = /*sheetIsLocked*/
      i[8], Z(a, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(e, "class", "shield shield--attunement svelte-1hrnm5e"), b(p, "class", "footer-shield-header svelte-1hrnm5e"), b(
        p,
        "data-tooltip",
        /*supplyTooltip*/
        i[3]
      ), b(p, "data-tooltip-direction", "UP"), b(d, "class", "shield svelte-1hrnm5e");
    },
    m(D, I) {
      T(D, e, I), A(e, t), A(e, s), A(e, n), A(n, r), A(e, o), A(e, a), T(D, f, I), T(D, d, I), A(d, p), A(p, g), A(d, h), S.m(d, null), _ || (y = W(
        a,
        "change",
        /*change_handler*/
        i[15]
      ), _ = !0);
    },
    p(D, I) {
      I & /*attunement*/
      128 && l !== (l = /*attunement*/
      D[7].current + "") && be(r, l), I & /*attunement*/
      128 && c !== (c = /*attunement*/
      D[7].max) && a.value !== c && (a.value = c), I & /*sheetIsLocked*/
      256 && (a.disabled = /*sheetIsLocked*/
      D[8]), I & /*$actor*/
      1 && Z(a, "disable-pointer-events", !/*$actor*/
      D[0].isOwner), I & /*supplyTooltip*/
      8 && b(
        p,
        "data-tooltip",
        /*supplyTooltip*/
        D[3]
      ), k === (k = v(D)) && S ? S.p(D, I) : (S.d(1), S = k(D), S && (S.c(), S.m(d, null)));
    },
    d(D) {
      D && (C(e), C(f), C(d)), S.d(), _ = !1, y();
    }
  };
}
u(RF, "create_if_block_3$n");
function Are(i) {
  let e, t, s;
  return {
    c() {
      e = E("input"), b(e, "class", "shield-input a5e-footer-group__input svelte-1hrnm5e"), b(e, "type", "number"), b(e, "name", "system.supply"), e.value = /*totalSupply*/
      i[2], b(e, "placeholder", "0"), b(e, "min", "0"), e.disabled = /*sheetIsLocked*/
      i[8], Z(e, "disable-pointer-events", !/*$actor*/
      i[0].isOwner);
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "change",
        /*change_handler_2*/
        i[17]
      ), t = !0);
    },
    p(n, l) {
      l & /*totalSupply*/
      4 && e.value !== /*totalSupply*/
      n[2] && (e.value = /*totalSupply*/
      n[2]), l & /*sheetIsLocked*/
      256 && (e.disabled = /*sheetIsLocked*/
      n[8]), l & /*$actor*/
      1 && Z(e, "disable-pointer-events", !/*$actor*/
      n[0].isOwner);
    },
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(Are, "create_else_block$q");
function Ere(i) {
  let e, t, s;
  return {
    c() {
      e = E("input"), b(e, "class", "shield-input a5e-footer-group__input svelte-1hrnm5e"), b(e, "type", "number"), b(e, "name", "system.supply"), e.value = /*supply*/
      i[4], b(e, "placeholder", "0"), b(e, "min", "0"), Z(e, "disable-pointer-events", !/*$actor*/
      i[0].isOwner);
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "change",
        /*change_handler_1*/
        i[16]
      ), t = !0);
    },
    p(n, l) {
      l & /*supply*/
      16 && e.value !== /*supply*/
      n[4] && (e.value = /*supply*/
      n[4]), l & /*$actor*/
      1 && Z(e, "disable-pointer-events", !/*$actor*/
      n[0].isOwner);
    },
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(Ere, "create_if_block_4$j");
function Sre(i) {
  let e, t, s, n, l, r, o, a, c;
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.Implant")}`, s = F(), n = E("span"), l = Q(
        /*implantItems*/
        i[9]
      ), r = Q(`
            /
            `), o = E("input"), b(t, "class", "footer-shield-header svelte-1hrnm5e"), b(n, "class", "a5e-footer-group__value a5e-footer-group__value--implants"), b(o, "class", "shield-input a5e-footer-group__input svelte-1hrnm5e"), b(o, "type", "number"), b(o, "name", "system.attributes.prof"), o.value = /*implantMax*/
      i[1], b(o, "placeholder", "0"), b(o, "min", "0"), b(o, "max", "9"), o.disabled = /*sheetIsLocked*/
      i[8], Z(o, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(e, "class", "shield shield--implants svelte-1hrnm5e");
    },
    m(f, d) {
      T(f, e, d), A(e, t), A(e, s), A(e, n), A(n, l), A(e, r), A(e, o), a || (c = W(
        o,
        "change",
        /*change_handler_3*/
        i[18]
      ), a = !0);
    },
    p(f, d) {
      d & /*implantItems*/
      512 && be(
        l,
        /*implantItems*/
        f[9]
      ), d & /*implantMax*/
      2 && o.value !== /*implantMax*/
      f[1] && (o.value = /*implantMax*/
      f[1]), d & /*sheetIsLocked*/
      256 && (o.disabled = /*sheetIsLocked*/
      f[8]), d & /*$actor*/
      1 && Z(o, "disable-pointer-events", !/*$actor*/
      f[0].isOwner);
    },
    d(f) {
      f && C(e), a = !1, c();
    }
  };
}
u(Sre, "create_if_block_2$z");
function Cre(i) {
  let e, t, s = K(
    /*label*/
    i[24]
  ) + "", n, l, r, o, a, c, f, d, p, m, g;
  return {
    c() {
      e = E("li"), t = E("label"), n = Q(s), r = F(), o = E("input"), d = F(), b(t, "class", "currency__label svelte-1hrnm5e"), b(t, "for", l = "currency-" + /*label*/
      i[24]), Z(t, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(o, "class", "a5e-footer-group__input a5e-footer-group__input--currency shield-input svelte-1hrnm5e"), b(o, "id", a = "currency-" + /*label*/
      i[24]), b(o, "type", "number"), b(o, "name", c = "system.currency." + /*label*/
      i[24]), o.value = f = /*value*/
      i[25], b(o, "min", "0"), Z(o, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(e, "class", "currency__item svelte-1hrnm5e"), b(e, "data-type", p = /*label*/
      i[24]);
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(t, n), A(e, r), A(e, o), A(e, d), m || (g = W(
        o,
        "change",
        /*change_handler_5*/
        i[20]
      ), m = !0);
    },
    p(h, _) {
      _ & /*currency*/
      32 && s !== (s = K(
        /*label*/
        h[24]
      ) + "") && be(n, s), _ & /*currency*/
      32 && l !== (l = "currency-" + /*label*/
      h[24]) && b(t, "for", l), _ & /*$actor*/
      1 && Z(t, "disable-pointer-events", !/*$actor*/
      h[0].isOwner), _ & /*currency*/
      32 && a !== (a = "currency-" + /*label*/
      h[24]) && b(o, "id", a), _ & /*currency*/
      32 && c !== (c = "system.currency." + /*label*/
      h[24]) && b(o, "name", c), _ & /*currency*/
      32 && f !== (f = /*value*/
      h[25]) && o.value !== f && (o.value = f), _ & /*$actor*/
      1 && Z(o, "disable-pointer-events", !/*$actor*/
      h[0].isOwner), _ & /*currency*/
      32 && p !== (p = /*label*/
      h[24]) && b(e, "data-type", p);
    },
    d(h) {
      h && C(e), m = !1, g();
    }
  };
}
u(Cre, "create_if_block_1$O");
function Tre(i) {
  let e, t, s = K(
    /*label*/
    i[24]
  ) + "", n, l, r, o, a, c, f, d, p, m, g;
  return {
    c() {
      e = E("li"), t = E("label"), n = Q(s), r = F(), o = E("input"), d = F(), b(t, "class", "currency__label svelte-1hrnm5e"), b(t, "for", l = "currency-" + /*label*/
      i[24]), Z(t, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(o, "class", "a5e-footer-group__input a5e-footer-group__input--currency shield-input svelte-1hrnm5e"), b(o, "id", a = "currency-" + /*label*/
      i[24]), b(o, "type", "number"), b(o, "name", c = "system.currency." + /*label*/
      i[24]), o.value = f = /*value*/
      i[25], b(o, "min", "0"), Z(o, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(e, "class", "currency__item svelte-1hrnm5e"), b(e, "data-type", p = /*label*/
      i[24]);
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(t, n), A(e, r), A(e, o), A(e, d), m || (g = W(
        o,
        "change",
        /*change_handler_4*/
        i[19]
      ), m = !0);
    },
    p(h, _) {
      _ & /*currency*/
      32 && s !== (s = K(
        /*label*/
        h[24]
      ) + "") && be(n, s), _ & /*currency*/
      32 && l !== (l = "currency-" + /*label*/
      h[24]) && b(t, "for", l), _ & /*$actor*/
      1 && Z(t, "disable-pointer-events", !/*$actor*/
      h[0].isOwner), _ & /*currency*/
      32 && a !== (a = "currency-" + /*label*/
      h[24]) && b(o, "id", a), _ & /*currency*/
      32 && c !== (c = "system.currency." + /*label*/
      h[24]) && b(o, "name", c), _ & /*currency*/
      32 && f !== (f = /*value*/
      h[25]) && o.value !== f && (o.value = f), _ & /*$actor*/
      1 && Z(o, "disable-pointer-events", !/*$actor*/
      h[0].isOwner), _ & /*currency*/
      32 && p !== (p = /*label*/
      h[24]) && b(e, "data-type", p);
    },
    d(h) {
      h && C(e), m = !1, g();
    }
  };
}
u(Tre, "create_if_block$1h");
function NF(i) {
  let e;
  function t(l, r) {
    if (
      /*useCredits*/
      l[13] && /*label*/
      l[24] == "cr"
    ) return Tre;
    if (!/*useCredits*/
    l[13] && /*label*/
    l[24] != "cr") return Cre;
  }
  u(t, "select_block_type_1");
  let s = t(i), n = s && s(i);
  return {
    c() {
      n && n.c(), e = $e();
    },
    m(l, r) {
      n && n.m(l, r), T(l, e, r);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n && n.d(1), n = s && s(l), n && (n.c(), n.m(e.parentNode, e)));
    },
    d(l) {
      l && C(e), n && n.d(l);
    }
  };
}
u(NF, "create_each_block$Q");
function Ore(i) {
  let e, t, s, n, l = K("Bulky Items") + "", r, o, a, c, f, d, p, m, g = (
    /*$actor*/
    i[0].type === "character" && RF(i)
  ), h = (
    /*showVRCImplants*/
    i[12] && Sre(i)
  ), _ = ue(Object.entries(
    /*currency*/
    i[5]
  )), y = [];
  for (let v = 0; v < _.length; v += 1)
    y[v] = NF(FF(i, _, v));
  return {
    c() {
      e = E("section"), g && g.c(), t = F(), s = E("div"), n = E("h3"), r = Q(l), o = F(), a = E("span"), c = Q(
        /*bulkyItems*/
        i[10]
      ), f = F(), h && h.c(), d = F(), p = E("div"), m = E("ol");
      for (let v = 0; v < y.length; v += 1)
        y[v].c();
      b(n, "class", "footer-shield-header svelte-1hrnm5e"), b(
        n,
        "data-tooltip",
        /*bulkyTooltip*/
        i[6]
      ), b(n, "data-tooltip-direction", "UP"), b(a, "class", "a5e-footer-group__value"), b(s, "class", "shield svelte-1hrnm5e"), b(m, "class", "currency__list svelte-1hrnm5e"), b(p, "class", "u-flex u-gap-sm u-text-sm shield shield--currency  svelte-1hrnm5e"), Z(
        p,
        "u-ml-auto",
        /*$actor*/
        i[0].type === "npc"
      ), Z(
        p,
        "u-mr-auto",
        /*$actor*/
        i[0].type === "npc"
      ), b(e, "class", "shield-container svelte-1hrnm5e");
    },
    m(v, k) {
      T(v, e, k), g && g.m(e, null), A(e, t), A(e, s), A(s, n), A(n, r), A(s, o), A(s, a), A(a, c), A(e, f), h && h.m(e, null), A(e, d), A(e, p), A(p, m);
      for (let S = 0; S < y.length; S += 1)
        y[S] && y[S].m(m, null);
    },
    p(v, [k]) {
      if (/*$actor*/
      v[0].type === "character" ? g ? g.p(v, k) : (g = RF(v), g.c(), g.m(e, t)) : g && (g.d(1), g = null), k & /*bulkyTooltip*/
      64 && b(
        n,
        "data-tooltip",
        /*bulkyTooltip*/
        v[6]
      ), k & /*bulkyItems*/
      1024 && be(
        c,
        /*bulkyItems*/
        v[10]
      ), /*showVRCImplants*/
      v[12] && h.p(v, k), k & /*Object, currency, $actor, Number, useCredits*/
      8225) {
        _ = ue(Object.entries(
          /*currency*/
          v[5]
        ));
        let S;
        for (S = 0; S < _.length; S += 1) {
          const D = FF(v, _, S);
          y[S] ? y[S].p(D, k) : (y[S] = NF(D), y[S].c(), y[S].m(m, null));
        }
        for (; S < y.length; S += 1)
          y[S].d(1);
        y.length = _.length;
      }
      k & /*$actor*/
      1 && Z(
        p,
        "u-ml-auto",
        /*$actor*/
        v[0].type === "npc"
      ), k & /*$actor*/
      1 && Z(
        p,
        "u-mr-auto",
        /*$actor*/
        v[0].type === "npc"
      );
    },
    i: se,
    o: se,
    d(v) {
      v && C(e), g && g.d(), h && h.d(), Le(y, v);
    }
  };
}
u(Ore, "create_fragment$2n");
function Dre(i, e, t) {
  let s, n, l, r, o, a, c, f, d, p, m, g;
  CONFIG;
  const h = de("actor");
  pe(i, h, (z) => t(0, g = z));
  const _ = game.settings.get("a5e", "showVRCImplants") ?? !1, y = game.settings.get("a5e", "useCredits") ?? !1;
  function v(z) {
    let q;
    const { supply: U } = z.system;
    return U ? q = Math.max(1 + z.system.abilities.str.mod, 1) : q = Math.max(2 + z.system.abilities.str.mod, 2), `Bulky Limit: ${q}`;
  }
  u(v, "getBulkyTooltip");
  function k(z) {
    const { supply: q } = z.system, U = z.system.abilities.str.value, H = Math.abs(Math.min(U - q, 0));
    return H ? `Free Supply: ${U} &nbsp;&nbsp;|&nbsp;&nbsp; Additional Supply: ${H}` : `Free Supply: ${q} &nbsp;&nbsp;|&nbsp;&nbsp; Additional Supply: 0`;
  }
  u(k, "getSupplyTooltip");
  const S = /* @__PURE__ */ u(({ target: z }) => te(g, z.name, Number(z.value)), "change_handler"), D = /* @__PURE__ */ u(({ target: z }) => te(g, z.name, Number(z.value)), "change_handler_1"), I = /* @__PURE__ */ u(({ target: z }) => te(g, z.name, Number(z.value)), "change_handler_2"), M = /* @__PURE__ */ u(({ target: z }) => te(g, z.name, Number(z.value)), "change_handler_3"), L = /* @__PURE__ */ u(({ target: z }) => te(g, z.name, Number(z.value)), "change_handler_4"), B = /* @__PURE__ */ u(({ target: z }) => te(g, z.name, Number(z.value)), "change_handler_5");
  return i.$$.update = () => {
    var z, q;
    i.$$.dirty & /*$actor*/
    1 && t(10, s = g.items.reduce(
      (U, H) => (H.system.bulky && H.system.equippedState && (H.system.objectType === "armor" && H.system.equippedState === 2 || (U += 1)), U),
      0
    )), i.$$.dirty & /*$actor*/
    1 && t(9, n = g.items.reduce(
      (U, H) => (H.system.implant && H.system.equippedState && (U += 1), U),
      0
    )), i.$$.dirty & /*$actor*/
    1 && t(14, l = g.items.reduce(
      (U, H) => (H.system.supply && H.system.equippedState && (U += 1), U),
      0
    )), i.$$.dirty & /*$actor*/
    1 && t(8, r = g.isOwner ? ((q = (z = g.flags) == null ? void 0 : z.a5e) == null ? void 0 : q.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*$actor*/
    1 && t(7, o = g.system.attributes.attunement), i.$$.dirty & /*$actor*/
    1 && t(6, a = v(g)), i.$$.dirty & /*$actor*/
    1 && t(5, c = g.system.currency), i.$$.dirty & /*$actor*/
    1 && t(4, f = g.system.supply), i.$$.dirty & /*$actor*/
    1 && t(3, d = k(g)), i.$$.dirty & /*$actor, supplyItems*/
    16385 && t(2, p = g.system.supply + l), i.$$.dirty & /*$actor*/
    1 && t(1, m = g.system.attributes.prof);
  }, [
    g,
    m,
    p,
    d,
    f,
    c,
    a,
    o,
    r,
    n,
    s,
    h,
    _,
    y,
    l,
    S,
    D,
    I,
    M,
    L,
    B
  ];
}
u(Dre, "instance$2e");
const hS = class hS extends re {
  constructor(e) {
    super(), oe(this, e, Dre, Ore, le, {});
  }
};
u(hS, "ActorInventoryShields");
let P0 = hS;
function Ire(i) {
  var l;
  const e = i.system.abilities.str.value, { size: t } = i.system.traits, s = CONFIG.A5E.carryCapacityMultiplier[t || "med"], n = (l = i.flags.a5e) != null && l.doubleCarryCapacity ? 2 : 1;
  return e * s * n * 15;
}
u(Ire, "calculateCarryCapacity");
function Pre(i) {
  var a, c;
  const { EQUIPPED_STATES: e } = CONFIG.A5E, t = i.system, s = i.items.map((f) => f), n = s.reduce((f, d) => {
    let p = null;
    if (d.system.containerId && (p = s.find((_) => _.uuid === d.system.containerId), !p) || ![e.EQUIPPED, e.CARRIED].includes(
      d.system.equippedState
    ) && !p || p) return f;
    const { quantity: g } = d.system, h = parseFloat(d.weight || 0, 10) ?? 0;
    return f + (g ? h * g : h);
  }, 0), l = Object.values(t.currency).reduce((f, d) => f + Number(d), 0), r = 2 * Math.abs(Math.min(t.abilities.str.value - (t.supply ?? 0), 0));
  return ((c = (a = i.flags) == null ? void 0 : a.a5e) == null ? void 0 : c.trackCurrencyWeight) ?? game.settings.get("a5e", "currencyWeight") ? n + r + l * 0.02 : n + r;
}
u(Pre, "calculateInventoryWeight");
function jF(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.ConditionEncumbered")}`;
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(jF, "create_if_block$1g");
function Mre(i) {
  var v;
  let e, t, s, n, l = (
    /*inventoryWeight*/
    ((v = i[1]) == null ? void 0 : v.toFixed(1)) + ""
  ), r, o, a = K("A5E.MeasurementPoundsAbbr") + "", c, f, d, p, m, g = K("A5E.MeasurementPoundsAbbr") + "", h, _, y = (
    /*encumbrancePercentage*/
    i[2] === 100 && jF()
  );
  return {
    c() {
      e = E("div"), t = E("div"), s = E("div"), n = E("span"), r = Q(l), o = F(), c = Q(a), f = Q(`

            /

            `), d = E("span"), p = Q(
        /*carryCapacity*/
        i[0]
      ), m = F(), h = Q(g), _ = F(), y && y.c(), b(s, "class", "u-flex u-gap-md u-pos-absolute u-pos-center u-text-light u-text-sm"), b(t, "class", "u-h-full u-rounded"), G(t, "color", "#eee"), G(t, "text-shadow", "0 0 2px #000"), G(
        t,
        "background-color",
        /*encumbrancePercentage*/
        i[2] === 100 ? "var(--a5e-color-error)" : "#0b5a2f"
      ), G(t, "width", `${Math.min(
        /*encumbrancePercentage*/
        i[2],
        100
      )}%`), b(e, "class", "track-container u-border u-border-thin u-border-light-gray u-h-4 u-pos-relative u-rounded u-w-full  svelte-qzqyjw"), G(e, "background-color", "#a9a594");
    },
    m(k, S) {
      T(k, e, S), A(e, t), A(t, s), A(s, n), A(n, r), A(n, o), A(n, c), A(s, f), A(s, d), A(d, p), A(d, m), A(d, h), A(s, _), y && y.m(s, null);
    },
    p(k, [S]) {
      var D;
      S & /*inventoryWeight*/
      2 && l !== (l = /*inventoryWeight*/
      ((D = k[1]) == null ? void 0 : D.toFixed(1)) + "") && be(r, l), S & /*carryCapacity*/
      1 && be(
        p,
        /*carryCapacity*/
        k[0]
      ), /*encumbrancePercentage*/
      k[2] === 100 ? y || (y = jF(), y.c(), y.m(s, null)) : y && (y.d(1), y = null), S & /*encumbrancePercentage*/
      4 && G(
        t,
        "background-color",
        /*encumbrancePercentage*/
        k[2] === 100 ? "var(--a5e-color-error)" : "#0b5a2f"
      ), S & /*encumbrancePercentage*/
      4 && G(t, "width", `${Math.min(
        /*encumbrancePercentage*/
        k[2],
        100
      )}%`);
    },
    i: se,
    o: se,
    d(k) {
      k && C(e), y && y.d();
    }
  };
}
u(Mre, "create_fragment$2m");
function Fre(i, e, t) {
  let s, n, l, r;
  const o = de("actor");
  return pe(i, o, (a) => t(4, r = a)), i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    16 && t(1, s = Pre(r)), i.$$.dirty & /*$actor*/
    16 && t(0, n = Ire(r)), i.$$.dirty & /*inventoryWeight, carryCapacity*/
    3 && t(2, l = Math.min(s / n * 100, 100));
  }, [n, s, l, o, r];
}
u(Fre, "instance$2d");
const gS = class gS extends re {
  constructor(e) {
    super(), oe(this, e, Fre, Mre, le, {});
  }
};
u(gS, "ItemWeightTrack");
let M0 = gS;
function LF(i, e, t) {
  const s = i.slice();
  return s[16] = e[t][0], s[17] = e[t][1], s;
}
u(LF, "get_each_context$P");
function BF(i) {
  let e, t;
  return e = new Ll({
    props: {
      $$slots: { default: [Rre] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $actor, menuList, showDescription*/
      1048625 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(BF, "create_if_block_2$y");
function Rre(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g;
  return e = new Nl({ props: { reducerType: md } }), s = new vc({}), s.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[10]
  ), l = new jl({ props: { reducerType: md } }), o = new yc({ props: { reducerType: md } }), c = new Tn({
    props: {
      reducerType: md,
      menuList: (
        /*menuList*/
        i[4]
      )
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment), f = F(), d = E("button"), b(d, "class", "a5e-import-from-compendium-button fa-solid fa-download"), b(d, "data-tooltip", "Import Items from Compendium"), b(d, "data-tooltip-direction", "UP");
    },
    m(h, _) {
      R(e, h, _), T(h, t, _), R(s, h, _), T(h, n, _), R(l, h, _), T(h, r, _), R(o, h, _), T(h, a, _), R(c, h, _), T(h, f, _), T(h, d, _), p = !0, m || (g = W(
        d,
        "click",
        /*click_handler*/
        i[11]
      ), m = !0);
    },
    p(h, _) {
      const y = {};
      _ & /*menuList*/
      16 && (y.menuList = /*menuList*/
      h[4]), c.$set(y);
    },
    i(h) {
      p || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(l.$$.fragment, h), w(o.$$.fragment, h), w(c.$$.fragment, h), p = !0);
    },
    o(h) {
      O(e.$$.fragment, h), O(s.$$.fragment, h), O(l.$$.fragment, h), O(o.$$.fragment, h), O(c.$$.fragment, h), p = !1;
    },
    d(h) {
      h && (C(t), C(n), C(r), C(a), C(f), C(d)), N(e, h), N(s, h), N(l, h), N(o, h), N(c, h), m = !1, g();
    }
  };
}
u(Rre, "create_default_slot_1$u");
function qF(i) {
  let e, t;
  return e = new $r({
    props: {
      label: (
        /*label*/
        i[16]
      ),
      items: (
        /*items*/
        i[17]
      ),
      showDescription: (
        /*showDescription*/
        i[0]
      ),
      showQuantity: (
        /*showQuantity*/
        i[2]
      ),
      showUses: (
        /*showUses*/
        i[1]
      ),
      type: "objectTypesPlural"
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*sortedObjects*/
      8 && (l.label = /*label*/
      s[16]), n & /*sortedObjects*/
      8 && (l.items = /*items*/
      s[17]), n & /*showDescription*/
      1 && (l.showDescription = /*showDescription*/
      s[0]), n & /*showQuantity*/
      4 && (l.showQuantity = /*showQuantity*/
      s[2]), n & /*showUses*/
      2 && (l.showUses = /*showUses*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(qF, "create_if_block_1$N");
function GF(i) {
  let e, t, s = (
    /*items*/
    i[17].length && qF(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*items*/
      n[17].length ? s ? (s.p(n, l), l & /*sortedObjects*/
      8 && w(s, 1)) : (s = qF(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(GF, "create_each_block$P");
function zF(i) {
  let e, t;
  return e = new M0({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(zF, "create_if_block$1f");
function Nre(i) {
  var l, r;
  let e, t, s, n = (
    /*$actor*/
    (((r = (l = i[5].flags) == null ? void 0 : l.a5e) == null ? void 0 : r.trackInventoryWeight) ?? !0) && zF()
  );
  return t = new P0({}), {
    c() {
      n && n.c(), e = F(), j(t.$$.fragment);
    },
    m(o, a) {
      n && n.m(o, a), T(o, e, a), R(t, o, a), s = !0;
    },
    p(o, a) {
      var c, f;
      /*$actor*/
      ((f = (c = o[5].flags) == null ? void 0 : c.a5e) == null ? void 0 : f.trackInventoryWeight) ?? !0 ? n ? a & /*$actor*/
      32 && w(n, 1) : (n = zF(), n.c(), w(n, 1), n.m(e.parentNode, e)) : n && (ae(), O(n, 1, 1, () => {
        n = null;
      }), ce());
    },
    i(o) {
      s || (w(n), w(t.$$.fragment, o), s = !0);
    },
    o(o) {
      O(n), O(t.$$.fragment, o), s = !1;
    },
    d(o) {
      o && C(e), n && n.d(o), N(t, o);
    }
  };
}
u(Nre, "create_default_slot$11");
function jre(i) {
  let e, t, s, n, l, r = (
    /*$actor*/
    i[5].isOwner && BF(i)
  ), o = ue(
    /*sortedObjects*/
    i[3]
  ), a = [];
  for (let f = 0; f < o.length; f += 1)
    a[f] = GF(LF(i, o, f));
  const c = /* @__PURE__ */ u((f) => O(a[f], 1, 1, () => {
    a[f] = null;
  }), "out");
  return n = new kc({
    props: {
      $$slots: { default: [Nre] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      r && r.c(), e = F(), t = E("section");
      for (let f = 0; f < a.length; f += 1)
        a[f].c();
      s = F(), j(n.$$.fragment), b(t, "class", "a5e-page-wrapper a5e-page-wrapper--item-list");
    },
    m(f, d) {
      r && r.m(f, d), T(f, e, d), T(f, t, d);
      for (let p = 0; p < a.length; p += 1)
        a[p] && a[p].m(t, null);
      T(f, s, d), R(n, f, d), l = !0;
    },
    p(f, [d]) {
      if (/*$actor*/
      f[5].isOwner ? r ? (r.p(f, d), d & /*$actor*/
      32 && w(r, 1)) : (r = BF(f), r.c(), w(r, 1), r.m(e.parentNode, e)) : r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce()), d & /*sortedObjects, showDescription, showQuantity, showUses*/
      15) {
        o = ue(
          /*sortedObjects*/
          f[3]
        );
        let m;
        for (m = 0; m < o.length; m += 1) {
          const g = LF(f, o, m);
          a[m] ? (a[m].p(g, d), w(a[m], 1)) : (a[m] = GF(g), a[m].c(), w(a[m], 1), a[m].m(t, null));
        }
        for (ae(), m = o.length; m < a.length; m += 1)
          c(m);
        ce();
      }
      const p = {};
      d & /*$$scope, $actor*/
      1048608 && (p.$$scope = { dirty: d, ctx: f }), n.$set(p);
    },
    i(f) {
      if (!l) {
        w(r);
        for (let d = 0; d < o.length; d += 1)
          w(a[d]);
        w(n.$$.fragment, f), l = !0;
      }
    },
    o(f) {
      O(r), a = a.filter(Boolean);
      for (let d = 0; d < a.length; d += 1)
        O(a[d]);
      O(n.$$.fragment, f), l = !1;
    },
    d(f) {
      f && (C(e), C(t), C(s)), r && r.d(f), Le(a, f), N(n, f);
    }
  };
}
u(jre, "create_fragment$2l");
const md = "objects";
function Lre(i, e, t) {
  let s, n, l, r;
  const o = de("actor");
  pe(i, o, (k) => t(5, r = k));
  const { objects: a } = o;
  pe(i, a, (k) => t(9, l = k));
  const { A5E: c } = CONFIG, f = c.reducerSortMap.objects, d = c.objectTypes, p = game.a5e.utils.openCompendium;
  let m = !1, g = Gl(a), h = Ip(a);
  const _ = a.subscribe((k) => {
    t(1, g = Gl(a)), t(2, h = Ip(a));
  });
  Qt(() => {
    _();
  });
  const y = /* @__PURE__ */ u(() => t(0, m = !m), "updateSelection_handler"), v = /* @__PURE__ */ u(() => p(r, "inventory"), "click_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$objects*/
    512 && t(3, n = Object.entries(l._types).sort((k, S) => f[k[0]] - f[S[0]]));
  }, t(4, s = Object.entries(d)), [
    m,
    g,
    h,
    n,
    s,
    r,
    o,
    a,
    p,
    l,
    y,
    v
  ];
}
u(Lre, "instance$2c");
const bS = class bS extends re {
  constructor(e) {
    super(), oe(this, e, Lre, jre, le, {});
  }
};
u(bS, "ActorInventoryPage");
let F0 = bS;
function HF(i, e, t) {
  const s = i.slice();
  return s[16] = e[t][0], s[17] = e[t][1], s;
}
u(HF, "get_each_context$O");
function UF(i) {
  let e, t;
  return e = new Ll({
    props: {
      $$slots: { default: [Bre] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $actor, menuList, showDescription*/
      1048587 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(UF, "create_if_block_3$m");
function Bre(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g;
  return e = new Nl({ props: { reducerType: hd } }), s = new vc({}), s.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[9]
  ), l = new jl({ props: { reducerType: hd } }), o = new yc({ props: { reducerType: hd } }), c = new Tn({
    props: {
      reducerType: hd,
      menuList: (
        /*menuList*/
        i[3]
      )
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment), f = F(), d = E("button"), b(d, "class", "a5e-import-from-compendium-button fa-solid fa-download"), b(d, "data-tooltip", "Import Maneuvers from Compendium"), b(d, "data-tooltip-direction", "UP");
    },
    m(h, _) {
      R(e, h, _), T(h, t, _), R(s, h, _), T(h, n, _), R(l, h, _), T(h, r, _), R(o, h, _), T(h, a, _), R(c, h, _), T(h, f, _), T(h, d, _), p = !0, m || (g = W(
        d,
        "click",
        /*click_handler*/
        i[10]
      ), m = !0);
    },
    p(h, _) {
      const y = {};
      _ & /*menuList*/
      8 && (y.menuList = /*menuList*/
      h[3]), c.$set(y);
    },
    i(h) {
      p || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(l.$$.fragment, h), w(o.$$.fragment, h), w(c.$$.fragment, h), p = !0);
    },
    o(h) {
      O(e.$$.fragment, h), O(s.$$.fragment, h), O(l.$$.fragment, h), O(o.$$.fragment, h), O(c.$$.fragment, h), p = !1;
    },
    d(h) {
      h && (C(t), C(n), C(r), C(a), C(f), C(d)), N(e, h), N(s, h), N(l, h), N(o, h), N(c, h), m = !1, g();
    }
  };
}
u(Bre, "create_default_slot_1$t");
function VF(i) {
  let e, t;
  return e = new $r({
    props: {
      label: (
        /*label*/
        i[16]
      ),
      items: (
        /*items*/
        i[17]
      ),
      showDescription: (
        /*showDescription*/
        i[1]
      ),
      showUses: (
        /*showUses*/
        i[2]
      ),
      type: "maneuverDegrees"
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$maneuvers*/
      32 && (l.label = /*label*/
      s[16]), n & /*$maneuvers*/
      32 && (l.items = /*items*/
      s[17]), n & /*showDescription*/
      2 && (l.showDescription = /*showDescription*/
      s[1]), n & /*showUses*/
      4 && (l.showUses = /*showUses*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(VF, "create_if_block_2$x");
function WF(i) {
  let e, t, s = (
    /*items*/
    i[17].length && VF(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*items*/
      n[17].length ? s ? (s.p(n, l), l & /*$maneuvers*/
      32 && w(s, 1)) : (s = VF(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(WF, "create_each_block$O");
function KF(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m = (
    /*exertion*/
    i[4].current < /*exertion*/
    i[4].max && /*exertion*/
    i[4].max && YF(i)
  );
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.ExertionPool")}`, s = F(), n = E("input"), r = Q(`
            /
            `), o = E("input"), f = F(), m && m.c(), b(t, "class", "u-mb-0 u-text-sm u-text-bold"), b(n, "class", "a5e-footer-group__input svelte-1f61qo5"), b(n, "type", "number"), b(n, "name", "system.attributes.exertion.current"), n.value = l = /*exertion*/
      i[4].current, b(n, "placeholder", "0"), b(n, "min", "0"), Z(n, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(o, "class", "a5e-footer-group__input"), b(o, "type", "number"), b(o, "name", "system.attributes.exertion.max"), o.value = a = /*exertion*/
      i[4].max, o.disabled = c = /*$actor*/
      i[0].automationAvailable, b(o, "placeholder", "0"), b(o, "min", "0"), b(e, "class", "u-flex u-align-center u-gap-md");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), A(e, f), m && m.m(e, null), d || (p = [
        W(
          n,
          "change",
          /*change_handler*/
          i[11]
        ),
        W(
          o,
          "change",
          /*change_handler_1*/
          i[12]
        )
      ], d = !0);
    },
    p(g, h) {
      h & /*exertion*/
      16 && l !== (l = /*exertion*/
      g[4].current) && n.value !== l && (n.value = l), h & /*$actor*/
      1 && Z(n, "disable-pointer-events", !/*$actor*/
      g[0].isOwner), h & /*exertion*/
      16 && a !== (a = /*exertion*/
      g[4].max) && o.value !== a && (o.value = a), h & /*$actor*/
      1 && c !== (c = /*$actor*/
      g[0].automationAvailable) && (o.disabled = c), /*exertion*/
      g[4].current < /*exertion*/
      g[4].max && /*exertion*/
      g[4].max ? m ? m.p(g, h) : (m = YF(g), m.c(), m.m(e, null)) : m && (m.d(1), m = null);
    },
    d(g) {
      g && C(e), m && m.d(), d = !1, Me(p);
    }
  };
}
u(KF, "create_if_block$1e");
function YF(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = '<i class="fa-solid fa-bolt"></i>', b(e, "class", "recharge-button svelte-1f61qo5"), b(e, "data-tooltip", "A5E.ExertionRechargeFromHitDice"), b(e, "data-tooltip-direction", "UP");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler_1*/
        i[13]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(YF, "create_if_block_1$M");
function qre(i) {
  let e, t = (
    /*$actor*/
    i[0].type === "character" && KF(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*$actor*/
      s[0].type === "character" ? t ? t.p(s, n) : (t = KF(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(qre, "create_default_slot$10");
function Gre(i) {
  let e, t, s, n, l, r, o = (
    /*$actor*/
    i[0].isOwner && UF(i)
  ), a = ue(Object.entries(
    /*$maneuvers*/
    i[5]._degrees
  )), c = [];
  for (let d = 0; d < a.length; d += 1)
    c[d] = WF(HF(i, a, d));
  const f = /* @__PURE__ */ u((d) => O(c[d], 1, 1, () => {
    c[d] = null;
  }), "out");
  return n = new kc({
    props: {
      $$slots: { default: [qre] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      o && o.c(), e = F(), t = E("section");
      for (let d = 0; d < c.length; d += 1)
        c[d].c();
      s = F(), l = E("div"), j(n.$$.fragment), b(t, "class", "a5e-page-wrapper a5e-page-wrapper--item-list"), G(l, "display", "contents"), G(l, "--padding-right", "1rem");
    },
    m(d, p) {
      o && o.m(d, p), T(d, e, p), T(d, t, p);
      for (let m = 0; m < c.length; m += 1)
        c[m] && c[m].m(t, null);
      T(d, s, p), T(d, l, p), R(n, l, null), r = !0;
    },
    p(d, [p]) {
      if (/*$actor*/
      d[0].isOwner ? o ? (o.p(d, p), p & /*$actor*/
      1 && w(o, 1)) : (o = UF(d), o.c(), w(o, 1), o.m(e.parentNode, e)) : o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce()), p & /*Object, $maneuvers, showDescription, showUses*/
      38) {
        a = ue(Object.entries(
          /*$maneuvers*/
          d[5]._degrees
        ));
        let g;
        for (g = 0; g < a.length; g += 1) {
          const h = HF(d, a, g);
          c[g] ? (c[g].p(h, p), w(c[g], 1)) : (c[g] = WF(h), c[g].c(), w(c[g], 1), c[g].m(t, null));
        }
        for (ae(), g = a.length; g < c.length; g += 1)
          f(g);
        ce();
      }
      const m = {};
      p & /*$$scope, $actor, exertion*/
      1048593 && (m.$$scope = { dirty: p, ctx: d }), n.$set(m);
    },
    i(d) {
      if (!r) {
        w(o);
        for (let p = 0; p < a.length; p += 1)
          w(c[p]);
        w(n.$$.fragment, d), r = !0;
      }
    },
    o(d) {
      O(o), c = c.filter(Boolean);
      for (let p = 0; p < c.length; p += 1)
        O(c[p]);
      O(n.$$.fragment, d), r = !1;
    },
    d(d) {
      d && (C(e), C(t), C(s)), o && o.d(d), Le(c, d), d && n && C(l), N(n, d);
    }
  };
}
u(Gre, "create_fragment$2k");
const hd = "maneuvers";
function zre(i, e, t) {
  let s, n, l, r;
  const o = de("actor");
  pe(i, o, (k) => t(0, l = k));
  const { maneuvers: a } = o;
  pe(i, a, (k) => t(5, r = k));
  const c = CONFIG.A5E.maneuverDegrees, f = game.a5e.utils.openCompendium;
  let d = !1, p = Gl(a);
  const m = a.subscribe((k) => {
    t(2, p = Gl(a));
  });
  Qt(() => {
    m();
  });
  const g = /* @__PURE__ */ u(() => t(1, d = !d), "updateSelection_handler"), h = /* @__PURE__ */ u(() => f(l, "maneuvers"), "click_handler"), _ = /* @__PURE__ */ u(({ target: k }) => te(l, k.name, Number(k.value)), "change_handler"), y = /* @__PURE__ */ u(({ target: k }) => te(l, k.name, Number(k.value)), "change_handler_1"), v = /* @__PURE__ */ u(() => l.recoverExertionUsingHitDice(), "click_handler_1");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(4, s = l.system.attributes.exertion);
  }, t(3, n = Object.entries(c)), [
    l,
    d,
    p,
    n,
    s,
    r,
    o,
    a,
    f,
    g,
    h,
    _,
    y,
    v
  ];
}
u(zre, "instance$2b");
const _S = class _S extends re {
  constructor(e) {
    super(), oe(this, e, zre, Gre, le, {});
  }
};
u(_S, "ActorManueversPage");
let R0 = _S;
function Hre(i) {
  let e, t = K(
    /*tab*/
    i[2].label
  ) + "", s, n, l;
  return {
    c() {
      e = E("li"), s = Q(t), b(e, "class", "a5e-secondary-nav-list__item"), Z(
        e,
        "a5e-secondary-nav-list__item--active",
        /*name*/
        i[1] === /*currentTab*/
        i[0]
      );
    },
    m(r, o) {
      T(r, e, o), A(e, s), n || (l = W(
        e,
        "click",
        /*click_handler*/
        i[4]
      ), n = !0);
    },
    p(r, [o]) {
      o & /*tab*/
      4 && t !== (t = K(
        /*tab*/
        r[2].label
      ) + "") && be(s, t), o & /*name, currentTab*/
      3 && Z(
        e,
        "a5e-secondary-nav-list__item--active",
        /*name*/
        r[1] === /*currentTab*/
        r[0]
      );
    },
    i: se,
    o: se,
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Hre, "create_fragment$2j");
function Ure(i, e, t) {
  let { currentTab: s } = e, { name: n } = e, { tab: l } = e;
  const r = ft(), o = /* @__PURE__ */ u(() => r("tab-change", n), "click_handler");
  return i.$$set = (a) => {
    "currentTab" in a && t(0, s = a.currentTab), "name" in a && t(1, n = a.name), "tab" in a && t(2, l = a.tab);
  }, [s, n, l, r, o];
}
u(Ure, "instance$2a");
const yS = class yS extends re {
  constructor(e) {
    super(), oe(this, e, Ure, Hre, le, { currentTab: 0, name: 1, tab: 2 });
  }
};
u(yS, "SecondaryNavigationItem");
let N0 = yS;
function XF(i, e, t) {
  const s = i.slice();
  return s[3] = e[t][0], s[4] = e[t][1], s;
}
u(XF, "get_each_context$N");
function JF(i) {
  let e, t;
  return e = new N0({
    props: {
      currentTab: (
        /*currentTab*/
        i[0]
      ),
      name: (
        /*name*/
        i[3]
      ),
      tab: (
        /*tab*/
        i[4]
      )
    }
  }), e.$on(
    "tab-change",
    /*tab_change_handler*/
    i[2]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*currentTab*/
      1 && (l.currentTab = /*currentTab*/
      s[0]), n & /*tabs*/
      2 && (l.name = /*name*/
      s[3]), n & /*tabs*/
      2 && (l.tab = /*tab*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(JF, "create_if_block$1d");
function ZF(i) {
  var n;
  let e, t, s = (
    /*tab*/
    (((n = i[4]) == null ? void 0 : n.display) ?? !0) && JF(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(l, r) {
      s && s.m(l, r), T(l, e, r), t = !0;
    },
    p(l, r) {
      var o;
      /*tab*/
      ((o = l[4]) == null ? void 0 : o.display) ?? !0 ? s ? (s.p(l, r), r & /*tabs*/
      2 && w(s, 1)) : (s = JF(l), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(l) {
      t || (w(s), t = !0);
    },
    o(l) {
      O(s), t = !1;
    },
    d(l) {
      l && C(e), s && s.d(l);
    }
  };
}
u(ZF, "create_each_block$N");
function Vre(i) {
  let e, t, s, n = ue(Object.entries(
    /*tabs*/
    i[1]
  )), l = [];
  for (let o = 0; o < n.length; o += 1)
    l[o] = ZF(XF(i, n, o));
  const r = /* @__PURE__ */ u((o) => O(l[o], 1, 1, () => {
    l[o] = null;
  }), "out");
  return {
    c() {
      e = E("nav"), t = E("ul");
      for (let o = 0; o < l.length; o += 1)
        l[o].c();
      b(t, "class", "a5e-secondary-nav-list"), b(e, "class", "a5e-secondary-nav");
    },
    m(o, a) {
      T(o, e, a), A(e, t);
      for (let c = 0; c < l.length; c += 1)
        l[c] && l[c].m(t, null);
      s = !0;
    },
    p(o, [a]) {
      if (a & /*currentTab, Object, tabs*/
      3) {
        n = ue(Object.entries(
          /*tabs*/
          o[1]
        ));
        let c;
        for (c = 0; c < n.length; c += 1) {
          const f = XF(o, n, c);
          l[c] ? (l[c].p(f, a), w(l[c], 1)) : (l[c] = ZF(f), l[c].c(), w(l[c], 1), l[c].m(t, null));
        }
        for (ae(), c = n.length; c < l.length; c += 1)
          r(c);
        ce();
      }
    },
    i(o) {
      if (!s) {
        for (let a = 0; a < n.length; a += 1)
          w(l[a]);
        s = !0;
      }
    },
    o(o) {
      l = l.filter(Boolean);
      for (let a = 0; a < l.length; a += 1)
        O(l[a]);
      s = !1;
    },
    d(o) {
      o && C(e), Le(l, o);
    }
  };
}
u(Vre, "create_fragment$2i");
function Wre(i, e, t) {
  let { currentTab: s } = e, { tabs: n } = e;
  function l(r) {
    bt.call(this, i, r);
  }
  return u(l, "tab_change_handler"), i.$$set = (r) => {
    "currentTab" in r && t(0, s = r.currentTab), "tabs" in r && t(1, n = r.tabs);
  }, [s, n, l];
}
u(Wre, "instance$29");
const vS = class vS extends re {
  constructor(e) {
    super(), oe(this, e, Wre, Vre, le, { currentTab: 0, tabs: 1 });
  }
};
u(vS, "SecondaryNavigationBar");
let Mp = vS;
function QF(i, e, t) {
  const s = i.slice();
  return s[11] = e[t][0], s[12] = e[t][1], s;
}
u(QF, "get_each_context$M");
function xF(i, e, t) {
  const s = i.slice();
  return s[11] = e[t][0], s[12] = e[t][1], s;
}
u(xF, "get_each_context_1$9");
function e6(i) {
  let e, t, s, n, l, r, o = ue(Object.entries(
    /*charChoicesLabel*/
    i[5]
  )), a = [];
  for (let m = 0; m < o.length; m += 1)
    a[m] = t6(xF(i, o, m));
  const c = /* @__PURE__ */ u((m) => O(a[m], 1, 1, () => {
    a[m] = null;
  }), "out");
  let f = ue(Object.entries(
    /*traitsLabel*/
    i[6]
  )), d = [];
  for (let m = 0; m < f.length; m += 1)
    d[m] = s6(QF(i, f, m));
  const p = /* @__PURE__ */ u((m) => O(d[m], 1, 1, () => {
    d[m] = null;
  }), "out_1");
  return {
    c() {
      e = E("section");
      for (let m = 0; m < a.length; m += 1)
        a[m].c();
      t = F(), s = E("section");
      for (let m = 0; m < d.length; m += 1)
        d[m].c();
      n = F(), l = E("heading"), l.innerHTML = '<h3 class="a5e-section-header__heading">Appearance</h3>', b(e, "class", "a5e-box u-p-md a5e-form__section--bio-wrapper"), b(s, "class", "a5e-box u-p-md a5e-form__section--bio-wrapper"), b(l, "class", "a5e-section-header");
    },
    m(m, g) {
      T(m, e, g);
      for (let h = 0; h < a.length; h += 1)
        a[h] && a[h].m(e, null);
      T(m, t, g), T(m, s, g);
      for (let h = 0; h < d.length; h += 1)
        d[h] && d[h].m(s, null);
      T(m, n, g), T(m, l, g), r = !0;
    },
    p(m, g) {
      if (g & /*Object, charChoicesLabel, actor, $actor, Number*/
      42) {
        o = ue(Object.entries(
          /*charChoicesLabel*/
          m[5]
        ));
        let h;
        for (h = 0; h < o.length; h += 1) {
          const _ = xF(m, o, h);
          a[h] ? (a[h].p(_, g), w(a[h], 1)) : (a[h] = t6(_), a[h].c(), w(a[h], 1), a[h].m(e, null));
        }
        for (ae(), h = o.length; h < a.length; h += 1)
          c(h);
        ce();
      }
      if (g & /*Object, traitsLabel, actor, $actor*/
      74) {
        f = ue(Object.entries(
          /*traitsLabel*/
          m[6]
        ));
        let h;
        for (h = 0; h < f.length; h += 1) {
          const _ = QF(m, f, h);
          d[h] ? (d[h].p(_, g), w(d[h], 1)) : (d[h] = s6(_), d[h].c(), w(d[h], 1), d[h].m(s, null));
        }
        for (ae(), h = f.length; h < d.length; h += 1)
          p(h);
        ce();
      }
    },
    i(m) {
      if (!r) {
        for (let g = 0; g < o.length; g += 1)
          w(a[g]);
        for (let g = 0; g < f.length; g += 1)
          w(d[g]);
        r = !0;
      }
    },
    o(m) {
      a = a.filter(Boolean);
      for (let g = 0; g < a.length; g += 1)
        O(a[g]);
      d = d.filter(Boolean);
      for (let g = 0; g < d.length; g += 1)
        O(d[g]);
      r = !1;
    },
    d(m) {
      m && (C(e), C(t), C(s), C(n), C(l)), Le(a, m), Le(d, m);
    }
  };
}
u(e6, "create_if_block$1c");
function Kre(i) {
  let e, t, s, n, l;
  function r(...o) {
    return (
      /*change_handler*/
      i[7](
        /*key*/
        i[11],
        ...o
      )
    );
  }
  return u(r, "change_handler"), {
    c() {
      e = E("input"), s = F(), b(e, "class", "a5e-input a5e-input--slim u-w-full"), b(
        e,
        "id",
        /*actor*/
        i[3].id + "-details-" + /*key*/
        i[11]
      ), b(e, "type", "text"), b(e, "name", "system.details." + /*key*/
      i[11]), e.value = t = /*$actor*/
      i[1].system.details[
        /*key*/
        i[11]
      ] ?? "", Z(e, "disable-pointer-events", !/*$actor*/
      i[1].isOwner);
    },
    m(o, a) {
      T(o, e, a), T(o, s, a), n || (l = W(e, "change", r), n = !0);
    },
    p(o, a) {
      i = o, a & /*$actor*/
      2 && t !== (t = /*$actor*/
      i[1].system.details[
        /*key*/
        i[11]
      ] ?? "") && e.value !== t && (e.value = t), a & /*$actor*/
      2 && Z(e, "disable-pointer-events", !/*$actor*/
      i[1].isOwner);
    },
    d(o) {
      o && (C(e), C(s)), n = !1, l();
    }
  };
}
u(Kre, "create_default_slot_1$s");
function t6(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: (
        /*label*/
        i[12]
      ),
      $$slots: { default: [Kre] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-gap", "0.25rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, $actor*/
      131074 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(t6, "create_each_block_1$9");
function Yre(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("input"), s = F(), b(e, "class", "a5e-input a5e-input--slim"), b(
        e,
        "id",
        /*actor*/
        i[3].id + "-details-" + /*key*/
        i[11]
      ), b(e, "type", "text"), b(e, "name", "system.details." + /*key*/
      i[11]), e.value = t = /*$actor*/
      i[1].system.details[
        /*key*/
        i[11]
      ], Z(e, "disable-pointer-events", !/*$actor*/
      i[1].isOwner);
    },
    m(r, o) {
      T(r, e, o), T(r, s, o), n || (l = W(
        e,
        "change",
        /*change_handler_1*/
        i[8]
      ), n = !0);
    },
    p(r, o) {
      o & /*$actor*/
      2 && t !== (t = /*$actor*/
      r[1].system.details[
        /*key*/
        r[11]
      ]) && e.value !== t && (e.value = t), o & /*$actor*/
      2 && Z(e, "disable-pointer-events", !/*$actor*/
      r[1].isOwner);
    },
    d(r) {
      r && (C(e), C(s)), n = !1, l();
    }
  };
}
u(Yre, "create_default_slot$$");
function s6(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: (
        /*label*/
        i[12]
      ),
      $$slots: { default: [Yre] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-gap", "0.25rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, $actor*/
      131074 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(s6, "create_each_block$M");
function Xre(i) {
  let e, t, s, n, l, r;
  e = new Mp({
    props: {
      currentTab: (
        /*currentTab*/
        i[0]
      ),
      tabs: (
        /*tabs*/
        i[4]
      )
    }
  }), e.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  let o = (
    /*currentTab*/
    i[0] === "appearance" && e6(i)
  );
  return l = new wr({
    props: {
      document: (
        /*actor*/
        i[3]
      ),
      content: (
        /*$actor*/
        i[1].system.details[
          /*currentTab*/
          i[0]
        ]
      ),
      updatePath: "system.details." + /*currentTab*/
      i[0]
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), s = E("div"), o && o.c(), n = F(), j(l.$$.fragment), b(s, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(a, c) {
      R(e, a, c), T(a, t, c), T(a, s, c), o && o.m(s, null), A(s, n), R(l, s, null), r = !0;
    },
    p(a, [c]) {
      const f = {};
      c & /*currentTab*/
      1 && (f.currentTab = /*currentTab*/
      a[0]), e.$set(f), /*currentTab*/
      a[0] === "appearance" ? o ? (o.p(a, c), c & /*currentTab*/
      1 && w(o, 1)) : (o = e6(a), o.c(), w(o, 1), o.m(s, n)) : o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce());
      const d = {};
      c & /*$actor, currentTab*/
      3 && (d.content = /*$actor*/
      a[1].system.details[
        /*currentTab*/
        a[0]
      ]), c & /*currentTab*/
      1 && (d.updatePath = "system.details." + /*currentTab*/
      a[0]), l.$set(d);
    },
    i(a) {
      r || (w(e.$$.fragment, a), w(o), w(l.$$.fragment, a), r = !0);
    },
    o(a) {
      O(e.$$.fragment, a), O(o), O(l.$$.fragment, a), r = !1;
    },
    d(a) {
      a && (C(t), C(s)), N(e, a), o && o.d(), N(l);
    }
  };
}
u(Xre, "create_fragment$2h");
function Jre(i, e, t) {
  var g;
  let s;
  function n({ detail: h }) {
    const { uuid: _ } = s;
    t(0, d = h), al.update((y) => ({
      ...y,
      [_]: {
        ...y[_] ?? {},
        currentNotesTab: h
      }
    }));
  }
  u(n, "updateCurrentTab");
  const l = de("actor");
  pe(i, l, (h) => t(1, s = h));
  let r = game.user.isGM;
  const o = {
    appearance: {
      label: "Character Details",
      display: s.type === "character"
    },
    bio: {
      label: s.type === "npc" ? "A5E.TabBiography" : "Backstory",
      display: s.type === "character" || r && s.type === "npc"
    },
    notes: { label: "A5E.TabNotes" },
    privateNotes: {
      label: "A5E.DetailsNotesPrivate",
      display: r && s.type === "npc"
    }
  }, a = {
    classes: "A5E.ClassPlural",
    archetype: "A5E.Archetype",
    // background: "A5E.Background",
    // culture: "A5E.Culture",
    // destiny: "A5E.Destiny",
    // heritage: "A5E.Heritage",
    prestige: "A5E.Prestige"
  }, c = {
    age: "A5E.DetailsAge",
    eyeColor: "A5E.DetailsEyeColor",
    hairColor: "A5E.DetailsHairColor",
    skinColor: "A5E.DetailsSkinColor",
    height: "A5E.DetailsHeight",
    weight: "A5E.DetailsWeight",
    gender: "A5E.DetailsGender"
  };
  let f = {};
  al.subscribe((h) => {
    f = h;
  });
  let d = ((g = f[s == null ? void 0 : s.uuid]) == null ? void 0 : g.currentNotesTab) ?? (s.type === "npc" ? "bio" : "appearance");
  return [
    d,
    s,
    n,
    l,
    o,
    a,
    c,
    /* @__PURE__ */ u((h, { target: _ }) => {
      te(s, _.name, h === "prestige" ? Number(_.value) : _.value);
    }, "change_handler"),
    /* @__PURE__ */ u(({ target: h }) => {
      te(s, h.name, h.value);
    }, "change_handler_1")
  ];
}
u(Jre, "instance$28");
const kS = class kS extends re {
  constructor(e) {
    super(), oe(this, e, Jre, Xre, le, {});
  }
};
u(kS, "ActorNotesPage");
let j0 = kS;
function Zre(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.automatePrototypeTokenSize",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.automatePrototypeTokenSize) ?? /*automateTokenSize*/
        i[3] ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.automatePrototypeTokenSize) ?? /*automateTokenSize*/
      n[3] ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(Zre, "create_default_slot_12$3");
function Qre(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.HideGenericResources",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.hideGenericResources) ?? /*$actor*/
        i[0].type === "npc"
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[5]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags, $actor*/
      3 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.hideGenericResources) ?? /*$actor*/
      n[0].type === "npc"), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(Qre, "create_default_slot_11$3");
function xre(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.includeAbilityModifiersForSkills",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.includeAbilityModifiersForSkills) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[6]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.includeAbilityModifiersForSkills) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(xre, "create_default_slot_10$3");
function eoe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showFavoritesSection",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.showFavoritesSection) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.showFavoritesSection) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(eoe, "create_default_slot_9$4");
function toe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showManeuverTab",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.showManeuverTab) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.showManeuverTab) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(toe, "create_default_slot_8$5");
function soe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showPassiveScores",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.showPassiveScores) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[9]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.showPassiveScores) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(soe, "create_default_slot_7$9");
function noe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showSpellTab",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.showSpellTab) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[10]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.showSpellTab) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(noe, "create_default_slot_6$b");
function n6(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [ioe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, flags, $actor*/
      65539 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(n6, "create_if_block_1$L");
function ioe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showXP",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.showXP) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[11]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.showXP) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(ioe, "create_default_slot_5$d");
function loe(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _;
  e = new ie({
    props: {
      $$slots: { default: [Zre] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      $$slots: { default: [Qre] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      $$slots: { default: [xre] },
      $$scope: { ctx: i }
    }
  }), o = new ie({
    props: {
      $$slots: { default: [eoe] },
      $$scope: { ctx: i }
    }
  }), c = new ie({
    props: {
      $$slots: { default: [toe] },
      $$scope: { ctx: i }
    }
  }), d = new ie({
    props: {
      $$slots: { default: [soe] },
      $$scope: { ctx: i }
    }
  }), m = new ie({
    props: {
      $$slots: { default: [noe] },
      $$scope: { ctx: i }
    }
  });
  let y = (
    /*$actor*/
    i[0].type === "character" && n6(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment), f = F(), j(d.$$.fragment), p = F(), j(m.$$.fragment), g = F(), y && y.c(), h = $e();
    },
    m(v, k) {
      R(e, v, k), T(v, t, k), R(s, v, k), T(v, n, k), R(l, v, k), T(v, r, k), R(o, v, k), T(v, a, k), R(c, v, k), T(v, f, k), R(d, v, k), T(v, p, k), R(m, v, k), T(v, g, k), y && y.m(v, k), T(v, h, k), _ = !0;
    },
    p(v, k) {
      const S = {};
      k & /*$$scope, flags, $actor*/
      65539 && (S.$$scope = { dirty: k, ctx: v }), e.$set(S);
      const D = {};
      k & /*$$scope, flags, $actor*/
      65539 && (D.$$scope = { dirty: k, ctx: v }), s.$set(D);
      const I = {};
      k & /*$$scope, flags, $actor*/
      65539 && (I.$$scope = { dirty: k, ctx: v }), l.$set(I);
      const M = {};
      k & /*$$scope, flags, $actor*/
      65539 && (M.$$scope = { dirty: k, ctx: v }), o.$set(M);
      const L = {};
      k & /*$$scope, flags, $actor*/
      65539 && (L.$$scope = { dirty: k, ctx: v }), c.$set(L);
      const B = {};
      k & /*$$scope, flags, $actor*/
      65539 && (B.$$scope = { dirty: k, ctx: v }), d.$set(B);
      const z = {};
      k & /*$$scope, flags, $actor*/
      65539 && (z.$$scope = { dirty: k, ctx: v }), m.$set(z), /*$actor*/
      v[0].type === "character" ? y ? (y.p(v, k), k & /*$actor*/
      1 && w(y, 1)) : (y = n6(v), y.c(), w(y, 1), y.m(h.parentNode, h)) : y && (ae(), O(y, 1, 1, () => {
        y = null;
      }), ce());
    },
    i(v) {
      _ || (w(e.$$.fragment, v), w(s.$$.fragment, v), w(l.$$.fragment, v), w(o.$$.fragment, v), w(c.$$.fragment, v), w(d.$$.fragment, v), w(m.$$.fragment, v), w(y), _ = !0);
    },
    o(v) {
      O(e.$$.fragment, v), O(s.$$.fragment, v), O(l.$$.fragment, v), O(o.$$.fragment, v), O(c.$$.fragment, v), O(d.$$.fragment, v), O(m.$$.fragment, v), O(y), _ = !1;
    },
    d(v) {
      v && (C(t), C(n), C(r), C(a), C(f), C(p), C(g), C(h)), N(e, v), N(s, v), N(l, v), N(o, v), N(c, v), N(d, v), N(m, v), y && y.d(v);
    }
  };
}
u(loe, "create_default_slot_4$e");
function i6(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Automation Customization",
      $$slots: { default: [coe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, flags, $actor*/
      65539 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(i6, "create_if_block$1b");
function roe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.automateHitDice",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.automateHitDice) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_8*/
    i[12]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.automateHitDice) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(roe, "create_default_slot_3$l");
function ooe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.automateSpellResources",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.automateSpellResources) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_9*/
    i[13]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.automateSpellResources) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(ooe, "create_default_slot_2$o");
function aoe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.automaticallyExecuteAvailableMacros",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.automaticallyExecuteAvailableMacros) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_10*/
    i[14]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.automaticallyExecuteAvailableMacros) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(aoe, "create_default_slot_1$r");
function coe(i) {
  let e, t, s, n, l, r;
  return e = new ie({
    props: {
      $$slots: { default: [roe] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      $$slots: { default: [ooe] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      $$slots: { default: [aoe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), R(s, o, a), T(o, n, a), R(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, flags, $actor*/
      65539 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const f = {};
      a & /*$$scope, flags, $actor*/
      65539 && (f.$$scope = { dirty: a, ctx: o }), s.$set(f);
      const d = {};
      a & /*$$scope, flags, $actor*/
      65539 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(s.$$.fragment, o), O(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (C(t), C(n)), N(e, o), N(s, o), N(l, o);
    }
  };
}
u(coe, "create_default_slot$_");
function uoe(i) {
  let e, t, s, n, l;
  e = new De({
    props: {
      heading: "Sheet Customization",
      $$slots: { default: [loe] },
      $$scope: { ctx: i }
    }
  });
  let r = (
    /*$actor*/
    i[0].type === "character" && i6(i)
  );
  return {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), r && r.c(), n = $e(), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*$$scope, flags, $actor*/
      65539 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c), /*$actor*/
      o[0].type === "character" ? r ? (r.p(o, a), a & /*$actor*/
      1 && w(r, 1)) : (r = i6(o), r.c(), w(r, 1), r.m(n.parentNode, n)) : r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce());
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(r), l = !1;
    },
    d(o) {
      o && (C(s), C(n)), o && e && C(t), N(e, o), r && r.d(o);
    }
  };
}
u(uoe, "create_fragment$2g");
function foe(i, e, t) {
  let s, n;
  const l = de("actor");
  pe(i, l, (k) => t(0, n = k));
  let o = game.a5e.settings.store.getStore("automatePrototypeTokenSize");
  const a = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, "flags.a5e.automatePrototypeTokenSize", k);
  }, "updateSelection_handler"), c = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, "flags.a5e.hideGenericResources", k);
  }, "updateSelection_handler_1"), f = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, "flags.a5e.includeAbilityModifiersForSkills", k);
  }, "updateSelection_handler_2"), d = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, "flags.a5e.showFavoritesSection", k);
  }, "updateSelection_handler_3"), p = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, "flags.a5e.showManeuverTab", k);
  }, "updateSelection_handler_4"), m = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, "flags.a5e.showPassiveScores", k);
  }, "updateSelection_handler_5"), g = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, "flags.a5e.showSpellTab", k);
  }, "updateSelection_handler_6"), h = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, "flags.a5e.showXP", k);
  }, "updateSelection_handler_7"), _ = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, "flags.a5e.automateHitDice", k);
  }, "updateSelection_handler_8"), y = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, "flags.a5e.automateSpellResources", k);
  }, "updateSelection_handler_9"), v = /* @__PURE__ */ u(({ detail: k }) => {
    te(n, "flags.a5e.automaticallyExecuteAvailableMacros", k);
  }, "updateSelection_handler_10");
  return i.$$.update = () => {
    var k;
    i.$$.dirty & /*$actor*/
    1 && t(1, s = ((k = n.flags) == null ? void 0 : k.a5e) ?? {});
  }, [
    n,
    s,
    l,
    o,
    a,
    c,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    v
  ];
}
u(foe, "instance$27");
const wS = class wS extends re {
  constructor(e) {
    super(), oe(this, e, foe, uoe, le, {});
  }
};
u(wS, "ActorGeneralSettingsTab");
let L0 = wS;
function doe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.trackInventoryWeight",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.trackInventoryWeight) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.trackInventoryWeight) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(doe, "create_default_slot_3$k");
function l6(i) {
  let e, t, s, n;
  return e = new ie({
    props: {
      $$slots: { default: [poe] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      hint: "A5E.settings.hints.trackCurrencyWeight",
      $$slots: { default: [moe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, flags, $actor*/
      131 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, flags, $actor*/
      131 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(l6, "create_if_block$1a");
function poe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.doubleCarryingCapacity",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.doubleCarryCapacity) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[5]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.doubleCarryCapacity) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(poe, "create_default_slot_2$n");
function moe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.trackCurrencyWeight",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.trackCurrencyWeight) ?? /*globalCurrencyWeightTrackingSelection*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[6]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.trackCurrencyWeight) ?? /*globalCurrencyWeightTrackingSelection*/
      n[3]), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(moe, "create_default_slot_1$q");
function hoe(i) {
  var r;
  let e, t, s, n;
  e = new ie({
    props: {
      $$slots: { default: [doe] },
      $$scope: { ctx: i }
    }
  });
  let l = (
    /*flags*/
    (((r = i[1]) == null ? void 0 : r.trackInventoryWeight) ?? !0) && l6(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), l && l.c(), s = $e();
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), l && l.m(o, a), T(o, s, a), n = !0;
    },
    p(o, a) {
      var f;
      const c = {};
      a & /*$$scope, flags, $actor*/
      131 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c), /*flags*/
      ((f = o[1]) == null ? void 0 : f.trackInventoryWeight) ?? !0 ? l ? (l.p(o, a), a & /*flags*/
      2 && w(l, 1)) : (l = l6(o), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ae(), O(l, 1, 1, () => {
        l = null;
      }), ce());
    },
    i(o) {
      n || (w(e.$$.fragment, o), w(l), n = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(l), n = !1;
    },
    d(o) {
      o && (C(t), C(s)), N(e, o), l && l.d(o);
    }
  };
}
u(hoe, "create_default_slot$Z");
function goe(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Weight Tracking Options",
      $$slots: { default: [hoe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, flags, $actor*/
      131 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(goe, "create_fragment$2f");
function boe(i, e, t) {
  let s, n;
  const l = de("actor");
  pe(i, l, (f) => t(0, n = f));
  const r = game.settings.get("a5e", "currencyWeight"), o = /* @__PURE__ */ u(({ detail: f }) => {
    te(n, "flags.a5e.trackInventoryWeight", f);
  }, "updateSelection_handler"), a = /* @__PURE__ */ u(({ detail: f }) => {
    te(n, "flags.a5e.doubleCarryCapacity", f);
  }, "updateSelection_handler_1"), c = /* @__PURE__ */ u(({ detail: f }) => {
    te(n, "flags.a5e.trackCurrencyWeight", f);
  }, "updateSelection_handler_2");
  return i.$$.update = () => {
    var f;
    i.$$.dirty & /*$actor*/
    1 && t(1, s = ((f = n.flags) == null ? void 0 : f.a5e) ?? {});
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c
  ];
}
u(boe, "instance$26");
const $S = class $S extends re {
  constructor(e) {
    super(), oe(this, e, boe, goe, le, {});
  }
};
u($S, "ActorInventorySettingsTab");
let B0 = $S;
function _oe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.ExertionRecoveryConfigPrompt",
      checked: (
        /*$actor*/
        i[0].system.attributes.exertion.recoverOnRest
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[2]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      1 && (l.checked = /*$actor*/
      s[0].system.attributes.exertion.recoverOnRest), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(_oe, "create_default_slot_1$p");
function yoe(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [_oe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $actor*/
      9 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(yoe, "create_default_slot$Y");
function voe(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Maneuver Resource Settings",
      $$slots: { default: [yoe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, $actor*/
      9 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(voe, "create_fragment$2e");
function koe(i, e, t) {
  let s;
  const n = de("actor");
  return pe(i, n, (r) => t(0, s = r)), [s, n, /* @__PURE__ */ u(({ detail: r }) => {
    te(s, "system.attributes.exertion.recoverOnRest", r);
  }, "updateSelection_handler")];
}
u(koe, "instance$25");
const AS = class AS extends re {
  constructor(e) {
    super(), oe(this, e, koe, voe, le, {});
  }
};
u(AS, "ActorManeuverSettingsTab");
let q0 = AS;
function woe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.halflingLuck",
      checked: (
        /*flags*/
        ((s = i[1].a5e) == null ? void 0 : s.halflingLuck) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[3]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1].a5e) == null ? void 0 : o.halflingLuck) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(woe, "create_default_slot_3$j");
function $oe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.jackOfAllTrades",
      checked: (
        /*flags*/
        ((s = i[1].a5e) == null ? void 0 : s.jackOfAllTrades) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[4]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1].a5e) == null ? void 0 : o.jackOfAllTrades) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u($oe, "create_default_slot_2$m");
function Aoe(i) {
  let e, t, s, n, l = K("A5E.settings.deathSaveThreshold") + "", r, o, a;
  return {
    c() {
      var c;
      e = E("input"), s = F(), n = E("label"), r = Q(l), b(
        e,
        "id",
        /*actor*/
        i[2].id + "-death-save-threshold"
      ), b(e, "class", "a5e-input a5e-input--small a5e-input--slim"), b(e, "type", "number"), b(e, "min", "0"), b(e, "max", "20"), e.value = t = /*flags*/
      ((c = i[1].a5e) == null ? void 0 : c.deathSaveThreshold) ?? 10, b(
        n,
        "for",
        /*actor*/
        i[2].id + "-death-save-threshold"
      );
    },
    m(c, f) {
      T(c, e, f), T(c, s, f), T(c, n, f), A(n, r), o || (a = W(
        e,
        "change",
        /*change_handler*/
        i[5]
      ), o = !0);
    },
    p(c, f) {
      var d;
      f & /*flags*/
      2 && t !== (t = /*flags*/
      ((d = c[1].a5e) == null ? void 0 : d.deathSaveThreshold) ?? 10) && e.value !== t && (e.value = t);
    },
    d(c) {
      c && (C(e), C(s), C(n)), o = !1, a();
    }
  };
}
u(Aoe, "create_default_slot_1$o");
function Eoe(i) {
  let e, t, s, n, l, r, o;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.halflingLuck",
      $$slots: { default: [woe] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      hint: "A5E.settings.hints.jackOfAllTrades",
      $$slots: { default: [$oe] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      hint: "A5E.settings.hints.deathSaveThreshold",
      $$slots: { default: [Aoe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), r = E("div"), j(l.$$.fragment), G(r, "display", "contents"), G(r, "--a5e-field-wrapper-direction", "row"), G(r, "--a5e-field-wrapper-item-alignment", "center");
    },
    m(a, c) {
      R(e, a, c), T(a, t, c), R(s, a, c), T(a, n, c), T(a, r, c), R(l, r, null), o = !0;
    },
    p(a, c) {
      const f = {};
      c & /*$$scope, flags, $actor*/
      67 && (f.$$scope = { dirty: c, ctx: a }), e.$set(f);
      const d = {};
      c & /*$$scope, flags, $actor*/
      67 && (d.$$scope = { dirty: c, ctx: a }), s.$set(d);
      const p = {};
      c & /*$$scope, flags, $actor*/
      67 && (p.$$scope = { dirty: c, ctx: a }), l.$set(p);
    },
    i(a) {
      o || (w(e.$$.fragment, a), w(s.$$.fragment, a), w(l.$$.fragment, a), o = !0);
    },
    o(a) {
      O(e.$$.fragment, a), O(s.$$.fragment, a), O(l.$$.fragment, a), o = !1;
    },
    d(a) {
      a && (C(t), C(n)), N(e, a), N(s, a), a && l && C(r), N(l, a);
    }
  };
}
u(Eoe, "create_default_slot$X");
function Soe(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Roll Modifiers",
      $$slots: { default: [Eoe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, flags, $actor*/
      67 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Soe, "create_fragment$2d");
function Coe(i, e, t) {
  let s, n;
  const l = de("actor");
  pe(i, l, (c) => t(0, n = c));
  const r = /* @__PURE__ */ u(({ detail: c }) => {
    te(n, "flags.a5e.halflingLuck", c);
  }, "updateSelection_handler"), o = /* @__PURE__ */ u(({ detail: c }) => {
    te(n, "flags.a5e.jackOfAllTrades", c);
  }, "updateSelection_handler_1"), a = /* @__PURE__ */ u(({ target: c }) => {
    te(n, "flags.a5e.deathSaveThreshold", parseInt(c.value, 10));
  }, "change_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(1, s = n.flags);
  }, [
    n,
    s,
    l,
    r,
    o,
    a
  ];
}
u(Coe, "instance$24");
const ES = class ES extends re {
  constructor(e) {
    super(), oe(this, e, Coe, Soe, le, {});
  }
};
u(ES, "ActorRollSettingsTab");
let G0 = ES;
function Toe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.restoreSpellSlotsOnShortRest",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.restoreSpellSlotsOnShortRest) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.restoreSpellSlotsOnShortRest) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(Toe, "create_default_slot_3$i");
function Ooe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.restoreSpellPointsOnShortRest",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.restoreSpellPointsOnShortRest) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[5]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.restoreSpellPointsOnShortRest) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(Ooe, "create_default_slot_2$l");
function Doe(i) {
  let e, t, s, n;
  return e = new ie({
    props: {
      $$slots: { default: [Toe] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      $$slots: { default: [Ooe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, flags, $actor*/
      131 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, flags, $actor*/
      131 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(Doe, "create_default_slot_1$n");
function Ioe(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "A5E.DefaultSpellcastingAbilityScore",
      optionStyles: "min-width:2rem; text-align: center;",
      options: Object.entries(
        /*abilityAbbreviations*/
        i[3]
      ),
      selected: (
        /*$actor*/
        i[0].system.attributes.spellcasting
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[6]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      1 && (l.selected = /*$actor*/
      s[0].system.attributes.spellcasting), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Ioe, "create_default_slot$W");
function Poe(i) {
  let e, t, s, n, l, r;
  return e = new De({
    props: {
      heading: "Spell Resource Settings",
      $$slots: { default: [Doe] },
      $$scope: { ctx: i }
    }
  }), n = new De({
    props: {
      heading: "Miscellaneous Spell Settings",
      $$slots: { default: [Ioe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(l, "display", "contents"), G(l, "--a5e-section-body-gap", "0.75rem");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), T(o, l, a), R(n, l, null), r = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*$$scope, flags, $actor*/
      131 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const f = {};
      a & /*$$scope, $actor*/
      129 && (f.$$scope = { dirty: a, ctx: o }), n.$set(f);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && C(s), o && e && C(t), N(e, o), o && n && C(l), N(n, o);
    }
  };
}
u(Poe, "create_fragment$2c");
function Moe(i, e, t) {
  let s, n;
  const l = de("actor");
  pe(i, l, (f) => t(0, n = f));
  const { abilityAbbreviations: r } = CONFIG.A5E, o = /* @__PURE__ */ u(({ detail: f }) => {
    te(n, "flags.a5e.restoreSpellSlotsOnShortRest", f);
  }, "updateSelection_handler"), a = /* @__PURE__ */ u(({ detail: f }) => {
    te(n, "flags.a5e.restoreSpellPointsOnShortRest", f);
  }, "updateSelection_handler_1"), c = /* @__PURE__ */ u((f) => te(n, "system.attributes.spellcasting", f.detail), "updateSelection_handler_2");
  return i.$$.update = () => {
    var f;
    i.$$.dirty & /*$actor*/
    1 && t(1, s = ((f = n.flags) == null ? void 0 : f.a5e) ?? {});
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c
  ];
}
u(Moe, "instance$23");
const SS = class SS extends re {
  constructor(e) {
    super(), oe(this, e, Moe, Poe, le, {});
  }
};
u(SS, "ActorSpellSettingsTab");
let z0 = SS;
function Foe(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "Disable Randomized HP Rolls",
      checked: (
        /*flags*/
        ((s = i[1].a5e) == null ? void 0 : s.disableRandomizedHP) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[3]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1].a5e) == null ? void 0 : o.disableRandomizedHP) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(Foe, "create_default_slot_1$m");
function Roe(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [Foe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, flags, $actor*/
      19 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Roe, "create_default_slot$V");
function Noe(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Token Options",
      $$slots: { default: [Roe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, flags, $actor*/
      19 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Noe, "create_fragment$2b");
function joe(i, e, t) {
  let s, n;
  const l = de("actor");
  pe(i, l, (o) => t(0, n = o));
  const r = /* @__PURE__ */ u(({ detail: o }) => {
    te(n, "flags.a5e.disableRandomizedHP", o);
  }, "updateSelection_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(1, s = n.flags);
  }, [n, s, l, r];
}
u(joe, "instance$22");
const CS = class CS extends re {
  constructor(e) {
    super(), oe(this, e, joe, Noe, le, {});
  }
};
u(CS, "ActorNPCSettingsTab");
let H0 = CS;
function Loe(i) {
  var a;
  let e, t, s, n, l;
  e = new Mp({
    props: {
      currentTab: (
        /*currentTab*/
        i[0]
      ),
      tabs: (
        /*tabs*/
        i[3]
      )
    }
  }), e.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[1]
  );
  var r = (
    /*tabs*/
    (a = i[3][
      /*currentTab*/
      i[0]
    ]) == null ? void 0 : a.component
  );
  function o(c, f) {
    return {};
  }
  return u(o, "switch_props"), r && (n = et(r, o())), {
    c() {
      j(e.$$.fragment), t = F(), s = E("section"), n && j(n.$$.fragment), b(s, "class", "a5e-page-wrapper");
    },
    m(c, f) {
      R(e, c, f), T(c, t, f), T(c, s, f), n && R(n, s, null), l = !0;
    },
    p(c, [f]) {
      var p;
      const d = {};
      if (f & /*currentTab*/
      1 && (d.currentTab = /*currentTab*/
      c[0]), e.$set(d), f & /*currentTab*/
      1 && r !== (r = /*tabs*/
      (p = c[3][
        /*currentTab*/
        c[0]
      ]) == null ? void 0 : p.component)) {
        if (n) {
          ae();
          const m = n;
          O(m.$$.fragment, 1, 0, () => {
            N(m, 1);
          }), ce();
        }
        r ? (n = et(r, o()), j(n.$$.fragment), w(n.$$.fragment, 1), R(n, s, null)) : n = null;
      }
    },
    i(c) {
      l || (w(e.$$.fragment, c), n && w(n.$$.fragment, c), l = !0);
    },
    o(c) {
      O(e.$$.fragment, c), n && O(n.$$.fragment, c), l = !1;
    },
    d(c) {
      c && (C(t), C(s)), N(e, c), n && N(n);
    }
  };
}
u(Loe, "create_fragment$2a");
function Boe(i, e, t) {
  var c;
  let s;
  function n({ detail: f }) {
    const { uuid: d } = s;
    t(0, a = f), al.update((p) => ({
      ...p,
      [d]: {
        ...p[d] ?? {},
        currentSettingsTab: f
      }
    }));
  }
  u(n, "updateCurrentTab");
  let l = {};
  al.subscribe((f) => {
    l = f;
  });
  const r = de("actor");
  pe(i, r, (f) => t(5, s = f));
  const o = {
    general: {
      component: L0,
      label: "General"
    },
    inventory: {
      component: B0,
      label: "Inventory"
    },
    maneuvers: {
      component: q0,
      label: "Maneuvers",
      display: s.type === "character"
    },
    spells: {
      component: z0,
      label: "Spells"
    },
    rolls: {
      component: G0,
      label: "Rolls",
      display: s.type === "character"
    },
    npc: {
      component: H0,
      label: "NPC Options",
      display: s.type === "npc" && (game.settings.get("a5e", "randomizeNPCHitPoints") ?? !0)
    }
  };
  let a = ((c = l[s == null ? void 0 : s.uuid]) == null ? void 0 : c.currentSettingsTab) ?? "general";
  return [a, n, r, o];
}
u(Boe, "instance$21");
const TS = class TS extends re {
  constructor(e) {
    super(), oe(this, e, Boe, Loe, le, {});
  }
};
u(TS, "ActorSettingsPage");
let U0 = TS;
function r6(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-ability-score__config-button fas fa-gear");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler*/
        i[9]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(r6, "create_if_block$19");
function qoe(i) {
  var q, U;
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h = nl(
    /*ability*/
    i[0].check.deterministicBonus
  ) + "", _, y, v, k, S, D = nl(
    /*ability*/
    i[0].save.deterministicBonus
  ) + "", I, M, L, B, z = !/*$actor*/
  (!i[3].isOwner || /*$actor*/
  (((U = (q = i[3].flags) == null ? void 0 : q.a5e) == null ? void 0 : U.sheetIsLocked) ?? !0)) && r6(i);
  return {
    c() {
      e = E("li"), t = E("header"), s = E("h3"), n = Q(
        /*abilityLabel*/
        i[1]
      ), l = F(), z && z.c(), r = F(), o = E("div"), a = E("input"), p = F(), m = E("button"), g = E("div"), _ = Q(h), v = F(), k = E("button"), S = E("div"), I = Q(D), b(s, "class", "a5e-ability-score__label"), b(t, "class", "a5e-ability-score__header"), b(a, "class", "a5e-ability-score__value"), b(a, "name", c = "system.abilities." + /*abilityLabel*/
      i[1] + ".value"), b(a, "type", "number"), a.value = f = /*sheetIsLocked*/
      i[4] ? (
        /*ability*/
        i[0].value
      ) : (
        /*sourceValue*/
        i[5]
      ), b(a, "tabindex", d = /*idx*/
      i[2] + 1), b(a, "placeholder", "10"), a.disabled = /*sheetIsLocked*/
      i[4], b(g, "class", "a5e-ability-score__roll-button-value"), b(m, "class", "a5e-ability-score__roll-button a5e-ability-score__roll-button--check"), b(m, "data-tooltip", y = /*sheetIsLocked*/
      i[4] ? "A5E.RollAbilityCheck" : null), b(m, "data-tooltip-direction", "DOWN"), Z(m, "a5e-ability-score__roll-button--no-click", !/*sheetIsLocked*/
      i[4]), b(S, "class", "a5e-ability-score__roll-button-value"), b(k, "class", "a5e-ability-score__roll-button a5e-ability-score__roll-button--save"), b(k, "data-tooltip", M = /*sheetIsLocked*/
      i[4] ? "A5E.RollSavingThrow" : "Toggle Saving Throw Proficiency"), b(k, "data-tooltip-direction", "DOWN"), Z(
        k,
        "a5e-ability-score__roll-button--proficient",
        /*ability*/
        i[0].save.proficient
      ), b(o, "class", "a5e-ability-score__body"), b(e, "class", "a5e-ability-score");
    },
    m(H, V) {
      T(H, e, V), A(e, t), A(t, s), A(s, n), A(t, l), z && z.m(t, null), A(e, r), A(e, o), A(o, a), A(o, p), A(o, m), A(m, g), A(g, _), A(o, v), A(o, k), A(k, S), A(S, I), L || (B = [
        W(
          a,
          "change",
          /*change_handler*/
          i[10]
        ),
        W(
          m,
          "click",
          /*click_handler_1*/
          i[11]
        ),
        W(
          k,
          "click",
          /*click_handler_2*/
          i[12]
        )
      ], L = !0);
    },
    p(H, [V]) {
      var Y, J;
      V & /*abilityLabel*/
      2 && be(
        n,
        /*abilityLabel*/
        H[1]
      ), /*$actor*/
      !H[3].isOwner || /*$actor*/
      (((J = (Y = H[3].flags) == null ? void 0 : Y.a5e) == null ? void 0 : J.sheetIsLocked) ?? !0) ? z && (z.d(1), z = null) : z ? z.p(H, V) : (z = r6(H), z.c(), z.m(t, null)), V & /*abilityLabel*/
      2 && c !== (c = "system.abilities." + /*abilityLabel*/
      H[1] + ".value") && b(a, "name", c), V & /*sheetIsLocked, ability, sourceValue*/
      49 && f !== (f = /*sheetIsLocked*/
      H[4] ? (
        /*ability*/
        H[0].value
      ) : (
        /*sourceValue*/
        H[5]
      )) && a.value !== f && (a.value = f), V & /*idx*/
      4 && d !== (d = /*idx*/
      H[2] + 1) && b(a, "tabindex", d), V & /*sheetIsLocked*/
      16 && (a.disabled = /*sheetIsLocked*/
      H[4]), V & /*ability*/
      1 && h !== (h = nl(
        /*ability*/
        H[0].check.deterministicBonus
      ) + "") && be(_, h), V & /*sheetIsLocked*/
      16 && y !== (y = /*sheetIsLocked*/
      H[4] ? "A5E.RollAbilityCheck" : null) && b(m, "data-tooltip", y), V & /*sheetIsLocked*/
      16 && Z(m, "a5e-ability-score__roll-button--no-click", !/*sheetIsLocked*/
      H[4]), V & /*ability*/
      1 && D !== (D = nl(
        /*ability*/
        H[0].save.deterministicBonus
      ) + "") && be(I, D), V & /*sheetIsLocked*/
      16 && M !== (M = /*sheetIsLocked*/
      H[4] ? "A5E.RollSavingThrow" : "Toggle Saving Throw Proficiency") && b(k, "data-tooltip", M), V & /*ability*/
      1 && Z(
        k,
        "a5e-ability-score__roll-button--proficient",
        /*ability*/
        H[0].save.proficient
      );
    },
    i: se,
    o: se,
    d(H) {
      H && C(e), z && z.d(), L = !1, Me(B);
    }
  };
}
u(qoe, "create_fragment$29");
function Goe(i, e, t) {
  let s, n, l, r;
  pe(i, Ml, (y) => t(13, r = y));
  let { ability: o } = e, { abilityLabel: a } = e, { idx: c } = e;
  function f(y) {
    n && l.rollAbilityCheck(y, ql(r));
  }
  u(f, "handleCheckClick");
  function d(y) {
    var v, k;
    if (n)
      l.rollSavingThrow(y, ql(r));
    else {
      const S = (k = (v = l.system.abilities[y]) == null ? void 0 : v.save) == null ? void 0 : k.proficient;
      l.update({
        [`system.abilities.${y}.save.proficient`]: !S
      });
    }
  }
  u(d, "handleSaveClick");
  const p = de("actor");
  pe(i, p, (y) => t(3, l = y));
  const m = /* @__PURE__ */ u(() => l.configureAbilityScore({ abilityKey: a }), "click_handler"), g = /* @__PURE__ */ u(({ target: y }) => te(l, y.name, Number(y.value)), "change_handler"), h = /* @__PURE__ */ u(() => f(a), "click_handler_1"), _ = /* @__PURE__ */ u(() => d(a), "click_handler_2");
  return i.$$set = (y) => {
    "ability" in y && t(0, o = y.ability), "abilityLabel" in y && t(1, a = y.abilityLabel), "idx" in y && t(2, c = y.idx);
  }, i.$$.update = () => {
    var y, v;
    i.$$.dirty & /*$actor, abilityLabel*/
    10 && t(5, s = l._source.system.abilities[a].value), i.$$.dirty & /*$actor*/
    8 && t(4, n = l.isOwner ? ((v = (y = l.flags) == null ? void 0 : y.a5e) == null ? void 0 : v.sheetIsLocked) ?? !0 : !0);
  }, [
    o,
    a,
    c,
    l,
    n,
    s,
    f,
    d,
    p,
    m,
    g,
    h,
    _
  ];
}
u(Goe, "instance$20");
const OS = class OS extends re {
  constructor(e) {
    super(), oe(this, e, Goe, qoe, le, { ability: 0, abilityLabel: 1, idx: 2 });
  }
};
u(OS, "AbilityScore");
let V0 = OS;
function o6(i, e, t) {
  const s = i.slice();
  return s[2] = e[t][0], s[3] = e[t][1], s[5] = t, s;
}
u(o6, "get_each_context$L");
function a6(i) {
  let e, t;
  return e = new V0({
    props: {
      ability: (
        /*ability*/
        i[3]
      ),
      abilityLabel: (
        /*abilityLabel*/
        i[2]
      ),
      idx: (
        /*idx*/
        i[5]
      )
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      1 && (l.ability = /*ability*/
      s[3]), n & /*$actor*/
      1 && (l.abilityLabel = /*abilityLabel*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(a6, "create_each_block$L");
function zoe(i) {
  let e, t, s = ue(Object.entries(
    /*$actor*/
    i[0].system.abilities
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = a6(o6(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "a5e-ability-scores");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, [o]) {
      if (o & /*Object, $actor*/
      1) {
        s = ue(Object.entries(
          /*$actor*/
          r[0].system.abilities
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = o6(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = a6(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(zoe, "create_fragment$28");
function Hoe(i, e, t) {
  let s;
  const n = de("actor");
  return pe(i, n, (l) => t(0, s = l)), [s, n];
}
u(Hoe, "instance$1$");
const DS = class DS extends re {
  constructor(e) {
    super(), oe(this, e, Hoe, zoe, le, {});
  }
};
u(DS, "AbilityScores");
let W0 = DS;
function Uoe(i) {
  var e;
  if (i.isType("character")) {
    let t = ((e = i.levels) == null ? void 0 : e.character) ?? 1;
    return t < 1 ? t = 1 : t > 19 && (t = 19), CONFIG.A5E.CHARACTER_EXP_LEVELS[t.toString()] ?? 0;
  }
  return 0;
}
u(Uoe, "getRequiredExperiencePoints");
function c6(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v;
  return {
    c() {
      e = E("div"), t = E("label"), s = Q("Current XP"), l = F(), r = E("input"), c = F(), f = E("div"), d = E("label"), p = Q("Required XP"), g = F(), h = E("input"), b(t, "class", "xp-label svelte-1htvyal"), b(t, "for", n = /*$actor*/
      i[0].id + "-current-xp"), b(r, "id", o = /*$actor*/
      i[0].id + "-current-xp"), b(r, "class", "xp-input svelte-1htvyal"), b(r, "type", "number"), b(r, "name", "system.details.xp"), r.value = a = /*$actor*/
      i[0].system.details.xp, b(r, "placeholder", "0"), b(r, "min", "0"), Z(r, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(e, "class", "xp-box svelte-1htvyal"), b(d, "class", "xp-label svelte-1htvyal"), b(d, "for", m = /*$actor*/
      i[0].id + "-required-xp"), b(h, "id", _ = /*$actor*/
      i[0].id + "-required-xp"), b(h, "class", "xp-input svelte-1htvyal"), b(h, "type", "number"), h.value = /*requiredXP*/
      i[2], b(h, "placeholder", "0"), b(h, "min", "0"), h.disabled = !0, b(f, "class", "xp-box svelte-1htvyal");
    },
    m(k, S) {
      T(k, e, S), A(e, t), A(t, s), A(e, l), A(e, r), T(k, c, S), T(k, f, S), A(f, d), A(d, p), A(f, g), A(f, h), y || (v = [
        W(
          r,
          "change",
          /*change_handler_1*/
          i[10]
        ),
        W(r, "click", Koe)
      ], y = !0);
    },
    p(k, S) {
      S & /*$actor*/
      1 && n !== (n = /*$actor*/
      k[0].id + "-current-xp") && b(t, "for", n), S & /*$actor*/
      1 && o !== (o = /*$actor*/
      k[0].id + "-current-xp") && b(r, "id", o), S & /*$actor*/
      1 && a !== (a = /*$actor*/
      k[0].system.details.xp) && r.value !== a && (r.value = a), S & /*$actor*/
      1 && Z(r, "disable-pointer-events", !/*$actor*/
      k[0].isOwner), S & /*$actor*/
      1 && m !== (m = /*$actor*/
      k[0].id + "-required-xp") && b(d, "for", m), S & /*$actor*/
      1 && _ !== (_ = /*$actor*/
      k[0].id + "-required-xp") && b(h, "id", _), S & /*requiredXP*/
      4 && h.value !== /*requiredXP*/
      k[2] && (h.value = /*requiredXP*/
      k[2]);
    },
    d(k) {
      k && (C(e), C(c), C(f)), y = !1, Me(v);
    }
  };
}
u(c6, "create_if_block$18");
function Voe(i) {
  var V, Y;
  let e, t, s, n = K("A5E.Inspiration") + "", l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S, D, I, M, L, B, z, q, U, H = (
    /*$actor*/
    (((Y = (V = i[0].flags) == null ? void 0 : V.a5e) == null ? void 0 : Y.showXP) ?? !0) && c6(i)
  );
  return {
    c() {
      e = E("div"), t = E("div"), s = E("label"), l = Q(n), o = F(), a = E("i"), c = F(), f = E("div"), d = E("label"), p = Q("Level"), g = F(), h = E("input"), y = F(), v = E("div"), k = E("label"), S = Q("Prof."), I = F(), M = E("input"), z = F(), H && H.c(), b(s, "class", "xp-label svelte-1htvyal"), b(s, "for", r = /*$actor*/
      i[0].id + "-inspiration"), b(a, "class", "fas fa-dice-d20 shield-inspiration svelte-1htvyal"), Z(
        a,
        "shield-inspiration--active",
        /*hasInspiration*/
        i[3]
      ), Z(a, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(t, "class", "character-shields__box svelte-1htvyal"), b(d, "class", "xp-label svelte-1htvyal"), b(d, "for", m = /*$actor*/
      i[0].id + "-level"), b(h, "id", _ = /*$actor*/
      i[0].id + "-level"), b(h, "class", "xp-input svelte-1htvyal"), b(
        h,
        "data-tooltip",
        /*levelSource*/
        i[4]
      ), b(h, "data-tooltip-direction", "DOWN"), b(h, "type", "number"), b(h, "name", "system.details.level"), h.value = /*characterLevel*/
      i[5], b(h, "placeholder", "0"), b(h, "min", "0"), h.disabled = /*levelIsLocked*/
      i[1], Z(h, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(f, "class", "character-shields__box svelte-1htvyal"), b(k, "class", "xp-label svelte-1htvyal"), b(k, "for", D = /*$actor*/
      i[0].id + "-prof"), b(M, "id", L = /*$actor*/
      i[0].id + "-prof"), b(M, "class", "xp-input svelte-1htvyal"), b(M, "type", "number"), M.value = B = /*$actor*/
      i[0].system.attributes.prof, b(M, "placeholder", "0"), b(M, "min", "0"), M.disabled = !0, b(v, "class", "character-shields__box svelte-1htvyal"), b(e, "class", "character-shields__container svelte-1htvyal");
    },
    m(J, fe) {
      T(J, e, fe), A(e, t), A(t, s), A(s, l), A(t, o), A(t, a), A(e, c), A(e, f), A(f, d), A(d, p), A(f, g), A(f, h), A(e, y), A(e, v), A(v, k), A(k, S), A(v, I), A(v, M), A(e, z), H && H.m(e, null), q || (U = [
        W(
          a,
          "click",
          /*click_handler*/
          i[8]
        ),
        W(
          h,
          "change",
          /*change_handler*/
          i[9]
        ),
        W(h, "click", Woe)
      ], q = !0);
    },
    p(J, [fe]) {
      var ke, ee;
      fe & /*$actor*/
      1 && r !== (r = /*$actor*/
      J[0].id + "-inspiration") && b(s, "for", r), fe & /*hasInspiration*/
      8 && Z(
        a,
        "shield-inspiration--active",
        /*hasInspiration*/
        J[3]
      ), fe & /*$actor*/
      1 && Z(a, "disable-pointer-events", !/*$actor*/
      J[0].isOwner), fe & /*$actor*/
      1 && m !== (m = /*$actor*/
      J[0].id + "-level") && b(d, "for", m), fe & /*$actor*/
      1 && _ !== (_ = /*$actor*/
      J[0].id + "-level") && b(h, "id", _), fe & /*levelSource*/
      16 && b(
        h,
        "data-tooltip",
        /*levelSource*/
        J[4]
      ), fe & /*characterLevel*/
      32 && h.value !== /*characterLevel*/
      J[5] && (h.value = /*characterLevel*/
      J[5]), fe & /*levelIsLocked*/
      2 && (h.disabled = /*levelIsLocked*/
      J[1]), fe & /*$actor*/
      1 && Z(h, "disable-pointer-events", !/*$actor*/
      J[0].isOwner), fe & /*$actor*/
      1 && D !== (D = /*$actor*/
      J[0].id + "-prof") && b(k, "for", D), fe & /*$actor*/
      1 && L !== (L = /*$actor*/
      J[0].id + "-prof") && b(M, "id", L), fe & /*$actor*/
      1 && B !== (B = /*$actor*/
      J[0].system.attributes.prof) && M.value !== B && (M.value = B), /*$actor*/
      ((ee = (ke = J[0].flags) == null ? void 0 : ke.a5e) == null ? void 0 : ee.showXP) ?? !0 ? H ? H.p(J, fe) : (H = c6(J), H.c(), H.m(e, null)) : H && (H.d(1), H = null);
    },
    i: se,
    o: se,
    d(J) {
      J && C(e), H && H.d(), q = !1, Me(U);
    }
  };
}
u(Voe, "create_fragment$27");
const Woe = /* @__PURE__ */ u(({ target: i }) => i.select(), "click_handler_1$1"), Koe = /* @__PURE__ */ u(({ target: i }) => i.select(), "click_handler_2");
function Yoe(i, e, t) {
  let s, n, l, r, o, a, c;
  const f = de("actor");
  pe(i, f, (y) => t(0, c = y));
  function d() {
    return !!(o || Object.keys(c.classes ?? {}).length);
  }
  u(d, "isLevelLocked");
  function p() {
    return Object.keys(c.classes ?? {}).length ? c.levels.character : c.system.details.level;
  }
  u(p, "getCharacterLevel");
  function m() {
    return Object.keys(c.classes ?? {}).length ? Object.values(c.classes ?? {}).map(
      (v) => `${v.name} (${v.classLevels})`,
      []
    ).join(" / ") : "";
  }
  u(m, "getLevelSource");
  const g = /* @__PURE__ */ u(() => c.toggleInspiration(), "click_handler"), h = /* @__PURE__ */ u(({ target: y }) => te(c, y.name, Number(y.value)), "change_handler"), _ = /* @__PURE__ */ u(({ target: y }) => te(c, y.name, Number(y.value)), "change_handler_1");
  return i.$$.update = () => {
    var y;
    i.$$.dirty & /*$actor*/
    1 && t(5, s = p()), i.$$.dirty & /*$actor*/
    1 && t(4, n = m()), i.$$.dirty & /*$actor*/
    1 && t(3, l = c.system.attributes.inspiration), i.$$.dirty & /*$actor*/
    1 && t(2, r = Uoe(c)), i.$$.dirty & /*$actor*/
    1 && t(7, o = ((y = c.flags.a5e) == null ? void 0 : y.sheetIsLocked) ?? !0), i.$$.dirty & /*$actor, sheetIsLocked*/
    129 && t(1, a = d());
  }, [
    c,
    a,
    r,
    l,
    n,
    s,
    f,
    o,
    g,
    h,
    _
  ];
}
u(Yoe, "instance$1_");
const IS = class IS extends re {
  constructor(e) {
    super(), oe(this, e, Yoe, Voe, le, {});
  }
};
u(IS, "CharacterShields");
let K0 = IS;
function FB(i) {
  var n, l, r, o;
  const e = parseFloat(((l = (n = i == null ? void 0 : i.system) == null ? void 0 : n.details) == null ? void 0 : l.cr) || 0);
  let t = 0;
  return e === 0.125 ? t = CONFIG.A5E.CR_EXP_LEVELS["1/8"] : e === 0.25 ? t = CONFIG.A5E.CR_EXP_LEVELS["1/4"] : e === 0.5 ? t = CONFIG.A5E.CR_EXP_LEVELS["1/2"] : t = CONFIG.A5E.CR_EXP_LEVELS[parseInt(e, 10) > 30 ? 30 : e], ((o = (r = i == null ? void 0 : i.system) == null ? void 0 : r.details) != null && o.elite ? t * 2 : t).toLocaleString();
}
u(FB, "prepareXP");
function u6(i) {
  let e, t, s, n, l, r, o, a;
  return {
    c() {
      e = E("div"), t = E("label"), s = Q("Elite"), l = F(), r = E("i"), b(t, "class", "xp-label svelte-wfohy5"), b(t, "for", n = /*$actor*/
      i[0].id + "-elite"), b(r, "class", "fas fa-skull shield-elite svelte-wfohy5"), Z(r, "shield-elite--unlocked", !/*sheetIsLocked*/
      i[1]), Z(
        r,
        "shield-elite--active",
        /*isElite*/
        i[2]
      ), b(e, "class", "level-box svelte-wfohy5");
    },
    m(c, f) {
      T(c, e, f), A(e, t), A(t, s), A(e, l), A(e, r), o || (a = W(
        r,
        "click",
        /*click_handler*/
        i[7]
      ), o = !0);
    },
    p(c, f) {
      f & /*$actor*/
      1 && n !== (n = /*$actor*/
      c[0].id + "-elite") && b(t, "for", n), f & /*sheetIsLocked*/
      2 && Z(r, "shield-elite--unlocked", !/*sheetIsLocked*/
      c[1]), f & /*isElite*/
      4 && Z(
        r,
        "shield-elite--active",
        /*isElite*/
        c[2]
      );
    },
    d(c) {
      c && C(e), o = !1, a();
    }
  };
}
u(u6, "create_if_block$17");
function Xoe(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S, D, I, M, L, B, z, q, U, H = (
    /*isElite*/
    (i[2] || !/*sheetIsLocked*/
    i[1]) && u6(i)
  );
  return {
    c() {
      e = E("div"), H && H.c(), t = F(), s = E("div"), n = E("label"), l = Q("CR"), o = F(), a = E("input"), f = F(), d = E("div"), p = E("label"), m = Q("XP"), h = F(), _ = E("span"), y = Q(
        /*xp*/
        i[3]
      ), v = F(), k = E("div"), S = E("label"), D = Q("Prof."), M = F(), L = E("input"), b(n, "class", "xp-label svelte-wfohy5"), b(n, "for", r = /*$actor*/
      i[0].id + "-cr"), b(a, "id", c = /*$actor*/
      i[0].id + "-cr"), b(a, "class", "xp-input svelte-wfohy5"), b(a, "type", "text"), b(a, "name", "system.details.cr"), a.value = /*cr*/
      i[4], b(a, "placeholder", "0"), b(a, "min", "0"), a.disabled = /*sheetIsLocked*/
      i[1], b(s, "class", "level-box svelte-wfohy5"), b(p, "class", "xp-label svelte-wfohy5"), b(p, "for", g = /*$actor*/
      i[0].id + "-xp"), b(_, "class", "xp-input svelte-wfohy5"), b(
        _,
        "value",
        /*xp*/
        i[3]
      ), b(d, "class", "level-box svelte-wfohy5"), b(S, "class", "xp-label svelte-wfohy5"), b(S, "for", I = /*$actor*/
      i[0].id + "-prof"), b(L, "id", B = /*$actor*/
      i[0].id + "-prof"), b(L, "class", "xp-input svelte-wfohy5"), b(L, "type", "number"), L.value = z = /*$actor*/
      i[0].system.attributes.prof, b(L, "placeholder", "0"), b(L, "min", "0"), L.disabled = !0, b(k, "class", "level-box svelte-wfohy5"), b(e, "class", "level-container svelte-wfohy5");
    },
    m(V, Y) {
      T(V, e, Y), H && H.m(e, null), A(e, t), A(e, s), A(s, n), A(n, l), A(s, o), A(s, a), A(e, f), A(e, d), A(d, p), A(p, m), A(d, h), A(d, _), A(_, y), A(e, v), A(e, k), A(k, S), A(S, D), A(k, M), A(k, L), q || (U = [
        W(
          a,
          "change",
          /*change_handler*/
          i[8]
        ),
        W(
          a,
          "click",
          /*click_handler_1*/
          i[9]
        )
      ], q = !0);
    },
    p(V, [Y]) {
      /*isElite*/
      V[2] || !/*sheetIsLocked*/
      V[1] ? H ? H.p(V, Y) : (H = u6(V), H.c(), H.m(e, t)) : H && (H.d(1), H = null), Y & /*$actor*/
      1 && r !== (r = /*$actor*/
      V[0].id + "-cr") && b(n, "for", r), Y & /*$actor*/
      1 && c !== (c = /*$actor*/
      V[0].id + "-cr") && b(a, "id", c), Y & /*cr*/
      16 && a.value !== /*cr*/
      V[4] && (a.value = /*cr*/
      V[4]), Y & /*sheetIsLocked*/
      2 && (a.disabled = /*sheetIsLocked*/
      V[1]), Y & /*$actor*/
      1 && g !== (g = /*$actor*/
      V[0].id + "-xp") && b(p, "for", g), Y & /*xp*/
      8 && be(
        y,
        /*xp*/
        V[3]
      ), Y & /*xp*/
      8 && b(
        _,
        "value",
        /*xp*/
        V[3]
      ), Y & /*$actor*/
      1 && I !== (I = /*$actor*/
      V[0].id + "-prof") && b(S, "for", I), Y & /*$actor*/
      1 && B !== (B = /*$actor*/
      V[0].id + "-prof") && b(L, "id", B), Y & /*$actor*/
      1 && z !== (z = /*$actor*/
      V[0].system.attributes.prof) && L.value !== z && (L.value = z);
    },
    i: se,
    o: se,
    d(V) {
      V && C(e), H && H.d(), q = !1, Me(U);
    }
  };
}
u(Xoe, "create_fragment$26");
function Joe(i, e, t) {
  let s, n, l, r, o;
  const a = de("actor");
  pe(i, a, (g) => t(0, o = g));
  function c(g) {
    const { value: h } = g;
    let _;
    h === "1/2" ? _ = 0.5 : h === "1/4" ? _ = 0.25 : h === "1/8" ? _ = 0.125 : _ = parseInt(h, 10), isNaN(_) && (_ = o.system.details.cr), te(o, g.name, _);
  }
  u(c, "updateCr");
  function f(g) {
    return g === 0.5 ? "1/2" : g === 0.25 ? "1/4" : g === 0.125 ? "1/8" : g;
  }
  u(f, "displayCr");
  const d = /* @__PURE__ */ u(() => r ? null : o.toggleElite(), "click_handler"), p = /* @__PURE__ */ u(({ target: g }) => c(g), "change_handler"), m = /* @__PURE__ */ u(({ target: g }) => !r && g.select(), "click_handler_1");
  return i.$$.update = () => {
    var g;
    i.$$.dirty & /*$actor*/
    1 && t(4, s = f(o.system.details.cr)), i.$$.dirty & /*$actor*/
    1 && t(3, n = FB(o)), i.$$.dirty & /*$actor*/
    1 && t(2, l = o.system.details.elite), i.$$.dirty & /*$actor*/
    1 && t(1, r = ((g = o.flags.a5e) == null ? void 0 : g.sheetIsLocked) ?? !0);
  }, [
    o,
    r,
    l,
    n,
    s,
    a,
    c,
    d,
    p,
    m
  ];
}
u(Joe, "instance$1Z");
const PS = class PS extends re {
  constructor(e) {
    super(), oe(this, e, Joe, Xoe, le, {});
  }
};
u(PS, "NpcShields");
let Y0 = PS;
function Zoe(i) {
  let e, t, s;
  return t = new Y0({}), {
    c() {
      e = E("section"), j(t.$$.fragment);
    },
    m(n, l) {
      T(n, e, l), R(t, e, null), s = !0;
    },
    i(n) {
      s || (w(t.$$.fragment, n), s = !0);
    },
    o(n) {
      O(t.$$.fragment, n), s = !1;
    },
    d(n) {
      n && C(e), N(t);
    }
  };
}
u(Zoe, "create_else_block$p");
function Qoe(i) {
  let e, t, s;
  return t = new K0({}), {
    c() {
      e = E("section"), j(t.$$.fragment);
    },
    m(n, l) {
      T(n, e, l), R(t, e, null), s = !0;
    },
    i(n) {
      s || (w(t.$$.fragment, n), s = !0);
    },
    o(n) {
      O(t.$$.fragment, n), s = !1;
    },
    d(n) {
      n && C(e), N(t);
    }
  };
}
u(Qoe, "create_if_block$16");
function xoe(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m;
  const g = [Qoe, Zoe], h = [];
  function _(y, v) {
    return (
      /*$actor*/
      y[0].type === "character" ? 0 : 1
    );
  }
  return u(_, "select_block_type"), o = _(i), a = h[o] = g[o](i), f = new W0({}), {
    c() {
      e = E("header"), t = E("section"), s = E("section"), n = E("input"), r = F(), a.c(), c = F(), j(f.$$.fragment), b(n, "type", "text"), b(n, "name", "name"), n.value = l = /*$actor*/
      i[0].name, b(n, "class", "a5e-input a5e-input--character-name svelte-b6ggbk"), b(n, "placeholder", "Name"), b(n, "spellcheck", "false"), Z(n, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(s, "class", "sheet-header-top-left svelte-b6ggbk"), b(t, "class", "sheet-header-top svelte-b6ggbk"), b(e, "class", "sheet-header svelte-b6ggbk");
    },
    m(y, v) {
      T(y, e, v), A(e, t), A(t, s), A(s, n), A(t, r), h[o].m(t, null), A(e, c), R(f, e, null), d = !0, p || (m = W(
        n,
        "change",
        /*change_handler*/
        i[2]
      ), p = !0);
    },
    p(y, [v]) {
      (!d || v & /*$actor*/
      1 && l !== (l = /*$actor*/
      y[0].name) && n.value !== l) && (n.value = l), (!d || v & /*$actor*/
      1) && Z(n, "disable-pointer-events", !/*$actor*/
      y[0].isOwner);
      let k = o;
      o = _(y), o !== k && (ae(), O(h[k], 1, 1, () => {
        h[k] = null;
      }), ce(), a = h[o], a || (a = h[o] = g[o](y), a.c()), w(a, 1), a.m(t, null));
    },
    i(y) {
      d || (w(a), w(f.$$.fragment, y), d = !0);
    },
    o(y) {
      O(a), O(f.$$.fragment, y), d = !1;
    },
    d(y) {
      y && C(e), h[o].d(), N(f), p = !1, m();
    }
  };
}
u(xoe, "create_fragment$25");
function eae(i, e, t) {
  let s;
  const n = de("actor");
  return pe(i, n, (r) => t(0, s = r)), [s, n, /* @__PURE__ */ u(({ target: r }) => te(s, r.name, r.value), "change_handler")];
}
u(eae, "instance$1Y");
const MS = class MS extends re {
  constructor(e) {
    super(), oe(this, e, eae, xoe, le, {});
  }
};
u(MS, "ActorSheetHeader");
let X0 = MS;
function f6(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "fas fa-cog ac__config-button svelte-12z7c31"), b(e, "data-tooltip", "A5E.ArmorClassConfigurationTitle"), b(e, "data-tooltip-direction", "DOWN");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler*/
        i[4]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(f6, "create_if_block$15");
function tae(i) {
  let e, t, s, n, l, r, o, a, c, f = !/*sheetIsLocked*/
  i[2] && f6(i);
  return {
    c() {
      e = E("li"), t = E("h4"), t.textContent = "AC", s = F(), n = E("input"), r = F(), o = fi("svg"), a = fi("path"), c = F(), f && f.c(), b(t, "class", "ac-label svelte-12z7c31"), b(n, "class", "ac-value svelte-12z7c31"), b(n, "name", "system.attributes.ac.value"), b(n, "type", "number"), n.value = l = /*$actor*/
      i[0].system.attributes.ac.value, b(n, "placeholder", "10"), n.disabled = !0, b(
        n,
        "data-tooltip",
        /*acFormula*/
        i[1]
      ), b(n, "data-tooltip-direction", "UP"), b(a, "d", `M45,100C-2.6,79.3,0,12.6,0,12.6c0-2.2,1.8-4,4.4-4.6l39.1-7.9C44,0,44.5,0,45,0c0.5,0,1,0,1.4,0.1L85.5,8
                c2.6,0.5,4.4,2.4,4.4,4.6C90,12.6,92.6,79.3,45,100L45,100z`), b(o, "class", "ac-background svelte-12z7c31"), b(o, "version", "1.1"), b(o, "x", "0px"), b(o, "y", "0px"), b(o, "viewBox", "0 0 90 100"), b(o, "xml:space", "preserve"), b(e, "class", "ac-wrapper svelte-12z7c31");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), A(o, a), A(e, c), f && f.m(e, null);
    },
    p(d, [p]) {
      p & /*$actor*/
      1 && l !== (l = /*$actor*/
      d[0].system.attributes.ac.value) && n.value !== l && (n.value = l), p & /*acFormula*/
      2 && b(
        n,
        "data-tooltip",
        /*acFormula*/
        d[1]
      ), /*sheetIsLocked*/
      d[2] ? f && (f.d(1), f = null) : f ? f.p(d, p) : (f = f6(d), f.c(), f.m(e, null));
    },
    i: se,
    o: se,
    d(d) {
      d && C(e), f && f.d();
    }
  };
}
u(tae, "create_fragment$24");
function sae(i, e, t) {
  let s, n, l;
  const r = de("actor");
  pe(i, r, (a) => t(0, l = a));
  const o = /* @__PURE__ */ u(() => l.configureArmorClass(), "click_handler");
  return i.$$.update = () => {
    var a, c;
    i.$$.dirty & /*$actor*/
    1 && t(2, s = l.isOwner ? ((c = (a = l.flags) == null ? void 0 : a.a5e) == null ? void 0 : c.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*$actor*/
    1 && t(1, n = S9(l));
  }, [l, n, s, r, o];
}
u(sae, "instance$1X");
const FS = class FS extends re {
  constructor(e) {
    super(), oe(this, e, sae, tae, le, {});
  }
};
u(FS, "ArmorClass");
let J0 = FS;
function nae(i) {
  return Object.values(i.system.attributes.hitDice).reduce(
    // @ts-ignore
    (e, { current: t }) => e + t,
    0
  );
}
u(nae, "computeTotalAvailableHitDice");
function iae(i) {
  let e, t, s, n, l, r, o, a, c;
  return {
    c() {
      e = E("li"), t = E("h4"), t.textContent = "Hit Dice", s = F(), n = E("div"), l = Q(
        /*availableHitDice*/
        i[0]
      ), r = F(), o = fi("svg"), a = fi("g"), c = fi("path"), b(t, "class", "hit-die-label svelte-1fta331"), b(n, "class", "hit-dice svelte-1fta331"), b(n, "data-tooltip", "A5E.HitDiceRemaining"), b(n, "data-tooltip-direction", "DOWN"), b(c, "d", "M3250 11884 c-25 -2 -106 -11 -180 -20 -1485 -172 -2704 -1295 -3001 -2764 -133 -660 -67 -1507 171 -2223 252 -753 675 -1411 1397 -2172 342 -360 634 -630 1588 -1470 231 -203 488 -430 570 -505 1024 -920 1735 -1692 2346 -2547 l130 -183 132 0 132 1 130 192 c557 822 1212 1560 2185 2461 191 178 408 373 1027 923 956 852 1445 1343 1841 1850 643 825 968 1603 1064 2553 19 196 17 665 -5 835 -105 805 -441 1497 -998 2054 -557 557 -1250 894 -2054 998 -193 24 -613 24 -810 0 -733 -93 -1379 -387 -1920 -874 -191 -172 -406 -417 -535 -610 -30 -45 -57 -82 -60 -82 -3 0 -30 37 -60 82 -129 193 -344 438 -535 610 -531 478 -1170 773 -1878 867 -146 20 -562 34 -677 24z"), b(a, "transform", "translate(0.000000,1189.000000) scale(0.100000,-0.100000)"), b(a, "fill", "rgba(0, 0, 0, 0.15)"), b(a, "stroke", "none"), b(o, "class", "hit-dice-background svelte-1fta331"), b(o, "xmlns", "http://www.w3.org/2000/svg"), b(o, "version", "1.0"), b(o, "viewBox", "0 0 1280.000000 1189.000000"), b(o, "preserveAspectRatio", "xMidYMid meet"), b(e, "class", "hit-dice-wrapper svelte-1fta331");
    },
    m(f, d) {
      T(f, e, d), A(e, t), A(e, s), A(e, n), A(n, l), A(e, r), A(e, o), A(o, a), A(a, c);
    },
    p(f, [d]) {
      d & /*availableHitDice*/
      1 && be(
        l,
        /*availableHitDice*/
        f[0]
      );
    },
    i: se,
    o: se,
    d(f) {
      f && C(e);
    }
  };
}
u(iae, "create_fragment$23");
function lae(i, e, t) {
  let s, n;
  const l = de("actor");
  return pe(i, l, (r) => t(2, n = r)), i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    4 && t(0, s = nae(n));
  }, [s, l, n];
}
u(lae, "instance$1W");
const RS = class RS extends re {
  constructor(e) {
    super(), oe(this, e, lae, iae, le, {});
  }
};
u(RS, "HitDice");
let Z0 = RS;
function rae(i) {
  let e, t;
  const s = (
    /*#slots*/
    i[4].default
  ), n = Gt(
    s,
    i,
    /*$$scope*/
    i[3],
    null
  );
  return {
    c() {
      e = E("div"), n && n.c(), b(e, "class", "hp-bar svelte-ju94cw"), G(
        e,
        "--primary-hp-percentage",
        /*hpPrimaryPercentage*/
        i[1]
      ), G(
        e,
        "--temp-hp-percentage",
        /*hpTempPercentage*/
        i[0]
      ), G(e, "--secondary-bar-color", "#2FA6B1");
    },
    m(l, r) {
      T(l, e, r), n && n.m(e, null), t = !0;
    },
    p(l, [r]) {
      n && n.p && (!t || r & /*$$scope*/
      8) && Ht(
        n,
        s,
        l,
        /*$$scope*/
        l[3],
        t ? zt(
          s,
          /*$$scope*/
          l[3],
          r,
          null
        ) : Ut(
          /*$$scope*/
          l[3]
        ),
        null
      ), (!t || r & /*hpPrimaryPercentage*/
      2) && G(
        e,
        "--primary-hp-percentage",
        /*hpPrimaryPercentage*/
        l[1]
      ), (!t || r & /*hpTempPercentage*/
      1) && G(
        e,
        "--temp-hp-percentage",
        /*hpTempPercentage*/
        l[0]
      );
    },
    i(l) {
      t || (w(n, l), t = !0);
    },
    o(l) {
      O(n, l), t = !1;
    },
    d(l) {
      l && C(e), n && n.d(l);
    }
  };
}
u(rae, "create_fragment$22");
function oae(i, e, t) {
  let s, n, { $$slots: l = {}, $$scope: r } = e, { hp: o } = e;
  return i.$$set = (a) => {
    "hp" in a && t(2, o = a.hp), "$$scope" in a && t(3, r = a.$$scope);
  }, i.$$.update = () => {
    i.$$.dirty & /*hp*/
    4 && t(1, s = Math.floor(Math.min(o.value / o.max * 100, 100))), i.$$.dirty & /*hp*/
    4 && t(0, n = Math.min((o.temp || 0) / o.max * 100, 100));
  }, [n, s, o, r, l];
}
u(oae, "instance$1V");
const NS = class NS extends re {
  constructor(e) {
    super(), oe(this, e, oae, rae, le, { hp: 2 });
  }
};
u(NS, "HitPointBar");
let Q0 = NS;
function d6(i, e, t) {
  const s = i.slice();
  return s[7] = e[t].key, s[8] = e[t].label, s[9] = e[t].value, s;
}
u(d6, "get_each_context$K");
function aae(i) {
  let e, t, s, n, l = K("A5E.HitPointsConfigurationTooltip") + "", r, o, a;
  return {
    c() {
      e = E("div"), t = E("button"), s = E("i"), n = F(), r = Q(l), b(s, "class", "fas fa-gear"), b(t, "class", "a5e-button svelte-unidym"), b(e, "class", "hp-config__container svelte-unidym");
    },
    m(c, f) {
      T(c, e, f), A(e, t), A(t, s), A(t, n), A(t, r), o || (a = W(
        t,
        "click",
        /*click_handler_1*/
        i[6]
      ), o = !0);
    },
    p: se,
    d(c) {
      c && C(e), o = !1, a();
    }
  };
}
u(aae, "create_else_block$o");
function cae(i) {
  let e, t = ue(
    /*hpFields*/
    i[0]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = p6(d6(i, t, n));
  return {
    c() {
      e = E("div");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "hp-container svelte-unidym");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*$actor, hpFields, Number*/
      3) {
        t = ue(
          /*hpFields*/
          n[0]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = d6(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = p6(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(cae, "create_if_block$14");
function p6(i) {
  let e, t, s = (
    /*label*/
    i[8] + ""
  ), n, l, r, o, a, c, f, d, p, m, g, h;
  return {
    c() {
      e = E("div"), t = E("label"), n = Q(s), r = F(), o = E("input"), m = F(), b(t, "class", "hp-label svelte-unidym"), b(t, "for", l = /*$actor*/
      i[1].id + "-hp-" + /*key*/
      i[7]), b(o, "id", a = /*$actor*/
      i[1].id + "-hp-" + /*key*/
      i[7]), b(o, "class", "hp-input svelte-unidym"), b(o, "type", "number"), b(o, "name", c = "system.attributes.hp." + /*key*/
      i[7]), o.value = f = /*value*/
      i[9], b(o, "placeholder", "0"), b(o, "min", d = /*key*/
      i[7] !== "bonus" ? 0 : ""), o.disabled = p = /*key*/
      i[7] === "max", Z(o, "disable-pointer-events", !/*$actor*/
      i[1].isOwner), b(e, "class", "hp-box svelte-unidym");
    },
    m(_, y) {
      T(_, e, y), A(e, t), A(t, n), A(e, r), A(e, o), A(e, m), g || (h = [
        W(
          o,
          "change",
          /*change_handler*/
          i[5]
        ),
        W(o, "click", fae)
      ], g = !0);
    },
    p(_, y) {
      y & /*hpFields*/
      1 && s !== (s = /*label*/
      _[8] + "") && be(n, s), y & /*$actor, hpFields*/
      3 && l !== (l = /*$actor*/
      _[1].id + "-hp-" + /*key*/
      _[7]) && b(t, "for", l), y & /*$actor, hpFields*/
      3 && a !== (a = /*$actor*/
      _[1].id + "-hp-" + /*key*/
      _[7]) && b(o, "id", a), y & /*hpFields*/
      1 && c !== (c = "system.attributes.hp." + /*key*/
      _[7]) && b(o, "name", c), y & /*hpFields*/
      1 && f !== (f = /*value*/
      _[9]) && o.value !== f && (o.value = f), y & /*hpFields*/
      1 && d !== (d = /*key*/
      _[7] !== "bonus" ? 0 : "") && b(o, "min", d), y & /*hpFields*/
      1 && p !== (p = /*key*/
      _[7] === "max") && (o.disabled = p), y & /*$actor*/
      2 && Z(o, "disable-pointer-events", !/*$actor*/
      _[1].isOwner);
    },
    d(_) {
      _ && C(e), g = !1, Me(h);
    }
  };
}
u(p6, "create_each_block$K");
function uae(i) {
  let e;
  function t(l, r) {
    return (
      /*sheetIsLocked*/
      l[2] ? cae : aae
    );
  }
  u(t, "select_block_type");
  let s = t(i), n = s(i);
  return {
    c() {
      n.c(), e = $e();
    },
    m(l, r) {
      n.m(l, r), T(l, e, r);
    },
    p(l, [r]) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e.parentNode, e)));
    },
    i: se,
    o: se,
    d(l) {
      l && C(e), n.d(l);
    }
  };
}
u(uae, "create_fragment$21");
const fae = /* @__PURE__ */ u(({ target: i }) => i.select(), "click_handler");
function dae(i, e, t) {
  let s, n, { hp: l } = e, { hpFields: r } = e;
  const o = de("actor");
  pe(i, o, (f) => t(1, n = f));
  const a = /* @__PURE__ */ u(({ target: f }) => te(n, f.name, Number(f.value)), "change_handler"), c = /* @__PURE__ */ u(() => n.configureHealth(), "click_handler_1");
  return i.$$set = (f) => {
    "hp" in f && t(4, l = f.hp), "hpFields" in f && t(0, r = f.hpFields);
  }, i.$$.update = () => {
    var f, d;
    i.$$.dirty & /*hp*/
    16 && t(0, r = [
      {
        key: "temp",
        label: "Temp. HP",
        value: l.temp
      },
      {
        key: "value",
        label: "Curr. HP",
        value: l.value
      },
      {
        key: "max",
        label: "Max HP",
        value: l.max
      },
      {
        key: "bonus",
        label: "Bonus HP",
        value: l.bonus
      }
    ]), i.$$.dirty & /*$actor*/
    2 && t(2, s = n.isOwner ? ((d = (f = n.flags) == null ? void 0 : f.a5e) == null ? void 0 : d.sheetIsLocked) ?? !0 : !0);
  }, [r, n, s, o, l, a, c];
}
u(dae, "instance$1U");
const jS = class jS extends re {
  constructor(e) {
    super(), oe(this, e, dae, uae, le, { hp: 4, hpFields: 0 });
  }
};
u(jS, "HitPointValues");
let x0 = jS;
function pae(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "initiative-roll-button fas fa-cog svelte-16kjhsb"), b(e, "data-tooltip", "A5E.InitiativeConfigurationTitle"), b(e, "data-tooltip-direction", "DOWN");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler_1*/
        i[6]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(pae, "create_else_block$n");
function mae(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "initiative-roll-button fas fa-dice-d20 svelte-16kjhsb"), b(e, "data-tooltip", "A5E.RollInitiative"), b(e, "data-tooltip-direction", "DOWN"), Z(
        e,
        "initiative-roll-button--shift",
        /*$pressedKeysStore*/
        i[2].Shift
      ), Z(
        e,
        "initiative-roll-button--ctrl",
        /*$pressedKeysStore*/
        i[2].Control
      ), Z(e, "disable-pointer-events", !/*$actor*/
      i[0].isOwner);
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler*/
        i[5]
      ), t = !0);
    },
    p(n, l) {
      l & /*$pressedKeysStore*/
      4 && Z(
        e,
        "initiative-roll-button--shift",
        /*$pressedKeysStore*/
        n[2].Shift
      ), l & /*$pressedKeysStore*/
      4 && Z(
        e,
        "initiative-roll-button--ctrl",
        /*$pressedKeysStore*/
        n[2].Control
      ), l & /*$actor*/
      1 && Z(e, "disable-pointer-events", !/*$actor*/
      n[0].isOwner);
    },
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(mae, "create_if_block$13");
function hae(i) {
  let e, t, s;
  function n(o, a) {
    return (
      /*sheetIsLocked*/
      o[1] ? mae : pae
    );
  }
  u(n, "select_block_type");
  let l = n(i), r = l(i);
  return {
    c() {
      e = E("li"), t = E("h4"), t.textContent = "Initiative", s = F(), r.c(), b(t, "class", "initiative-label svelte-16kjhsb");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), r.m(e, null);
    },
    p(o, [a]) {
      l === (l = n(o)) && r ? r.p(o, a) : (r.d(1), r = l(o), r && (r.c(), r.m(e, null)));
    },
    i: se,
    o: se,
    d(o) {
      o && C(e), r.d();
    }
  };
}
u(hae, "create_fragment$20");
function gae(i, e, t) {
  let s, n, l;
  pe(i, Ml, (p) => t(2, l = p));
  const r = de("actor");
  pe(i, r, (p) => t(0, n = p));
  const { settings: o } = game;
  function a() {
    const p = ql(l, {
      reverseAlt: o.get("a5e", "reverseInitiativeAltBehavior")
    });
    return console.log(p), p.expertiseDie = n.RollOverrideManager.getExpertiseDice("initiative", p.expertiseDie ?? 0, { ability: c }), p.rollMode = n.RollOverrideManager.getRollOverride("initiative", p.rollMode, { ability: c }), p;
  }
  u(a, "getRollOptions");
  let c = n.system.attributes.initiative.ability ?? "dex";
  const f = /* @__PURE__ */ u(() => n.rollInitiative({
    createCombatants: !0,
    initiativeOptions: { rollOptions: a() }
  }), "click_handler"), d = /* @__PURE__ */ u(() => n.configureInitiative(), "click_handler_1");
  return i.$$.update = () => {
    var p, m;
    i.$$.dirty & /*$actor*/
    1 && t(1, s = n.isOwner ? ((m = (p = n.flags) == null ? void 0 : p.a5e) == null ? void 0 : m.sheetIsLocked) ?? !0 : !0);
  }, [
    n,
    s,
    l,
    r,
    a,
    f,
    d
  ];
}
u(gae, "instance$1T");
const LS = class LS extends re {
  constructor(e) {
    super(), oe(this, e, gae, hae, le, {});
  }
};
u(LS, "Initiative");
let ev = LS;
function m6(i, e, t) {
  const s = i.slice();
  return s[3] = e[t].label, s[4] = e[t].value, s[5] = e[t].tooltip, s;
}
u(m6, "get_each_context$J");
function h6(i) {
  let e, t, s = K(
    /*label*/
    i[3]
  ) + "", n, l, r, o = (
    /*value*/
    i[4] + ""
  ), a, c, f;
  return {
    c() {
      e = E("div"), t = E("h4"), n = Q(s), l = F(), r = E("div"), a = Q(o), f = F(), b(t, "class", "passive-label svelte-acg54j"), b(r, "class", "passive-value svelte-acg54j"), b(r, "data-tooltip", c = /*tooltip*/
      i[5] ?? ""), b(r, "data-tooltip-direction", "UP"), b(e, "class", "passive-box svelte-acg54j");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, n), A(e, l), A(e, r), A(r, a), A(e, f);
    },
    p(d, p) {
      p & /*passiveFields*/
      1 && s !== (s = K(
        /*label*/
        d[3]
      ) + "") && be(n, s), p & /*passiveFields*/
      1 && o !== (o = /*value*/
      d[4] + "") && be(a, o), p & /*passiveFields*/
      1 && c !== (c = /*tooltip*/
      d[5] ?? "") && b(r, "data-tooltip", c);
    },
    d(d) {
      d && C(e);
    }
  };
}
u(h6, "create_each_block$J");
function bae(i) {
  let e, t = ue(
    /*passiveFields*/
    i[0]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = h6(m6(i, t, n));
  return {
    c() {
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      e = $e();
    },
    m(n, l) {
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(n, l);
      T(n, e, l);
    },
    p(n, [l]) {
      if (l & /*passiveFields*/
      1) {
        t = ue(
          /*passiveFields*/
          n[0]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = m6(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = h6(o), s[r].c(), s[r].m(e.parentNode, e));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    i: se,
    o: se,
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(bae, "create_fragment$1$");
function _ae(i, e, t) {
  let s, { passiveFields: n } = e;
  const l = de("actor");
  return pe(i, l, (r) => t(2, s = r)), i.$$set = (r) => {
    "passiveFields" in r && t(0, n = r.passiveFields);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    4 && t(0, n = [
      {
        label: "A5E.ManeuverDC",
        value: s.system.attributes.maneuverDC
      },
      {
        label: "A5E.SpellDC",
        value: s.system.attributes.spellDC,
        tooltip: s.spellBooks.getSpellDCString(!0)
      },
      {
        label: "Passive Percep.",
        value: s.system.skills.prc.passive
      }
    ]);
  }, [n, l, s];
}
u(_ae, "instance$1S");
const BS = class BS extends re {
  constructor(e) {
    super(), oe(this, e, _ae, bae, le, { passiveFields: 0 });
  }
};
u(BS, "Passives");
let tv = BS;
function yae(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("div"), t = E("i"), b(t, "class", "rest__icon fas fa-campfire svelte-gp7m8t"), Z(t, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(e, "class", "rest svelte-gp7m8t"), b(e, "data-tooltip", "A5E.Rest"), b(e, "data-tooltip-direction", "DOWN"), Z(
        e,
        "rest--5e",
        /*replaceFatigueAndStrife*/
        i[2]
      ), Z(e, "disable-pointer-events", !/*$actor*/
      i[0].isOwner);
    },
    m(l, r) {
      T(l, e, r), A(e, t), s || (n = W(
        t,
        "click",
        /*click_handler*/
        i[3]
      ), s = !0);
    },
    p(l, [r]) {
      r & /*$actor*/
      1 && Z(t, "disable-pointer-events", !/*$actor*/
      l[0].isOwner), r & /*$actor*/
      1 && Z(e, "disable-pointer-events", !/*$actor*/
      l[0].isOwner);
    },
    i: se,
    o: se,
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(yae, "create_fragment$1_");
function vae(i, e, t) {
  let s;
  const n = de("actor");
  pe(i, n, (o) => t(0, s = o));
  let l = game.settings.get("a5e", "replaceFatigueAndStrife");
  return [s, n, l, /* @__PURE__ */ u(() => s.triggerRest(), "click_handler")];
}
u(vae, "instance$1R");
const qS = class qS extends re {
  constructor(e) {
    super(), oe(this, e, vae, yae, le, {});
  }
};
u(qS, "RestButton");
let sv = qS;
function g6(i, e, t) {
  const s = i.slice();
  return s[10] = e[t].value, s[11] = e[t].hint, s;
}
u(g6, "get_each_context$I");
function b6(i) {
  let e, t, s = (
    /*value*/
    i[10] + ""
  ), n, l, r, o, a, c;
  function f() {
    return (
      /*click_handler*/
      i[9](
        /*value*/
        i[10]
      )
    );
  }
  return u(f, "click_handler"), {
    c() {
      e = E("li"), t = E("button"), n = Q(s), r = F(), b(t, "class", "track-item svelte-18in170"), b(t, "data-degree", l = /*value*/
      i[10]), Z(
        t,
        "track-item-selected",
        /*value*/
        i[10] === /*selectedOption*/
        i[4]
      ), Z(t, "disable-pointer-events", !/*$actor*/
      i[5].isOwner), b(e, "data-tooltip", o = /*hint*/
      i[11] || null), b(e, "data-tooltip-direction", "DOWN");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, n), A(e, r), a || (c = W(t, "click", f), a = !0);
    },
    p(d, p) {
      i = d, p & /*options*/
      8 && s !== (s = /*value*/
      i[10] + "") && be(n, s), p & /*options*/
      8 && l !== (l = /*value*/
      i[10]) && b(t, "data-degree", l), p & /*options, selectedOption*/
      24 && Z(
        t,
        "track-item-selected",
        /*value*/
        i[10] === /*selectedOption*/
        i[4]
      ), p & /*$actor*/
      32 && Z(t, "disable-pointer-events", !/*$actor*/
      i[5].isOwner), p & /*options*/
      8 && o !== (o = /*hint*/
      i[11] || null) && b(e, "data-tooltip", o);
    },
    d(d) {
      d && C(e), a = !1, c();
    }
  };
}
u(b6, "create_each_block$I");
function kae(i) {
  let e, t, s, n, l, r, o = ue(
    /*options*/
    i[3]
  ), a = [];
  for (let c = 0; c < o.length; c += 1)
    a[c] = b6(g6(i, o, c));
  return {
    c() {
      e = E("div"), t = E("i"), n = F(), l = E("ul");
      for (let c = 0; c < a.length; c += 1)
        a[c].c();
      b(t, "class", s = "track-icon fas " + /*icon*/
      i[0] + " track-icon-level-" + /*selectedOption*/
      i[4] + " svelte-18in170"), b(l, "class", "track-items svelte-18in170"), b(e, "class", r = "track track--" + /*trackProperty*/
      i[2] + " svelte-18in170"), b(
        e,
        "data-tooltip",
        /*tooltipText*/
        i[1]
      ), b(e, "data-tooltip-direction", "DOWN"), Z(
        e,
        "track--5e",
        /*replaceFatigueAndStrife*/
        i[8]
      );
    },
    m(c, f) {
      T(c, e, f), A(e, t), A(e, n), A(e, l);
      for (let d = 0; d < a.length; d += 1)
        a[d] && a[d].m(l, null);
    },
    p(c, [f]) {
      if (f & /*icon, selectedOption*/
      17 && s !== (s = "track-icon fas " + /*icon*/
      c[0] + " track-icon-level-" + /*selectedOption*/
      c[4] + " svelte-18in170") && b(t, "class", s), f & /*options, selectedOption, $actor, handleStatusEffectChange*/
      120) {
        o = ue(
          /*options*/
          c[3]
        );
        let d;
        for (d = 0; d < o.length; d += 1) {
          const p = g6(c, o, d);
          a[d] ? a[d].p(p, f) : (a[d] = b6(p), a[d].c(), a[d].m(l, null));
        }
        for (; d < a.length; d += 1)
          a[d].d(1);
        a.length = o.length;
      }
      f & /*trackProperty*/
      4 && r !== (r = "track track--" + /*trackProperty*/
      c[2] + " svelte-18in170") && b(e, "class", r), f & /*tooltipText*/
      2 && b(
        e,
        "data-tooltip",
        /*tooltipText*/
        c[1]
      ), f & /*trackProperty, replaceFatigueAndStrife*/
      260 && Z(
        e,
        "track--5e",
        /*replaceFatigueAndStrife*/
        c[8]
      );
    },
    i: se,
    o: se,
    d(c) {
      c && C(e), Le(a, c);
    }
  };
}
u(kae, "create_fragment$1Z");
function wae(i, e, t) {
  let s, { icon: n } = e, { tooltipText: l } = e, { trackProperty: r } = e, { options: o } = e, { selectedOption: a } = e;
  function c(m) {
    te(s, `system.attributes.${r}`, m);
  }
  u(c, "handleStatusEffectChange");
  const f = de("actor");
  pe(i, f, (m) => t(5, s = m));
  let d = game.settings.get("a5e", "replaceFatigueAndStrife");
  const p = /* @__PURE__ */ u((m) => c(m), "click_handler");
  return i.$$set = (m) => {
    "icon" in m && t(0, n = m.icon), "tooltipText" in m && t(1, l = m.tooltipText), "trackProperty" in m && t(2, r = m.trackProperty), "options" in m && t(3, o = m.options), "selectedOption" in m && t(4, a = m.selectedOption);
  }, [
    n,
    l,
    r,
    o,
    a,
    s,
    c,
    f,
    d,
    p
  ];
}
u(wae, "instance$1Q");
const GS = class GS extends re {
  constructor(e) {
    super(), oe(this, e, wae, kae, le, {
      icon: 0,
      tooltipText: 1,
      trackProperty: 2,
      options: 3,
      selectedOption: 4
    });
  }
};
u(GS, "StatusTrack");
let Fp = GS;
function $ae(i) {
  var t;
  return ((t = i.system.traits.alignment) == null ? void 0 : t.sort(
    (s, n) => s.toLowerCase().localeCompare(n.toLowerCase())
  )).map((s) => K(CONFIG.A5E.alignments[s] ?? s));
}
u($ae, "prepareAlignment");
function Aae(i) {
  const e = i.system.proficiencies.armor.map(
    (t) => game.i18n.localize(
      t === "shield" ? "A5E.ArmorShieldPlural" : CONFIG.A5E.armor[t] ?? t
    )
  );
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
u(Aae, "getArmorProficiencies");
function Eae(i) {
  const e = i.system.traits.conditionImmunities.map(
    (t) => game.i18n.localize(CONFIG.A5E.conditions[t]) ?? t
  );
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
u(Eae, "prepareConditionImmunities");
function Sae(i) {
  return i.type !== "npc" ? [] : i.system.details.terrain.sort(
    (t, s) => t.toLowerCase().localeCompare(s.toLowerCase())
  ).map((t) => K(CONFIG.A5E.terrainTypes[t] ?? t));
}
u(Sae, "prepareCreatureTerrains");
function Cae(i) {
  const t = i.system.details.creatureTypes.sort(
    (s, n) => s.toLowerCase().localeCompare(n.toLowerCase())
  ).map((s) => K(CONFIG.A5E.creatureTypes[s] ?? s));
  return i.system.details.isSquad && t.push(K("Squad")), i.system.details.isSwarm && t.push(K("A5E.CreatureSwarm")), t;
}
u(Cae, "prepareCreatureTypes");
function Tae(i) {
  return [CONFIG.A5E.actorSizes[i.system.traits.size]].map((e) => game.i18n.localize(e));
}
u(Tae, "prepareCreatureSize");
function Oae(i) {
  const e = i.system.traits.damageImmunities.map(
    (t) => game.i18n.localize(CONFIG.A5E.damageTypes[t]) ?? t
  );
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
u(Oae, "prepareDamageImmunities");
function Dae(i) {
  const e = i.system.traits.damageResistances.map(
    (t) => game.i18n.localize(CONFIG.A5E.damageTypes[t]) ?? t
  );
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
u(Dae, "prepareDamageResistances");
function Iae(i) {
  const e = i.system.traits.damageVulnerabilities.map(
    (t) => game.i18n.localize(CONFIG.A5E.damageTypes[t]) ?? t
  );
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
u(Iae, "prepareDamageVulnerabilities");
function Pae(i) {
  const e = i.system.proficiencies.languages.map(
    (t) => game.i18n.localize(CONFIG.A5E.languages[t]) ?? t
  );
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
u(Pae, "getLanguageProficiencies");
function Mae(i) {
  if (i.type !== "character") return [];
  const e = (i.system.proficiencies.traditions ?? []).map(
    (t) => game.i18n.localize(CONFIG.A5E.maneuverTraditions[t]) ?? t
  );
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
u(Mae, "prepareManeuverTraditions");
function Fae(i) {
  return Object.entries(i.system.attributes.senses).filter(
    ([t, s]) => t === "blindsight" && s.otherwiseBlind || s.distance || s.unit === "unlimited"
  ).map(([t, s]) => {
    const n = game.i18n.localize(CONFIG.A5E.senses[t]), l = game.i18n.localize(CONFIG.A5E.distanceAbbreviations[s.unit]);
    if (t === "blindsight" && s.otherwiseBlind)
      return `${n} - ${s.distance} ${l || "ft."} (Blind Beyond)`;
    if (s.unit === "unlimited") {
      const r = game.i18n.localize(CONFIG.A5E.visionUnits.unlimited);
      return `${n} - ${r}`;
    }
    return `${n} - ${s.distance} ${l || "ft."}`;
  });
}
u(Fae, "prepareSenses");
function Rae(i) {
  var n, l;
  const e = (l = (n = i.system.attributes.movement) == null ? void 0 : n.traits) == null ? void 0 : l.hover, t = Object.entries(i.system.attributes.movement).filter(
    ([r, o]) => r === "fly" && e ? !0 : r === "traits" || o.distance === 0 ? !1 : o
  ), s = game.i18n.localize("A5E.MovementHover");
  return t.map(([r, o]) => {
    const a = game.i18n.localize(CONFIG.A5E.movement[r]), c = game.i18n.localize(CONFIG.A5E.distanceAbbreviations[o.unit]);
    return r === "fly" && e ? `${a} - ${o.distance || 0} ${c} (${s.toLocaleLowerCase()})` : `${a} - ${o.distance} ${c || "ft."}`;
  });
}
u(Rae, "getMovementData");
function Nae(i) {
  const e = i.system.proficiencies.tools.reduce((t, s) => {
    let n;
    for (const l of [
      "artisansTools",
      "gamingSets",
      "musicalInstruments",
      "miscellaneous",
      "vehicles"
    ])
      if (CONFIG.A5E.toolsPlural[l][s]) {
        n = game.i18n.localize(CONFIG.A5E.toolsPlural[l][s]);
        break;
      }
    return t.push(n || s), t;
  }, []);
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
u(Nae, "getToolProficiencies");
function jae(i) {
  const e = i.system.proficiencies.weapons.reduce(
    (s, n) => (Object.keys(CONFIG.A5E.weaponsPlural.martial).includes(n) ? s.martial.push(n) : Object.keys(CONFIG.A5E.weaponsPlural.simple).includes(n) ? s.simple.push(n) : Object.keys(CONFIG.A5E.weaponsPlural.rare).includes(n) ? s.rare.push(n) : Object.keys(CONFIG.A5E.weaponsPlural.miscellaneous).includes(n) ? s.miscellaneous.push(n) : s.other.push(n), s),
    {
      simple: [],
      martial: [],
      rare: [],
      miscellaneous: [],
      other: []
    }
  );
  ["simple", "martial", "rare", "miscellaneous"].forEach((s) => {
    const n = Object.keys(CONFIG.A5E.weaponsPlural[s]);
    gu(n, e[s]) ? e[s] = [
      game.i18n.localize(`A5E.Weapons${s[0].toUpperCase() + s.slice(1)}`)
    ] : e[s] = e[s].map(
      (l) => game.i18n.localize(CONFIG.A5E.weaponsPlural[s][l])
    );
  });
  const t = Object.values(e).flat();
  return t.sort((s, n) => s.toLowerCase().localeCompare(n.toLowerCase())), t;
}
u(jae, "getWeaponProficiencies");
function _6(i, e, t) {
  const s = i.slice();
  return s[6] = e[t].dialogMethod, s[7] = e[t].display, s[8] = e[t].heading, s[9] = e[t].propertyKey, s[10] = e[t].tooltip, s[11] = e[t].values, s;
}
u(_6, "get_each_context$H");
function y6(i, e, t) {
  const s = i.slice();
  return s[14] = e[t], s;
}
u(y6, "get_each_context_1$8");
function v6(i) {
  let e, t, s;
  function n() {
    return (
      /*func*/
      i[5](
        /*dialogMethod*/
        i[6],
        /*propertyKey*/
        i[9]
      )
    );
  }
  return u(n, "func"), e = new ie({
    props: {
      heading: (
        /*heading*/
        i[8]
      ),
      buttons: [
        {
          classes: "fa-solid fa-gear a5e-field-wrapper__header-button--scale",
          display: !/*sheetIsLocked*/
          i[0],
          handler: n,
          tooltip: (
            /*tooltip*/
            i[10]
          )
        }
      ],
      $$slots: { default: [Lae] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-heading-weight", "400"), G(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), G(t, "--a5e-header-button-color-hover", "#555");
    },
    m(l, r) {
      T(l, t, r), R(e, t, null), s = !0;
    },
    p(l, r) {
      i = l;
      const o = {};
      r & /*details*/
      2 && (o.heading = /*heading*/
      i[8]), r & /*sheetIsLocked, details*/
      3 && (o.buttons = [
        {
          classes: "fa-solid fa-gear a5e-field-wrapper__header-button--scale",
          display: !/*sheetIsLocked*/
          i[0],
          handler: n,
          tooltip: (
            /*tooltip*/
            i[10]
          )
        }
      ]), r & /*$$scope, details*/
      131074 && (o.$$scope = { dirty: r, ctx: i }), e.$set(o);
    },
    i(l) {
      s || (w(e.$$.fragment, l), s = !0);
    },
    o(l) {
      O(e.$$.fragment, l), s = !1;
    },
    d(l) {
      l && e && C(t), N(e, l);
    }
  };
}
u(v6, "create_if_block$12");
function k6(i) {
  let e, t;
  return e = new po({
    props: {
      label: (
        /*tag*/
        i[14]
      ),
      value: (
        /*tag*/
        i[14]
      ),
      tight: !0,
      optionStyles: `
                            color: black;
                            background-color: rgba(0 0 0 / 0.05);
                            max-width: 98%;
                            border: 1px solid #ccc;
                        `,
      disabled: !0
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*details*/
      2 && (l.label = /*tag*/
      s[14]), n & /*details*/
      2 && (l.value = /*tag*/
      s[14]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(k6, "create_each_block_1$8");
function Lae(i) {
  let e, t, s, n = ue(
    /*values*/
    i[11]
  ), l = [];
  for (let o = 0; o < n.length; o += 1)
    l[o] = k6(y6(i, n, o));
  const r = /* @__PURE__ */ u((o) => O(l[o], 1, 1, () => {
    l[o] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let o = 0; o < l.length; o += 1)
        l[o].c();
      t = F(), b(e, "class", "details-list svelte-1i77ueo");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < l.length; c += 1)
        l[c] && l[c].m(e, null);
      T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a & /*details*/
      2) {
        n = ue(
          /*values*/
          o[11]
        );
        let c;
        for (c = 0; c < n.length; c += 1) {
          const f = y6(o, n, c);
          l[c] ? (l[c].p(f, a), w(l[c], 1)) : (l[c] = k6(f), l[c].c(), w(l[c], 1), l[c].m(e, null));
        }
        for (ae(), c = n.length; c < l.length; c += 1)
          r(c);
        ce();
      }
    },
    i(o) {
      if (!s) {
        for (let a = 0; a < n.length; a += 1)
          w(l[a]);
        s = !0;
      }
    },
    o(o) {
      l = l.filter(Boolean);
      for (let a = 0; a < l.length; a += 1)
        O(l[a]);
      s = !1;
    },
    d(o) {
      o && (C(e), C(t)), Le(l, o);
    }
  };
}
u(Lae, "create_default_slot$U");
function w6(i) {
  let e, t, s = (
    /*values*/
    (i[11].length || !/*sheetIsLocked*/
    i[0]) && /*display*/
    (i[7] ?? !0) && v6(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*values*/
      (n[11].length || !/*sheetIsLocked*/
      n[0]) && /*display*/
      (n[7] ?? !0) ? s ? (s.p(n, l), l & /*details, sheetIsLocked*/
      3 && w(s, 1)) : (s = v6(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(w6, "create_each_block$H");
function Bae(i) {
  let e, t, s = ue(
    /*details*/
    i[1]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = w6(_6(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, [o]) {
      if (o & /*details, sheetIsLocked, openConfig*/
      11) {
        s = ue(
          /*details*/
          r[1]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = _6(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = w6(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(Bae, "create_fragment$1Y");
function qae(i, e, t) {
  let s, n, l;
  const r = de("actor");
  pe(i, r, (c) => t(4, l = c));
  function o(c, f) {
    if (!Xo(l, f)) return l[c]({ propertyKey: f });
    ui.notifications.warn(K("A5E.validations.warnings.modifiedByEffect"));
  }
  u(o, "openConfig");
  const a = /* @__PURE__ */ u((c, f) => o(c, f), "func");
  return i.$$.update = () => {
    var c, f;
    i.$$.dirty & /*$actor*/
    16 && t(1, s = [
      {
        heading: K("A5E.Movement"),
        values: Rae(l),
        dialogMethod: "configureMovement",
        propertyKey: "system.attributes.movement",
        tooltip: "Configure Movement"
      },
      {
        heading: K("A5E.SensesSpecial"),
        values: Fae(l),
        dialogMethod: "configureSenses",
        propertyKey: "system.attributes.senses",
        tooltip: "Configure Senses"
      },
      {
        heading: K("A5E.Languages"),
        values: Pae(l),
        dialogMethod: "configureLanguages",
        propertyKey: "system.proficiencies.languages",
        tooltip: "Configure Languages"
      },
      {
        heading: K("A5E.ConditionImmunities"),
        values: Eae(l),
        dialogMethod: "configureConditionImmunities",
        propertyKey: "system.traits.conditionImmunities",
        tooltip: "Configure Condition Immunities"
      },
      {
        heading: K("A5E.DamageImmunities"),
        values: Oae(l),
        dialogMethod: "configureDamageImmunities",
        propertyKey: "system.traits.damageImmunities",
        tooltip: "Configure Damage Immunities"
      },
      {
        heading: K("A5E.DamageResistances"),
        values: Dae(l),
        dialogMethod: "configureDamageResistances",
        propertyKey: "system.traits.damageResistances",
        tooltip: "Configure Damage Resistances"
      },
      {
        heading: K("A5E.DamageVulnerabilities"),
        values: Iae(l),
        dialogMethod: "configureDamageVulnerabilities",
        propertyKey: "system.traits.damageVulnerabilities",
        tooltip: "Configure Damage Vulnerabilities"
      },
      {
        heading: K("A5E.ManeuverTraditionPlural"),
        values: Mae(l),
        dialogMethod: "configureManeuverTraditions",
        propertyKey: "system.proficiencies.traditions",
        tooltip: "Configure Maneuver Traditions",
        display: l.type === "character"
      },
      {
        heading: K("A5E.WeaponProficiencies"),
        values: jae(l),
        dialogMethod: "configureWeaponProficiencies",
        propertyKey: "system.proficiencies.weapons",
        tooltip: "Configure Weapon Proficiencies"
      },
      {
        heading: K("A5E.ArmorProficiencies"),
        values: Aae(l),
        dialogMethod: "configureArmorProficiencies",
        propertyKey: "system.proficiencies.armor",
        tooltip: "Configure Armor Proficiencies"
      },
      {
        heading: K("A5E.ToolProficiencies"),
        values: Nae(l),
        dialogMethod: "configureToolProficiencies",
        propertyKey: "system.proficiencies.tools",
        tooltip: "Configure Tool Proficiencies"
      },
      {
        heading: K("A5E.Size"),
        values: Tae(l),
        dialogMethod: "configureSizeCategory",
        propertyKey: "system.traits.size",
        tooltip: "Configure Size Category"
      },
      {
        heading: K("A5E.CreatureTypesLabel"),
        values: Cae(l),
        dialogMethod: "configureCreatureTypes",
        propertyKey: "system.details.creatureTypes",
        tooltip: "Configure Creature Types"
      },
      {
        heading: K("A5E.CreatureTerrainsLabel"),
        values: Sae(l),
        dialogMethod: "configureCreatureTerrains",
        propertyKey: "system.details.terrain",
        tooltip: "Configure Creature Terrains",
        display: l.type === "npc"
      },
      {
        heading: K("A5E.Alignments"),
        values: $ae(l),
        dialogMethod: "configureAlignment",
        propertyKey: "system.traits.alignment",
        tooltip: "Configure Alignment"
      }
    ]), i.$$.dirty & /*$actor*/
    16 && t(0, n = l.isOwner ? ((f = (c = l.flags) == null ? void 0 : c.a5e) == null ? void 0 : f.sheetIsLocked) ?? !0 : !0);
  }, [n, s, r, o, l, a];
}
u(qae, "instance$1P");
const zS = class zS extends re {
  constructor(e) {
    super(), oe(this, e, qae, Bae, le, {});
  }
};
u(zS, "Details");
let nv = zS;
function Gae(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "death-saves__input svelte-7rgdbi"), b(e, "type", "number"), b(e, "name", "system.attributes.death.success"), b(e, "placeholder", "?"), b(e, "min", "0"), b(e, "data-tooltip", "A5E.DeathSuccess"), b(e, "data-tooltip-direction", "UP"), e.value = t = /*death*/
      i[1].success;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      r & /*death*/
      2 && t !== (t = /*death*/
      l[1].success) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Gae, "create_if_block_1$K");
function zae(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "death-saves__input svelte-7rgdbi"), b(e, "type", "number"), b(e, "name", "system.attributes.death.failure"), b(e, "data-dtype", "Number"), b(e, "placeholder", "0"), b(e, "min", "0"), b(e, "data-tooltip", "A5E.DeathFailure"), b(e, "data-tooltip-direction", "UP"), e.value = t = /*isBlind*/
      i[4] ? "?" : (
        /*death*/
        i[1].failure
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      r & /*death*/
      2 && t !== (t = /*isBlind*/
      l[4] ? "?" : (
        /*death*/
        l[1].failure
      )) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(zae, "create_if_block$11");
function Hae(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p = !/*isBlind*/
  i[4] && Gae(i), m = !/*isBlind*/
  i[4] && zae(i);
  return {
    c() {
      e = E("div"), t = E("button"), t.innerHTML = '<i class="fas fa-check"></i>', s = F(), p && p.c(), n = F(), l = E("div"), r = E("button"), r.innerHTML = '<i class="fas fa-skull a5e-js-roll-death-saving-throw"></i>', o = F(), m && m.c(), a = F(), c = E("button"), c.innerHTML = '<i class="fas fa-times"></i>', b(t, "class", "death-saves__button svelte-7rgdbi"), b(r, "class", "death-saves__button svelte-7rgdbi"), b(r, "data-tooltip", "A5E.DeathSavingThrowRoll"), b(r, "data-tooltip-direction", "UP"), b(l, "class", "death-saves__icon u-align-center u-flex u-flex-col u-pos-relative svelte-7rgdbi"), b(c, "class", "death-saves__button svelte-7rgdbi"), b(e, "class", "death-saves svelte-7rgdbi");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(e, s), p && p.m(e, null), A(e, n), A(e, l), A(l, r), A(e, o), m && m.m(e, null), A(e, a), A(e, c), f || (d = [
        W(
          t,
          "click",
          /*click_handler*/
          i[5]
        ),
        W(r, "click", function() {
          $t(
            /*$actor*/
            i[0].rollDeathSavingThrow(ql(
              /*$pressedKeysStore*/
              i[2]
            ))
          ) && i[0].rollDeathSavingThrow(ql(
            /*$pressedKeysStore*/
            i[2]
          )).apply(this, arguments);
        }),
        W(
          c,
          "click",
          /*click_handler_1*/
          i[8]
        )
      ], f = !0);
    },
    p(g, [h]) {
      i = g, /*isBlind*/
      i[4] || p.p(i, h), /*isBlind*/
      i[4] || m.p(i, h);
    },
    i: se,
    o: se,
    d(g) {
      g && C(e), p && p.d(), m && m.d(), f = !1, Me(d);
    }
  };
}
u(Hae, "create_fragment$1X");
function Uae(i, e, t) {
  let s, n, l;
  pe(i, Ml, (p) => t(2, l = p));
  const r = de("actor");
  pe(i, r, (p) => t(0, n = p));
  let o = game.settings.get("a5e", "blindDeathSaves");
  const a = /* @__PURE__ */ u(() => te(n, "system.attributes.death.success", s.success + 1), "click_handler"), c = /* @__PURE__ */ u(({ target: p }) => te(n, p.name, Number(p.value)), "change_handler"), f = /* @__PURE__ */ u(({ target: p }) => te(n, p.name, Number(p.value)), "change_handler_1"), d = /* @__PURE__ */ u(() => te(n, "system.attributes.death.failure", s.failure + 1), "click_handler_1");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(1, s = n.system.attributes.death);
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c,
    f,
    d
  ];
}
u(Uae, "instance$1O");
const HS = class HS extends re {
  constructor(e) {
    super(), oe(this, e, Uae, Hae, le, {});
  }
};
u(HS, "DeathSaveOverlay");
let iv = HS;
function $6(i) {
  let e, t;
  return e = new iv({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u($6, "create_if_block_1$J");
function Vae(i) {
  let e, t, s, n, l, r, o, a, c, f = (
    /*hp*/
    i[0].value === 0 && $6()
  );
  return {
    c() {
      e = E("img"), l = F(), f && f.c(), r = $e(), b(e, "class", "actor-image svelte-1wowav7"), ze(e.src, t = /*$actor*/
      i[1].img) || b(e, "src", t), b(e, "alt", s = /*$actor*/
      i[1].name), b(e, "title", n = /*$actor*/
      i[1].name);
    },
    m(d, p) {
      T(d, e, p), T(d, l, p), f && f.m(d, p), T(d, r, p), o = !0, a || (c = W(
        e,
        "click",
        /*onEditImage*/
        i[6]
      ), a = !0);
    },
    p(d, p) {
      (!o || p & /*$actor*/
      2 && !ze(e.src, t = /*$actor*/
      d[1].img)) && b(e, "src", t), (!o || p & /*$actor*/
      2 && s !== (s = /*$actor*/
      d[1].name)) && b(e, "alt", s), (!o || p & /*$actor*/
      2 && n !== (n = /*$actor*/
      d[1].name)) && b(e, "title", n), /*hp*/
      d[0].value === 0 ? f ? p & /*hp*/
      1 && w(f, 1) : (f = $6(), f.c(), w(f, 1), f.m(r.parentNode, r)) : f && (ae(), O(f, 1, 1, () => {
        f = null;
      }), ce());
    },
    i(d) {
      o || (w(f), o = !0);
    },
    o(d) {
      O(f), o = !1;
    },
    d(d) {
      d && (C(e), C(l), C(r)), f && f.d(d), a = !1, c();
    }
  };
}
u(Vae, "create_default_slot$T");
function Wae(i) {
  let e, t;
  return e = new Fp({
    props: {
      icon: "fa-brain",
      tooltipText: "A5E.Strife",
      trackProperty: "strife",
      options: (
        /*strifeOptions*/
        i[4]
      ),
      selectedOption: (
        /*$actor*/
        i[1].system.attributes.strife
      )
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      2 && (l.selectedOption = /*$actor*/
      s[1].system.attributes.strife), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Wae, "create_if_block$10");
function Kae(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S, D, I, M, L, B;
  s = new Q0({
    props: {
      hp: (
        /*hp*/
        i[0]
      ),
      $$slots: { default: [Vae] },
      $$scope: { ctx: i }
    }
  }), l = new Fp({
    props: {
      icon: "fa-running",
      tooltipText: (
        /*replaceFatigueAndStrife*/
        i[5] ? "A5E.Exhaustion" : "A5E.Fatigue"
      ),
      trackProperty: "fatigue",
      options: (
        /*fatigueOptions*/
        i[2]
      ),
      selectedOption: (
        /*$actor*/
        i[1].system.attributes.fatigue
      )
    }
  });
  let z = !/*replaceFatigueAndStrife*/
  i[5] && Wae(i);
  return a = new sv({}), d = new x0({ props: { hp: (
    /*hp*/
    i[0]
  ) } }), g = new J0({}), _ = new Z0({}), v = new ev({}), D = new nv({}), L = new tv({}), {
    c() {
      e = E("div"), t = E("section"), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), z && z.c(), o = F(), j(a.$$.fragment), c = F(), f = E("section"), j(d.$$.fragment), p = F(), m = E("ul"), j(g.$$.fragment), h = F(), j(_.$$.fragment), y = F(), j(v.$$.fragment), k = F(), S = E("div"), j(D.$$.fragment), I = F(), M = E("footer"), j(L.$$.fragment), b(t, "class", "actor-portrait-wrapper svelte-1wowav7"), b(m, "class", "actor-glance-trackers svelte-1wowav7"), b(S, "class", "actor-details svelte-1wowav7"), b(M, "class", "actor-sidebar-footer svelte-1wowav7"), b(f, "class", "actor-sidebar-lower svelte-1wowav7"), b(e, "class", "actor-sidebar svelte-1wowav7");
    },
    m(q, U) {
      T(q, e, U), A(e, t), R(s, t, null), A(t, n), R(l, t, null), A(t, r), z && z.m(t, null), A(t, o), R(a, t, null), A(e, c), A(e, f), R(d, f, null), A(f, p), A(f, m), R(g, m, null), A(m, h), R(_, m, null), A(m, y), R(v, m, null), A(f, k), A(f, S), R(D, S, null), A(f, I), A(f, M), R(L, M, null), B = !0;
    },
    p(q, [U]) {
      const H = {};
      U & /*hp*/
      1 && (H.hp = /*hp*/
      q[0]), U & /*$$scope, hp, $actor*/
      131 && (H.$$scope = { dirty: U, ctx: q }), s.$set(H);
      const V = {};
      U & /*fatigueOptions*/
      4 && (V.options = /*fatigueOptions*/
      q[2]), U & /*$actor*/
      2 && (V.selectedOption = /*$actor*/
      q[1].system.attributes.fatigue), l.$set(V), /*replaceFatigueAndStrife*/
      q[5] || z.p(q, U);
      const Y = {};
      U & /*hp*/
      1 && (Y.hp = /*hp*/
      q[0]), d.$set(Y);
    },
    i(q) {
      B || (w(s.$$.fragment, q), w(l.$$.fragment, q), w(z), w(a.$$.fragment, q), w(d.$$.fragment, q), w(g.$$.fragment, q), w(_.$$.fragment, q), w(v.$$.fragment, q), w(D.$$.fragment, q), w(L.$$.fragment, q), B = !0);
    },
    o(q) {
      O(s.$$.fragment, q), O(l.$$.fragment, q), O(z), O(a.$$.fragment, q), O(d.$$.fragment, q), O(g.$$.fragment, q), O(_.$$.fragment, q), O(v.$$.fragment, q), O(D.$$.fragment, q), O(L.$$.fragment, q), B = !1;
    },
    d(q) {
      q && C(e), N(s), N(l), z && z.d(), N(a), N(d), N(g), N(_), N(v), N(D), N(L);
    }
  };
}
u(Kae, "create_fragment$1W");
function Yae(i, e, t) {
  let s, { hp: n } = e;
  const l = de("actor");
  pe(i, l, (f) => t(1, s = f));
  let r = [
    { value: 0, hint: null },
    {
      value: 1,
      hint: "A5E.tracks.fatigue.hints.1"
    },
    {
      value: 2,
      hint: "A5E.tracks.fatigue.hints.2"
    },
    {
      value: 3,
      hint: "A5E.tracks.fatigue.hints.3"
    },
    {
      value: 4,
      hint: "A5E.tracks.fatigue.hints.4"
    },
    {
      value: 5,
      hint: "A5E.tracks.fatigue.hints.5"
    },
    {
      value: 6,
      hint: "A5E.tracks.fatigue.hints.6"
    },
    {
      value: 7,
      hint: "A5E.tracks.fatigue.hints.7"
    }
  ];
  const o = [
    { value: 0, hint: null },
    {
      value: 1,
      hint: "A5E.tracks.strife.hints.1"
    },
    {
      value: 2,
      hint: "A5E.tracks.strife.hints.2"
    },
    {
      value: 3,
      hint: "A5E.tracks.strife.hints.3"
    },
    {
      value: 4,
      hint: "A5E.tracks.strife.hints.4"
    },
    {
      value: 5,
      hint: "A5E.tracks.strife.hints.5"
    },
    {
      value: 6,
      hint: "A5E.tracks.strife.hints.6"
    },
    {
      value: 7,
      hint: "A5E.tracks.strife.hints.7"
    }
  ], a = game.settings.get("a5e", "replaceFatigueAndStrife");
  a && (r = [
    { value: 0, hint: null },
    {
      value: 1,
      hint: "A5E.tracks.exhaustion.hints.1"
    },
    {
      value: 2,
      hint: "A5E.tracks.exhaustion.hints.2"
    },
    {
      value: 3,
      hint: "A5E.tracks.exhaustion.hints.3"
    },
    {
      value: 4,
      hint: "A5E.tracks.exhaustion.hints.4"
    },
    {
      value: 5,
      hint: "A5E.tracks.exhaustion.hints.5"
    },
    {
      value: 6,
      hint: "A5E.tracks.exhaustion.hints.6"
    }
  ]);
  async function c(f) {
    await gg(s, { shiftKey: f.shiftKey });
  }
  return u(c, "onEditImage"), i.$$set = (f) => {
    "hp" in f && t(0, n = f.hp);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    2 && t(0, n = s.system.attributes.hp);
  }, [
    n,
    s,
    r,
    l,
    o,
    a,
    c
  ];
}
u(Yae, "instance$1N");
const US = class US extends re {
  constructor(e) {
    super(), oe(this, e, Yae, Kae, le, { hp: 0 });
  }
};
u(US, "ActorSidebar");
let lv = US;
function A6(i, e, t) {
  const s = i.slice();
  return s[17] = e[t][0], s[18] = e[t][1], s;
}
u(A6, "get_each_context$G");
function E6(i) {
  let e, t;
  return e = new Ll({
    props: {
      $$slots: { default: [Xae] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $actor, spellBookId, menuList, reducer, showDescription*/
      2097451 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(E6, "create_if_block_1$I");
function Xae(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g;
  return e = new Nl({
    props: { reducerType: gd, reducer: (
      /*reducer*/
      i[1]
    ) }
  }), s = new vc({}), s.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  ), l = new jl({
    props: {
      reducerType: gd,
      reducer: (
        /*reducer*/
        i[1]
      ),
      reducerId: (
        /*spellBookId*/
        i[0]
      )
    }
  }), o = new yc({
    props: {
      reducerType: gd,
      reducerId: (
        /*spellBookId*/
        i[0]
      ),
      reducer: (
        /*reducer*/
        i[1]
      )
    }
  }), c = new Tn({
    props: {
      reducerType: gd,
      menuList: (
        /*menuList*/
        i[8]
      ),
      reducer: (
        /*reducer*/
        i[1]
      )
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment), f = F(), d = E("button"), b(d, "class", "a5e-import-from-compendium-button fa-solid fa-download"), b(d, "data-tooltip", "Import Spells from Compendium"), b(d, "data-tooltip-direction", "UP");
    },
    m(h, _) {
      R(e, h, _), T(h, t, _), R(s, h, _), T(h, n, _), R(l, h, _), T(h, r, _), R(o, h, _), T(h, a, _), R(c, h, _), T(h, f, _), T(h, d, _), p = !0, m || (g = W(
        d,
        "click",
        /*click_handler*/
        i[15]
      ), m = !0);
    },
    p(h, _) {
      const y = {};
      _ & /*reducer*/
      2 && (y.reducer = /*reducer*/
      h[1]), e.$set(y);
      const v = {};
      _ & /*reducer*/
      2 && (v.reducer = /*reducer*/
      h[1]), _ & /*spellBookId*/
      1 && (v.reducerId = /*spellBookId*/
      h[0]), l.$set(v);
      const k = {};
      _ & /*spellBookId*/
      1 && (k.reducerId = /*spellBookId*/
      h[0]), _ & /*reducer*/
      2 && (k.reducer = /*reducer*/
      h[1]), o.$set(k);
      const S = {};
      _ & /*menuList*/
      256 && (S.menuList = /*menuList*/
      h[8]), _ & /*reducer*/
      2 && (S.reducer = /*reducer*/
      h[1]), c.$set(S);
    },
    i(h) {
      p || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(l.$$.fragment, h), w(o.$$.fragment, h), w(c.$$.fragment, h), p = !0);
    },
    o(h) {
      O(e.$$.fragment, h), O(s.$$.fragment, h), O(l.$$.fragment, h), O(o.$$.fragment, h), O(c.$$.fragment, h), p = !1;
    },
    d(h) {
      h && (C(t), C(n), C(r), C(a), C(f), C(d)), N(e, h), N(s, h), N(l, h), N(o, h), N(c, h), m = !1, g();
    }
  };
}
u(Xae, "create_default_slot$S");
function S6(i) {
  var s, n, l, r, o;
  let e, t;
  return e = new $r({
    props: {
      level: (
        /*level*/
        i[17]
      ),
      label: (
        /*label*/
        i[18]
      ),
      showDescription: (
        /*showDescription*/
        i[5]
      ),
      showArtifactCharges: (
        /*spellBook*/
        ((s = i[7]) == null ? void 0 : s.showArtifactCharges) ?? !1
      ),
      showSpellPoints: (
        /*spellBook*/
        ((n = i[7]) == null ? void 0 : n.showSpellPoints) ?? !1
      ),
      showSpellSlots: (
        /*spellBook*/
        ((l = i[7]) == null ? void 0 : l.showSpellSlots) ?? !0
      ),
      showUses: (
        /*showUses*/
        i[4]
      ),
      items: (
        /*$reducer*/
        (o = (r = i[2]) == null ? void 0 : r._levels) == null ? void 0 : o[
          /*level*/
          i[17]
        ]
      ),
      type: "spellLevels"
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(a, c) {
      R(e, a, c), t = !0;
    },
    p(a, c) {
      var d, p, m, g, h;
      const f = {};
      c & /*showDescription*/
      32 && (f.showDescription = /*showDescription*/
      a[5]), c & /*spellBook*/
      128 && (f.showArtifactCharges = /*spellBook*/
      ((d = a[7]) == null ? void 0 : d.showArtifactCharges) ?? !1), c & /*spellBook*/
      128 && (f.showSpellPoints = /*spellBook*/
      ((p = a[7]) == null ? void 0 : p.showSpellPoints) ?? !1), c & /*spellBook*/
      128 && (f.showSpellSlots = /*spellBook*/
      ((m = a[7]) == null ? void 0 : m.showSpellSlots) ?? !0), c & /*showUses*/
      16 && (f.showUses = /*showUses*/
      a[4]), c & /*$reducer*/
      4 && (f.items = /*$reducer*/
      (h = (g = a[2]) == null ? void 0 : g._levels) == null ? void 0 : h[
        /*level*/
        a[17]
      ]), e.$set(f);
    },
    i(a) {
      t || (w(e.$$.fragment, a), t = !0);
    },
    o(a) {
      O(e.$$.fragment, a), t = !1;
    },
    d(a) {
      N(e, a);
    }
  };
}
u(S6, "create_if_block$$");
function C6(i) {
  let e = (
    /*isSpellLevelVisible*/
    i[6](
      /*level*/
      i[17]
    )
  ), t, s, n = e && S6(i);
  return {
    c() {
      n && n.c(), t = $e();
    },
    m(l, r) {
      n && n.m(l, r), T(l, t, r), s = !0;
    },
    p(l, r) {
      r & /*isSpellLevelVisible*/
      64 && (e = /*isSpellLevelVisible*/
      l[6](
        /*level*/
        l[17]
      )), e ? n ? (n.p(l, r), r & /*isSpellLevelVisible*/
      64 && w(n, 1)) : (n = S6(l), n.c(), w(n, 1), n.m(t.parentNode, t)) : n && (ae(), O(n, 1, 1, () => {
        n = null;
      }), ce());
    },
    i(l) {
      s || (w(n), s = !0);
    },
    o(l) {
      O(n), s = !1;
    },
    d(l) {
      l && C(t), n && n.d(l);
    }
  };
}
u(C6, "create_each_block$G");
function Jae(i) {
  let e, t, s, n, l = (
    /*$actor*/
    i[3].isOwner && E6(i)
  ), r = ue(Object.entries(
    /*spellLevels*/
    i[11]
  )), o = [];
  for (let c = 0; c < r.length; c += 1)
    o[c] = C6(A6(i, r, c));
  const a = /* @__PURE__ */ u((c) => O(o[c], 1, 1, () => {
    o[c] = null;
  }), "out");
  return {
    c() {
      e = E("article"), l && l.c(), t = F(), s = E("section");
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      b(s, "class", "a5e-page-wrapper a5e-page-wrapper--item-list"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(
        e,
        "data-spell-book-id",
        /*spellBookId*/
        i[0]
      );
    },
    m(c, f) {
      T(c, e, f), l && l.m(e, null), A(e, t), A(e, s);
      for (let d = 0; d < o.length; d += 1)
        o[d] && o[d].m(s, null);
      n = !0;
    },
    p(c, [f]) {
      if (/*$actor*/
      c[3].isOwner ? l ? (l.p(c, f), f & /*$actor*/
      8 && w(l, 1)) : (l = E6(c), l.c(), w(l, 1), l.m(e, t)) : l && (ae(), O(l, 1, 1, () => {
        l = null;
      }), ce()), f & /*Object, spellLevels, showDescription, spellBook, showUses, $reducer, isSpellLevelVisible*/
      2292) {
        r = ue(Object.entries(
          /*spellLevels*/
          c[11]
        ));
        let d;
        for (d = 0; d < r.length; d += 1) {
          const p = A6(c, r, d);
          o[d] ? (o[d].p(p, f), w(o[d], 1)) : (o[d] = C6(p), o[d].c(), w(o[d], 1), o[d].m(s, null));
        }
        for (ae(), d = r.length; d < o.length; d += 1)
          a(d);
        ce();
      }
      (!n || f & /*spellBookId*/
      1) && b(
        e,
        "data-spell-book-id",
        /*spellBookId*/
        c[0]
      );
    },
    i(c) {
      if (!n) {
        w(l);
        for (let f = 0; f < r.length; f += 1)
          w(o[f]);
        n = !0;
      }
    },
    o(c) {
      O(l), o = o.filter(Boolean);
      for (let f = 0; f < o.length; f += 1)
        O(o[f]);
      n = !1;
    },
    d(c) {
      c && C(e), l && l.d(), Le(o, c);
    }
  };
}
u(Jae, "create_fragment$1V");
const gd = "spells";
function Zae(i, e, t) {
  let s, n, l, r, o, a = se, c = /* @__PURE__ */ u(() => (a(), a = Xt(p, (I) => t(2, o = I)), p), "$$subscribe_reducer"), f;
  i.$$.on_destroy.push(() => a());
  let { spellBookId: d } = e, { reducer: p } = e;
  c();
  function m(I) {
    I.forEach((M) => {
      M.system.spellBook = d;
    }), f.createEmbeddedDocuments("Item", I);
  }
  u(m, "importer");
  const g = de("actor");
  pe(i, g, (I) => t(3, f = I));
  const { spellLevels: h } = CONFIG.A5E, _ = game.a5e.utils.openCompendium;
  let y = !1;
  const v = p.subscribe((I) => {
    const M = Object.keys(h).reduce(
      (L, B) => (L.push(...o == null ? void 0 : o._levels[B]), L),
      []
    );
    t(4, y = Gl(M));
  });
  let k = !1;
  Qt(() => {
    v();
  });
  const S = /* @__PURE__ */ u(() => t(5, k = !k), "updateSelection_handler"), D = /* @__PURE__ */ u(() => _(f, "spells", { importFunction: m, spellBookId: d }), "click_handler");
  return i.$$set = (I) => {
    "spellBookId" in I && t(0, d = I.spellBookId), "reducer" in I && c(t(1, p = I.reducer));
  }, i.$$.update = () => {
    var I, M, L;
    i.$$.dirty & /*$actor, spellBookId*/
    9 && t(7, n = (I = f == null ? void 0 : f.spellBooks) == null ? void 0 : I.get(d)), i.$$.dirty & /*$actor*/
    8 && t(13, l = f.isOwner ? ((L = (M = f.flags) == null ? void 0 : M.a5e) == null ? void 0 : L.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*sheetIsLocked, $actor, $reducer*/
    8204 && t(6, r = /* @__PURE__ */ u((B) => {
      var H, V, Y;
      if (!l) return !0;
      const z = (H = f.system.spellResources.slots[B]) == null ? void 0 : H.max, q = ((Y = (V = f.flags) == null ? void 0 : V.a5e) == null ? void 0 : Y.showSpellSlots) ?? !0;
      return !!([...(o == null ? void 0 : o._levels[B]) ?? []].length || q && z > 0);
    }, "isSpellLevelVisible"));
  }, t(8, s = Object.entries(h)), [
    d,
    p,
    o,
    f,
    y,
    k,
    r,
    n,
    s,
    m,
    g,
    h,
    _,
    l,
    S,
    D
  ];
}
u(Zae, "instance$1M");
const VS = class VS extends re {
  constructor(e) {
    super(), oe(this, e, Zae, Jae, le, { spellBookId: 0, reducer: 1 });
  }
};
u(VS, "SpellBook");
let rv = VS;
function Qae(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "text"), b(e, "spellcheck", "false"), e.value = t = /*book*/
      ((l = i[3]) == null ? void 0 : l.name) || "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*book*/
      8 && t !== (t = /*book*/
      ((o = l[3]) == null ? void 0 : o.name) || "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Qae, "create_default_slot_7$8");
function xae(i) {
  var s;
  let e, t;
  return e = new Ke({
    props: {
      allowDeselect: !1,
      options: (
        /*abilityOptions*/
        i[4]
      ),
      selected: (
        /*book*/
        ((s = i[3]) == null ? void 0 : s.ability) ?? "default"
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*book*/
      8 && (r.selected = /*book*/
      ((o = n[3]) == null ? void 0 : o.ability) ?? "default"), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(xae, "create_default_slot_6$a");
function ece(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "Show Artifact Charges",
      checked: (
        /*book*/
        ((s = i[3]) == null ? void 0 : s.showArtifactCharges) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*book*/
      8 && (r.checked = /*book*/
      ((o = n[3]) == null ? void 0 : o.showArtifactCharges) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(ece, "create_default_slot_5$c");
function tce(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "Show Spell Inventions",
      checked: (
        /*book*/
        ((s = i[3]) == null ? void 0 : s.showSpellInventions) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[9]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*book*/
      8 && (r.checked = /*book*/
      ((o = n[3]) == null ? void 0 : o.showSpellInventions) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(tce, "create_default_slot_4$d");
function sce(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "Show Spell Points",
      checked: (
        /*book*/
        ((s = i[3]) == null ? void 0 : s.showSpellPoints) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[10]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*book*/
      8 && (r.checked = /*book*/
      ((o = n[3]) == null ? void 0 : o.showSpellPoints) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(sce, "create_default_slot_3$h");
function nce(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "Show Spell Slots",
      checked: (
        /*book*/
        ((s = i[3]) == null ? void 0 : s.showSpellSlots) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[11]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*book*/
      8 && (r.checked = /*book*/
      ((o = n[3]) == null ? void 0 : o.showSpellSlots) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(nce, "create_default_slot_2$k");
function ice(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "Disable Spell Consumers",
      checked: (
        /*book*/
        ((s = i[3]) == null ? void 0 : s.disableSpellConsumers) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[12]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*book*/
      8 && (r.checked = /*book*/
      ((o = n[3]) == null ? void 0 : o.disableSpellConsumers) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(ice, "create_default_slot_1$l");
function lce(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g;
  return e = new ie({
    props: {
      heading: "Spell Book Name",
      $$slots: { default: [Qae] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      heading: "Spellcasting Ability",
      hint: "Spells in this spellbook will use this spellcasting ability for the purposes of spell attack roll and spell save DCs in place of the sheet default.",
      $$slots: { default: [xae] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      $$slots: { default: [ece] },
      $$scope: { ctx: i }
    }
  }), o = new ie({
    props: {
      $$slots: { default: [tce] },
      $$scope: { ctx: i }
    }
  }), c = new ie({
    props: {
      $$slots: { default: [sce] },
      $$scope: { ctx: i }
    }
  }), d = new ie({
    props: {
      $$slots: { default: [nce] },
      $$scope: { ctx: i }
    }
  }), m = new ie({
    props: {
      hint: "When enabled, resource consumers for spell slots and points will be ignored by default. This is useful for things like ritual books, where you're rarely if ever going to want to consume a spell slot.",
      $$slots: { default: [ice] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment), f = F(), j(d.$$.fragment), p = F(), j(m.$$.fragment);
    },
    m(h, _) {
      R(e, h, _), T(h, t, _), R(s, h, _), T(h, n, _), R(l, h, _), T(h, r, _), R(o, h, _), T(h, a, _), R(c, h, _), T(h, f, _), R(d, h, _), T(h, p, _), R(m, h, _), g = !0;
    },
    p(h, _) {
      const y = {};
      _ & /*$$scope, book, $document, spellBookId*/
      8206 && (y.$$scope = { dirty: _, ctx: h }), e.$set(y);
      const v = {};
      _ & /*$$scope, book, $document, spellBookId*/
      8206 && (v.$$scope = { dirty: _, ctx: h }), s.$set(v);
      const k = {};
      _ & /*$$scope, book, $document, spellBookId*/
      8206 && (k.$$scope = { dirty: _, ctx: h }), l.$set(k);
      const S = {};
      _ & /*$$scope, book, $document, spellBookId*/
      8206 && (S.$$scope = { dirty: _, ctx: h }), o.$set(S);
      const D = {};
      _ & /*$$scope, book, $document, spellBookId*/
      8206 && (D.$$scope = { dirty: _, ctx: h }), c.$set(D);
      const I = {};
      _ & /*$$scope, book, $document, spellBookId*/
      8206 && (I.$$scope = { dirty: _, ctx: h }), d.$set(I);
      const M = {};
      _ & /*$$scope, book, $document, spellBookId*/
      8206 && (M.$$scope = { dirty: _, ctx: h }), m.$set(M);
    },
    i(h) {
      g || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(l.$$.fragment, h), w(o.$$.fragment, h), w(c.$$.fragment, h), w(d.$$.fragment, h), w(m.$$.fragment, h), g = !0);
    },
    o(h) {
      O(e.$$.fragment, h), O(s.$$.fragment, h), O(l.$$.fragment, h), O(o.$$.fragment, h), O(c.$$.fragment, h), O(d.$$.fragment, h), O(m.$$.fragment, h), g = !1;
    },
    d(h) {
      h && (C(t), C(n), C(r), C(a), C(f), C(p)), N(e, h), N(s, h), N(l, h), N(o, h), N(c, h), N(d, h), N(m, h);
    }
  };
}
u(lce, "create_default_slot$R");
function rce(i) {
  let e, t, s, n;
  return t = new De({
    props: {
      $$slots: { default: [lce] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), s = E("div"), j(t.$$.fragment), G(s, "display", "contents"), G(s, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-b67m4t");
    },
    m(l, r) {
      T(l, e, r), A(e, s), R(t, s, null), n = !0;
    },
    p(l, [r]) {
      const o = {};
      r & /*$$scope, book, $document, spellBookId*/
      8206 && (o.$$scope = { dirty: r, ctx: l }), t.$set(o);
    },
    i(l) {
      n || (w(t.$$.fragment, l), n = !0);
    },
    o(l) {
      O(t.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(e), N(t);
    }
  };
}
u(rce, "create_fragment$1U");
function oce(i, e, t) {
  let s, n, l = se, r = /* @__PURE__ */ u(() => (l(), l = Xt(f, (D) => t(2, n = D)), f), "$$subscribe_document");
  i.$$.on_destroy.push(() => l());
  let { document: o, appId: a, spellBookId: c } = de("#external").application, { document: f = o, appId: d = a, spellBookId: p = c } = e;
  r();
  const m = [["default", "A5E.abilities.default"], ...fl()], g = /* @__PURE__ */ u(({ target: D }) => {
    te(n, `system.spellBooks.${p}.name`, D.value);
  }, "change_handler"), h = /* @__PURE__ */ u(({ detail: D }) => te(n, `system.spellBooks.${p}.ability`, D), "updateSelection_handler"), _ = /* @__PURE__ */ u(({ detail: D }) => {
    te(n, `system.spellBooks.${p}.showArtifactCharges`, D);
  }, "updateSelection_handler_1"), y = /* @__PURE__ */ u(({ detail: D }) => {
    te(n, `system.spellBooks.${p}.showSpellInventions`, D);
  }, "updateSelection_handler_2"), v = /* @__PURE__ */ u(({ detail: D }) => {
    te(n, `system.spellBooks.${p}.showSpellPoints`, D);
  }, "updateSelection_handler_3"), k = /* @__PURE__ */ u(({ detail: D }) => {
    te(n, `system.spellBooks.${p}.showSpellSlots`, D);
  }, "updateSelection_handler_4"), S = /* @__PURE__ */ u(({ detail: D }) => {
    te(n, `system.spellBooks.${p}.disableSpellConsumers`, D);
  }, "updateSelection_handler_5");
  return i.$$set = (D) => {
    "document" in D && r(t(0, f = D.document)), "appId" in D && t(5, d = D.appId), "spellBookId" in D && t(1, p = D.spellBookId);
  }, i.$$.update = () => {
    var D;
    i.$$.dirty & /*$document, spellBookId*/
    6 && t(3, s = (D = n.spellBooks) == null ? void 0 : D.get(p));
  }, [
    f,
    p,
    n,
    s,
    m,
    d,
    g,
    h,
    _,
    y,
    v,
    k,
    S
  ];
}
u(oce, "instance$1L");
const WS = class WS extends re {
  constructor(e) {
    super(), oe(this, e, oce, rce, le, { document: 0, appId: 5, spellBookId: 1 });
  }
};
u(WS, "SpellbookConfigDialog");
let ov = WS;
function ace(i) {
  let e, t, s, n, l, r, o, a, c;
  return {
    c() {
      e = E("form"), t = E("p"), t.textContent = `Are you sure you want to delete this spellbook? This will also remove
        all of the spells it contains.`, s = F(), n = E("div"), l = E("button"), l.textContent = "Delete", r = F(), o = E("button"), o.textContent = "Cancel", b(n, "class", "button-container svelte-1osm0n1"), b(e, "class", "svelte-1osm0n1");
    },
    m(f, d) {
      T(f, e, d), A(e, t), A(e, s), A(e, n), A(n, l), A(n, r), A(n, o), a || (c = [
        W(l, "click", st(
          /*click_handler*/
          i[3]
        )),
        W(o, "click", st(
          /*click_handler_1*/
          i[4]
        ))
      ], a = !0);
    },
    p: se,
    i: se,
    o: se,
    d(f) {
      f && C(e), a = !1, Me(c);
    }
  };
}
u(ace, "create_fragment$1T");
function cce(i, e, t) {
  let { dialog: s } = de("#external").application, { dialog: n = s } = e;
  function l() {
    n.submit({ confirmDeletion: !0 });
  }
  u(l, "onSubmit");
  function r() {
    n.submit({ confirmDeletion: !1 });
  }
  u(r, "onCancelDeletion");
  const o = /* @__PURE__ */ u(() => l(), "click_handler"), a = /* @__PURE__ */ u(() => r(), "click_handler_1");
  return i.$$set = (c) => {
    "dialog" in c && t(2, n = c.dialog);
  }, [l, r, n, o, a];
}
u(cce, "instance$1K");
var Wa;
let uce = (Wa = class extends re {
  constructor(e) {
    super(), oe(this, e, cce, ace, le, { dialog: 2 });
  }
}, u(Wa, "SpellbookDeletionConfirmationDialog"), Wa);
var Zf, cv;
const KS = class KS extends Un {
  constructor() {
    super(
      {
        title: "Confirm Spellbook Deletion",
        content: {
          class: uce,
          props: {}
        }
      },
      {
        classes: ["a5e-sheet"],
        width: 420
      }
    );
    x(this, Zf);
    this.data.content.props.dialog = this, this.promise = new Promise((t) => {
      this.resolve = t;
    });
  }
  /** @inheritdoc */
  close(t) {
    return X(this, Zf, cv).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return X(this, Zf, cv).call(this, t), super.close();
  }
};
Zf = new WeakSet(), cv = /* @__PURE__ */ u(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), u(KS, "SpellbookDeletionConfirmationDialog");
let av = KS;
function T6(i, e, t) {
  const s = i.slice();
  return s[35] = e[t][0], s[36] = e[t][1], s[38] = t, s;
}
u(T6, "get_each_context$F");
function O6(i) {
  let e, t, s = ue([.../*spellBooks*/
  i[9]]), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = I6(T6(i, s, r));
  let l = !/*sheetIsLocked*/
  i[0] && P6(i);
  return {
    c() {
      e = E("nav");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      t = F(), l && l.c(), b(e, "class", "a5e-spellbook-list svelte-f4y3ce");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      A(e, t), l && l.m(e, null);
    },
    p(r, o) {
      if (o[0] & /*currentSpellBook, spellBooks, updateCurrentSpellBook, deleteSpellbook, configureSpellbook, sheetIsLocked*/
      229897) {
        s = ue([.../*spellBooks*/
        r[9]]);
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = T6(r, s, a);
          n[a] ? n[a].p(c, o) : (n[a] = I6(c), n[a].c(), n[a].m(e, t));
        }
        for (; a < n.length; a += 1)
          n[a].d(1);
        n.length = s.length;
      }
      /*sheetIsLocked*/
      r[0] ? l && (l.d(1), l = null) : l ? l.p(r, o) : (l = P6(r), l.c(), l.m(e, null));
    },
    d(r) {
      r && C(e), Le(n, r), l && l.d();
    }
  };
}
u(O6, "create_if_block_9$7");
function D6(i) {
  let e, t, s, n, l;
  function r() {
    return (
      /*click_handler*/
      i[19](
        /*spellBookId*/
        i[35]
      )
    );
  }
  u(r, "click_handler");
  function o() {
    return (
      /*click_handler_1*/
      i[20](
        /*spellBookId*/
        i[35]
      )
    );
  }
  return u(o, "click_handler_1"), {
    c() {
      e = E("i"), t = F(), s = E("i"), b(e, "class", "a5e-control-button a5e-control-button--config fa-solid fa-gear svelte-f4y3ce"), b(s, "class", "a5e-control-button a5e-control-button--delete fa-solid fa-trash svelte-f4y3ce");
    },
    m(a, c) {
      T(a, e, c), T(a, t, c), T(a, s, c), n || (l = [
        W(e, "click", Ve(r)),
        W(s, "click", Ve(o))
      ], n = !0);
    },
    p(a, c) {
      i = a;
    },
    d(a) {
      a && (C(e), C(t), C(s)), n = !1, Me(l);
    }
  };
}
u(D6, "create_if_block_11$3");
function I6(i) {
  let e, t = (
    /*spellBook*/
    i[36].name + ""
  ), s, n, l, r, o = !/*sheetIsLocked*/
  i[0] && D6(i);
  function a() {
    return (
      /*click_handler_2*/
      i[21](
        /*spellBookId*/
        i[35]
      )
    );
  }
  return u(a, "click_handler_2"), {
    c() {
      e = E("button"), s = Q(t), n = F(), o && o.c(), b(e, "class", "a5e-spellbook-list__item svelte-f4y3ce"), Z(
        e,
        "a5e-spellbook-list__item--active",
        /*currentSpellBook*/
        i[3] ? (
          /*currentSpellBook*/
          i[3] === /*spellBookId*/
          i[35]
        ) : (
          /*index*/
          i[38] === 0
        )
      );
    },
    m(c, f) {
      T(c, e, f), A(e, s), A(e, n), o && o.m(e, null), l || (r = W(e, "click", a), l = !0);
    },
    p(c, f) {
      i = c, f[0] & /*spellBooks*/
      512 && t !== (t = /*spellBook*/
      i[36].name + "") && be(s, t), /*sheetIsLocked*/
      i[0] ? o && (o.d(1), o = null) : o ? o.p(i, f) : (o = D6(i), o.c(), o.m(e, null)), f[0] & /*currentSpellBook, spellBooks*/
      520 && Z(
        e,
        "a5e-spellbook-list__item--active",
        /*currentSpellBook*/
        i[3] ? (
          /*currentSpellBook*/
          i[3] === /*spellBookId*/
          i[35]
        ) : (
          /*index*/
          i[38] === 0
        )
      );
    },
    d(c) {
      c && C(e), o && o.d(), l = !1, r();
    }
  };
}
u(I6, "create_each_block$F");
function P6(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-spellbook-list__item a5e-spellbook-list__item--add fa-solid fa-plus svelte-f4y3ce"), b(e, "data-tooltip", "Create new spell book");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler_3*/
        i[22]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(P6, "create_if_block_10$6");
function M6(i) {
  let e = (
    /*currentSpellBook*/
    i[3]
  ), t, s, n = F6(i);
  return {
    c() {
      n.c(), t = $e();
    },
    m(l, r) {
      n.m(l, r), T(l, t, r), s = !0;
    },
    p(l, r) {
      r[0] & /*currentSpellBook*/
      8 && le(e, e = /*currentSpellBook*/
      l[3]) ? (ae(), O(n, 1, 1, se), ce(), n = F6(l), n.c(), w(n, 1), n.m(t.parentNode, t)) : n.p(l, r);
    },
    i(l) {
      s || (w(n), s = !0);
    },
    o(l) {
      O(n), s = !1;
    },
    d(l) {
      l && C(t), n.d(l);
    }
  };
}
u(M6, "create_if_block_8$8");
function F6(i) {
  let e, t;
  return e = new rv({
    props: {
      spellBookId: (
        /*currentSpellBook*/
        i[3]
      ),
      reducer: (
        /*$spells*/
        i[11]._books[
          /*currentSpellBook*/
          i[3]
        ]
      )
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*currentSpellBook*/
      8 && (l.spellBookId = /*currentSpellBook*/
      s[3]), n[0] & /*$spells, currentSpellBook*/
      2056 && (l.reducer = /*$spells*/
      s[11]._books[
        /*currentSpellBook*/
        s[3]
      ]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(F6, "create_key_block");
function R6(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = "Spells Prepared:", s = F(), n = E("span"), l = Q(
        /*preparedSpellCount*/
        i[10]
      ), b(t, "class", "u-mb-0 u-text-bold u-text-sm u-flex-grow-1"), b(n, "class", "a5e-footer-group__input"), b(e, "class", "u-flex u-flex-wrap u-align-center u-gap-md"), b(e, "data-tooltip", "This number does not include spells which are marked as always prepared."), b(e, "data-tooltip-direction", "UP");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(e, s), A(e, n), A(n, l);
    },
    p(r, o) {
      o[0] & /*preparedSpellCount*/
      1024 && be(
        l,
        /*preparedSpellCount*/
        r[10]
      );
    },
    d(r) {
      r && C(e);
    }
  };
}
u(R6, "create_if_block_7$a");
function N6(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.ArtifactCharges")}`, s = F(), n = E("input"), r = Q(`
            /
            `), o = E("input"), b(t, "class", "u-mb-0 u-text-bold u-text-sm u-flex-grow-1"), b(n, "class", "a5e-footer-group__input svelte-f4y3ce"), b(n, "type", "number"), b(n, "name", "system.spellResources.artifactCharges.current"), n.value = l = /*spellResources*/
      i[1].artifactCharges.current, b(n, "placeholder", "0"), b(n, "min", "0"), Z(n, "disable-pointer-events", !/*$actor*/
      i[2].isOwner), b(o, "class", "a5e-footer-group__input"), b(o, "type", "number"), b(o, "name", "system.spellResources.artifactCharges.max"), o.value = a = /*artifactChargesMax*/
      i[8] ?? 0, o.disabled = /*sheetIsLocked*/
      i[0], b(o, "placeholder", "0"), b(o, "min", "0"), b(e, "class", "u-flex u-flex-wrap u-align-center u-gap-md");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), c || (f = [
        W(
          n,
          "change",
          /*change_handler*/
          i[23]
        ),
        W(
          o,
          "change",
          /*change_handler_1*/
          i[24]
        )
      ], c = !0);
    },
    p(d, p) {
      p[0] & /*spellResources*/
      2 && l !== (l = /*spellResources*/
      d[1].artifactCharges.current) && n.value !== l && (n.value = l), p[0] & /*$actor*/
      4 && Z(n, "disable-pointer-events", !/*$actor*/
      d[2].isOwner), p[0] & /*artifactChargesMax*/
      256 && a !== (a = /*artifactChargesMax*/
      d[8] ?? 0) && o.value !== a && (o.value = a), p[0] & /*sheetIsLocked*/
      1 && (o.disabled = /*sheetIsLocked*/
      d[0]);
    },
    d(d) {
      d && C(e), c = !1, Me(f);
    }
  };
}
u(N6, "create_if_block_6$c");
function j6(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.SpellInventions")}`, s = F(), n = E("input"), b(t, "class", "u-mb-0 u-text-bold u-text-sm u-flex-grow-1"), b(n, "class", "a5e-footer-group__input"), b(n, "type", "number"), b(n, "name", "system.spellResources.inventions.max"), n.value = l = /*spellInventionsMax*/
      i[7] ?? 0, n.disabled = /*sheetIsLocked*/
      i[0], b(n, "placeholder", "0"), b(n, "min", "0"), b(e, "class", "u-flex u-flex-wrap u-align-center u-gap-md");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, s), A(e, n), r || (o = W(
        n,
        "change",
        /*change_handler_2*/
        i[25]
      ), r = !0);
    },
    p(a, c) {
      c[0] & /*spellInventionsMax*/
      128 && l !== (l = /*spellInventionsMax*/
      a[7] ?? 0) && n.value !== l && (n.value = l), c[0] & /*sheetIsLocked*/
      1 && (n.disabled = /*sheetIsLocked*/
      a[0]);
    },
    d(a) {
      a && C(e), r = !1, o();
    }
  };
}
u(j6, "create_if_block_5$d");
function fce(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m = (
    /*exertion*/
    i[5].current < /*exertion*/
    i[5].max && /*exertion*/
    i[5].max && L6(i)
  );
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.ExertionPool")}`, s = F(), n = E("input"), r = Q(`
            /
            `), o = E("input"), f = F(), m && m.c(), b(t, "class", "u-mb-0 u-text-sm u-text-bold"), b(n, "class", "a5e-footer-group__input svelte-f4y3ce"), b(n, "type", "number"), b(n, "name", "system.attributes.exertion.current"), n.value = l = /*exertion*/
      i[5].current, b(n, "placeholder", "0"), b(n, "min", "0"), Z(n, "disable-pointer-events", !/*$actor*/
      i[2].isOwner), b(o, "class", "a5e-footer-group__input"), b(o, "type", "number"), b(o, "name", "system.attributes.exertion.max"), o.value = a = /*exertion*/
      i[5].max, o.disabled = c = /*$actor*/
      i[2].automationAvailable, b(o, "placeholder", "0"), b(o, "min", "0"), b(e, "class", "u-flex u-align-center u-gap-md");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), A(e, f), m && m.m(e, null), d || (p = [
        W(
          n,
          "change",
          /*change_handler_5*/
          i[29]
        ),
        W(
          o,
          "change",
          /*change_handler_6*/
          i[30]
        )
      ], d = !0);
    },
    p(g, h) {
      h[0] & /*exertion*/
      32 && l !== (l = /*exertion*/
      g[5].current) && n.value !== l && (n.value = l), h[0] & /*$actor*/
      4 && Z(n, "disable-pointer-events", !/*$actor*/
      g[2].isOwner), h[0] & /*exertion*/
      32 && a !== (a = /*exertion*/
      g[5].max) && o.value !== a && (o.value = a), h[0] & /*$actor*/
      4 && c !== (c = /*$actor*/
      g[2].automationAvailable) && (o.disabled = c), /*exertion*/
      g[5].current < /*exertion*/
      g[5].max && /*exertion*/
      g[5].max ? m ? m.p(g, h) : (m = L6(g), m.c(), m.m(e, null)) : m && (m.d(1), m = null);
    },
    d(g) {
      g && C(e), m && m.d(), d = !1, Me(p);
    }
  };
}
u(fce, "create_else_block$m");
function dce(i) {
  var n, l;
  let e = (
    /*$actor*/
    ((l = (n = i[2].spellBooks) == null ? void 0 : n.get(
      /*currentSpellBook*/
      i[3]
    )) == null ? void 0 : l.showSpellPoints) ?? !1
  ), t, s = e && B6(i);
  return {
    c() {
      s && s.c(), t = $e();
    },
    m(r, o) {
      s && s.m(r, o), T(r, t, o);
    },
    p(r, o) {
      var a, c;
      o[0] & /*$actor, currentSpellBook*/
      12 && (e = /*$actor*/
      ((c = (a = r[2].spellBooks) == null ? void 0 : a.get(
        /*currentSpellBook*/
        r[3]
      )) == null ? void 0 : c.showSpellPoints) ?? !1), e ? s ? s.p(r, o) : (s = B6(r), s.c(), s.m(t.parentNode, t)) : s && (s.d(1), s = null);
    },
    d(r) {
      r && C(t), s && s.d(r);
    }
  };
}
u(dce, "create_if_block_1$H");
function L6(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = '<i class="fa-solid fa-bolt"></i>', b(e, "class", "recharge-button svelte-f4y3ce"), b(e, "data-tooltip", "A5E.ExertionRechargeFromHitDice"), b(e, "data-tooltip-direction", "UP");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler_5*/
        i[31]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(L6, "create_if_block_4$i");
function B6(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p = (
    /*spellResources*/
    i[1].points.current < /*spellPointMax*/
    i[6] && /*spellPointMax*/
    i[6] && /*startingClass*/
    i[4] === "psion" && q6(i)
  );
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.SpellPoints")}`, s = F(), n = E("input"), r = Q(`
                /
                `), o = E("input"), c = F(), p && p.c(), b(t, "class", "u-mb-0 u-text-bold u-text-sm u-flex-grow-1"), b(n, "class", "a5e-footer-group__input svelte-f4y3ce"), b(n, "type", "number"), b(n, "name", "system.spellResources.points.current"), n.value = l = /*spellResources*/
      i[1].points.current, b(n, "placeholder", "0"), b(n, "min", "0"), Z(n, "disable-pointer-events", !/*$actor*/
      i[2].isOwner), b(o, "class", "a5e-footer-group__input"), b(o, "type", "number"), b(o, "name", "system.spellResources.points.max"), o.value = a = /*spellPointMax*/
      i[6] ?? 0, o.disabled = /*sheetIsLocked*/
      i[0], b(o, "placeholder", "0"), b(o, "min", "0"), b(e, "class", "u-flex u-flex-wrap u-align-center u-gap-md");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), A(e, c), p && p.m(e, null), f || (d = [
        W(
          n,
          "change",
          /*change_handler_3*/
          i[26]
        ),
        W(
          o,
          "change",
          /*change_handler_4*/
          i[27]
        )
      ], f = !0);
    },
    p(m, g) {
      g[0] & /*spellResources*/
      2 && l !== (l = /*spellResources*/
      m[1].points.current) && n.value !== l && (n.value = l), g[0] & /*$actor*/
      4 && Z(n, "disable-pointer-events", !/*$actor*/
      m[2].isOwner), g[0] & /*spellPointMax*/
      64 && a !== (a = /*spellPointMax*/
      m[6] ?? 0) && o.value !== a && (o.value = a), g[0] & /*sheetIsLocked*/
      1 && (o.disabled = /*sheetIsLocked*/
      m[0]), /*spellResources*/
      m[1].points.current < /*spellPointMax*/
      m[6] && /*spellPointMax*/
      m[6] && /*startingClass*/
      m[4] === "psion" ? p ? p.p(m, g) : (p = q6(m), p.c(), p.m(e, null)) : p && (p.d(1), p = null);
    },
    d(m) {
      m && C(e), p && p.d(), f = !1, Me(d);
    }
  };
}
u(B6, "create_if_block_2$w");
function q6(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = '<i class="fa-solid fa-brain"></i>', b(e, "class", "recharge-button svelte-f4y3ce"), b(e, "data-tooltip", "A5E.PsionicPointsRechargeFromHitDice"), b(e, "data-tooltip-direction", "UP");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler_4*/
        i[28]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(q6, "create_if_block_3$l");
function G6(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.CasterLevel")}`, s = F(), n = E("input"), b(t, "class", "u-mb-0 u-text-bold u-text-sm u-flex-grow-1"), b(n, "class", "a5e-footer-group__input svelte-f4y3ce"), b(n, "type", "number"), b(n, "name", "system.attributes.casterLevel"), n.value = l = /*$actor*/
      i[2].system.attributes.casterLevel, b(n, "placeholder", "0"), b(n, "min", "0"), Z(n, "disable-pointer-events", !/*$actor*/
      i[2].isOwner || /*sheetIsLocked*/
      i[0]), b(e, "class", "u-flex u-flex-wrap u-align-center u-gap-md");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, s), A(e, n), r || (o = W(
        n,
        "change",
        /*change_handler_7*/
        i[32]
      ), r = !0);
    },
    p(a, c) {
      c[0] & /*$actor*/
      4 && l !== (l = /*$actor*/
      a[2].system.attributes.casterLevel) && n.value !== l && (n.value = l), c[0] & /*$actor, sheetIsLocked*/
      5 && Z(n, "disable-pointer-events", !/*$actor*/
      a[2].isOwner || /*sheetIsLocked*/
      a[0]);
    },
    d(a) {
      a && C(e), r = !1, o();
    }
  };
}
u(G6, "create_if_block$_");
function pce(i) {
  var h, _, y, v;
  let e, t = (
    /*$actor*/
    ((_ = (h = i[2].spellBooks) == null ? void 0 : h.get(
      /*currentSpellBook*/
      i[3]
    )) == null ? void 0 : _.showArtifactCharges) ?? !1
  ), s, n = (
    /*$actor*/
    ((v = (y = i[2].spellBooks) == null ? void 0 : y.get(
      /*currentSpellBook*/
      i[3]
    )) == null ? void 0 : v.showSpellInventions) ?? !1
  ), l, r, o, a = (
    /*preparedSpellCount*/
    i[10] && R6(i)
  ), c = t && N6(i), f = n && j6(i);
  function d(k, S) {
    return (
      /*startingClass*/
      k[4] !== "psyknight" ? dce : fce
    );
  }
  u(d, "select_block_type");
  let p = d(i), m = p(i), g = (
    /*$actor*/
    i[2].type === "npc" && G6(i)
  );
  return {
    c() {
      a && a.c(), e = F(), c && c.c(), s = F(), f && f.c(), l = F(), m.c(), r = F(), g && g.c(), o = $e();
    },
    m(k, S) {
      a && a.m(k, S), T(k, e, S), c && c.m(k, S), T(k, s, S), f && f.m(k, S), T(k, l, S), m.m(k, S), T(k, r, S), g && g.m(k, S), T(k, o, S);
    },
    p(k, S) {
      var D, I, M, L;
      /*preparedSpellCount*/
      k[10] ? a ? a.p(k, S) : (a = R6(k), a.c(), a.m(e.parentNode, e)) : a && (a.d(1), a = null), S[0] & /*$actor, currentSpellBook*/
      12 && (t = /*$actor*/
      ((I = (D = k[2].spellBooks) == null ? void 0 : D.get(
        /*currentSpellBook*/
        k[3]
      )) == null ? void 0 : I.showArtifactCharges) ?? !1), t ? c ? c.p(k, S) : (c = N6(k), c.c(), c.m(s.parentNode, s)) : c && (c.d(1), c = null), S[0] & /*$actor, currentSpellBook*/
      12 && (n = /*$actor*/
      ((L = (M = k[2].spellBooks) == null ? void 0 : M.get(
        /*currentSpellBook*/
        k[3]
      )) == null ? void 0 : L.showSpellInventions) ?? !1), n ? f ? f.p(k, S) : (f = j6(k), f.c(), f.m(l.parentNode, l)) : f && (f.d(1), f = null), p === (p = d(k)) && m ? m.p(k, S) : (m.d(1), m = p(k), m && (m.c(), m.m(r.parentNode, r))), /*$actor*/
      k[2].type === "npc" ? g ? g.p(k, S) : (g = G6(k), g.c(), g.m(o.parentNode, o)) : g && (g.d(1), g = null);
    },
    d(k) {
      k && (C(e), C(s), C(l), C(r), C(o)), a && a.d(k), c && c.d(k), f && f.d(k), m.d(k), g && g.d(k);
    }
  };
}
u(pce, "create_default_slot$Q");
function mce(i) {
  let e, t, s, n, l, r = (!/*sheetIsLocked*/
  i[0] || [.../*spellBooks*/
  i[9]].length > 1) && O6(i), o = (
    /*currentSpellBook*/
    i[3] && /*$spells*/
    i[11]._books[
      /*currentSpellBook*/
      i[3]
    ] && M6(i)
  );
  return s = new kc({
    props: {
      $$slots: { default: [pce] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      r && r.c(), e = F(), o && o.c(), t = F(), n = E("div"), j(s.$$.fragment), G(n, "display", "contents"), G(n, "--padding-right", "1rem");
    },
    m(a, c) {
      r && r.m(a, c), T(a, e, c), o && o.m(a, c), T(a, t, c), T(a, n, c), R(s, n, null), l = !0;
    },
    p(a, c) {
      !/*sheetIsLocked*/
      a[0] || [.../*spellBooks*/
      a[9]].length > 1 ? r ? r.p(a, c) : (r = O6(a), r.c(), r.m(e.parentNode, e)) : r && (r.d(1), r = null), /*currentSpellBook*/
      a[3] && /*$spells*/
      a[11]._books[
        /*currentSpellBook*/
        a[3]
      ] ? o ? (o.p(a, c), c[0] & /*currentSpellBook, $spells*/
      2056 && w(o, 1)) : (o = M6(a), o.c(), w(o, 1), o.m(t.parentNode, t)) : o && (ae(), O(o, 1, 1, () => {
        o = null;
      }), ce());
      const f = {};
      c[0] & /*$actor, sheetIsLocked, spellResources, spellPointMax, startingClass, currentSpellBook, exertion, spellInventionsMax, artifactChargesMax, preparedSpellCount*/
      1535 | c[1] & /*$$scope*/
      256 && (f.$$scope = { dirty: c, ctx: a }), s.$set(f);
    },
    i(a) {
      l || (w(o), w(s.$$.fragment, a), l = !0);
    },
    o(a) {
      O(o), O(s.$$.fragment, a), l = !1;
    },
    d(a) {
      a && (C(e), C(t)), r && r.d(a), o && o.d(a), a && s && C(n), N(s, a);
    }
  };
}
u(mce, "create_fragment$1S");
function hce(i, e, t) {
  var Pe, ye;
  let s, n, l, r, o, a, c, f, d, p, m;
  const g = de("actor");
  pe(i, g, (me) => t(2, m = me));
  let { spells: h } = g;
  pe(i, h, (me) => t(11, p = me));
  async function _() {
    const me = Object.keys(m.system.spellBooks ?? {}).length, Ce = await m.spellBooks.add({});
    h.initialize(), me === 0 ? S(Ce) : t(3, M), y(Ce);
  }
  u(_, "addSpellBook");
  async function y(me) {
    await new gi(m, "Configure Spell Book", ov, { spellBookId: me }).render(!0);
  }
  u(y, "configureSpellbook");
  async function v(me) {
    var Re;
    const Ce = Object.keys(m.system.spellBooks ?? {}).length, Je = new av();
    await Je.render(!0);
    const { confirmDeletion: Ne } = await Je.promise;
    if (Ne && (m.spellBooks.remove(me), Ce === 1 && S(null), M === me)) {
      const ge = (Re = Object.keys(m.system.spellBooks ?? {})) == null ? void 0 : Re[0];
      S(ge);
    }
  }
  u(v, "deleteSpellbook");
  function k(me) {
    return m.type !== "character" || l ? s[me].max : s[me].override;
  }
  u(k, "getMaxSpellResource");
  function S(me) {
    const { uuid: Ce } = m;
    t(3, M = me), al.update((Je) => ({
      ...Je,
      [Ce]: {
        ...Je[Ce] ?? {},
        currentSpellBook: me
      }
    }));
  }
  u(S, "updateCurrentSpellBook");
  function D(me, Ce) {
    const Je = m.type === "character" ? `system.spellResources.${me}.override` : `system.spellResources.${me}.max`;
    te(m, Je, Ce);
  }
  u(D, "updateMaxSpellResource");
  let I = {};
  al.subscribe((me) => {
    I = me;
  });
  let M = ((Pe = I[m == null ? void 0 : m.uuid]) == null ? void 0 : Pe.currentSpellBook) ?? ((ye = Object.keys(m.system.spellBooks ?? {})) == null ? void 0 : ye[0]);
  p._books[M] || h.initialize();
  const L = /* @__PURE__ */ u((me) => y(me), "click_handler"), B = /* @__PURE__ */ u((me) => v(me), "click_handler_1"), z = /* @__PURE__ */ u((me) => S(me), "click_handler_2"), q = /* @__PURE__ */ u(() => _(), "click_handler_3"), U = /* @__PURE__ */ u(({ target: me }) => te(m, me.name, Number(me.value)), "change_handler"), H = /* @__PURE__ */ u(({ target: me }) => D("artifactCharges", Number(me.value)), "change_handler_1"), V = /* @__PURE__ */ u(({ target: me }) => D("inventions", Number(me.value)), "change_handler_2"), Y = /* @__PURE__ */ u(({ target: me }) => te(m, me.name, Number(me.value)), "change_handler_3"), J = /* @__PURE__ */ u(({ target: me }) => D("points", Number(me.value)), "change_handler_4"), fe = /* @__PURE__ */ u(() => m.recoverPsionicPointsUsingHitDice(), "click_handler_4"), ke = /* @__PURE__ */ u(({ target: me }) => te(m, me.name, Number(me.value)), "change_handler_5"), ee = /* @__PURE__ */ u(({ target: me }) => te(m, me.name, Number(me.value)), "change_handler_6"), ne = /* @__PURE__ */ u(() => m.recoverExertionUsingHitDice(), "click_handler_5"), Ee = /* @__PURE__ */ u(({ target: me }) => te(m, me.name, Number(me.value)), "change_handler_7");
  return i.$$.update = () => {
    var me, Ce, Je;
    i.$$.dirty[0] & /*$actor*/
    4 && t(1, s = m.system.spellResources), i.$$.dirty[0] & /*$actor*/
    4 && t(10, n = m.items.filter((Ne) => !(Ne.type !== "spell" || !Ne.system.prepared || Ne.system.prepared === CONFIG.A5E.PREPARED_STATES.ALWAYS_PREPARED)).length), i.$$.dirty[0] & /*$actor*/
    4 && t(0, l = m.isOwner ? ((Ce = (me = m.flags) == null ? void 0 : me.a5e) == null ? void 0 : Ce.sheetIsLocked) ?? !0 : !0), i.$$.dirty[0] & /*$actor*/
    4 && t(9, r = m.spellBooks), i.$$.dirty[0] & /*spellResources, sheetIsLocked*/
    3 && t(8, o = k("artifactCharges")), i.$$.dirty[0] & /*spellResources, sheetIsLocked*/
    3 && t(7, a = k("inventions")), i.$$.dirty[0] & /*spellResources, sheetIsLocked*/
    3 && t(6, c = k("points")), i.$$.dirty[0] & /*$actor*/
    4 && t(5, f = m.system.attributes.exertion), i.$$.dirty[0] & /*$actor*/
    4 && t(4, d = (Je = m.system.classes) == null ? void 0 : Je.startingClass);
  }, [
    l,
    s,
    m,
    M,
    d,
    f,
    c,
    a,
    o,
    r,
    n,
    p,
    g,
    h,
    _,
    y,
    v,
    S,
    D,
    L,
    B,
    z,
    q,
    U,
    H,
    V,
    Y,
    J,
    fe,
    ke,
    ee,
    ne,
    Ee
  ];
}
u(hce, "instance$1J");
const YS = class YS extends re {
  constructor(e) {
    super(), oe(this, e, hce, mce, le, {}, null, [-1, -1]);
  }
};
u(YS, "ActorSpellsPage");
let uv = YS;
function gce(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("li"), b(e, "class", t = "a5e-nav-item " + /*icon*/
      i[2]), b(e, "data-tooltip", s = K(
        /*label*/
        i[3]
      )), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "a5e-nav-item--active",
        /*name*/
        i[1] === /*currentTab*/
        i[0].name
      );
    },
    m(r, o) {
      T(r, e, o), n || (l = W(
        e,
        "click",
        /*click_handler*/
        i[5]
      ), n = !0);
    },
    p(r, [o]) {
      o & /*icon*/
      4 && t !== (t = "a5e-nav-item " + /*icon*/
      r[2]) && b(e, "class", t), o & /*label*/
      8 && s !== (s = K(
        /*label*/
        r[3]
      )) && b(e, "data-tooltip", s), o & /*icon, name, currentTab*/
      7 && Z(
        e,
        "a5e-nav-item--active",
        /*name*/
        r[1] === /*currentTab*/
        r[0].name
      );
    },
    i: se,
    o: se,
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(gce, "create_fragment$1R");
function bce(i, e, t) {
  let { currentTab: s } = e, { name: n } = e, { icon: l } = e, { label: r } = e;
  const o = ft(), a = /* @__PURE__ */ u(() => o("tab-change", n), "click_handler");
  return i.$$set = (c) => {
    "currentTab" in c && t(0, s = c.currentTab), "name" in c && t(1, n = c.name), "icon" in c && t(2, l = c.icon), "label" in c && t(3, r = c.label);
  }, [s, n, l, r, o, a];
}
u(bce, "instance$1I");
const XS = class XS extends re {
  constructor(e) {
    super(), oe(this, e, bce, gce, le, {
      currentTab: 0,
      name: 1,
      icon: 2,
      label: 3
    });
  }
};
u(XS, "NewNavigationItem");
let fv = XS;
function z6(i, e, t) {
  const s = i.slice();
  return s[9] = e[t].name, s[10] = e[t].display, s[11] = e[t].icon, s[12] = e[t].label, s;
}
u(z6, "get_each_context$E");
function H6(i, e, t) {
  const s = i.slice();
  return s[9] = e[t].name, s[12] = e[t].label, s;
}
u(H6, "get_each_context_1$7");
function U6(i) {
  let e, t = K(
    /*label*/
    i[12]
  ) + "", s;
  return {
    c() {
      e = E("span"), s = Q(t), b(e, "class", "a5e-nav__current-tab-label"), Z(
        e,
        "a5e-nav__current-tab-label--active",
        /*name*/
        i[9] === /*currentTab*/
        i[0].name
      );
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*tabs*/
      2 && t !== (t = K(
        /*label*/
        n[12]
      ) + "") && be(s, t), l & /*tabs, currentTab*/
      3 && Z(
        e,
        "a5e-nav__current-tab-label--active",
        /*name*/
        n[9] === /*currentTab*/
        n[0].name
      );
    },
    d(n) {
      n && C(e);
    }
  };
}
u(U6, "create_each_block_1$7");
function V6(i) {
  let e, t;
  return e = new fv({
    props: {
      icon: (
        /*icon*/
        i[11]
      ),
      label: (
        /*label*/
        i[12]
      ),
      name: (
        /*name*/
        i[9]
      ),
      currentTab: (
        /*currentTab*/
        i[0]
      )
    }
  }), e.$on(
    "tab-change",
    /*tab_change_handler*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*tabs*/
      2 && (l.icon = /*icon*/
      s[11]), n & /*tabs*/
      2 && (l.label = /*label*/
      s[12]), n & /*tabs*/
      2 && (l.name = /*name*/
      s[9]), n & /*currentTab*/
      1 && (l.currentTab = /*currentTab*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(V6, "create_if_block_1$G");
function W6(i) {
  let e, t, s = (
    /*display*/
    (i[10] ?? !0) && V6(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*display*/
      n[10] ?? !0 ? s ? (s.p(n, l), l & /*tabs*/
      2 && w(s, 1)) : (s = V6(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(W6, "create_each_block$E");
function K6(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("li"), b(e, "class", t = "a5e-nav-item a5e-nav-item--lock fa-solid " + /*sheetIsLocked*/
      (i[4] ? "fa-lock" : "fa-unlock")), b(e, "data-tooltip", "Toggle Sheet Lock"), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "a5e-nav-item--active",
        /*sheetIsLocked*/
        i[4]
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "click",
        /*click_handler*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*sheetIsLocked*/
      16 && t !== (t = "a5e-nav-item a5e-nav-item--lock fa-solid " + /*sheetIsLocked*/
      (l[4] ? "fa-lock" : "fa-unlock")) && b(e, "class", t), r & /*sheetIsLocked, sheetIsLocked*/
      16 && Z(
        e,
        "a5e-nav-item--active",
        /*sheetIsLocked*/
        l[4]
      );
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(K6, "create_if_block$Z");
function _ce(i) {
  let e, t, s, n, l, r = ue(
    /*tabs*/
    i[1]
  ), o = [];
  for (let p = 0; p < r.length; p += 1)
    o[p] = U6(H6(i, r, p));
  let a = ue(
    /*tabs*/
    i[1]
  ), c = [];
  for (let p = 0; p < a.length; p += 1)
    c[p] = W6(z6(i, a, p));
  const f = /* @__PURE__ */ u((p) => O(c[p], 1, 1, () => {
    c[p] = null;
  }), "out");
  let d = (
    /*showLock*/
    i[2] && /*$actor*/
    i[3].permission !== /*observerPermissionsLevel*/
    i[6] && K6(i)
  );
  return {
    c() {
      e = E("nav");
      for (let p = 0; p < o.length; p += 1)
        o[p].c();
      t = F(), s = E("ul");
      for (let p = 0; p < c.length; p += 1)
        c[p].c();
      n = F(), d && d.c(), b(s, "class", "a5e-nav-list"), b(e, "class", "a5e-nav"), Z(
        e,
        "a5e-nav--flat-bottom",
        /*currentTab*/
        i[0].hasSubNavigation
      );
    },
    m(p, m) {
      T(p, e, m);
      for (let g = 0; g < o.length; g += 1)
        o[g] && o[g].m(e, null);
      A(e, t), A(e, s);
      for (let g = 0; g < c.length; g += 1)
        c[g] && c[g].m(s, null);
      A(s, n), d && d.m(s, null), l = !0;
    },
    p(p, [m]) {
      if (m & /*tabs, currentTab*/
      3) {
        r = ue(
          /*tabs*/
          p[1]
        );
        let g;
        for (g = 0; g < r.length; g += 1) {
          const h = H6(p, r, g);
          o[g] ? o[g].p(h, m) : (o[g] = U6(h), o[g].c(), o[g].m(e, t));
        }
        for (; g < o.length; g += 1)
          o[g].d(1);
        o.length = r.length;
      }
      if (m & /*tabs, currentTab*/
      3) {
        a = ue(
          /*tabs*/
          p[1]
        );
        let g;
        for (g = 0; g < a.length; g += 1) {
          const h = z6(p, a, g);
          c[g] ? (c[g].p(h, m), w(c[g], 1)) : (c[g] = W6(h), c[g].c(), w(c[g], 1), c[g].m(s, n));
        }
        for (ae(), g = a.length; g < c.length; g += 1)
          f(g);
        ce();
      }
      /*showLock*/
      p[2] && /*$actor*/
      p[3].permission !== /*observerPermissionsLevel*/
      p[6] ? d ? d.p(p, m) : (d = K6(p), d.c(), d.m(s, null)) : d && (d.d(1), d = null), (!l || m & /*currentTab*/
      1) && Z(
        e,
        "a5e-nav--flat-bottom",
        /*currentTab*/
        p[0].hasSubNavigation
      );
    },
    i(p) {
      if (!l) {
        for (let m = 0; m < a.length; m += 1)
          w(c[m]);
        l = !0;
      }
    },
    o(p) {
      c = c.filter(Boolean);
      for (let m = 0; m < c.length; m += 1)
        O(c[m]);
      l = !1;
    },
    d(p) {
      p && C(e), Le(o, p), Le(c, p), d && d.d();
    }
  };
}
u(_ce, "create_fragment$1Q");
function yce(i, e, t) {
  let s, n, { currentTab: l } = e, { tabs: r } = e, { showLock: o = !1 } = e;
  const a = de("actor");
  pe(i, a, (p) => t(3, n = p));
  const c = CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER;
  function f(p) {
    bt.call(this, i, p);
  }
  u(f, "tab_change_handler");
  const d = /* @__PURE__ */ u(({ target: p }) => {
    AB(n), p.blur();
  }, "click_handler");
  return i.$$set = (p) => {
    "currentTab" in p && t(0, l = p.currentTab), "tabs" in p && t(1, r = p.tabs), "showLock" in p && t(2, o = p.showLock);
  }, i.$$.update = () => {
    var p, m;
    i.$$.dirty & /*$actor*/
    8 && t(4, s = n.isOwner ? ((m = (p = n.flags) == null ? void 0 : p.a5e) == null ? void 0 : m.sheetIsLocked) ?? !0 : !0);
  }, [
    l,
    r,
    o,
    n,
    s,
    a,
    c,
    f,
    d
  ];
}
u(yce, "instance$1H");
const JS = class JS extends re {
  constructor(e) {
    super(), oe(this, e, yce, _ce, le, { currentTab: 0, tabs: 1, showLock: 2 });
  }
};
u(JS, "NewNavigationBar");
let dv = JS;
function vce(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p;
  t = new lv({}), l = new X0({}), o = new dv({
    props: {
      currentTab: (
        /*currentTab*/
        i[3]
      ),
      tabs: (
        /*tabs*/
        i[2]
      ),
      showLock: !0
    }
  }), o.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[4]
  );
  var m = (
    /*currentTab*/
    i[3].component
  );
  function g(h, _) {
    return {};
  }
  return u(g, "switch_props"), m && (c = et(m, g())), {
    c() {
      e = E("main"), j(t.$$.fragment), s = F(), n = E("section"), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), c && j(c.$$.fragment), b(n, "class", "main-container svelte-1w2h5ga"), b(e, "class", "svelte-1w2h5ga");
    },
    m(h, _) {
      T(h, e, _), R(t, e, null), A(e, s), A(e, n), R(l, n, null), A(n, r), R(o, n, null), A(n, a), c && R(c, n, null), f = !0, d || (p = W(e, "drop", Ve(st(
        /*drop_handler*/
        i[9]
      ))), d = !0);
    },
    p(h, _) {
      const y = {};
      if (_ & /*currentTab*/
      8 && (y.currentTab = /*currentTab*/
      h[3]), _ & /*tabs*/
      4 && (y.tabs = /*tabs*/
      h[2]), o.$set(y), _ & /*currentTab*/
      8 && m !== (m = /*currentTab*/
      h[3].component)) {
        if (c) {
          ae();
          const v = c;
          O(v.$$.fragment, 1, 0, () => {
            N(v, 1);
          }), ce();
        }
        m ? (c = et(m, g()), j(c.$$.fragment), w(c.$$.fragment, 1), R(c, n, null)) : c = null;
      }
    },
    i(h) {
      f || (w(t.$$.fragment, h), w(l.$$.fragment, h), w(o.$$.fragment, h), c && w(c.$$.fragment, h), f = !0);
    },
    o(h) {
      O(t.$$.fragment, h), O(l.$$.fragment, h), O(o.$$.fragment, h), c && O(c.$$.fragment, h), f = !1;
    },
    d(h) {
      h && C(e), N(t), N(l), N(o), c && N(c), d = !1, p();
    }
  };
}
u(vce, "create_default_slot$P");
function kce(i) {
  let e, t, s;
  function n(r) {
    i[10](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [vce] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, sheet, currentTab, tabs*/
        16398 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(kce, "create_fragment$1P");
function wce(i, e, t) {
  let s;
  const n = de("#external");
  let { document: l, sheet: r } = n, { document: o = l, sheet: a = r } = e, { elementRoot: c } = e;
  function f(k) {
    const { uuid: S } = s, D = (k == null ? void 0 : k.detail) ?? "core";
    t(3, _ = h.find((I) => I.name === D) ?? h[0]), al.update((I) => ({
      ...I,
      [S]: { currentTab: (k == null ? void 0 : k.detail) ?? "core" }
    }));
  }
  u(f, "updateCurrentTab");
  function d(k) {
    var S, D, I, M, L, B;
    return [
      {
        name: "core",
        label: "A5E.TabCore",
        icon: "fa-solid fa-home",
        component: O0
      },
      {
        name: "skills",
        label: "A5E.TabSkills",
        icon: "fa-solid fa-graduation-cap",
        component: Dp,
        display: ((D = (S = k.flags) == null ? void 0 : S.a5e) == null ? void 0 : D.showFavoritesSection) ?? !0
      },
      {
        name: "inventory",
        label: "A5E.TabInventory",
        icon: "fa-solid fa-box-open",
        component: F0
      },
      {
        name: "features",
        label: "A5E.TabFeatures",
        icon: "fa-solid fa-table-list",
        component: I0
      },
      {
        name: "maneuvers",
        label: "A5E.TabManeuvers",
        icon: "fa-solid fa-hand-fist",
        component: R0,
        display: (M = (I = k.flags) == null ? void 0 : I.a5e) == null ? void 0 : M.showManeuverTab
      },
      {
        name: "spells",
        label: "A5E.TabSpells",
        icon: "fa-solid fa-wand-sparkles",
        component: uv,
        display: (B = (L = k.flags) == null ? void 0 : L.a5e) == null ? void 0 : B.showSpellTab
      },
      // {
      //     name: "biography",
      //     label: "A5E.TabBiography",
      //     component: ActorBioPage,
      //     display: actor.type === "character",
      // },
      {
        name: "notes",
        label: "A5E.TabNotes",
        icon: "fa-solid fa-file-lines",
        component: j0,
        hasSubNavigation: !0
      },
      {
        name: "bonuses",
        label: "Bonuses",
        icon: "fa-solid fa-angles-up",
        component: w0
      },
      {
        name: "effects",
        label: "A5E.TabEffects",
        icon: "fa-solid fa-person-rays",
        component: D0
      },
      {
        name: "settings",
        label: "A5E.TabSettings",
        icon: "fas fa-gear",
        component: U0,
        hasSubNavigation: !0,
        display: !k.pack && k.permission !== CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER.OBSERVER
      }
    ];
  }
  u(d, "getTabs");
  let p = {};
  const m = al.subscribe((k) => {
    p = k;
  }), g = o;
  pe(i, g, (k) => t(8, s = k));
  let h = d(s), _ = h.find((k) => {
    var S;
    return k.name === ((S = p[s == null ? void 0 : s.uuid]) == null ? void 0 : S.currentTab);
  }) ?? h[0];
  lt("actor", g), lt("sheet", a), Qt(() => {
    m();
  });
  const y = /* @__PURE__ */ u((k) => a._onDrop(k), "drop_handler");
  function v(k) {
    c = k, t(0, c);
  }
  return u(v, "applicationshell_elementRoot_binding"), i.$$set = (k) => {
    "document" in k && t(7, o = k.document), "sheet" in k && t(1, a = k.sheet), "elementRoot" in k && t(0, c = k.elementRoot);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    256 && t(2, h = d(s));
  }, [
    c,
    a,
    h,
    _,
    f,
    g,
    n,
    o,
    s,
    y,
    v
  ];
}
u(wce, "instance$1G");
var Ka;
let $ce = (Ka = class extends re {
  constructor(e) {
    super(), oe(this, e, wce, kce, le, {
      application: 6,
      document: 7,
      sheet: 1,
      elementRoot: 0
    });
  }
  get application() {
    return this.$$.ctx[6];
  }
  get document() {
    return this.$$.ctx[7];
  }
  set document(e) {
    this.$$set({ document: e }), Xe();
  }
  get sheet() {
    return this.$$.ctx[1];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
}, u(Ka, "ActorSheet"), Ka);
function Ace(i) {
  let e, t, s;
  return {
    c() {
      e = E("hr"), t = F(), s = E("div"), b(e, "class", "a5e-rule u-ml-xl u-mr-xl"), b(s, "class", "description-wrapper svelte-1wmarmd");
    },
    m(n, l) {
      T(n, e, l), T(n, t, l), T(n, s, l), s.innerHTML = /*description*/
      i[3];
    },
    p: se,
    d(n) {
      n && (C(e), C(t), C(s));
    }
  };
}
u(Ace, "create_if_block$Y");
function Ece(i) {
  let e, t, s, n, l, r, o, a, c = (
    /*$document*/
    i[2].name + ""
  ), f, d, p = (
    /*showDescription*/
    i[4] && Ace(i)
  );
  return {
    c() {
      e = E("main"), t = E("div"), s = E("img"), o = F(), a = E("h1"), f = Q(c), d = F(), p && p.c(), b(s, "class", "document-image svelte-1wmarmd"), ze(s.src, n = /*$document*/
      i[2].img) || b(s, "src", n), b(s, "alt", l = /*$document*/
      i[2].name), b(s, "title", r = /*$document*/
      i[2].name), b(t, "class", "image-wrapper svelte-1wmarmd"), b(a, "class", "document-name svelte-1wmarmd"), b(e, "class", "svelte-1wmarmd");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, s), A(e, o), A(e, a), A(a, f), A(e, d), p && p.m(e, null);
    },
    p(m, g) {
      g & /*$document*/
      4 && !ze(s.src, n = /*$document*/
      m[2].img) && b(s, "src", n), g & /*$document*/
      4 && l !== (l = /*$document*/
      m[2].name) && b(s, "alt", l), g & /*$document*/
      4 && r !== (r = /*$document*/
      m[2].name) && b(s, "title", r), g & /*$document*/
      4 && c !== (c = /*$document*/
      m[2].name + "") && be(f, c), /*showDescription*/
      m[4] && p.p(m, g);
    },
    d(m) {
      m && C(e), p && p.d();
    }
  };
}
u(Ece, "create_default_slot$O");
function Sce(i) {
  let e, t, s;
  function n(r) {
    i[6](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Ece] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, $document*/
        132 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(Sce, "create_fragment$1O");
function Cce(i, e, t) {
  let s, n = se, l = /* @__PURE__ */ u(() => (n(), n = Xt(a, (g) => t(2, s = g)), a), "$$subscribe_document");
  i.$$.on_destroy.push(() => n());
  let { document: r, sheet: o } = de("#external").application, { document: a = r, sheet: c = o } = e;
  l();
  let { elementRoot: f } = e;
  const d = s.system.unidentified ? s.system.unidentifiedDescription : s.system.description, p = d != null && d.length ? game.settings.get("a5e", "showDescriptionOnLimitedPerms") ?? !1 : !1;
  function m(g) {
    f = g, t(0, f);
  }
  return u(m, "applicationshell_elementRoot_binding"), i.$$set = (g) => {
    "document" in g && l(t(1, a = g.document)), "sheet" in g && t(5, c = g.sheet), "elementRoot" in g && t(0, f = g.elementRoot);
  }, [
    f,
    a,
    s,
    d,
    p,
    c,
    m
  ];
}
u(Cce, "instance$1F");
const ZS = class ZS extends re {
  constructor(e) {
    super(), oe(this, e, Cce, Sce, le, { document: 1, sheet: 5, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[1];
  }
  set document(e) {
    this.$$set({ document: e }), Xe();
  }
  get sheet() {
    return this.$$.ctx[5];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
};
u(ZS, "LimitedSheet");
let Rp = ZS;
function On(i) {
  if (!i) return;
  let e = `<header class="a5e-tooltip__heading a5e-tooltip__heading--source">${i.title}</header>`;
  return i.affiliate && (e += ' <small class="a5e-tooltip__note">Note: This is an affiliate link.</small>'), e;
}
u(On, "getDocumentSourceTooltip");
var In, RB, NB, jB, LB, BB, qB, Ya;
let Bg = (Ya = class extends Gs {
  /**
   * @inheritDoc
   */
  constructor(t, s = {}) {
    var n;
    s.svelte ?? (s.svelte = {}), [
      CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE,
      CONST.DOCUMENT_OWNERSHIP_LEVELS.LIMITED
      // @ts-expect-error
    ].includes(t.permission) ? (s.classes = ["a5e-sheet", "a5e-actor-sheet", "a5e-actor-sheet--limited"], s.svelte.class = Rp, s.width = 512, s.resizable = !1) : (s.svelte.class = $ce, s.width = 755, s.height = 706, s.resizable = !0);
    super(
      foundry.utils.mergeObject(s, {
        baseApplication: "ActorSheet",
        // @ts-expect-error
        id: `actor-sheet-${t.isToken ? (n = t.parent) == null ? void 0 : n.id : t.id}`,
        title: t.name,
        token: null,
        svelte: {
          props: {
            document: null
          }
        }
      })
    );
    x(this, In);
    qe(this, "actor");
    qe(this, "tempSettings");
    this.actor = t.isToken ? t.parent.actor : t, this.options.svelte.props.document = new k0(this.actor, {
      delete: this.close.bind(this)
    }), this.options.svelte.props.sheet = this, this.tempSettings = {}, al.subscribe((l) => {
      this.tempSettings = l;
    }), this.position.subscribe((l) => this.setPosition(l, !1));
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      baseApplication: "ActorSheet",
      classes: ["a5e-sheet", "a5e-actor-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      },
      token: null
    });
  }
  get document() {
    return this.actor;
  }
  get object() {
    return this.actor;
  }
  get token() {
    var t;
    return ((t = this.options) == null ? void 0 : t.token) || this.actor.token || null;
  }
  setPosition(t, s = !0) {
    return s ? super.setPosition(t) : this.position.get();
  }
  _getHeaderButtons() {
    var o, a, c;
    const t = super._getHeaderButtons(), s = {
      isGM: (o = game.user) == null ? void 0 : o.isGM,
      isOwner: this.actor.isOwner,
      canConfigure: (a = game.user) == null ? void 0 : a.can("TOKEN_CONFIGURE"),
      isPack: this.actor.pack
    };
    (s.isGM || s.isOwner && s.canConfigure) && t.unshift({
      label: this.options.token ? "Token" : "Prototype Token",
      class: "configure-token",
      icon: "fas fa-user-circle",
      onclick: /* @__PURE__ */ u(({ event: f }) => this._onConfigureToken(f), "onclick")
    }), s.isPack || t.unshift({
      label: "Sheet Configuration",
      class: "configure-sheet",
      icon: "fas fa-cog fa-fw",
      title: "Configure Sheet",
      onclick: /* @__PURE__ */ u(({ event: f }) => this._onConfigureSheet(f), "onclick")
    }), ((c = game.modules.get("warpgate")) == null ? void 0 : c.active) && !s.isPack && (s.isGM || s.isOwner && s.canConfigure) && (/* @__PURE__ */ u((d) => !(!(d instanceof TokenDocument) || warpgate.mutationStack(d).stack.length === 0), "shouldAddRevert"))(this.token) && t.unshift({
      label: "Revert",
      class: "revert-wrapgate",
      icon: "fas fa-undo-alt",
      title: "Revert",
      onclick: /* @__PURE__ */ u(async ({ event: d }) => {
        var _, y;
        const p = /* @__PURE__ */ u((v) => game.settings.get("warpgate", "revertButtonBehavior") === "menu" ? !v : v, "shouldShow"), m = (y = (_ = this.token) == null ? void 0 : _.actor) == null ? void 0 : y.getFlag("warpgate", "mutate");
        let g;
        if (p(d.shiftKey)) {
          const v = m.map((k) => ({
            label: k.name,
            value: k.name
          }));
          if (g = await warpgate.buttonDialog(
            { warpButtons: v, title: K("warpgate.display.revertDialogTitle") },
            "column"
          ), g === !1) return;
        }
        warpgate.revert(this.token), this == null || this.render(!1);
      }, "onclick")
    }), s.isPack && t.unshift({
      label: "Import",
      class: "import",
      icon: "fas fa-download",
      onclick: /* @__PURE__ */ u(({ event: f }) => this._onImport(f), "onclick")
    });
    const l = /* @__PURE__ */ new Set(), r = [];
    return t.forEach(({ label: f }, d) => {
      l.has(f) || (l.add(f), r.push(t[d]));
    }), r;
  }
  _onImport(t) {
    return t && t.preventDefault(), this.actor.collection.importFromCompendium(this.actor.compendium, this.actor.id);
  }
  _onConfigureToken(t) {
    return console.log(t), t && t.preventDefault(), this.token ? this.token.sheet.render(!0) : new CONFIG.Token.prototypeSheetClass(this.actor.prototypeToken).render(!0);
  }
  _onConfigureSheet(t) {
    t && t.preventDefault(), new DocumentSheetConfig(this.actor, { top: this.position.top + 40 }).render(!0);
  }
  async _onDrop(t, s = {}) {
    var d, p, m, g, h, _, y, v, k;
    const n = (d = t.dataTransfer) == null ? void 0 : d.getData("text/plain");
    if (!n) return;
    const l = JSON.parse(n);
    Hooks.callAll("dropActorSheetData", this.actor, this, l);
    const r = (p = this.tempSettings[this.actor.uuid]) == null ? void 0 : p.currentTab, o = ((m = this.tempSettings[this.actor.uuid]) == null ? void 0 : m.currentSpellBook) ?? ((_ = Object.keys((h = (g = this.actor) == null ? void 0 : g.system) == null ? void 0 : h.spellBooks)) == null ? void 0 : _[0]);
    if (r !== "inventory" && ((l == null ? void 0 : l.actorId) === ((y = this.actor) == null ? void 0 : y.id) || (l == null ? void 0 : l.parentId) === ((v = this.actor) == null ? void 0 : v.id)))
      return;
    o && (s.spellBookId = o);
    const { uuid: a, type: c } = l;
    let f = null;
    if (c)
      try {
        f = await ((k = CONFIG[c]) == null ? void 0 : k.documentClass).fromDropData(l);
      } catch {
        f = await fromUuid(a);
      }
    else
      f = await fromUuid(a);
    f && this._onDropDocument(f, s);
  }
  async _onDropDocument(t, s = {}) {
    t.documentName === "Actor" ? X(this, In, RB).call(this, t) : t.documentName === "Item" ? X(this, In, jB).call(this, t, s) : t.documentName === "ActiveEffect" && X(this, In, NB).call(this, t);
  }
  /** @inheritdoc */
  async close(t) {
    return this.options.token = null, super.close(t);
  }
  async _render(t = !1, s = {}) {
    var d, p, m, g, h, _, y;
    await super._render(t, s);
    const n = (d = this.element) == null ? void 0 : d[0];
    if (!n) return;
    const l = n.querySelector(".window-header .window-title");
    if (l.querySelector(".document-id-link")) return;
    const o = ((p = this.token) == null ? void 0 : p.id) ?? ((m = this.actor) == null ? void 0 : m.id), a = ((g = this.token) == null ? void 0 : g.uuid) ?? ((h = this.actor) == null ? void 0 : h.uuid), c = CONFIG.A5E.products[(y = (_ = this.actor) == null ? void 0 : _.system) == null ? void 0 : y.source];
    if (c != null && c.abbreviation) {
      const v = document.createElement("a");
      v.classList.add("a5e-document-source-link"), v.setAttribute("alt", c == null ? void 0 : c.title), v.dataset.tooltip = On(c), v.dataset.tooltipClass = "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source", v.dataset.tooltipDirection = "DOWN", v.innerHTML = `<i class="fa-solid fa-book-open"></i> ${c == null ? void 0 : c.abbreviation}`, v.href = c == null ? void 0 : c.url, v.target = "_blank", l.append(v);
    }
    const f = document.createElement("a");
    f.classList.add("document-id-link"), f.setAttribute("alt", "Copy Document ID"), f.dataset.tooltip = "Copy Document ID", f.dataset.tooltipDirection = "DOWN", f.innerHTML = '<i class="fa-solid fa-passport"></i>', f.addEventListener("click", (v) => {
      v.preventDefault(), game.clipboard.copyPlainText(o), ui.notifications.info(
        game.i18n.format("DOCUMENT.IdCopiedClipboard", {
          label: "Actor",
          type: "id",
          id: o
        })
      );
    }), f.addEventListener("contextmenu", (v) => {
      v.preventDefault(), game.clipboard.copyPlainText(a), ui.notifications.info(
        game.i18n.format("DOCUMENT.IdCopiedClipboard", {
          label: "Actor",
          type: "uuid",
          id: a
        })
      );
    }), l.append(f);
  }
}, In = new WeakSet(), RB = /* @__PURE__ */ u(async function(t) {
}, "#onDropActor"), NB = /* @__PURE__ */ u(async function(t) {
  this.actor.createEmbeddedDocuments("ActiveEffect", [t]);
}, "#onDropActiveEffect"), jB = /* @__PURE__ */ u(async function(t, s = {}) {
  t.isType("destiny") ? X(this, In, LB).call(this, t) : t.isType("object") ? X(this, In, BB).call(this, t, s) : t.isType("spell") ? X(this, In, qB).call(this, t, s) : this.actor.createEmbeddedDocuments("Item", [t]);
}, "#onDropItem"), LB = /* @__PURE__ */ u(async function(t) {
  if (!t.isType("destiny")) return;
  if (this.actor.type !== "character") {
    ui.notifications.warn("Destiny documents cannot be added to NPCs.");
    return;
  }
  await this.actor.setFlag("a5e", "destinyFulfilled", !1);
  const s = [t.system.sourceOfInspiration, t.system.inspirationFeature], n = (await Promise.all(s.map((l) => fromUuid(l)))).filter(
    (l) => l
  );
  await this.actor.createEmbeddedDocuments("Item", [t, ...n]);
}, "#onDropDestiny"), BB = /* @__PURE__ */ u(async function(t, s) {
  var l, r, o;
  if (((l = t == null ? void 0 : t.parent) == null ? void 0 : l.id) === this.actor.id) {
    t.updateContainer(s.containerUuid ?? "");
    return;
  }
  const n = t.toObject();
  n.system.containerId = s.containerUuid ?? "", (o = (r = await this.actor.createEmbeddedDocuments("Item", [n])) == null ? void 0 : r[0]) == null || o.updateContainer(s.containerUuid ?? "");
}, "#onDropObject"), qB = /* @__PURE__ */ u(async function(t, s) {
  var g, h;
  if (((g = this.tempSettings[this.actor.uuid]) == null ? void 0 : g.currentTab) !== "inventory") {
    const { spellBookId: _ } = s;
    if (_) {
      const y = this.actor.spellBooks.get(_);
      y == null || y.addSpell(t);
    } else
      ui.notifications.error("No spell book detected.");
    return;
  }
  const l = t.system.level, { attackBonus: r, cost: o, craftingComponent: a, saveDC: c, rarity: f } = CONFIG.A5E.scrollData[l], d = {
    name: `Spell Scroll (${t.name})`,
    img: "icons/sundries/scrolls/scroll-writing-brown-gold.webp",
    type: "object",
    system: {
      actions: {},
      craftingComponents: a,
      description: t.system.description,
      price: o,
      objectType: "consumable",
      rarity: f
    }
  };
  d.system.actions = [...t.actions.values()].reduce((_, y) => {
    const v = { ...y };
    return v.prompts = Object.entries((v == null ? void 0 : v.prompts) ?? {}).reduce(
      (k, [S, D]) => {
        const I = { ...D };
        return I.type === "savingThrow" && (I.saveDC.type = "custom", I.saveDC.bonus = c), k[S] = I, k;
      },
      {}
    ), v.rolls = Object.entries((v == null ? void 0 : v.rolls) ?? {}).reduce(
      (k, [S, D]) => {
        const I = { ...D };
        return I.type === "attack" && (I.ability = "none", I.bonus = r.toString(10)), I.scaling && delete I.scaling, k[S] = I, k;
      },
      {}
    ), v.consumers = {
      [foundry.utils.randomID()]: {
        // @ts-expect-error
        itemId: "",
        quantity: 1,
        type: "quantity"
      }
    }, _[foundry.utils.randomID()] = v, _;
  }, {});
  const p = (h = await this.actor.createEmbeddedDocuments("Item", [d])) == null ? void 0 : h[0];
  if (!p) return;
  const m = {};
  Object.entries(p.system.actions).forEach(([_, y]) => {
    Object.entries(y.consumers ?? {}).forEach(([v]) => {
      m[`system.actions.${_}.consumers.${v}.itemId`] = p.id;
    });
  }), p.update(m);
}, "#onDropSpell"), u(Ya, "ActorSheet"), Ya);
function Tce(i) {
  let e, t;
  return e = new wr({
    props: {
      document: (
        /*effect*/
        i[1]
      ),
      content: (
        /*content*/
        i[0]
      ),
      updatePath: "description"
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*content*/
      1 && (l.content = /*content*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Tce, "create_fragment$1N");
function Oce(i, e, t) {
  let s, n;
  const l = de("effect");
  return pe(i, l, (r) => t(2, n = r)), i.$$.update = () => {
    i.$$.dirty & /*$effect*/
    4 && t(0, s = n.description ?? "");
  }, [s, l, n];
}
u(Oce, "instance$1E");
const QS = class QS extends re {
  constructor(e) {
    super(), oe(this, e, Oce, Tce, le, {});
  }
};
u(QS, "EffectsDescriptionTab");
let pv = QS;
function Dce(i) {
  const e = Object.values(i), t = Object.entries(CONFIG.A5E.effectKeyGroups).reduce((n, [l, { items: r }]) => (r.forEach((o) => {
    n[o] = l;
  }), n), {}), s = e.map((n) => {
    var l;
    return {
      label: n.label,
      key: n.effectKey,
      group: K(
        ((l = CONFIG.A5E.effectKeyGroups[t[n.effectKey] ?? "other"]) == null ? void 0 : l.label) ?? "Other"
      )
    };
  });
  return s.sort((n, l) => n.group.localeCompare(l.group)), s;
}
u(Dce, "getEffectOptionGroups");
const Np = Math.min, co = Math.max, jp = Math.round, bd = Math.floor, rl = /* @__PURE__ */ u((i) => ({
  x: i,
  y: i
}), "createCoords"), Ice = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Pce = {
  start: "end",
  end: "start"
};
function Y6(i, e, t) {
  return co(i, Np(e, t));
}
u(Y6, "clamp");
function bg(i, e) {
  return typeof i == "function" ? i(e) : i;
}
u(bg, "evaluate");
function _o(i) {
  return i.split("-")[0];
}
u(_o, "getSide");
function _g(i) {
  return i.split("-")[1];
}
u(_g, "getAlignment");
function GB(i) {
  return i === "x" ? "y" : "x";
}
u(GB, "getOppositeAxis");
function zB(i) {
  return i === "y" ? "height" : "width";
}
u(zB, "getAxisLength");
function wc(i) {
  return ["top", "bottom"].includes(_o(i)) ? "y" : "x";
}
u(wc, "getSideAxis");
function HB(i) {
  return GB(wc(i));
}
u(HB, "getAlignmentAxis");
function Mce(i, e, t) {
  t === void 0 && (t = !1);
  const s = _g(i), n = HB(i), l = zB(n);
  let r = n === "x" ? s === (t ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return e.reference[l] > e.floating[l] && (r = Lp(r)), [r, Lp(r)];
}
u(Mce, "getAlignmentSides");
function Fce(i) {
  const e = Lp(i);
  return [mv(i), e, mv(e)];
}
u(Fce, "getExpandedPlacements");
function mv(i) {
  return i.replace(/start|end/g, (e) => Pce[e]);
}
u(mv, "getOppositeAlignmentPlacement");
function Rce(i, e, t) {
  const s = ["left", "right"], n = ["right", "left"], l = ["top", "bottom"], r = ["bottom", "top"];
  switch (i) {
    case "top":
    case "bottom":
      return t ? e ? n : s : e ? s : n;
    case "left":
    case "right":
      return e ? l : r;
    default:
      return [];
  }
}
u(Rce, "getSideList");
function Nce(i, e, t, s) {
  const n = _g(i);
  let l = Rce(_o(i), t === "start", s);
  return n && (l = l.map((r) => r + "-" + n), e && (l = l.concat(l.map(mv)))), l;
}
u(Nce, "getOppositeAxisPlacements");
function Lp(i) {
  return i.replace(/left|right|bottom|top/g, (e) => Ice[e]);
}
u(Lp, "getOppositePlacement");
function jce(i) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...i
  };
}
u(jce, "expandPaddingObject");
function Lce(i) {
  return typeof i != "number" ? jce(i) : {
    top: i,
    right: i,
    bottom: i,
    left: i
  };
}
u(Lce, "getPaddingObject");
function Bp(i) {
  const {
    x: e,
    y: t,
    width: s,
    height: n
  } = i;
  return {
    width: s,
    height: n,
    top: t,
    left: e,
    right: e + s,
    bottom: t + n,
    x: e,
    y: t
  };
}
u(Bp, "rectToClientRect");
function X6(i, e, t) {
  let {
    reference: s,
    floating: n
  } = i;
  const l = wc(e), r = HB(e), o = zB(r), a = _o(e), c = l === "y", f = s.x + s.width / 2 - n.width / 2, d = s.y + s.height / 2 - n.height / 2, p = s[o] / 2 - n[o] / 2;
  let m;
  switch (a) {
    case "top":
      m = {
        x: f,
        y: s.y - n.height
      };
      break;
    case "bottom":
      m = {
        x: f,
        y: s.y + s.height
      };
      break;
    case "right":
      m = {
        x: s.x + s.width,
        y: d
      };
      break;
    case "left":
      m = {
        x: s.x - n.width,
        y: d
      };
      break;
    default:
      m = {
        x: s.x,
        y: s.y
      };
  }
  switch (_g(e)) {
    case "start":
      m[r] -= p * (t && c ? -1 : 1);
      break;
    case "end":
      m[r] += p * (t && c ? -1 : 1);
      break;
  }
  return m;
}
u(X6, "computeCoordsFromPlacement");
const Bce = /* @__PURE__ */ u(async (i, e, t) => {
  const {
    placement: s = "bottom",
    strategy: n = "absolute",
    middleware: l = [],
    platform: r
  } = t, o = l.filter(Boolean), a = await (r.isRTL == null ? void 0 : r.isRTL(e));
  let c = await r.getElementRects({
    reference: i,
    floating: e,
    strategy: n
  }), {
    x: f,
    y: d
  } = X6(c, s, a), p = s, m = {}, g = 0;
  for (let h = 0; h < o.length; h++) {
    const {
      name: _,
      fn: y
    } = o[h], {
      x: v,
      y: k,
      data: S,
      reset: D
    } = await y({
      x: f,
      y: d,
      initialPlacement: s,
      placement: p,
      strategy: n,
      middlewareData: m,
      rects: c,
      platform: r,
      elements: {
        reference: i,
        floating: e
      }
    });
    f = v ?? f, d = k ?? d, m = {
      ...m,
      [_]: {
        ...m[_],
        ...S
      }
    }, D && g <= 50 && (g++, typeof D == "object" && (D.placement && (p = D.placement), D.rects && (c = D.rects === !0 ? await r.getElementRects({
      reference: i,
      floating: e,
      strategy: n
    }) : D.rects), {
      x: f,
      y: d
    } = X6(c, p, a)), h = -1);
  }
  return {
    x: f,
    y: d,
    placement: p,
    strategy: n,
    middlewareData: m
  };
}, "computePosition$1");
async function UB(i, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: s,
    y: n,
    platform: l,
    rects: r,
    elements: o,
    strategy: a
  } = i, {
    boundary: c = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: d = "floating",
    altBoundary: p = !1,
    padding: m = 0
  } = bg(e, i), g = Lce(m), _ = o[p ? d === "floating" ? "reference" : "floating" : d], y = Bp(await l.getClippingRect({
    element: (t = await (l.isElement == null ? void 0 : l.isElement(_))) == null || t ? _ : _.contextElement || await (l.getDocumentElement == null ? void 0 : l.getDocumentElement(o.floating)),
    boundary: c,
    rootBoundary: f,
    strategy: a
  })), v = d === "floating" ? {
    x: s,
    y: n,
    width: r.floating.width,
    height: r.floating.height
  } : r.reference, k = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(o.floating)), S = await (l.isElement == null ? void 0 : l.isElement(k)) ? await (l.getScale == null ? void 0 : l.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, D = Bp(l.convertOffsetParentRelativeRectToViewportRelativeRect ? await l.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: o,
    rect: v,
    offsetParent: k,
    strategy: a
  }) : v);
  return {
    top: (y.top - D.top + g.top) / S.y,
    bottom: (D.bottom - y.bottom + g.bottom) / S.y,
    left: (y.left - D.left + g.left) / S.x,
    right: (D.right - y.right + g.right) / S.x
  };
}
u(UB, "detectOverflow");
const qce = /* @__PURE__ */ u(function(i) {
  return i === void 0 && (i = {}), {
    name: "flip",
    options: i,
    async fn(e) {
      var t, s;
      const {
        placement: n,
        middlewareData: l,
        rects: r,
        initialPlacement: o,
        platform: a,
        elements: c
      } = e, {
        mainAxis: f = !0,
        crossAxis: d = !0,
        fallbackPlacements: p,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: h = !0,
        ..._
      } = bg(i, e);
      if ((t = l.arrow) != null && t.alignmentOffset)
        return {};
      const y = _o(n), v = wc(o), k = _o(o) === o, S = await (a.isRTL == null ? void 0 : a.isRTL(c.floating)), D = p || (k || !h ? [Lp(o)] : Fce(o)), I = g !== "none";
      !p && I && D.push(...Nce(o, h, g, S));
      const M = [o, ...D], L = await UB(e, _), B = [];
      let z = ((s = l.flip) == null ? void 0 : s.overflows) || [];
      if (f && B.push(L[y]), d) {
        const V = Mce(n, r, S);
        B.push(L[V[0]], L[V[1]]);
      }
      if (z = [...z, {
        placement: n,
        overflows: B
      }], !B.every((V) => V <= 0)) {
        var q, U;
        const V = (((q = l.flip) == null ? void 0 : q.index) || 0) + 1, Y = M[V];
        if (Y)
          return {
            data: {
              index: V,
              overflows: z
            },
            reset: {
              placement: Y
            }
          };
        let J = (U = z.filter((fe) => fe.overflows[0] <= 0).sort((fe, ke) => fe.overflows[1] - ke.overflows[1])[0]) == null ? void 0 : U.placement;
        if (!J)
          switch (m) {
            case "bestFit": {
              var H;
              const fe = (H = z.filter((ke) => {
                if (I) {
                  const ee = wc(ke.placement);
                  return ee === v || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ee === "y";
                }
                return !0;
              }).map((ke) => [ke.placement, ke.overflows.filter((ee) => ee > 0).reduce((ee, ne) => ee + ne, 0)]).sort((ke, ee) => ke[1] - ee[1])[0]) == null ? void 0 : H[0];
              fe && (J = fe);
              break;
            }
            case "initialPlacement":
              J = o;
              break;
          }
        if (n !== J)
          return {
            reset: {
              placement: J
            }
          };
      }
      return {};
    }
  };
}, "flip$1");
async function Gce(i, e) {
  const {
    placement: t,
    platform: s,
    elements: n
  } = i, l = await (s.isRTL == null ? void 0 : s.isRTL(n.floating)), r = _o(t), o = _g(t), a = wc(t) === "y", c = ["left", "top"].includes(r) ? -1 : 1, f = l && a ? -1 : 1, d = bg(e, i);
  let {
    mainAxis: p,
    crossAxis: m,
    alignmentAxis: g
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return o && typeof g == "number" && (m = o === "end" ? g * -1 : g), a ? {
    x: m * f,
    y: p * c
  } : {
    x: p * c,
    y: m * f
  };
}
u(Gce, "convertValueToCoords");
const zce = /* @__PURE__ */ u(function(i) {
  return i === void 0 && (i = 0), {
    name: "offset",
    options: i,
    async fn(e) {
      var t, s;
      const {
        x: n,
        y: l,
        placement: r,
        middlewareData: o
      } = e, a = await Gce(e, i);
      return r === ((t = o.offset) == null ? void 0 : t.placement) && (s = o.arrow) != null && s.alignmentOffset ? {} : {
        x: n + a.x,
        y: l + a.y,
        data: {
          ...a,
          placement: r
        }
      };
    }
  };
}, "offset$1"), Hce = /* @__PURE__ */ u(function(i) {
  return i === void 0 && (i = {}), {
    name: "shift",
    options: i,
    async fn(e) {
      const {
        x: t,
        y: s,
        placement: n
      } = e, {
        mainAxis: l = !0,
        crossAxis: r = !1,
        limiter: o = {
          fn: /* @__PURE__ */ u((_) => {
            let {
              x: y,
              y: v
            } = _;
            return {
              x: y,
              y: v
            };
          }, "fn")
        },
        ...a
      } = bg(i, e), c = {
        x: t,
        y: s
      }, f = await UB(e, a), d = wc(_o(n)), p = GB(d);
      let m = c[p], g = c[d];
      if (l) {
        const _ = p === "y" ? "top" : "left", y = p === "y" ? "bottom" : "right", v = m + f[_], k = m - f[y];
        m = Y6(v, m, k);
      }
      if (r) {
        const _ = d === "y" ? "top" : "left", y = d === "y" ? "bottom" : "right", v = g + f[_], k = g - f[y];
        g = Y6(v, g, k);
      }
      const h = o.fn({
        ...e,
        [p]: m,
        [d]: g
      });
      return {
        ...h,
        data: {
          x: h.x - t,
          y: h.y - s,
          enabled: {
            [p]: l,
            [d]: r
          }
        }
      };
    }
  };
}, "shift$1");
function yg() {
  return typeof window < "u";
}
u(yg, "hasWindow");
function Cc(i) {
  return VB(i) ? (i.nodeName || "").toLowerCase() : "#document";
}
u(Cc, "getNodeName");
function Gn(i) {
  var e;
  return (i == null || (e = i.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
u(Gn, "getWindow");
function dl(i) {
  var e;
  return (e = (VB(i) ? i.ownerDocument : i.document) || window.document) == null ? void 0 : e.documentElement;
}
u(dl, "getDocumentElement");
function VB(i) {
  return yg() ? i instanceof Node || i instanceof Gn(i).Node : !1;
}
u(VB, "isNode");
function Ri(i) {
  return yg() ? i instanceof Element || i instanceof Gn(i).Element : !1;
}
u(Ri, "isElement");
function ul(i) {
  return yg() ? i instanceof HTMLElement || i instanceof Gn(i).HTMLElement : !1;
}
u(ul, "isHTMLElement");
function J6(i) {
  return !yg() || typeof ShadowRoot > "u" ? !1 : i instanceof ShadowRoot || i instanceof Gn(i).ShadowRoot;
}
u(J6, "isShadowRoot");
function ld(i) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: s,
    display: n
  } = Ni(i);
  return /auto|scroll|overlay|hidden|clip/.test(e + s + t) && !["inline", "contents"].includes(n);
}
u(ld, "isOverflowElement");
function Uce(i) {
  return ["table", "td", "th"].includes(Cc(i));
}
u(Uce, "isTableElement");
function vg(i) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return i.matches(e);
    } catch {
      return !1;
    }
  });
}
u(vg, "isTopLayer");
function B5(i) {
  const e = q5(), t = Ri(i) ? Ni(i) : i;
  return t.transform !== "none" || t.perspective !== "none" || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((s) => (t.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some((s) => (t.contain || "").includes(s));
}
u(B5, "isContainingBlock");
function Vce(i) {
  let e = Ar(i);
  for (; ul(e) && !$c(e); ) {
    if (B5(e))
      return e;
    if (vg(e))
      return null;
    e = Ar(e);
  }
  return null;
}
u(Vce, "getContainingBlock");
function q5() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
u(q5, "isWebKit");
function $c(i) {
  return ["html", "body", "#document"].includes(Cc(i));
}
u($c, "isLastTraversableNode");
function Ni(i) {
  return Gn(i).getComputedStyle(i);
}
u(Ni, "getComputedStyle$1");
function kg(i) {
  return Ri(i) ? {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  } : {
    scrollLeft: i.scrollX,
    scrollTop: i.scrollY
  };
}
u(kg, "getNodeScroll");
function Ar(i) {
  if (Cc(i) === "html")
    return i;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    i.assignedSlot || // DOM Element detected.
    i.parentNode || // ShadowRoot detected.
    J6(i) && i.host || // Fallback.
    dl(i)
  );
  return J6(e) ? e.host : e;
}
u(Ar, "getParentNode");
function WB(i) {
  const e = Ar(i);
  return $c(e) ? i.ownerDocument ? i.ownerDocument.body : i.body : ul(e) && ld(e) ? e : WB(e);
}
u(WB, "getNearestOverflowAncestor");
function Cu(i, e, t) {
  var s;
  e === void 0 && (e = []), t === void 0 && (t = !0);
  const n = WB(i), l = n === ((s = i.ownerDocument) == null ? void 0 : s.body), r = Gn(n);
  if (l) {
    const o = hv(r);
    return e.concat(r, r.visualViewport || [], ld(n) ? n : [], o && t ? Cu(o) : []);
  }
  return e.concat(n, Cu(n, [], t));
}
u(Cu, "getOverflowAncestors");
function hv(i) {
  return i.parent && Object.getPrototypeOf(i.parent) ? i.frameElement : null;
}
u(hv, "getFrameElement");
function KB(i) {
  const e = Ni(i);
  let t = parseFloat(e.width) || 0, s = parseFloat(e.height) || 0;
  const n = ul(i), l = n ? i.offsetWidth : t, r = n ? i.offsetHeight : s, o = jp(t) !== l || jp(s) !== r;
  return o && (t = l, s = r), {
    width: t,
    height: s,
    $: o
  };
}
u(KB, "getCssDimensions");
function G5(i) {
  return Ri(i) ? i : i.contextElement;
}
u(G5, "unwrapElement");
function Jo(i) {
  const e = G5(i);
  if (!ul(e))
    return rl(1);
  const t = e.getBoundingClientRect(), {
    width: s,
    height: n,
    $: l
  } = KB(e);
  let r = (l ? jp(t.width) : t.width) / s, o = (l ? jp(t.height) : t.height) / n;
  return (!r || !Number.isFinite(r)) && (r = 1), (!o || !Number.isFinite(o)) && (o = 1), {
    x: r,
    y: o
  };
}
u(Jo, "getScale");
const Wce = /* @__PURE__ */ rl(0);
function YB(i) {
  const e = Gn(i);
  return !q5() || !e.visualViewport ? Wce : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
u(YB, "getVisualOffsets");
function Kce(i, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== Gn(i) ? !1 : e;
}
u(Kce, "shouldAddVisualOffsets");
function yo(i, e, t, s) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const n = i.getBoundingClientRect(), l = G5(i);
  let r = rl(1);
  e && (s ? Ri(s) && (r = Jo(s)) : r = Jo(i));
  const o = Kce(l, t, s) ? YB(l) : rl(0);
  let a = (n.left + o.x) / r.x, c = (n.top + o.y) / r.y, f = n.width / r.x, d = n.height / r.y;
  if (l) {
    const p = Gn(l), m = s && Ri(s) ? Gn(s) : s;
    let g = p, h = hv(g);
    for (; h && s && m !== g; ) {
      const _ = Jo(h), y = h.getBoundingClientRect(), v = Ni(h), k = y.left + (h.clientLeft + parseFloat(v.paddingLeft)) * _.x, S = y.top + (h.clientTop + parseFloat(v.paddingTop)) * _.y;
      a *= _.x, c *= _.y, f *= _.x, d *= _.y, a += k, c += S, g = Gn(h), h = hv(g);
    }
  }
  return Bp({
    width: f,
    height: d,
    x: a,
    y: c
  });
}
u(yo, "getBoundingClientRect");
function z5(i, e) {
  const t = kg(i).scrollLeft;
  return e ? e.left + t : yo(dl(i)).left + t;
}
u(z5, "getWindowScrollBarX");
function XB(i, e, t) {
  t === void 0 && (t = !1);
  const s = i.getBoundingClientRect(), n = s.left + e.scrollLeft - (t ? 0 : (
    // RTL <body> scrollbar.
    z5(i, s)
  )), l = s.top + e.scrollTop;
  return {
    x: n,
    y: l
  };
}
u(XB, "getHTMLOffset");
function Yce(i) {
  let {
    elements: e,
    rect: t,
    offsetParent: s,
    strategy: n
  } = i;
  const l = n === "fixed", r = dl(s), o = e ? vg(e.floating) : !1;
  if (s === r || o && l)
    return t;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = rl(1);
  const f = rl(0), d = ul(s);
  if ((d || !d && !l) && ((Cc(s) !== "body" || ld(r)) && (a = kg(s)), ul(s))) {
    const m = yo(s);
    c = Jo(s), f.x = m.x + s.clientLeft, f.y = m.y + s.clientTop;
  }
  const p = r && !d && !l ? XB(r, a, !0) : rl(0);
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - a.scrollLeft * c.x + f.x + p.x,
    y: t.y * c.y - a.scrollTop * c.y + f.y + p.y
  };
}
u(Yce, "convertOffsetParentRelativeRectToViewportRelativeRect");
function Xce(i) {
  return Array.from(i.getClientRects());
}
u(Xce, "getClientRects");
function Jce(i) {
  const e = dl(i), t = kg(i), s = i.ownerDocument.body, n = co(e.scrollWidth, e.clientWidth, s.scrollWidth, s.clientWidth), l = co(e.scrollHeight, e.clientHeight, s.scrollHeight, s.clientHeight);
  let r = -t.scrollLeft + z5(i);
  const o = -t.scrollTop;
  return Ni(s).direction === "rtl" && (r += co(e.clientWidth, s.clientWidth) - n), {
    width: n,
    height: l,
    x: r,
    y: o
  };
}
u(Jce, "getDocumentRect");
function Zce(i, e) {
  const t = Gn(i), s = dl(i), n = t.visualViewport;
  let l = s.clientWidth, r = s.clientHeight, o = 0, a = 0;
  if (n) {
    l = n.width, r = n.height;
    const c = q5();
    (!c || c && e === "fixed") && (o = n.offsetLeft, a = n.offsetTop);
  }
  return {
    width: l,
    height: r,
    x: o,
    y: a
  };
}
u(Zce, "getViewportRect");
function Qce(i, e) {
  const t = yo(i, !0, e === "fixed"), s = t.top + i.clientTop, n = t.left + i.clientLeft, l = ul(i) ? Jo(i) : rl(1), r = i.clientWidth * l.x, o = i.clientHeight * l.y, a = n * l.x, c = s * l.y;
  return {
    width: r,
    height: o,
    x: a,
    y: c
  };
}
u(Qce, "getInnerBoundingClientRect");
function Z6(i, e, t) {
  let s;
  if (e === "viewport")
    s = Zce(i, t);
  else if (e === "document")
    s = Jce(dl(i));
  else if (Ri(e))
    s = Qce(e, t);
  else {
    const n = YB(i);
    s = {
      x: e.x - n.x,
      y: e.y - n.y,
      width: e.width,
      height: e.height
    };
  }
  return Bp(s);
}
u(Z6, "getClientRectFromClippingAncestor");
function JB(i, e) {
  const t = Ar(i);
  return t === e || !Ri(t) || $c(t) ? !1 : Ni(t).position === "fixed" || JB(t, e);
}
u(JB, "hasFixedPositionAncestor");
function xce(i, e) {
  const t = e.get(i);
  if (t)
    return t;
  let s = Cu(i, [], !1).filter((o) => Ri(o) && Cc(o) !== "body"), n = null;
  const l = Ni(i).position === "fixed";
  let r = l ? Ar(i) : i;
  for (; Ri(r) && !$c(r); ) {
    const o = Ni(r), a = B5(r);
    !a && o.position === "fixed" && (n = null), (l ? !a && !n : !a && o.position === "static" && !!n && ["absolute", "fixed"].includes(n.position) || ld(r) && !a && JB(i, r)) ? s = s.filter((f) => f !== r) : n = o, r = Ar(r);
  }
  return e.set(i, s), s;
}
u(xce, "getClippingElementAncestors");
function eue(i) {
  let {
    element: e,
    boundary: t,
    rootBoundary: s,
    strategy: n
  } = i;
  const r = [...t === "clippingAncestors" ? vg(e) ? [] : xce(e, this._c) : [].concat(t), s], o = r[0], a = r.reduce((c, f) => {
    const d = Z6(e, f, n);
    return c.top = co(d.top, c.top), c.right = Np(d.right, c.right), c.bottom = Np(d.bottom, c.bottom), c.left = co(d.left, c.left), c;
  }, Z6(e, o, n));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
u(eue, "getClippingRect");
function tue(i) {
  const {
    width: e,
    height: t
  } = KB(i);
  return {
    width: e,
    height: t
  };
}
u(tue, "getDimensions");
function sue(i, e, t) {
  const s = ul(e), n = dl(e), l = t === "fixed", r = yo(i, !0, l, e);
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = rl(0);
  if (s || !s && !l)
    if ((Cc(e) !== "body" || ld(n)) && (o = kg(e)), s) {
      const p = yo(e, !0, l, e);
      a.x = p.x + e.clientLeft, a.y = p.y + e.clientTop;
    } else n && (a.x = z5(n));
  const c = n && !s && !l ? XB(n, o) : rl(0), f = r.left + o.scrollLeft - a.x - c.x, d = r.top + o.scrollTop - a.y - c.y;
  return {
    x: f,
    y: d,
    width: r.width,
    height: r.height
  };
}
u(sue, "getRectRelativeToOffsetParent");
function qg(i) {
  return Ni(i).position === "static";
}
u(qg, "isStaticPositioned");
function Q6(i, e) {
  if (!ul(i) || Ni(i).position === "fixed")
    return null;
  if (e)
    return e(i);
  let t = i.offsetParent;
  return dl(i) === t && (t = t.ownerDocument.body), t;
}
u(Q6, "getTrueOffsetParent");
function ZB(i, e) {
  const t = Gn(i);
  if (vg(i))
    return t;
  if (!ul(i)) {
    let n = Ar(i);
    for (; n && !$c(n); ) {
      if (Ri(n) && !qg(n))
        return n;
      n = Ar(n);
    }
    return t;
  }
  let s = Q6(i, e);
  for (; s && Uce(s) && qg(s); )
    s = Q6(s, e);
  return s && $c(s) && qg(s) && !B5(s) ? t : s || Vce(i) || t;
}
u(ZB, "getOffsetParent");
const nue = /* @__PURE__ */ u(async function(i) {
  const e = this.getOffsetParent || ZB, t = this.getDimensions, s = await t(i.floating);
  return {
    reference: sue(i.reference, await e(i.floating), i.strategy),
    floating: {
      x: 0,
      y: 0,
      width: s.width,
      height: s.height
    }
  };
}, "getElementRects");
function iue(i) {
  return Ni(i).direction === "rtl";
}
u(iue, "isRTL");
const lue = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Yce,
  getDocumentElement: dl,
  getClippingRect: eue,
  getOffsetParent: ZB,
  getElementRects: nue,
  getClientRects: Xce,
  getDimensions: tue,
  getScale: Jo,
  isElement: Ri,
  isRTL: iue
};
function rue(i, e) {
  let t = null, s;
  const n = dl(i);
  function l() {
    var o;
    clearTimeout(s), (o = t) == null || o.disconnect(), t = null;
  }
  u(l, "cleanup");
  function r(o, a) {
    o === void 0 && (o = !1), a === void 0 && (a = 1), l();
    const {
      left: c,
      top: f,
      width: d,
      height: p
    } = i.getBoundingClientRect();
    if (o || e(), !d || !p)
      return;
    const m = bd(f), g = bd(n.clientWidth - (c + d)), h = bd(n.clientHeight - (f + p)), _ = bd(c), v = {
      rootMargin: -m + "px " + -g + "px " + -h + "px " + -_ + "px",
      threshold: co(0, Np(1, a)) || 1
    };
    let k = !0;
    function S(D) {
      const I = D[0].intersectionRatio;
      if (I !== a) {
        if (!k)
          return r();
        I ? r(!1, I) : s = setTimeout(() => {
          r(!1, 1e-7);
        }, 1e3);
      }
      k = !1;
    }
    u(S, "handleObserve");
    try {
      t = new IntersectionObserver(S, {
        ...v,
        // Handle <iframe>s
        root: n.ownerDocument
      });
    } catch {
      t = new IntersectionObserver(S, v);
    }
    t.observe(i);
  }
  return u(r, "refresh"), r(!0), l;
}
u(rue, "observeMove");
function oue(i, e, t, s) {
  s === void 0 && (s = {});
  const {
    ancestorScroll: n = !0,
    ancestorResize: l = !0,
    elementResize: r = typeof ResizeObserver == "function",
    layoutShift: o = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = s, c = G5(i), f = n || l ? [...c ? Cu(c) : [], ...Cu(e)] : [];
  f.forEach((y) => {
    n && y.addEventListener("scroll", t, {
      passive: !0
    }), l && y.addEventListener("resize", t);
  });
  const d = c && o ? rue(c, t) : null;
  let p = -1, m = null;
  r && (m = new ResizeObserver((y) => {
    let [v] = y;
    v && v.target === c && m && (m.unobserve(e), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var k;
      (k = m) == null || k.observe(e);
    })), t();
  }), c && !a && m.observe(c), m.observe(e));
  let g, h = a ? yo(i) : null;
  a && _();
  function _() {
    const y = yo(i);
    h && (y.x !== h.x || y.y !== h.y || y.width !== h.width || y.height !== h.height) && t(), h = y, g = requestAnimationFrame(_);
  }
  return u(_, "frameLoop"), t(), () => {
    var y;
    f.forEach((v) => {
      n && v.removeEventListener("scroll", t), l && v.removeEventListener("resize", t);
    }), d == null || d(), (y = m) == null || y.disconnect(), m = null, a && cancelAnimationFrame(g);
  };
}
u(oue, "autoUpdate");
const aue = zce, cue = Hce, uue = qce, fue = /* @__PURE__ */ u((i, e, t) => {
  const s = /* @__PURE__ */ new Map(), n = {
    platform: lue,
    ...t
  }, l = {
    ...n.platform,
    _c: s
  };
  return Bce(i, e, {
    ...n,
    platform: l
  });
}, "computePosition");
function due(i) {
  let e, t;
  const s = {
    autoUpdate: !0
  };
  let n = i;
  const l = /* @__PURE__ */ u((f) => ({ ...s, ...i || {}, ...f || {} }), "getOptions"), r = /* @__PURE__ */ u((f) => {
    e && t && (n = l(f), fue(e, t, n).then((d) => {
      Object.assign(t.style, {
        position: d.strategy,
        left: `${d.x}px`,
        top: `${d.y}px`
      }), n != null && n.onComputed && n.onComputed(d);
    }));
  }, "updatePosition"), o = /* @__PURE__ */ u((f) => {
    if ("subscribe" in f)
      return c(f), {};
    e = f, r();
  }, "referenceAction"), a = /* @__PURE__ */ u((f, d) => {
    let p;
    t = f, n = l(d), setTimeout(() => r(d), 0), r(d);
    const m = /* @__PURE__ */ u(() => {
      p && (p(), p = void 0);
    }, "destroyAutoUpdate"), g = /* @__PURE__ */ u(({ autoUpdate: h } = n || {}) => {
      m(), h !== !1 && I5().then(() => oue(e, t, () => r(n), h === !0 ? {} : h));
    }, "initAutoUpdate");
    return p = g(), {
      update(h) {
        r(h), p = g(h);
      },
      destroy() {
        m();
      }
    };
  }, "contentAction"), c = /* @__PURE__ */ u((f) => {
    const d = f.subscribe((p) => {
      e === void 0 ? (e = p, r()) : (Object.assign(e, p), r());
    });
    Qt(d);
  }, "setupVirtualElementObserver");
  return [
    o,
    a,
    r
  ];
}
u(due, "createFloatingActions");
function pue({
  loadOptions: i,
  filterText: e,
  items: t,
  multiple: s,
  value: n,
  itemId: l,
  groupBy: r,
  filterSelectedItems: o,
  itemFilter: a,
  convertStringItemsToObjects: c,
  filterGroupedItems: f,
  label: d
}) {
  if (t && i) return t;
  if (!t) return [];
  t && t.length > 0 && typeof t[0] != "object" && (t = c(t));
  let p = t.filter((m) => {
    let g = a(m[d], e, m);
    return g && s && (n != null && n.length) && (g = !n.some((h) => o ? h[l] === m[l] : !1)), g;
  });
  return r && (p = f(p)), p;
}
u(pue, "filter");
async function mue({ dispatch: i, loadOptions: e, convertStringItemsToObjects: t, filterText: s }) {
  let n = await e(s).catch((l) => {
    console.warn("svelte-select loadOptions error :>> ", l), i("error", { type: "loadOptions", details: l });
  });
  if (n && !n.cancelled)
    return n ? (n && n.length > 0 && typeof n[0] != "object" && (n = t(n)), i("loaded", { items: n })) : n = [], {
      filteredItems: n,
      loading: !1,
      focused: !0,
      listOpen: !0
    };
}
u(mue, "getItems");
function hue(i) {
  let e, t;
  return {
    c() {
      e = fi("svg"), t = fi("path"), b(t, "fill", "currentColor"), b(t, "d", `M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747
          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0
          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502
          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0
          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z`), b(e, "width", "100%"), b(e, "height", "100%"), b(e, "viewBox", "0 0 20 20"), b(e, "focusable", "false"), b(e, "aria-hidden", "true"), b(e, "class", "svelte-qbd276");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p: se,
    i: se,
    o: se,
    d(s) {
      s && C(e);
    }
  };
}
u(hue, "create_fragment$1M");
const xS = class xS extends re {
  constructor(e) {
    super(), oe(this, e, null, hue, le, {});
  }
};
u(xS, "ChevronIcon");
let gv = xS;
function gue(i) {
  let e, t;
  return {
    c() {
      e = fi("svg"), t = fi("path"), b(t, "fill", "currentColor"), b(t, "d", `M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124
    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z`), b(e, "width", "100%"), b(e, "height", "100%"), b(e, "viewBox", "-2 -2 50 50"), b(e, "focusable", "false"), b(e, "aria-hidden", "true"), b(e, "role", "presentation"), b(e, "class", "svelte-whdbu1");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p: se,
    i: se,
    o: se,
    d(s) {
      s && C(e);
    }
  };
}
u(gue, "create_fragment$1L");
const eC = class eC extends re {
  constructor(e) {
    super(), oe(this, e, null, gue, le, {});
  }
};
u(eC, "ClearIcon");
let Ac = eC;
function bue(i) {
  let e, t;
  return {
    c() {
      e = fi("svg"), t = fi("circle"), b(t, "class", "circle_path svelte-1p3nqvd"), b(t, "cx", "50"), b(t, "cy", "50"), b(t, "r", "20"), b(t, "fill", "none"), b(t, "stroke", "currentColor"), b(t, "stroke-width", "5"), b(t, "stroke-miterlimit", "10"), b(e, "class", "loading svelte-1p3nqvd"), b(e, "viewBox", "25 25 50 50");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p: se,
    i: se,
    o: se,
    d(s) {
      s && C(e);
    }
  };
}
u(bue, "create_fragment$1K");
const tC = class tC extends re {
  constructor(e) {
    super(), oe(this, e, null, bue, le, {});
  }
};
u(tC, "LoadingIcon");
let bv = tC;
const _ue = /* @__PURE__ */ u((i) => ({ value: i[0] & /*value*/
8 }), "get_required_slot_changes"), x6 = /* @__PURE__ */ u((i) => ({ value: (
  /*value*/
  i[3]
) }), "get_required_slot_context"), yue = /* @__PURE__ */ u((i) => ({ value: i[0] & /*value*/
8 }), "get_input_hidden_slot_changes"), eR = /* @__PURE__ */ u((i) => ({ value: (
  /*value*/
  i[3]
) }), "get_input_hidden_slot_context"), vue = /* @__PURE__ */ u((i) => ({ listOpen: i[0] & /*listOpen*/
64 }), "get_chevron_icon_slot_changes"), tR = /* @__PURE__ */ u((i) => ({ listOpen: (
  /*listOpen*/
  i[6]
) }), "get_chevron_icon_slot_context"), kue = /* @__PURE__ */ u((i) => ({}), "get_clear_icon_slot_changes"), sR = /* @__PURE__ */ u((i) => ({}), "get_clear_icon_slot_context"), wue = /* @__PURE__ */ u((i) => ({}), "get_loading_icon_slot_changes"), nR = /* @__PURE__ */ u((i) => ({}), "get_loading_icon_slot_context"), $ue = /* @__PURE__ */ u((i) => ({ selection: i[0] & /*value*/
8 }), "get_selection_slot_changes_1"), iR = /* @__PURE__ */ u((i) => ({ selection: (
  /*value*/
  i[3]
) }), "get_selection_slot_context_1");
function lR(i, e, t) {
  const s = i.slice();
  return s[126] = e[t], s[128] = t, s;
}
u(lR, "get_each_context$D");
const Aue = /* @__PURE__ */ u((i) => ({}), "get_multi_clear_icon_slot_changes"), rR = /* @__PURE__ */ u((i) => ({}), "get_multi_clear_icon_slot_context"), Eue = /* @__PURE__ */ u((i) => ({ selection: i[0] & /*value*/
8 }), "get_selection_slot_changes"), oR = /* @__PURE__ */ u((i) => ({
  selection: (
    /*item*/
    i[126]
  ),
  index: (
    /*i*/
    i[128]
  )
}), "get_selection_slot_context"), Sue = /* @__PURE__ */ u((i) => ({}), "get_prepend_slot_changes"), aR = /* @__PURE__ */ u((i) => ({}), "get_prepend_slot_context"), Cue = /* @__PURE__ */ u((i) => ({}), "get_list_append_slot_changes"), cR = /* @__PURE__ */ u((i) => ({}), "get_list_append_slot_context"), Tue = /* @__PURE__ */ u((i) => ({}), "get_empty_slot_changes"), uR = /* @__PURE__ */ u((i) => ({}), "get_empty_slot_context");
function fR(i, e, t) {
  const s = i.slice();
  return s[126] = e[t], s[128] = t, s;
}
u(fR, "get_each_context_1$6");
const Oue = /* @__PURE__ */ u((i) => ({
  item: i[0] & /*filteredItems*/
  16777216
}), "get_item_slot_changes"), dR = /* @__PURE__ */ u((i) => ({
  item: (
    /*item*/
    i[126]
  ),
  index: (
    /*i*/
    i[128]
  )
}), "get_item_slot_context"), Due = /* @__PURE__ */ u((i) => ({
  filteredItems: i[0] & /*filteredItems*/
  16777216
}), "get_list_slot_changes"), pR = /* @__PURE__ */ u((i) => ({ filteredItems: (
  /*filteredItems*/
  i[24]
) }), "get_list_slot_context"), Iue = /* @__PURE__ */ u((i) => ({}), "get_list_prepend_slot_changes"), mR = /* @__PURE__ */ u((i) => ({}), "get_list_prepend_slot_context");
function hR(i) {
  let e, t, s, n, l, r, o, a, c = (
    /*$$slots*/
    i[50]["list-prepend"] && gR(i)
  );
  const f = [Fue, Mue, Pue], d = [];
  function p(g, h) {
    return (
      /*$$slots*/
      g[50].list ? 0 : (
        /*filteredItems*/
        g[24].length > 0 ? 1 : (
          /*hideEmptyState*/
          g[19] ? -1 : 2
        )
      )
    );
  }
  u(p, "select_block_type"), ~(s = p(i)) && (n = d[s] = f[s](i));
  let m = (
    /*$$slots*/
    i[50]["list-append"] && _R(i)
  );
  return {
    c() {
      e = E("div"), c && c.c(), t = F(), n && n.c(), l = F(), m && m.c(), b(e, "class", "svelte-select-list svelte-82qwg8"), b(e, "role", "none"), Z(
        e,
        "prefloat",
        /*prefloat*/
        i[28]
      );
    },
    m(g, h) {
      T(g, e, h), c && c.m(e, null), A(e, t), ~s && d[s].m(e, null), A(e, l), m && m.m(e, null), i[91](e), r = !0, o || (a = [
        Et(
          /*floatingContent*/
          i[49].call(null, e)
        ),
        W(
          e,
          "scroll",
          /*handleListScroll*/
          i[41]
        ),
        W(e, "pointerup", Ve(st(
          /*pointerup_handler*/
          i[85]
        ))),
        W(e, "mousedown", Ve(st(
          /*mousedown_handler*/
          i[86]
        )))
      ], o = !0);
    },
    p(g, h) {
      /*$$slots*/
      g[50]["list-prepend"] ? c ? (c.p(g, h), h[1] & /*$$slots*/
      524288 && w(c, 1)) : (c = gR(g), c.c(), w(c, 1), c.m(e, t)) : c && (ae(), O(c, 1, 1, () => {
        c = null;
      }), ce());
      let _ = s;
      s = p(g), s === _ ? ~s && d[s].p(g, h) : (n && (ae(), O(d[_], 1, 1, () => {
        d[_] = null;
      }), ce()), ~s ? (n = d[s], n ? n.p(g, h) : (n = d[s] = f[s](g), n.c()), w(n, 1), n.m(e, l)) : n = null), /*$$slots*/
      g[50]["list-append"] ? m ? (m.p(g, h), h[1] & /*$$slots*/
      524288 && w(m, 1)) : (m = _R(g), m.c(), w(m, 1), m.m(e, null)) : m && (ae(), O(m, 1, 1, () => {
        m = null;
      }), ce()), (!r || h[0] & /*prefloat*/
      268435456) && Z(
        e,
        "prefloat",
        /*prefloat*/
        g[28]
      );
    },
    i(g) {
      r || (w(c), w(n), w(m), r = !0);
    },
    o(g) {
      O(c), O(n), O(m), r = !1;
    },
    d(g) {
      g && C(e), c && c.d(), ~s && d[s].d(), m && m.d(), i[91](null), o = !1, Me(a);
    }
  };
}
u(hR, "create_if_block_8$7");
function gR(i) {
  let e;
  const t = (
    /*#slots*/
    i[83]["list-prepend"]
  ), s = Gt(
    t,
    i,
    /*$$scope*/
    i[82],
    mR
  );
  return {
    c() {
      s && s.c();
    },
    m(n, l) {
      s && s.m(n, l), e = !0;
    },
    p(n, l) {
      s && s.p && (!e || l[2] & /*$$scope*/
      1048576) && Ht(
        s,
        t,
        n,
        /*$$scope*/
        n[82],
        e ? zt(
          t,
          /*$$scope*/
          n[82],
          l,
          Iue
        ) : Ut(
          /*$$scope*/
          n[82]
        ),
        mR
      );
    },
    i(n) {
      e || (w(s, n), e = !0);
    },
    o(n) {
      O(s, n), e = !1;
    },
    d(n) {
      s && s.d(n);
    }
  };
}
u(gR, "create_if_block_13");
function Pue(i) {
  let e;
  const t = (
    /*#slots*/
    i[83].empty
  ), s = Gt(
    t,
    i,
    /*$$scope*/
    i[82],
    uR
  ), n = s || Rue();
  return {
    c() {
      n && n.c();
    },
    m(l, r) {
      n && n.m(l, r), e = !0;
    },
    p(l, r) {
      s && s.p && (!e || r[2] & /*$$scope*/
      1048576) && Ht(
        s,
        t,
        l,
        /*$$scope*/
        l[82],
        e ? zt(
          t,
          /*$$scope*/
          l[82],
          r,
          Tue
        ) : Ut(
          /*$$scope*/
          l[82]
        ),
        uR
      );
    },
    i(l) {
      e || (w(n, l), e = !0);
    },
    o(l) {
      O(n, l), e = !1;
    },
    d(l) {
      n && n.d(l);
    }
  };
}
u(Pue, "create_if_block_12$1");
function Mue(i) {
  let e, t, s = ue(
    /*filteredItems*/
    i[24]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = bR(fR(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o[0] & /*filteredItems, value, itemId, listDom, scrollToHoverItem, hoverItemIndex, label*/
      1627402376 | o[1] & /*handleHover, handleItemClick, isItemActive*/
      28672 | o[2] & /*$$scope*/
      1048576) {
        s = ue(
          /*filteredItems*/
          r[24]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = fR(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = bR(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(Mue, "create_if_block_11$2");
function Fue(i) {
  let e;
  const t = (
    /*#slots*/
    i[83].list
  ), s = Gt(
    t,
    i,
    /*$$scope*/
    i[82],
    pR
  );
  return {
    c() {
      s && s.c();
    },
    m(n, l) {
      s && s.m(n, l), e = !0;
    },
    p(n, l) {
      s && s.p && (!e || l[0] & /*filteredItems*/
      16777216 | l[2] & /*$$scope*/
      1048576) && Ht(
        s,
        t,
        n,
        /*$$scope*/
        n[82],
        e ? zt(
          t,
          /*$$scope*/
          n[82],
          l,
          Due
        ) : Ut(
          /*$$scope*/
          n[82]
        ),
        pR
      );
    },
    i(n) {
      e || (w(s, n), e = !0);
    },
    o(n) {
      O(s, n), e = !1;
    },
    d(n) {
      s && s.d(n);
    }
  };
}
u(Fue, "create_if_block_10$5");
function Rue(i) {
  let e;
  return {
    c() {
      e = E("div"), e.textContent = "No options", b(e, "class", "empty svelte-82qwg8");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    d(t) {
      t && C(e);
    }
  };
}
u(Rue, "fallback_block_9");
function Nue(i) {
  var s;
  let e = (
    /*item*/
    ((s = i[126]) == null ? void 0 : s[
      /*label*/
      i[12]
    ]) + ""
  ), t;
  return {
    c() {
      t = Q(e);
    },
    m(n, l) {
      T(n, t, l);
    },
    p(n, l) {
      var r;
      l[0] & /*filteredItems, label*/
      16781312 && e !== (e = /*item*/
      ((r = n[126]) == null ? void 0 : r[
        /*label*/
        n[12]
      ]) + "") && be(t, e);
    },
    d(n) {
      n && C(t);
    }
  };
}
u(Nue, "fallback_block_8");
function bR(i) {
  let e, t, s, n, l, r, o, a;
  const c = (
    /*#slots*/
    i[83].item
  ), f = Gt(
    c,
    i,
    /*$$scope*/
    i[82],
    dR
  ), d = f || Nue(i);
  function p() {
    return (
      /*mouseover_handler*/
      i[88](
        /*i*/
        i[128]
      )
    );
  }
  u(p, "mouseover_handler");
  function m() {
    return (
      /*focus_handler*/
      i[89](
        /*i*/
        i[128]
      )
    );
  }
  u(m, "focus_handler");
  function g() {
    return (
      /*click_handler*/
      i[90](
        /*item*/
        i[126],
        /*i*/
        i[128]
      )
    );
  }
  return u(g, "click_handler"), {
    c() {
      var h;
      e = E("div"), t = E("div"), d && d.c(), l = F(), b(t, "class", "item svelte-82qwg8"), Z(
        t,
        "list-group-title",
        /*item*/
        i[126].groupHeader
      ), Z(
        t,
        "active",
        /*isItemActive*/
        i[45](
          /*item*/
          i[126],
          /*value*/
          i[3],
          /*itemId*/
          i[13]
        )
      ), Z(t, "first", Yue(
        /*i*/
        i[128]
      )), Z(
        t,
        "hover",
        /*hoverItemIndex*/
        i[7] === /*i*/
        i[128]
      ), Z(
        t,
        "group-item",
        /*item*/
        i[126].groupItem
      ), Z(
        t,
        "not-selectable",
        /*item*/
        ((h = i[126]) == null ? void 0 : h.selectable) === !1
      ), b(e, "class", "list-item svelte-82qwg8"), b(e, "tabindex", "-1"), b(e, "role", "none");
    },
    m(h, _) {
      T(h, e, _), A(e, t), d && d.m(t, null), A(e, l), r = !0, o || (a = [
        Et(s = /*activeScroll*/
        i[46].call(null, t, {
          scroll: (
            /*isItemActive*/
            i[45](
              /*item*/
              i[126],
              /*value*/
              i[3],
              /*itemId*/
              i[13]
            )
          ),
          listDom: (
            /*listDom*/
            i[30]
          )
        })),
        Et(n = /*hoverScroll*/
        i[47].call(null, t, {
          scroll: (
            /*scrollToHoverItem*/
            i[29] === /*i*/
            i[128]
          ),
          listDom: (
            /*listDom*/
            i[30]
          )
        })),
        W(e, "mouseover", p),
        W(e, "focus", m),
        W(e, "click", Ve(g)),
        W(e, "keydown", Ve(st(
          /*keydown_handler*/
          i[87]
        )))
      ], o = !0);
    },
    p(h, _) {
      var y;
      i = h, f ? f.p && (!r || _[0] & /*filteredItems*/
      16777216 | _[2] & /*$$scope*/
      1048576) && Ht(
        f,
        c,
        i,
        /*$$scope*/
        i[82],
        r ? zt(
          c,
          /*$$scope*/
          i[82],
          _,
          Oue
        ) : Ut(
          /*$$scope*/
          i[82]
        ),
        dR
      ) : d && d.p && (!r || _[0] & /*filteredItems, label*/
      16781312) && d.p(i, r ? _ : [-1, -1, -1, -1, -1]), s && $t(s.update) && _[0] & /*filteredItems, value, itemId, listDom*/
      1090527240 && s.update.call(null, {
        scroll: (
          /*isItemActive*/
          i[45](
            /*item*/
            i[126],
            /*value*/
            i[3],
            /*itemId*/
            i[13]
          )
        ),
        listDom: (
          /*listDom*/
          i[30]
        )
      }), n && $t(n.update) && _[0] & /*scrollToHoverItem, listDom*/
      1610612736 && n.update.call(null, {
        scroll: (
          /*scrollToHoverItem*/
          i[29] === /*i*/
          i[128]
        ),
        listDom: (
          /*listDom*/
          i[30]
        )
      }), (!r || _[0] & /*filteredItems*/
      16777216) && Z(
        t,
        "list-group-title",
        /*item*/
        i[126].groupHeader
      ), (!r || _[0] & /*filteredItems, value, itemId*/
      16785416 | _[1] & /*isItemActive*/
      16384) && Z(
        t,
        "active",
        /*isItemActive*/
        i[45](
          /*item*/
          i[126],
          /*value*/
          i[3],
          /*itemId*/
          i[13]
        )
      ), (!r || _[0] & /*hoverItemIndex*/
      128) && Z(
        t,
        "hover",
        /*hoverItemIndex*/
        i[7] === /*i*/
        i[128]
      ), (!r || _[0] & /*filteredItems*/
      16777216) && Z(
        t,
        "group-item",
        /*item*/
        i[126].groupItem
      ), (!r || _[0] & /*filteredItems*/
      16777216) && Z(
        t,
        "not-selectable",
        /*item*/
        ((y = i[126]) == null ? void 0 : y.selectable) === !1
      );
    },
    i(h) {
      r || (w(d, h), r = !0);
    },
    o(h) {
      O(d, h), r = !1;
    },
    d(h) {
      h && C(e), d && d.d(h), o = !1, Me(a);
    }
  };
}
u(bR, "create_each_block_1$6");
function _R(i) {
  let e;
  const t = (
    /*#slots*/
    i[83]["list-append"]
  ), s = Gt(
    t,
    i,
    /*$$scope*/
    i[82],
    cR
  );
  return {
    c() {
      s && s.c();
    },
    m(n, l) {
      s && s.m(n, l), e = !0;
    },
    p(n, l) {
      s && s.p && (!e || l[2] & /*$$scope*/
      1048576) && Ht(
        s,
        t,
        n,
        /*$$scope*/
        n[82],
        e ? zt(
          t,
          /*$$scope*/
          n[82],
          l,
          Cue
        ) : Ut(
          /*$$scope*/
          n[82]
        ),
        cR
      );
    },
    i(n) {
      e || (w(s, n), e = !0);
    },
    o(n) {
      O(s, n), e = !1;
    },
    d(n) {
      s && s.d(n);
    }
  };
}
u(_R, "create_if_block_9$6");
function yR(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("span"), t = Q(
        /*ariaSelection*/
        i[32]
      ), s = F(), n = E("span"), l = Q(
        /*ariaContext*/
        i[31]
      ), b(e, "id", "aria-selection"), b(e, "class", "svelte-82qwg8"), b(n, "id", "aria-context"), b(n, "class", "svelte-82qwg8");
    },
    m(r, o) {
      T(r, e, o), A(e, t), T(r, s, o), T(r, n, o), A(n, l);
    },
    p(r, o) {
      o[1] & /*ariaSelection*/
      2 && be(
        t,
        /*ariaSelection*/
        r[32]
      ), o[1] & /*ariaContext*/
      1 && be(
        l,
        /*ariaContext*/
        r[31]
      );
    },
    d(r) {
      r && (C(e), C(s), C(n));
    }
  };
}
u(yR, "create_if_block_7$9");
function vR(i) {
  let e, t, s, n;
  const l = [Lue, jue], r = [];
  function o(a, c) {
    return (
      /*multiple*/
      a[9] ? 0 : 1
    );
  }
  return u(o, "select_block_type_1"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(vR, "create_if_block_4$h");
function jue(i) {
  let e, t;
  const s = (
    /*#slots*/
    i[83].selection
  ), n = Gt(
    s,
    i,
    /*$$scope*/
    i[82],
    iR
  ), l = n || Bue(i);
  return {
    c() {
      e = E("div"), l && l.c(), b(e, "class", "selected-item svelte-82qwg8"), Z(
        e,
        "hide-selected-item",
        /*hideSelectedItem*/
        i[35]
      );
    },
    m(r, o) {
      T(r, e, o), l && l.m(e, null), t = !0;
    },
    p(r, o) {
      n ? n.p && (!t || o[0] & /*value*/
      8 | o[2] & /*$$scope*/
      1048576) && Ht(
        n,
        s,
        r,
        /*$$scope*/
        r[82],
        t ? zt(
          s,
          /*$$scope*/
          r[82],
          o,
          $ue
        ) : Ut(
          /*$$scope*/
          r[82]
        ),
        iR
      ) : l && l.p && (!t || o[0] & /*value, label*/
      4104) && l.p(r, t ? o : [-1, -1, -1, -1, -1]), (!t || o[1] & /*hideSelectedItem*/
      16) && Z(
        e,
        "hide-selected-item",
        /*hideSelectedItem*/
        r[35]
      );
    },
    i(r) {
      t || (w(l, r), t = !0);
    },
    o(r) {
      O(l, r), t = !1;
    },
    d(r) {
      r && C(e), l && l.d(r);
    }
  };
}
u(jue, "create_else_block$l");
function Lue(i) {
  let e, t, s = ue(
    /*value*/
    i[3]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = wR(lR(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o[0] & /*activeValue, disabled, multiFullItemClearable, value, label*/
      67116040 | o[1] & /*handleMultiItemClear*/
      32 | o[2] & /*$$scope*/
      1048576) {
        s = ue(
          /*value*/
          r[3]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = lR(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = wR(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(Lue, "create_if_block_5$c");
function Bue(i) {
  let e = (
    /*value*/
    i[3][
      /*label*/
      i[12]
    ] + ""
  ), t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n[0] & /*value, label*/
      4104 && e !== (e = /*value*/
      s[3][
        /*label*/
        s[12]
      ] + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(Bue, "fallback_block_7");
function que(i) {
  let e = (
    /*item*/
    i[126][
      /*label*/
      i[12]
    ] + ""
  ), t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n[0] & /*value, label*/
      4104 && e !== (e = /*item*/
      s[126][
        /*label*/
        s[12]
      ] + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(que, "fallback_block_6");
function kR(i) {
  let e, t, s, n;
  const l = (
    /*#slots*/
    i[83]["multi-clear-icon"]
  ), r = Gt(
    l,
    i,
    /*$$scope*/
    i[82],
    rR
  ), o = r || Gue();
  function a() {
    return (
      /*pointerup_handler_1*/
      i[92](
        /*i*/
        i[128]
      )
    );
  }
  return u(a, "pointerup_handler_1"), {
    c() {
      e = E("div"), o && o.c(), b(e, "class", "multi-item-clear svelte-82qwg8");
    },
    m(c, f) {
      T(c, e, f), o && o.m(e, null), t = !0, s || (n = W(e, "pointerup", Ve(st(a))), s = !0);
    },
    p(c, f) {
      i = c, r && r.p && (!t || f[2] & /*$$scope*/
      1048576) && Ht(
        r,
        l,
        i,
        /*$$scope*/
        i[82],
        t ? zt(
          l,
          /*$$scope*/
          i[82],
          f,
          Aue
        ) : Ut(
          /*$$scope*/
          i[82]
        ),
        rR
      );
    },
    i(c) {
      t || (w(o, c), t = !0);
    },
    o(c) {
      O(o, c), t = !1;
    },
    d(c) {
      c && C(e), o && o.d(c), s = !1, n();
    }
  };
}
u(kR, "create_if_block_6$b");
function Gue(i) {
  let e, t;
  return e = new Ac({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Gue, "fallback_block_5");
function wR(i) {
  let e, t, s, n, l, r, o;
  const a = (
    /*#slots*/
    i[83].selection
  ), c = Gt(
    a,
    i,
    /*$$scope*/
    i[82],
    oR
  ), f = c || que(i);
  let d = !/*disabled*/
  i[11] && !/*multiFullItemClearable*/
  i[10] && Ac && kR(i);
  function p() {
    return (
      /*click_handler_1*/
      i[93](
        /*i*/
        i[128]
      )
    );
  }
  return u(p, "click_handler_1"), {
    c() {
      e = E("div"), t = E("span"), f && f.c(), s = F(), d && d.c(), n = F(), b(t, "class", "multi-item-text svelte-82qwg8"), b(e, "class", "multi-item svelte-82qwg8"), b(e, "role", "none"), Z(
        e,
        "active",
        /*activeValue*/
        i[26] === /*i*/
        i[128]
      ), Z(
        e,
        "disabled",
        /*disabled*/
        i[11]
      );
    },
    m(m, g) {
      T(m, e, g), A(e, t), f && f.m(t, null), A(e, s), d && d.m(e, null), A(e, n), l = !0, r || (o = [
        W(e, "click", st(p)),
        W(e, "keydown", Ve(st(
          /*keydown_handler_1*/
          i[84]
        )))
      ], r = !0);
    },
    p(m, g) {
      i = m, c ? c.p && (!l || g[0] & /*value*/
      8 | g[2] & /*$$scope*/
      1048576) && Ht(
        c,
        a,
        i,
        /*$$scope*/
        i[82],
        l ? zt(
          a,
          /*$$scope*/
          i[82],
          g,
          Eue
        ) : Ut(
          /*$$scope*/
          i[82]
        ),
        oR
      ) : f && f.p && (!l || g[0] & /*value, label*/
      4104) && f.p(i, l ? g : [-1, -1, -1, -1, -1]), !/*disabled*/
      i[11] && !/*multiFullItemClearable*/
      i[10] && Ac ? d ? (d.p(i, g), g[0] & /*disabled, multiFullItemClearable*/
      3072 && w(d, 1)) : (d = kR(i), d.c(), w(d, 1), d.m(e, n)) : d && (ae(), O(d, 1, 1, () => {
        d = null;
      }), ce()), (!l || g[0] & /*activeValue*/
      67108864) && Z(
        e,
        "active",
        /*activeValue*/
        i[26] === /*i*/
        i[128]
      ), (!l || g[0] & /*disabled*/
      2048) && Z(
        e,
        "disabled",
        /*disabled*/
        i[11]
      );
    },
    i(m) {
      l || (w(f, m), w(d), l = !0);
    },
    o(m) {
      O(f, m), O(d), l = !1;
    },
    d(m) {
      m && C(e), f && f.d(m), d && d.d(), r = !1, Me(o);
    }
  };
}
u(wR, "create_each_block$D");
function $R(i) {
  let e, t;
  const s = (
    /*#slots*/
    i[83]["loading-icon"]
  ), n = Gt(
    s,
    i,
    /*$$scope*/
    i[82],
    nR
  ), l = n || zue();
  return {
    c() {
      e = E("div"), l && l.c(), b(e, "class", "icon loading svelte-82qwg8"), b(e, "aria-hidden", "true");
    },
    m(r, o) {
      T(r, e, o), l && l.m(e, null), t = !0;
    },
    p(r, o) {
      n && n.p && (!t || o[2] & /*$$scope*/
      1048576) && Ht(
        n,
        s,
        r,
        /*$$scope*/
        r[82],
        t ? zt(
          s,
          /*$$scope*/
          r[82],
          o,
          wue
        ) : Ut(
          /*$$scope*/
          r[82]
        ),
        nR
      );
    },
    i(r) {
      t || (w(l, r), t = !0);
    },
    o(r) {
      O(l, r), t = !1;
    },
    d(r) {
      r && C(e), l && l.d(r);
    }
  };
}
u($R, "create_if_block_3$k");
function zue(i) {
  let e, t;
  return e = new bv({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(zue, "fallback_block_4");
function AR(i) {
  let e, t, s, n;
  const l = (
    /*#slots*/
    i[83]["clear-icon"]
  ), r = Gt(
    l,
    i,
    /*$$scope*/
    i[82],
    sR
  ), o = r || Hue();
  return {
    c() {
      e = E("button"), o && o.c(), b(e, "type", "button"), b(e, "class", "icon clear-select svelte-82qwg8");
    },
    m(a, c) {
      T(a, e, c), o && o.m(e, null), t = !0, s || (n = W(
        e,
        "click",
        /*handleClear*/
        i[22]
      ), s = !0);
    },
    p(a, c) {
      r && r.p && (!t || c[2] & /*$$scope*/
      1048576) && Ht(
        r,
        l,
        a,
        /*$$scope*/
        a[82],
        t ? zt(
          l,
          /*$$scope*/
          a[82],
          c,
          kue
        ) : Ut(
          /*$$scope*/
          a[82]
        ),
        sR
      );
    },
    i(a) {
      t || (w(o, a), t = !0);
    },
    o(a) {
      O(o, a), t = !1;
    },
    d(a) {
      a && C(e), o && o.d(a), s = !1, n();
    }
  };
}
u(AR, "create_if_block_2$v");
function Hue(i) {
  let e, t;
  return e = new Ac({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Hue, "fallback_block_3");
function ER(i) {
  let e, t;
  const s = (
    /*#slots*/
    i[83]["chevron-icon"]
  ), n = Gt(
    s,
    i,
    /*$$scope*/
    i[82],
    tR
  ), l = n || Uue();
  return {
    c() {
      e = E("div"), l && l.c(), b(e, "class", "icon chevron svelte-82qwg8"), b(e, "aria-hidden", "true");
    },
    m(r, o) {
      T(r, e, o), l && l.m(e, null), t = !0;
    },
    p(r, o) {
      n && n.p && (!t || o[0] & /*listOpen*/
      64 | o[2] & /*$$scope*/
      1048576) && Ht(
        n,
        s,
        r,
        /*$$scope*/
        r[82],
        t ? zt(
          s,
          /*$$scope*/
          r[82],
          o,
          vue
        ) : Ut(
          /*$$scope*/
          r[82]
        ),
        tR
      );
    },
    i(r) {
      t || (w(l, r), t = !0);
    },
    o(r) {
      O(l, r), t = !1;
    },
    d(r) {
      r && C(e), l && l.d(r);
    }
  };
}
u(ER, "create_if_block_1$F");
function Uue(i) {
  let e, t;
  return e = new gv({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Uue, "fallback_block_2");
function Vue(i) {
  let e, t;
  return {
    c() {
      e = E("input"), b(
        e,
        "name",
        /*name*/
        i[8]
      ), b(e, "type", "hidden"), e.value = t = /*value*/
      i[3] ? JSON.stringify(
        /*value*/
        i[3]
      ) : null, b(e, "class", "svelte-82qwg8");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n[0] & /*name*/
      256 && b(
        e,
        "name",
        /*name*/
        s[8]
      ), n[0] & /*value*/
      8 && t !== (t = /*value*/
      s[3] ? JSON.stringify(
        /*value*/
        s[3]
      ) : null) && (e.value = t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(Vue, "fallback_block_1");
function SR(i) {
  let e;
  const t = (
    /*#slots*/
    i[83].required
  ), s = Gt(
    t,
    i,
    /*$$scope*/
    i[82],
    x6
  ), n = s || Wue();
  return {
    c() {
      n && n.c();
    },
    m(l, r) {
      n && n.m(l, r), e = !0;
    },
    p(l, r) {
      s && s.p && (!e || r[0] & /*value*/
      8 | r[2] & /*$$scope*/
      1048576) && Ht(
        s,
        t,
        l,
        /*$$scope*/
        l[82],
        e ? zt(
          t,
          /*$$scope*/
          l[82],
          r,
          _ue
        ) : Ut(
          /*$$scope*/
          l[82]
        ),
        x6
      );
    },
    i(l) {
      e || (w(n, l), e = !0);
    },
    o(l) {
      O(n, l), e = !1;
    },
    d(l) {
      n && n.d(l);
    }
  };
}
u(SR, "create_if_block$X");
function Wue(i) {
  let e;
  return {
    c() {
      e = E("select"), b(e, "class", "required svelte-82qwg8"), e.required = !0, b(e, "tabindex", "-1"), b(e, "aria-hidden", "true");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    d(t) {
      t && C(e);
    }
  };
}
u(Wue, "fallback_block");
function Kue(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S, D = (
    /*listOpen*/
    i[6] && hR(i)
  ), I = (
    /*focused*/
    i[2] && yR(i)
  );
  const M = (
    /*#slots*/
    i[83].prepend
  ), L = Gt(
    M,
    i,
    /*$$scope*/
    i[82],
    aR
  );
  let B = (
    /*hasValue*/
    i[25] && vR(i)
  ), z = [
    {
      readOnly: f = !/*searchable*/
      i[17]
    },
    /*_inputAttributes*/
    i[27],
    { placeholder: (
      /*placeholderText*/
      i[33]
    ) },
    { style: (
      /*inputStyles*/
      i[18]
    ) },
    { disabled: (
      /*disabled*/
      i[11]
    ) }
  ], q = {};
  for (let ee = 0; ee < z.length; ee += 1)
    q = Dt(q, z[ee]);
  let U = (
    /*loading*/
    i[5] && $R(i)
  ), H = (
    /*showClear*/
    i[34] && AR(i)
  ), V = (
    /*showChevron*/
    i[20] && ER(i)
  );
  const Y = (
    /*#slots*/
    i[83]["input-hidden"]
  ), J = Gt(
    Y,
    i,
    /*$$scope*/
    i[82],
    eR
  ), fe = J || Vue(i);
  let ke = (
    /*required*/
    i[16] && (!/*value*/
    i[3] || /*value*/
    i[3].length === 0) && SR(i)
  );
  return {
    c() {
      e = E("div"), D && D.c(), t = F(), s = E("span"), I && I.c(), n = F(), l = E("div"), L && L.c(), r = F(), o = E("div"), B && B.c(), a = F(), c = E("input"), d = F(), p = E("div"), U && U.c(), m = F(), H && H.c(), g = F(), V && V.c(), h = F(), fe && fe.c(), _ = F(), ke && ke.c(), b(s, "aria-live", "polite"), b(s, "aria-atomic", "false"), b(s, "aria-relevant", "additions text"), b(s, "class", "a11y-text svelte-82qwg8"), b(l, "class", "prepend svelte-82qwg8"), Bd(c, q), Z(c, "svelte-82qwg8", !0), b(o, "class", "value-container svelte-82qwg8"), b(p, "class", "indicators svelte-82qwg8"), b(e, "class", y = "svelte-select " + /*containerClasses*/
      i[21] + " svelte-82qwg8"), b(
        e,
        "style",
        /*containerStyles*/
        i[14]
      ), b(e, "role", "none"), Z(
        e,
        "multi",
        /*multiple*/
        i[9]
      ), Z(
        e,
        "disabled",
        /*disabled*/
        i[11]
      ), Z(
        e,
        "focused",
        /*focused*/
        i[2]
      ), Z(
        e,
        "list-open",
        /*listOpen*/
        i[6]
      ), Z(
        e,
        "show-chevron",
        /*showChevron*/
        i[20]
      ), Z(
        e,
        "error",
        /*hasError*/
        i[15]
      );
    },
    m(ee, ne) {
      T(ee, e, ne), D && D.m(e, null), A(e, t), A(e, s), I && I.m(s, null), A(e, n), A(e, l), L && L.m(l, null), A(e, r), A(e, o), B && B.m(o, null), A(o, a), A(o, c), c.autofocus && c.focus(), i[94](c), He(
        c,
        /*filterText*/
        i[4]
      ), A(e, d), A(e, p), U && U.m(p, null), A(p, m), H && H.m(p, null), A(p, g), V && V.m(p, null), A(e, h), fe && fe.m(e, null), A(e, _), ke && ke.m(e, null), i[96](e), v = !0, k || (S = [
        W(
          window,
          "click",
          /*handleClickOutside*/
          i[42]
        ),
        W(
          window,
          "keydown",
          /*handleKeyDown*/
          i[37]
        ),
        W(
          c,
          "keydown",
          /*handleKeyDown*/
          i[37]
        ),
        W(
          c,
          "blur",
          /*handleBlur*/
          i[39]
        ),
        W(
          c,
          "focus",
          /*handleFocus*/
          i[38]
        ),
        W(
          c,
          "input",
          /*input_1_input_handler*/
          i[95]
        ),
        W(e, "pointerup", st(
          /*handleClick*/
          i[40]
        )),
        Et(
          /*floatingRef*/
          i[48].call(null, e)
        )
      ], k = !0);
    },
    p(ee, ne) {
      /*listOpen*/
      ee[6] ? D ? (D.p(ee, ne), ne[0] & /*listOpen*/
      64 && w(D, 1)) : (D = hR(ee), D.c(), w(D, 1), D.m(e, t)) : D && (ae(), O(D, 1, 1, () => {
        D = null;
      }), ce()), /*focused*/
      ee[2] ? I ? I.p(ee, ne) : (I = yR(ee), I.c(), I.m(s, null)) : I && (I.d(1), I = null), L && L.p && (!v || ne[2] & /*$$scope*/
      1048576) && Ht(
        L,
        M,
        ee,
        /*$$scope*/
        ee[82],
        v ? zt(
          M,
          /*$$scope*/
          ee[82],
          ne,
          Sue
        ) : Ut(
          /*$$scope*/
          ee[82]
        ),
        aR
      ), /*hasValue*/
      ee[25] ? B ? (B.p(ee, ne), ne[0] & /*hasValue*/
      33554432 && w(B, 1)) : (B = vR(ee), B.c(), w(B, 1), B.m(o, a)) : B && (ae(), O(B, 1, 1, () => {
        B = null;
      }), ce()), Bd(c, q = Vt(z, [
        (!v || ne[0] & /*searchable*/
        131072 && f !== (f = !/*searchable*/
        ee[17])) && { readOnly: f },
        ne[0] & /*_inputAttributes*/
        134217728 && /*_inputAttributes*/
        ee[27],
        (!v || ne[1] & /*placeholderText*/
        4) && { placeholder: (
          /*placeholderText*/
          ee[33]
        ) },
        (!v || ne[0] & /*inputStyles*/
        262144) && { style: (
          /*inputStyles*/
          ee[18]
        ) },
        (!v || ne[0] & /*disabled*/
        2048) && { disabled: (
          /*disabled*/
          ee[11]
        ) }
      ])), ne[0] & /*filterText*/
      16 && c.value !== /*filterText*/
      ee[4] && He(
        c,
        /*filterText*/
        ee[4]
      ), Z(c, "svelte-82qwg8", !0), /*loading*/
      ee[5] ? U ? (U.p(ee, ne), ne[0] & /*loading*/
      32 && w(U, 1)) : (U = $R(ee), U.c(), w(U, 1), U.m(p, m)) : U && (ae(), O(U, 1, 1, () => {
        U = null;
      }), ce()), /*showClear*/
      ee[34] ? H ? (H.p(ee, ne), ne[1] & /*showClear*/
      8 && w(H, 1)) : (H = AR(ee), H.c(), w(H, 1), H.m(p, g)) : H && (ae(), O(H, 1, 1, () => {
        H = null;
      }), ce()), /*showChevron*/
      ee[20] ? V ? (V.p(ee, ne), ne[0] & /*showChevron*/
      1048576 && w(V, 1)) : (V = ER(ee), V.c(), w(V, 1), V.m(p, null)) : V && (ae(), O(V, 1, 1, () => {
        V = null;
      }), ce()), J ? J.p && (!v || ne[0] & /*value*/
      8 | ne[2] & /*$$scope*/
      1048576) && Ht(
        J,
        Y,
        ee,
        /*$$scope*/
        ee[82],
        v ? zt(
          Y,
          /*$$scope*/
          ee[82],
          ne,
          yue
        ) : Ut(
          /*$$scope*/
          ee[82]
        ),
        eR
      ) : fe && fe.p && (!v || ne[0] & /*name, value*/
      264) && fe.p(ee, v ? ne : [-1, -1, -1, -1, -1]), /*required*/
      ee[16] && (!/*value*/
      ee[3] || /*value*/
      ee[3].length === 0) ? ke ? (ke.p(ee, ne), ne[0] & /*required, value*/
      65544 && w(ke, 1)) : (ke = SR(ee), ke.c(), w(ke, 1), ke.m(e, null)) : ke && (ae(), O(ke, 1, 1, () => {
        ke = null;
      }), ce()), (!v || ne[0] & /*containerClasses*/
      2097152 && y !== (y = "svelte-select " + /*containerClasses*/
      ee[21] + " svelte-82qwg8")) && b(e, "class", y), (!v || ne[0] & /*containerStyles*/
      16384) && b(
        e,
        "style",
        /*containerStyles*/
        ee[14]
      ), (!v || ne[0] & /*containerClasses, multiple*/
      2097664) && Z(
        e,
        "multi",
        /*multiple*/
        ee[9]
      ), (!v || ne[0] & /*containerClasses, disabled*/
      2099200) && Z(
        e,
        "disabled",
        /*disabled*/
        ee[11]
      ), (!v || ne[0] & /*containerClasses, focused*/
      2097156) && Z(
        e,
        "focused",
        /*focused*/
        ee[2]
      ), (!v || ne[0] & /*containerClasses, listOpen*/
      2097216) && Z(
        e,
        "list-open",
        /*listOpen*/
        ee[6]
      ), (!v || ne[0] & /*containerClasses, showChevron*/
      3145728) && Z(
        e,
        "show-chevron",
        /*showChevron*/
        ee[20]
      ), (!v || ne[0] & /*containerClasses, hasError*/
      2129920) && Z(
        e,
        "error",
        /*hasError*/
        ee[15]
      );
    },
    i(ee) {
      v || (w(D), w(L, ee), w(B), w(U), w(H), w(V), w(fe, ee), w(ke), v = !0);
    },
    o(ee) {
      O(D), O(L, ee), O(B), O(U), O(H), O(V), O(fe, ee), O(ke), v = !1;
    },
    d(ee) {
      ee && C(e), D && D.d(), I && I.d(), L && L.d(ee), B && B.d(), i[94](null), U && U.d(), H && H.d(), V && V.d(), fe && fe.d(ee), ke && ke.d(), i[96](null), k = !1, Me(S);
    }
  };
}
u(Kue, "create_fragment$1J");
function CR(i) {
  return i.map((e, t) => ({ index: t, value: e, label: `${e}` }));
}
u(CR, "convertStringItemsToObjects");
function Yue(i) {
  return i === 0;
}
u(Yue, "isItemFirst");
function Xue(i) {
  return i.groupHeader && i.selectable || i.selectable || !i.hasOwnProperty("selectable");
}
u(Xue, "isItemSelectable");
function Jue(i, e, t) {
  let s, n, l, r, o, a, c, f, d, { $$slots: p = {}, $$scope: m } = e;
  const g = O5(p), h = ft();
  let { justValue: _ = null } = e, { filter: y = pue } = e, { getItems: v = mue } = e, { id: k = null } = e, { name: S = null } = e, { container: D = void 0 } = e, { input: I = void 0 } = e, { multiple: M = !1 } = e, { multiFullItemClearable: L = !1 } = e, { disabled: B = !1 } = e, { focused: z = !1 } = e, { value: q = null } = e, { filterText: U = "" } = e, { placeholder: H = "Please select" } = e, { placeholderAlwaysShow: V = !1 } = e, { items: Y = null } = e, { label: J = "label" } = e, { itemFilter: fe = /* @__PURE__ */ u((ve, it, ms) => `${ve}`.toLowerCase().includes(it.toLowerCase()), "itemFilter") } = e, { groupBy: ke = void 0 } = e, { groupFilter: ee = /* @__PURE__ */ u((ve) => ve, "groupFilter") } = e, { groupHeaderSelectable: ne = !1 } = e, { itemId: Ee = "value" } = e, { loadOptions: Pe = void 0 } = e, { containerStyles: ye = "" } = e, { hasError: me = !1 } = e, { filterSelectedItems: Ce = !0 } = e, { required: Je = !1 } = e, { closeListOnChange: Ne = !0 } = e, { clearFilterTextOnBlur: Re = !0 } = e, { createGroupHeaderItem: ge = /* @__PURE__ */ u((ve, it) => ({ value: ve, [J]: ve }), "createGroupHeaderItem") } = e;
  const je = /* @__PURE__ */ u(() => c, "getFilteredItems");
  let { searchable: Be = !0 } = e, { inputStyles: Ze = "" } = e, { clearable: Ge = !0 } = e, { loading: Se = !1 } = e, { listOpen: _e = !1 } = e, we, { debounce: Fe = /* @__PURE__ */ u((ve, it = 1) => {
    clearTimeout(we), we = setTimeout(ve, it);
  }, "debounce") } = e, { debounceWait: xe = 300 } = e, { hideEmptyState: vt = !1 } = e, { inputAttributes: ps = {} } = e, { listAutoWidth: As = !0 } = e, { showChevron: zs = !1 } = e, { listOffset: sn = 5 } = e, { hoverItemIndex: St = 0 } = e, { floatingConfig: ws = {} } = e, { class: _i = "" } = e, es, yi, Ir, Pr;
  function Ao() {
    if (typeof q == "string") {
      let ve = (Y || []).find((it) => it[Ee] === q);
      t(3, q = ve || { [Ee]: q, label: q });
    } else M && Array.isArray(q) && q.length > 0 && t(3, q = q.map((ve) => typeof ve == "string" ? { value: ve, label: ve } : ve));
  }
  u(Ao, "setValue");
  let Bi;
  function Eo() {
    t(27, Bi = Object.assign(
      {
        autocapitalize: "none",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        tabindex: 0,
        type: "text",
        "aria-autocomplete": "list"
      },
      ps
    )), k && t(27, Bi.id = k, Bi), Be || t(27, Bi.readonly = !0, Bi);
  }
  u(Eo, "assignInputAttributes");
  function Ie(ve) {
    const it = [], ms = {};
    ve.forEach((So) => {
      const hl = ke(So);
      it.includes(hl) || (it.push(hl), ms[hl] = [], hl && ms[hl].push(Object.assign(ge(hl, So), {
        id: hl,
        groupHeader: !0,
        selectable: ne
      }))), ms[hl].push(Object.assign({ groupItem: !!hl }, So));
    });
    const ml = [];
    return ee(it).forEach((So) => {
      ms[So] && ml.push(...ms[So]);
    }), ml;
  }
  u(Ie, "filterGroupedItems");
  function nt() {
    if (M) {
      JSON.stringify(q) !== JSON.stringify(yi) && R3() && h("input", q);
      return;
    }
    (!yi || JSON.stringify(q[Ee]) !== JSON.stringify(yi[Ee])) && h("input", q);
  }
  u(nt, "dispatchSelectedItem");
  function Ft() {
    q && (Array.isArray(q) ? t(3, q = [...q]) : t(3, q = [q]));
  }
  u(Ft, "setupMulti");
  function Qe() {
    q && t(3, q = null);
  }
  u(Qe, "setupSingle");
  function _n() {
    const ve = c.findIndex((it) => it[Ee] === q[Ee]);
    Mr(ve, !0);
  }
  u(_n, "setValueIndexAsHoverIndex");
  function Wl(ve) {
    h("hoverItem", ve);
  }
  u(Wl, "dispatchHover");
  function Mr(ve = 0, it) {
    t(7, St = ve < 0 ? 0 : ve), !it && ke && c[St] && !c[St].selectable && od(1);
  }
  u(Mr, "checkHoverSelectable");
  function Tc() {
    !Pe && U.length === 0 || (Pe ? Fe(
      async function() {
        t(5, Se = !0);
        let ve = await v({
          dispatch: h,
          loadOptions: Pe,
          convertStringItemsToObjects: CR,
          filterText: U
        });
        ve ? (t(5, Se = ve.loading), t(6, _e = _e ? ve.listOpen : U.length > 0), t(2, z = _e && ve.focused), t(51, Y = ke ? Ie(ve.filteredItems) : ve.filteredItems)) : (t(5, Se = !1), t(2, z = !0), t(6, _e = !0));
      },
      xe
    ) : (t(6, _e = !0), M && t(26, es = void 0)));
  }
  u(Tc, "setupFilterText");
  function Tq(ve) {
    _e && h("filter", ve);
  }
  u(Tq, "handleFilterEvent"), yG(async () => {
    t(78, yi = q), t(79, Ir = U), t(80, Pr = M);
  });
  function Oq() {
    return M ? q ? q.map((ve) => ve[Ee]) : null : q && q[Ee];
  }
  u(Oq, "computeJustValue");
  function R3() {
    let ve = !0;
    if (q) {
      const it = [], ms = [];
      q.forEach((ml) => {
        it.includes(ml[Ee]) ? ve = !1 : (it.push(ml[Ee]), ms.push(ml));
      }), ve || t(3, q = ms);
    }
    return ve;
  }
  u(R3, "checkValueForDuplicates");
  function N3(ve) {
    let it = ve ? ve[Ee] : q[Ee];
    return Y.find((ms) => ms[Ee] === it);
  }
  u(N3, "findItem");
  function Dq(ve) {
    !ve || ve.length === 0 || ve.some((it) => typeof it != "object") || !q || (M ? q.some((it) => !it || !it[Ee]) : !q[Ee]) || (Array.isArray(q) ? t(3, q = q.map((it) => N3(it) || it)) : t(3, q = N3() || q));
  }
  u(Dq, "updateValueDisplay");
  async function rd(ve) {
    const it = q[ve];
    q.length === 1 ? t(3, q = void 0) : t(3, q = q.filter((ms) => ms !== it)), h("clear", it);
  }
  u(rd, "handleMultiItemClear");
  function Iq(ve) {
    if (z)
      switch (ve.stopPropagation(), ve.key) {
        case "Escape":
          ve.preventDefault(), pl();
          break;
        case "Enter":
          if (ve.preventDefault(), _e) {
            if (c.length === 0) break;
            const it = c[St];
            if (q && !M && q[Ee] === it[Ee]) {
              pl();
              break;
            } else
              Tg(c[St]);
          }
          break;
        case "ArrowDown":
          ve.preventDefault(), _e ? od(1) : (t(6, _e = !0), t(26, es = void 0));
          break;
        case "ArrowUp":
          ve.preventDefault(), _e ? od(-1) : (t(6, _e = !0), t(26, es = void 0));
          break;
        case "Tab":
          if (_e && z) {
            if (c.length === 0 || q && q[Ee] === c[St][Ee]) return pl();
            ve.preventDefault(), Tg(c[St]), pl();
          }
          break;
        case "Backspace":
          if (!M || U.length > 0) return;
          if (M && q && q.length > 0) {
            if (rd(es !== void 0 ? es : q.length - 1), es === 0 || es === void 0) break;
            t(26, es = q.length > es ? es - 1 : void 0);
          }
          break;
        case "ArrowLeft":
          if (!q || !M || U.length > 0) return;
          es === void 0 ? t(26, es = q.length - 1) : q.length > es && es !== 0 && t(26, es -= 1);
          break;
        case "ArrowRight":
          if (!q || !M || U.length > 0 || es === void 0) return;
          es === q.length - 1 ? t(26, es = void 0) : es < q.length - 1 && t(26, es += 1);
          break;
      }
  }
  u(Iq, "handleKeyDown");
  function $g(ve) {
    z && I === (document == null ? void 0 : document.activeElement) || (ve && h("focus", ve), I == null || I.focus(), t(2, z = !0));
  }
  u($g, "handleFocus");
  async function j3(ve) {
    Cg || (_e || z) && (h("blur", ve), pl(), t(2, z = !1), t(26, es = void 0), I == null || I.blur());
  }
  u(j3, "handleBlur");
  function Pq() {
    if (!B) {
      if (U.length > 0) return t(6, _e = !0);
      t(6, _e = !_e);
    }
  }
  u(Pq, "handleClick");
  function Mq() {
    h("clear", q), t(3, q = void 0), pl(), $g();
  }
  u(Mq, "handleClear"), $o(() => {
    _e && t(2, z = !0), z && I && I.focus();
  });
  function Fq(ve) {
    if (ve) {
      t(4, U = "");
      const it = Object.assign({}, ve);
      if (it.groupHeader && !it.selectable) return;
      t(3, q = M ? q ? q.concat([it]) : [it] : t(3, q = it)), setTimeout(() => {
        Ne && pl(), t(26, es = void 0), h("change", q), h("select", ve);
      });
    }
  }
  u(Fq, "itemSelected");
  function pl() {
    Re && t(4, U = ""), t(6, _e = !1);
  }
  u(pl, "closeList");
  let { ariaValues: Ag = /* @__PURE__ */ u((ve) => `Option ${ve}, selected.`, "ariaValues") } = e, { ariaListOpen: Eg = /* @__PURE__ */ u((ve, it) => `You are currently focused on option ${ve}. There are ${it} results available.`, "ariaListOpen") } = e, { ariaFocused: Sg = /* @__PURE__ */ u(() => "Select is focused, type to refine list, press down to open the menu.", "ariaFocused") } = e;
  function Rq(ve) {
    let it;
    return ve && q.length > 0 ? it = q.map((ms) => ms[J]).join(", ") : it = q[J], Ag(it);
  }
  u(Rq, "handleAriaSelection");
  function Nq() {
    if (!c || c.length === 0) return "";
    let ve = c[St];
    if (_e && ve) {
      let it = c ? c.length : 0;
      return Eg(ve[J], it);
    } else
      return Sg();
  }
  u(Nq, "handleAriaContent");
  let yn = null, L3;
  function B3() {
    clearTimeout(L3), L3 = setTimeout(
      () => {
        Cg = !1;
      },
      100
    );
  }
  u(B3, "handleListScroll");
  function jq(ve) {
    !_e && !z && D && !D.contains(ve.target) && !(yn != null && yn.contains(ve.target)) && j3();
  }
  u(jq, "handleClickOutside"), Qt(() => {
    yn == null || yn.remove();
  });
  let Cg = !1;
  function Tg(ve) {
    !ve || ve.selectable === !1 || Fq(ve);
  }
  u(Tg, "handleSelect");
  function Og(ve) {
    Cg || t(7, St = ve);
  }
  u(Og, "handleHover");
  function q3(ve) {
    const { item: it, i: ms } = ve;
    if ((it == null ? void 0 : it.selectable) !== !1) {
      if (q && !M && q[Ee] === it[Ee]) return pl();
      Xue(it) && (t(7, St = ms), Tg(it));
    }
  }
  u(q3, "handleItemClick");
  function od(ve) {
    if (c.filter((ml) => !Object.hasOwn(ml, "selectable") || ml.selectable === !0).length === 0)
      return t(7, St = 0);
    ve > 0 && St === c.length - 1 ? t(7, St = 0) : ve < 0 && St === 0 ? t(7, St = c.length - 1) : t(7, St = St + ve);
    const ms = c[St];
    if (ms && ms.selectable === !1) {
      (ve === 1 || ve === -1) && od(ve);
      return;
    }
  }
  u(od, "setHoverIndex");
  function Lq(ve, it, ms) {
    if (!M)
      return it && it[ms] === ve[ms];
  }
  u(Lq, "isItemActive");
  const Bq = G3, qq = G3;
  function G3(ve) {
    return {
      update(it) {
        it.scroll && (B3(), ve.scrollIntoView({ behavior: "auto", block: "nearest" }));
      }
    };
  }
  u(G3, "scrollAction");
  function Gq() {
    const { width: ve } = D.getBoundingClientRect();
    t(23, yn.style.width = As ? ve + "px" : "auto", yn);
  }
  u(Gq, "setListWidth");
  let Oc = {
    strategy: "absolute",
    placement: "bottom-start",
    middleware: [aue(sn), uue(), cue()],
    autoUpdate: !1
  };
  const [zq, Hq, Uq] = due(Oc);
  let Dg = !0;
  function Vq(ve, it) {
    if (!ve || !it) return t(28, Dg = !0);
    setTimeout(
      () => {
        t(28, Dg = !1);
      },
      0
    );
  }
  u(Vq, "listMounted");
  function Wq(ve) {
    bt.call(this, i, ve);
  }
  u(Wq, "keydown_handler_1");
  function Kq(ve) {
    bt.call(this, i, ve);
  }
  u(Kq, "pointerup_handler");
  function Yq(ve) {
    bt.call(this, i, ve);
  }
  u(Yq, "mousedown_handler");
  function Xq(ve) {
    bt.call(this, i, ve);
  }
  u(Xq, "keydown_handler");
  const Jq = /* @__PURE__ */ u((ve) => Og(ve), "mouseover_handler"), Zq = /* @__PURE__ */ u((ve) => Og(ve), "focus_handler"), Qq = /* @__PURE__ */ u((ve, it) => q3({ item: ve, i: it }), "click_handler");
  function xq(ve) {
    rt[ve ? "unshift" : "push"](() => {
      yn = ve, t(23, yn);
    });
  }
  u(xq, "div_binding");
  const eG = /* @__PURE__ */ u((ve) => rd(ve), "pointerup_handler_1"), tG = /* @__PURE__ */ u((ve) => L ? rd(ve) : {}, "click_handler_1");
  function sG(ve) {
    rt[ve ? "unshift" : "push"](() => {
      I = ve, t(1, I);
    });
  }
  u(sG, "input_1_binding");
  function nG() {
    U = this.value, t(4, U);
  }
  u(nG, "input_1_input_handler");
  function iG(ve) {
    rt[ve ? "unshift" : "push"](() => {
      D = ve, t(0, D);
    });
  }
  return u(iG, "div3_binding"), i.$$set = (ve) => {
    "justValue" in ve && t(52, _ = ve.justValue), "filter" in ve && t(53, y = ve.filter), "getItems" in ve && t(54, v = ve.getItems), "id" in ve && t(55, k = ve.id), "name" in ve && t(8, S = ve.name), "container" in ve && t(0, D = ve.container), "input" in ve && t(1, I = ve.input), "multiple" in ve && t(9, M = ve.multiple), "multiFullItemClearable" in ve && t(10, L = ve.multiFullItemClearable), "disabled" in ve && t(11, B = ve.disabled), "focused" in ve && t(2, z = ve.focused), "value" in ve && t(3, q = ve.value), "filterText" in ve && t(4, U = ve.filterText), "placeholder" in ve && t(56, H = ve.placeholder), "placeholderAlwaysShow" in ve && t(57, V = ve.placeholderAlwaysShow), "items" in ve && t(51, Y = ve.items), "label" in ve && t(12, J = ve.label), "itemFilter" in ve && t(58, fe = ve.itemFilter), "groupBy" in ve && t(59, ke = ve.groupBy), "groupFilter" in ve && t(60, ee = ve.groupFilter), "groupHeaderSelectable" in ve && t(61, ne = ve.groupHeaderSelectable), "itemId" in ve && t(13, Ee = ve.itemId), "loadOptions" in ve && t(62, Pe = ve.loadOptions), "containerStyles" in ve && t(14, ye = ve.containerStyles), "hasError" in ve && t(15, me = ve.hasError), "filterSelectedItems" in ve && t(63, Ce = ve.filterSelectedItems), "required" in ve && t(16, Je = ve.required), "closeListOnChange" in ve && t(64, Ne = ve.closeListOnChange), "clearFilterTextOnBlur" in ve && t(65, Re = ve.clearFilterTextOnBlur), "createGroupHeaderItem" in ve && t(66, ge = ve.createGroupHeaderItem), "searchable" in ve && t(17, Be = ve.searchable), "inputStyles" in ve && t(18, Ze = ve.inputStyles), "clearable" in ve && t(68, Ge = ve.clearable), "loading" in ve && t(5, Se = ve.loading), "listOpen" in ve && t(6, _e = ve.listOpen), "debounce" in ve && t(69, Fe = ve.debounce), "debounceWait" in ve && t(70, xe = ve.debounceWait), "hideEmptyState" in ve && t(19, vt = ve.hideEmptyState), "inputAttributes" in ve && t(71, ps = ve.inputAttributes), "listAutoWidth" in ve && t(72, As = ve.listAutoWidth), "showChevron" in ve && t(20, zs = ve.showChevron), "listOffset" in ve && t(73, sn = ve.listOffset), "hoverItemIndex" in ve && t(7, St = ve.hoverItemIndex), "floatingConfig" in ve && t(74, ws = ve.floatingConfig), "class" in ve && t(21, _i = ve.class), "ariaValues" in ve && t(75, Ag = ve.ariaValues), "ariaListOpen" in ve && t(76, Eg = ve.ariaListOpen), "ariaFocused" in ve && t(77, Sg = ve.ariaFocused), "$$scope" in ve && t(82, m = ve.$$scope);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*value*/
    8 | i.$$.dirty[1] & /*items*/
    1048576 && q && Ao(), i.$$.dirty[0] & /*searchable*/
    131072 | i.$$.dirty[2] & /*inputAttributes*/
    512 && (ps || !Be) && Eo(), i.$$.dirty[0] & /*multiple*/
    512 && M && Ft(), i.$$.dirty[0] & /*multiple*/
    512 | i.$$.dirty[2] & /*prev_multiple*/
    262144 && Pr && !M && Qe(), i.$$.dirty[0] & /*multiple, value*/
    520 && M && q && q.length > 1 && R3(), i.$$.dirty[0] & /*value*/
    8 && q && nt(), i.$$.dirty[0] & /*value, multiple*/
    520 | i.$$.dirty[2] & /*prev_value*/
    65536 && !q && M && yi && h("input", q), i.$$.dirty[0] & /*focused, input*/
    6 && !z && I && pl(), i.$$.dirty[0] & /*filterText*/
    16 | i.$$.dirty[2] & /*prev_filterText*/
    131072 && U !== Ir && Tc(), i.$$.dirty[0] & /*filterText, multiple, value, itemId, label*/
    12824 | i.$$.dirty[1] & /*filter, items, groupBy, itemFilter*/
    407896064 | i.$$.dirty[2] & /*loadOptions, filterSelectedItems*/
    3 && t(24, c = y({
      loadOptions: Pe,
      filterText: U,
      items: Y,
      multiple: M,
      value: q,
      itemId: Ee,
      groupBy: ke,
      label: J,
      filterSelectedItems: Ce,
      itemFilter: fe,
      convertStringItemsToObjects: CR,
      filterGroupedItems: Ie
    })), i.$$.dirty[0] & /*multiple, listOpen, value, filteredItems*/
    16777800 && !M && _e && q && c && _n(), i.$$.dirty[0] & /*listOpen, multiple*/
    576 && _e && M && t(7, St = 0), i.$$.dirty[0] & /*filterText*/
    16 && U && t(7, St = 0), i.$$.dirty[0] & /*hoverItemIndex*/
    128 && Wl(St), i.$$.dirty[0] & /*multiple, value*/
    520 && t(25, s = M ? q && q.length > 0 : q), i.$$.dirty[0] & /*hasValue, filterText*/
    33554448 && t(35, n = s && U.length > 0), i.$$.dirty[0] & /*hasValue, disabled, loading*/
    33556512 | i.$$.dirty[2] & /*clearable*/
    64 && t(34, l = s && Ge && !B && !Se), i.$$.dirty[0] & /*multiple, value*/
    520 | i.$$.dirty[1] & /*placeholderAlwaysShow, placeholder*/
    100663296 && t(33, r = V && M || M && (q == null ? void 0 : q.length) === 0 ? H : q ? "" : H), i.$$.dirty[0] & /*value, multiple*/
    520 && t(32, o = q ? Rq(M) : ""), i.$$.dirty[0] & /*filteredItems, hoverItemIndex, focused, listOpen*/
    16777412 && t(31, a = Nq()), i.$$.dirty[1] & /*items*/
    1048576 && Dq(Y), i.$$.dirty[0] & /*multiple, value, itemId*/
    8712 && t(52, _ = Oq()), i.$$.dirty[0] & /*multiple, value*/
    520 | i.$$.dirty[2] & /*prev_value*/
    65536 && !M && yi && !q && h("input", q), i.$$.dirty[0] & /*listOpen, filteredItems, multiple, value*/
    16777800 && _e && c && !M && !q && Mr(), i.$$.dirty[0] & /*filteredItems*/
    16777216 && Tq(c), i.$$.dirty[0] & /*container*/
    1 | i.$$.dirty[2] & /*floatingConfig*/
    4096 && D && (ws == null ? void 0 : ws.autoUpdate) === void 0 && t(81, Oc.autoUpdate = !0, Oc), i.$$.dirty[0] & /*container*/
    1 | i.$$.dirty[2] & /*floatingConfig, _floatingConfig*/
    528384 && D && ws && Uq(Object.assign(Oc, ws)), i.$$.dirty[0] & /*list*/
    8388608 && t(30, f = !!yn), i.$$.dirty[0] & /*list, listOpen*/
    8388672 && Vq(yn, _e), i.$$.dirty[0] & /*listOpen, container, list*/
    8388673 && _e && D && yn && Gq(), i.$$.dirty[0] & /*hoverItemIndex*/
    128 && t(29, d = St), i.$$.dirty[0] & /*input, listOpen, focused*/
    70 && I && _e && !z && $g();
  }, [
    D,
    I,
    z,
    q,
    U,
    Se,
    _e,
    St,
    S,
    M,
    L,
    B,
    J,
    Ee,
    ye,
    me,
    Je,
    Be,
    Ze,
    vt,
    zs,
    _i,
    Mq,
    yn,
    c,
    s,
    es,
    Bi,
    Dg,
    d,
    f,
    a,
    o,
    r,
    l,
    n,
    rd,
    Iq,
    $g,
    j3,
    Pq,
    B3,
    jq,
    Og,
    q3,
    Lq,
    Bq,
    qq,
    zq,
    Hq,
    g,
    Y,
    _,
    y,
    v,
    k,
    H,
    V,
    fe,
    ke,
    ee,
    ne,
    Pe,
    Ce,
    Ne,
    Re,
    ge,
    je,
    Ge,
    Fe,
    xe,
    ps,
    As,
    sn,
    ws,
    Ag,
    Eg,
    Sg,
    yi,
    Ir,
    Pr,
    Oc,
    m,
    p,
    Wq,
    Kq,
    Yq,
    Xq,
    Jq,
    Zq,
    Qq,
    xq,
    eG,
    tG,
    sG,
    nG,
    iG
  ];
}
u(Jue, "instance$1D");
const sC = class sC extends re {
  constructor(e) {
    super(), oe(
      this,
      e,
      Jue,
      Kue,
      le,
      {
        justValue: 52,
        filter: 53,
        getItems: 54,
        id: 55,
        name: 8,
        container: 0,
        input: 1,
        multiple: 9,
        multiFullItemClearable: 10,
        disabled: 11,
        focused: 2,
        value: 3,
        filterText: 4,
        placeholder: 56,
        placeholderAlwaysShow: 57,
        items: 51,
        label: 12,
        itemFilter: 58,
        groupBy: 59,
        groupFilter: 60,
        groupHeaderSelectable: 61,
        itemId: 13,
        loadOptions: 62,
        containerStyles: 14,
        hasError: 15,
        filterSelectedItems: 63,
        required: 16,
        closeListOnChange: 64,
        clearFilterTextOnBlur: 65,
        createGroupHeaderItem: 66,
        getFilteredItems: 67,
        searchable: 17,
        inputStyles: 18,
        clearable: 68,
        loading: 5,
        listOpen: 6,
        debounce: 69,
        debounceWait: 70,
        hideEmptyState: 19,
        inputAttributes: 71,
        listAutoWidth: 72,
        showChevron: 20,
        listOffset: 73,
        hoverItemIndex: 7,
        floatingConfig: 74,
        class: 21,
        handleClear: 22,
        ariaValues: 75,
        ariaListOpen: 76,
        ariaFocused: 77
      },
      null,
      [-1, -1, -1, -1, -1]
    );
  }
  get getFilteredItems() {
    return this.$$.ctx[67];
  }
  get handleClear() {
    return this.$$.ctx[22];
  }
};
u(sC, "Select");
let _v = sC;
function TR(i, e, t) {
  const s = i.slice();
  return s[15] = e[t], s;
}
u(TR, "get_each_context$C");
function OR(i) {
  var f;
  let e, t, s, n, l, r, o, a = ue(
    /*optionsList*/
    ((f = i[2][
      /*key*/
      i[1]
    ]) == null ? void 0 : f.modes) ?? []
  ), c = [];
  for (let d = 0; d < a.length; d += 1)
    c[d] = DR(TR(i, a, d));
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.effects.mode")}`, s = F(), n = E("select");
      for (let d = 0; d < c.length; d += 1)
        c[d].c();
      b(t, "class", "u-text-sm u-text-bold"), b(n, "id", ""), b(e, "class", "change-section svelte-1wzzx54");
    },
    m(d, p) {
      var m;
      T(d, e, p), A(e, t), A(e, s), A(e, n);
      for (let g = 0; g < c.length; g += 1)
        c[g] && c[g].m(n, null);
      Ys(
        n,
        /*$effect*/
        (m = i[4].changes[
          /*idx*/
          i[0]
        ]) == null ? void 0 : m.mode
      ), r || (o = W(
        n,
        "change",
        /*change_handler_2*/
        i[14]
      ), r = !0);
    },
    p(d, p) {
      var m, g, h;
      if (p & /*MODES, optionsList, key*/
      262) {
        a = ue(
          /*optionsList*/
          ((m = d[2][
            /*key*/
            d[1]
          ]) == null ? void 0 : m.modes) ?? []
        );
        let _;
        for (_ = 0; _ < a.length; _ += 1) {
          const y = TR(d, a, _);
          c[_] ? c[_].p(y, p) : (c[_] = DR(y), c[_].c(), c[_].m(n, null));
        }
        for (; _ < c.length; _ += 1)
          c[_].d(1);
        c.length = a.length;
      }
      p & /*$effect, idx, MODES, optionsList, key*/
      279 && l !== (l = /*$effect*/
      (g = d[4].changes[
        /*idx*/
        d[0]
      ]) == null ? void 0 : g.mode) && Ys(
        n,
        /*$effect*/
        (h = d[4].changes[
          /*idx*/
          d[0]
        ]) == null ? void 0 : h.mode
      );
    },
    d(d) {
      d && C(e), Le(c, d), r = !1, o();
    }
  };
}
u(OR, "create_if_block$W");
function DR(i) {
  let e, t = (
    /*label*/
    i[15].toLowerCase().capitalize() + ""
  ), s, n, l;
  return {
    c() {
      e = E("option"), s = Q(t), n = F(), e.__value = l = /*MODES*/
      i[8][
        /*label*/
        i[15]
      ], He(e, e.__value);
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*optionsList, key*/
      6 && t !== (t = /*label*/
      r[15].toLowerCase().capitalize() + "") && be(s, t), o & /*optionsList, key*/
      6 && l !== (l = /*MODES*/
      r[8][
        /*label*/
        r[15]
      ]) && (e.__value = l, He(e, e.__value));
    },
    d(r) {
      r && C(e);
    }
  };
}
u(DR, "create_each_block$C");
function Zue(i) {
  var v, k;
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _;
  n = new _v({
    props: {
      clearable: (
        /*clearable*/
        i[3]
      ),
      items: (
        /*items*/
        i[9]
      ),
      value: (
        /*effectKeyLocalizations*/
        i[7][
          /*key*/
          i[1]
        ]
      ),
      groupBy: (
        /*groupBy*/
        i[10]
      )
    }
  }), n.$on(
    "change",
    /*change_handler*/
    i[11]
  ), n.$on(
    "clear",
    /*clear_handler*/
    i[12]
  );
  let y = (
    /*optionsList*/
    ((k = (v = i[2][
      /*key*/
      i[1]
    ]) == null ? void 0 : v.modes) == null ? void 0 : k.length) > 1 && OR(i)
  );
  return {
    c() {
      var S;
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.effects.key")}`, s = F(), l = E("div"), j(n.$$.fragment), r = F(), o = E("div"), a = E("h3"), a.textContent = `${K("A5E.effects.priority")}`, c = F(), f = E("input"), p = F(), y && y.c(), m = $e(), b(t, "class", "u-text-sm u-text-bold"), G(l, "display", "contents"), G(l, "--background", "rgba(0, 0, 0, 0.05)"), G(l, "--height", "calc(var(--form-field-height) + 1px)"), G(l, "--padding", "0 3px"), G(l, "--item-padding", "0.25rem"), G(l, "--group-item-padding-left", "1rem"), G(l, "--border-radius", "var(--a5e-border-radius-standard)"), G(l, "--font-size", "var(--a5e-text-size-sm)"), G(l, "--font-family", "inherit"), G(l, "--input-color", "black"), G(l, "--group-title-font-size", "var(--a5e-text-size-sm)"), G(l, "--group-title-font-weight", "bold"), G(l, "--text-overflow", "ellipsis"), b(e, "class", "change-section u-flex-grow svelte-1wzzx54"), b(a, "class", "u-text-sm u-text-bold"), b(f, "class", "small-input"), b(f, "type", "number"), b(f, "name", ""), f.value = d = /*$effect*/
      ((S = i[4].changes[
        /*idx*/
        i[0]
      ]) == null ? void 0 : S.priority) ?? 0, b(o, "class", "change-section svelte-1wzzx54");
    },
    m(S, D) {
      T(S, e, D), A(e, t), A(e, s), A(e, l), R(n, l, null), T(S, r, D), T(S, o, D), A(o, a), A(o, c), A(o, f), T(S, p, D), y && y.m(S, D), T(S, m, D), g = !0, h || (_ = W(
        f,
        "change",
        /*change_handler_1*/
        i[13]
      ), h = !0);
    },
    p(S, [D]) {
      var M, L, B;
      const I = {};
      D & /*clearable*/
      8 && (I.clearable = /*clearable*/
      S[3]), D & /*key*/
      2 && (I.value = /*effectKeyLocalizations*/
      S[7][
        /*key*/
        S[1]
      ]), n.$set(I), (!g || D & /*$effect, idx, MODES, optionsList, key*/
      279 && d !== (d = /*$effect*/
      ((M = S[4].changes[
        /*idx*/
        S[0]
      ]) == null ? void 0 : M.priority) ?? 0) && f.value !== d) && (f.value = d), /*optionsList*/
      ((B = (L = S[2][
        /*key*/
        S[1]
      ]) == null ? void 0 : L.modes) == null ? void 0 : B.length) > 1 ? y ? y.p(S, D) : (y = OR(S), y.c(), y.m(m.parentNode, m)) : y && (y.d(1), y = null);
    },
    i(S) {
      g || (w(n.$$.fragment, S), g = !0);
    },
    o(S) {
      O(n.$$.fragment, S), g = !1;
    },
    d(S) {
      S && (C(e), C(r), C(o), C(p), C(m)), N(n), y && y.d(S), h = !1, _();
    }
  };
}
u(Zue, "create_fragment$1I");
function Que(i, e, t) {
  let s, { idx: n } = e, { key: l } = e, { optionsList: r } = e, { clearable: o = !0 } = e;
  const a = ft(), c = de("effect");
  pe(i, c, (v) => t(4, s = v));
  const f = CONFIG.A5E.effectsKeyLocalizations, d = CONFIG.A5E.ACTIVE_EFFECT_MODES, p = Dce(r), m = /* @__PURE__ */ u((v) => v.group, "groupBy"), g = /* @__PURE__ */ u(({ detail: v }) => a("changeKey", v.key), "change_handler"), h = /* @__PURE__ */ u(() => a("changeKey", ""), "clear_handler"), _ = /* @__PURE__ */ u(({ target: v }) => a("changePriority", Number(v.value)), "change_handler_1"), y = /* @__PURE__ */ u(({ target: v }) => a("changeMode", v.value), "change_handler_2");
  return i.$$set = (v) => {
    "idx" in v && t(0, n = v.idx), "key" in v && t(1, l = v.key), "optionsList" in v && t(2, r = v.optionsList), "clearable" in v && t(3, o = v.clearable);
  }, [
    n,
    l,
    r,
    o,
    s,
    a,
    c,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
u(Que, "instance$1C");
const nC = class nC extends re {
  constructor(e) {
    super(), oe(this, e, Que, Zue, le, {
      idx: 0,
      key: 1,
      optionsList: 2,
      clearable: 3
    });
  }
};
u(nC, "ChangeConfiguration");
let yv = nC;
function xue(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("h3"), s.textContent = `${K("A5E.effects.value")}`, n = F(), l = E("input"), b(s, "class", "u-text-sm u-text-bold"), b(t, "class", "change-section u-w-full svelte-1xzd9q8"), b(l, "type", "text"), l.value = /*value*/
      i[3], b(e, "class", "row");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(t, s), A(e, n), A(e, l), r || (o = W(
        l,
        "change",
        /*change_handler_10*/
        i[26]
      ), r = !0);
    },
    p(a, c) {
      c & /*value*/
      8 && l.value !== /*value*/
      a[3] && (l.value = /*value*/
      a[3]);
    },
    i: se,
    o: se,
    d(a) {
      a && C(e), r = !1, o();
    }
  };
}
u(xue, "create_else_block$k");
function efe(i) {
  return {
    c: se,
    m: se,
    p: se,
    i: se,
    o: se,
    d: se
  };
}
u(efe, "create_if_block_10$4");
function tfe(i) {
  let e, t, s;
  return e = new hp({ props: { jsonValue: (
    /*value*/
    i[3]
  ) } }), e.$on(
    "change",
    /*change_handler_9*/
    i[25]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--padding", "0"), G(t, "--background", "none");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*value*/
      8 && (r.jsonValue = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(tfe, "create_if_block_9$5");
function sfe(i) {
  let e, t, s;
  return e = new pp({ props: { jsonValue: (
    /*value*/
    i[3]
  ) } }), e.$on(
    "change",
    /*change_handler_8*/
    i[24]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--padding", "0"), G(t, "--background", "none");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*value*/
      8 && (r.jsonValue = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(sfe, "create_if_block_8$6");
function nfe(i) {
  let e, t, s;
  return e = new mp({ props: { jsonValue: (
    /*value*/
    i[3]
  ) } }), e.$on(
    "change",
    /*change_handler_7*/
    i[23]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--padding", "0"), G(t, "--background", "none");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*value*/
      8 && (r.jsonValue = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(nfe, "create_if_block_7$8");
function ife(i) {
  let e, t, s;
  return e = new dp({ props: { jsonValue: (
    /*value*/
    i[3]
  ) } }), e.$on(
    "change",
    /*change_handler_6*/
    i[22]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--padding", "0"), G(t, "--background", "none");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*value*/
      8 && (r.jsonValue = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(ife, "create_if_block_6$a");
function lfe(i) {
  let e, t, s;
  return e = new fp({ props: { jsonValue: (
    /*value*/
    i[3]
  ) } }), e.$on(
    "change",
    /*change_handler_5*/
    i[21]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--padding", "0"), G(t, "--background", "none");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*value*/
      8 && (r.jsonValue = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(lfe, "create_if_block_5$b");
function rfe(i) {
  let e, t, s;
  return e = new up({ props: { jsonValue: (
    /*value*/
    i[3]
  ) } }), e.$on(
    "change",
    /*change_handler_4*/
    i[20]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--padding", "0"), G(t, "--background", "none");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*value*/
      8 && (r.jsonValue = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(rfe, "create_if_block_4$g");
function ofe(i) {
  var s;
  let e, t;
  return e = new Pi({
    props: {
      heading: "A5E.effects.options",
      options: (
        /*optionsList*/
        ((s = i[2][
          /*key*/
          i[0]
        ]) == null ? void 0 : s.options) ?? [[null, null]]
      ),
      selected: qp(
        /*value*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[19]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*optionsList, key*/
      5 && (r.options = /*optionsList*/
      ((o = n[2][
        /*key*/
        n[0]
      ]) == null ? void 0 : o.options) ?? [[null, null]]), l & /*value*/
      8 && (r.selected = qp(
        /*value*/
        n[3]
      )), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(ofe, "create_if_block_3$j");
function afe(i) {
  var s;
  let e, t;
  return e = new tt({
    props: {
      heading: "A5E.effects.options",
      options: (
        /*optionsList*/
        ((s = i[2][
          /*key*/
          i[0]
        ]) == null ? void 0 : s.options) ?? [[null, null]]
      ),
      selected: qp(
        /*value*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[18]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*optionsList, key*/
      5 && (r.options = /*optionsList*/
      ((o = n[2][
        /*key*/
        n[0]
      ]) == null ? void 0 : o.options) ?? [[null, null]]), l & /*value*/
      8 && (r.selected = qp(
        /*value*/
        n[3]
      )), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(afe, "create_if_block_2$u");
function cfe(i) {
  var s;
  let e, t;
  return e = new Ke({
    props: {
      heading: "A5E.effects.options",
      allowDeselect: !1,
      options: (
        /*optionsList*/
        ((s = i[2][
          /*key*/
          i[0]
        ]) == null ? void 0 : s.options) ?? [[null, null]]
      ),
      selected: (
        /*value*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*optionsList, key*/
      5 && (r.options = /*optionsList*/
      ((o = n[2][
        /*key*/
        n[0]
      ]) == null ? void 0 : o.options) ?? [[null, null]]), l & /*value*/
      8 && (r.selected = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(cfe, "create_if_block_1$E");
function ufe(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y;
  return {
    c() {
      e = E("div"), t = Q(`If original value is
        `), s = E("select"), n = E("option"), n.textContent = "equal to", l = E("option"), l.textContent = "not equal", r = E("option"), r.textContent = "greater than", o = E("option"), o.textContent = "greater than or equal to", a = E("option"), a.textContent = "less than", c = E("option"), c.textContent = "less than or equal to", f = F(), d = E("input"), p = Q(`

        then change to

        `), m = E("input"), g = Q(`

        else change to

        `), h = E("input"), n.__value = "==", He(n, n.__value), l.__value = "!==", He(l, l.__value), r.__value = ">", He(r, r.__value), o.__value = ">=", He(o, o.__value), a.__value = "<", He(a, a.__value), c.__value = "<=", He(c, c.__value), /*conditionalObj*/
      i[4].comparisonOperator === void 0 && ks(() => (
        /*select_change_handler*/
        i[9].call(s)
      )), b(d, "class", "conditional-input svelte-1xzd9q8"), b(d, "type", "text"), b(m, "class", "conditional-input svelte-1xzd9q8"), b(m, "type", "text"), b(h, "class", "conditional-input svelte-1xzd9q8"), b(h, "type", "text"), b(e, "class", "conditional-container u-pt-sm svelte-1xzd9q8");
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(e, s), A(s, n), A(s, l), A(s, r), A(s, o), A(s, a), A(s, c), Ys(
        s,
        /*conditionalObj*/
        i[4].comparisonOperator,
        !0
      ), A(e, f), A(e, d), He(
        d,
        /*conditionalObj*/
        i[4].comparisonValue
      ), A(e, p), A(e, m), He(
        m,
        /*conditionalObj*/
        i[4].positiveValue
      ), A(e, g), A(e, h), He(
        h,
        /*conditionalObj*/
        i[4].negativeValue
      ), _ || (y = [
        W(
          s,
          "change",
          /*select_change_handler*/
          i[9]
        ),
        W(
          s,
          "change",
          /*change_handler*/
          i[10]
        ),
        W(
          d,
          "input",
          /*input0_input_handler*/
          i[11]
        ),
        W(
          d,
          "change",
          /*change_handler_1*/
          i[12]
        ),
        W(
          m,
          "input",
          /*input1_input_handler*/
          i[13]
        ),
        W(
          m,
          "change",
          /*change_handler_2*/
          i[14]
        ),
        W(
          h,
          "input",
          /*input2_input_handler*/
          i[15]
        ),
        W(
          h,
          "change",
          /*change_handler_3*/
          i[16]
        )
      ], _ = !0);
    },
    p(v, k) {
      k & /*conditionalObj*/
      16 && Ys(
        s,
        /*conditionalObj*/
        v[4].comparisonOperator
      ), k & /*conditionalObj*/
      16 && d.value !== /*conditionalObj*/
      v[4].comparisonValue && He(
        d,
        /*conditionalObj*/
        v[4].comparisonValue
      ), k & /*conditionalObj*/
      16 && m.value !== /*conditionalObj*/
      v[4].positiveValue && He(
        m,
        /*conditionalObj*/
        v[4].positiveValue
      ), k & /*conditionalObj*/
      16 && h.value !== /*conditionalObj*/
      v[4].negativeValue && He(
        h,
        /*conditionalObj*/
        v[4].negativeValue
      );
    },
    i: se,
    o: se,
    d(v) {
      v && C(e), _ = !1, Me(y);
    }
  };
}
u(ufe, "create_if_block$V");
function ffe(i) {
  let e, t, s, n;
  const l = [
    ufe,
    cfe,
    afe,
    ofe,
    rfe,
    lfe,
    ife,
    nfe,
    sfe,
    tfe,
    efe,
    xue
  ], r = [];
  function o(a, c) {
    return (
      /*mode*/
      a[1] === /*MODES*/
      a[8].CONDITIONAL ? 0 : (
        /*componentType*/
        a[5] === "RADIO" ? 1 : (
          /*componentType*/
          a[5] === "CHECKBOX" ? 2 : (
            /*componentType*/
            a[5] === "TAG_GROUP" ? 3 : (
              /*componentType*/
              a[5] === "ABILITY_BONUS" ? 4 : (
                /*componentType*/
                a[5] === "ATTACK_BONUS" ? 5 : (
                  /*componentType*/
                  a[5] === "DAMAGE_BONUS" ? 6 : (
                    /*componentType*/
                    a[5] === "HEALING_BONUS" ? 7 : (
                      /*componentType*/
                      a[5] === "INITIATIVE_BONUS" ? 8 : (
                        /*componentType*/
                        a[5] === "SKILL_BONUS" ? 9 : (
                          /*componentType*/
                          a[5] === "NONE" ? 10 : 11
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, [c]) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(ffe, "create_fragment$1H");
function qp(i) {
  try {
    const e = JSON.parse((i ?? "").trim());
    return Array.isArray(e) ? e : [e];
  } catch {
    return [];
  }
}
u(qp, "convertToArray");
function dfe(i) {
  try {
    const e = JSON.parse((i ?? "").trim());
    if (typeof e != "object") throw new Error();
    return e.comparisonOperator = e.comparisonOperator ?? "==", e.comparisonValue = e.comparisonValue ?? "", e.positiveValue = e.positiveValue ?? "", e.negativeValue = e.negativeValue ?? "", e;
  } catch {
    return {
      comparisonOperator: "==",
      comparisonValue: "",
      positiveValue: "",
      negativeValue: ""
    };
  }
}
u(dfe, "convertToObject");
function pfe(i, e, t) {
  let s, { key: n } = e, { mode: l } = e, { optionsList: r } = e, { value: o } = e;
  const a = ft();
  function c(V) {
    const Y = JSON.stringify(V);
    a("change", Y);
  }
  u(c, "updateObjectValue");
  let f = dfe(o);
  const d = CONFIG.A5E.ACTIVE_EFFECT_MODES;
  function p() {
    f.comparisonOperator = fo(this), t(4, f);
  }
  u(p, "select_change_handler");
  const m = /* @__PURE__ */ u(() => c(f), "change_handler");
  function g() {
    f.comparisonValue = this.value, t(4, f);
  }
  u(g, "input0_input_handler");
  const h = /* @__PURE__ */ u(() => c(f), "change_handler_1");
  function _() {
    f.positiveValue = this.value, t(4, f);
  }
  u(_, "input1_input_handler");
  const y = /* @__PURE__ */ u(() => c(f), "change_handler_2");
  function v() {
    f.negativeValue = this.value, t(4, f);
  }
  u(v, "input2_input_handler");
  const k = /* @__PURE__ */ u(() => c(f), "change_handler_3"), S = /* @__PURE__ */ u(({ detail: V }) => a("change", V), "updateSelection_handler"), D = /* @__PURE__ */ u(({ detail: V }) => a("change", JSON.stringify(V)), "updateSelection_handler_1"), I = /* @__PURE__ */ u(({ detail: V }) => {
    a("change", JSON.stringify(V));
  }, "updateSelection_handler_2"), M = /* @__PURE__ */ u(({ detail: V }) => a("change", V), "change_handler_4"), L = /* @__PURE__ */ u(({ detail: V }) => a("change", V), "change_handler_5"), B = /* @__PURE__ */ u(({ detail: V }) => a("change", V), "change_handler_6"), z = /* @__PURE__ */ u(({ detail: V }) => a("change", V), "change_handler_7"), q = /* @__PURE__ */ u(({ detail: V }) => a("change", V), "change_handler_8"), U = /* @__PURE__ */ u(({ detail: V }) => a("change", V), "change_handler_9"), H = /* @__PURE__ */ u(({ target: V }) => a("change", V.value), "change_handler_10");
  return i.$$set = (V) => {
    "key" in V && t(0, n = V.key), "mode" in V && t(1, l = V.mode), "optionsList" in V && t(2, r = V.optionsList), "value" in V && t(3, o = V.value);
  }, i.$$.update = () => {
    var V;
    i.$$.dirty & /*optionsList, key*/
    5 && t(5, s = ((V = r[n]) == null ? void 0 : V.type) ?? "DEFAULT");
  }, [
    n,
    l,
    r,
    o,
    f,
    s,
    a,
    c,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    v,
    k,
    S,
    D,
    I,
    M,
    L,
    B,
    z,
    q,
    U,
    H
  ];
}
u(pfe, "instance$1B");
const iC = class iC extends re {
  constructor(e) {
    super(), oe(this, e, pfe, ffe, le, {
      key: 0,
      mode: 1,
      optionsList: 2,
      value: 3
    });
  }
};
u(iC, "ChangeValue");
let vv = iC;
function IR(i, e, t) {
  const s = i.slice();
  return s[15] = e[t].key, s[16] = e[t].value, s[17] = e[t].mode, s[19] = t, s;
}
u(IR, "get_each_context$B");
function PR(i, e) {
  let t, s, n, l, r, o, a, c, f, d, p, m;
  function g() {
    return (
      /*click_handler*/
      e[7](
        /*idx*/
        e[19]
      )
    );
  }
  u(g, "click_handler");
  function h(...k) {
    return (
      /*changeKey_handler*/
      e[8](
        /*idx*/
        e[19],
        ...k
      )
    );
  }
  u(h, "changeKey_handler");
  function _(...k) {
    return (
      /*changePriority_handler*/
      e[9](
        /*idx*/
        e[19],
        ...k
      )
    );
  }
  u(_, "changePriority_handler");
  function y(...k) {
    return (
      /*changeMode_handler*/
      e[10](
        /*idx*/
        e[19],
        ...k
      )
    );
  }
  u(y, "changeMode_handler"), o = new yv({
    props: {
      idx: (
        /*idx*/
        e[19]
      ),
      key: (
        /*key*/
        e[15]
      ),
      optionsList: (
        /*optionsList*/
        e[5]
      )
    }
  }), o.$on("changeKey", h), o.$on("changePriority", _), o.$on("changeMode", y);
  function v(...k) {
    return (
      /*change_handler*/
      e[11](
        /*idx*/
        e[19],
        ...k
      )
    );
  }
  return u(v, "change_handler"), c = new vv({
    props: {
      key: (
        /*key*/
        e[15]
      ),
      value: (
        /*value*/
        e[16]
      ),
      mode: (
        /*mode*/
        e[17]
      ),
      optionsList: (
        /*optionsList*/
        e[5]
      )
    }
  }), c.$on("change", v), {
    key: i,
    first: null,
    c() {
      t = E("li"), s = E("div"), n = E("button"), l = F(), r = E("div"), j(o.$$.fragment), a = F(), j(c.$$.fragment), f = F(), b(n, "class", "a5e-button a5e-button--delete fas fa-trash"), G(n, "font-size", "var(--a5e-text-size-md)"), b(s, "class", "button-wrapper svelte-1u74caf"), b(r, "class", "row svelte-1u74caf"), G(r, "padding-right", "2rem"), b(t, "class", "a5e-item a5e-item--effect-config"), this.first = t;
    },
    m(k, S) {
      T(k, t, S), A(t, s), A(s, n), A(t, l), A(t, r), R(o, r, null), A(t, a), R(c, t, null), A(t, f), d = !0, p || (m = W(n, "click", g), p = !0);
    },
    p(k, S) {
      e = k;
      const D = {};
      S & /*changes*/
      1 && (D.idx = /*idx*/
      e[19]), S & /*changes*/
      1 && (D.key = /*key*/
      e[15]), o.$set(D);
      const I = {};
      S & /*changes*/
      1 && (I.key = /*key*/
      e[15]), S & /*changes*/
      1 && (I.value = /*value*/
      e[16]), S & /*changes*/
      1 && (I.mode = /*mode*/
      e[17]), c.$set(I);
    },
    i(k) {
      d || (w(o.$$.fragment, k), w(c.$$.fragment, k), d = !0);
    },
    o(k) {
      O(o.$$.fragment, k), O(c.$$.fragment, k), d = !1;
    },
    d(k) {
      k && C(t), N(o), N(c), p = !1, m();
    }
  };
}
u(PR, "create_each_block$B");
function mfe(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r, o, a, c, f = ue(
    /*changes*/
    i[0]
  );
  const d = /* @__PURE__ */ u((p) => (
    /*idx*/
    p[19]
  ), "get_key");
  for (let p = 0; p < f.length; p += 1) {
    let m = IR(i, f, p), g = d(m);
    n.set(g, s[p] = PR(g, m));
  }
  return o = new mc({
    props: {
      title: "Add Change",
      icon: "fas fa-plus",
      onPress: (
        /*func*/
        i[12]
      )
    }
  }), {
    c() {
      e = E("section"), t = E("ul");
      for (let p = 0; p < s.length; p += 1)
        s[p].c();
      l = F(), r = E("div"), a = E("div"), j(o.$$.fragment), b(t, "class", "a5e-item-list"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), G(a, "display", "contents"), G(a, "--tjs-icon-button-background-hover", "none"), G(a, "--tjs-icon-button-background-focus", "none"), G(a, "--tjs-icon-button-background-focus-visible", "none"), G(a, "--tjs-icon-button-background-selected", "none"), G(a, "--tjs-icon-button-text-shadow-hover", "none"), G(a, "--tjs-icon-button-text-shadow-focus", "none"), G(a, "--tjs-icon-button-transition", "var(--a5e-transition-standard)"), G(a, "--tjs-icon-button-diameter", "1rem"), G(a, "--tjs-icon-button-border-radius", "0"), b(r, "class", "sticky-add-button svelte-1u74caf");
    },
    m(p, m) {
      T(p, e, m), A(e, t);
      for (let g = 0; g < s.length; g += 1)
        s[g] && s[g].m(t, null);
      T(p, l, m), T(p, r, m), A(r, a), R(o, a, null), c = !0;
    },
    p(p, [m]) {
      m & /*changes, optionsList, updateChange, deleteChange*/
      57 && (f = ue(
        /*changes*/
        p[0]
      ), ae(), s = Lt(s, m, d, 1, p, f, n, t, cn, PR, null, IR), ce());
    },
    i(p) {
      if (!c) {
        for (let m = 0; m < f.length; m += 1)
          w(s[m]);
        w(o.$$.fragment, p), c = !0;
      }
    },
    o(p) {
      for (let m = 0; m < s.length; m += 1)
        O(s[m]);
      O(o.$$.fragment, p), c = !1;
    },
    d(p) {
      p && (C(e), C(l), C(r));
      for (let m = 0; m < s.length; m += 1)
        s[m].d();
      N(o);
    }
  };
}
u(mfe, "create_fragment$1G");
function hfe(i, e, t) {
  let s, n;
  const l = de("effect");
  pe(i, l, (v) => t(6, n = v));
  const r = de("sheet");
  function o() {
    const v = {
      key: "",
      mode: null,
      value: "",
      priority: null
    };
    t(0, s = [...s, v]), n.update({ changes: s });
  }
  u(o, "addChange");
  function a(v) {
    t(0, s = s.filter((k, S) => S !== v)), n.update({ changes: s });
  }
  u(a, "deleteChange");
  function c(v, k, S) {
    var D, I, M;
    t(0, s[v] ?? (s[v] = {}), s), t(0, s[v][k] = S, s), k === "key" && (t(0, s[v].value = "", s), t(0, s[v].mode = f[(M = (I = d[(D = s[v]) == null ? void 0 : D.key]) == null ? void 0 : I.modes) == null ? void 0 : M[0]] ?? null, s)), n.update({ changes: s });
  }
  u(c, "updateChange");
  const f = CONFIG.A5E.ACTIVE_EFFECT_MODES, d = r.optionsList, p = /* @__PURE__ */ u((v) => a(v), "click_handler"), m = /* @__PURE__ */ u((v, { detail: k }) => c(v, "key", k), "changeKey_handler"), g = /* @__PURE__ */ u((v, { detail: k }) => c(v, "priority", k), "changePriority_handler"), h = /* @__PURE__ */ u((v, { detail: k }) => c(v, "mode", k), "changeMode_handler"), _ = /* @__PURE__ */ u((v, { detail: k }) => c(v, "value", k), "change_handler"), y = /* @__PURE__ */ u(() => o(), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$effect*/
    64 && t(0, s = n.changes);
  }, [
    s,
    l,
    o,
    a,
    c,
    d,
    n,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
u(hfe, "instance$1A");
const lC = class lC extends re {
  constructor(e) {
    super(), oe(this, e, hfe, mfe, le, {});
  }
};
u(lC, "EffectsEffectTab");
let kv = lC;
function MR(i, e, t) {
  const s = i.slice();
  return s[15] = e[t][0], s[16] = e[t][1], s;
}
u(MR, "get_each_context$A");
function FR(i) {
  let e, t, s, n, l, r, o;
  return e = new ie({
    props: {
      $$slots: { default: [gfe] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      $$slots: { default: [bfe] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      heading: "Effect Duration",
      $$slots: { default: [vfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), r = E("div"), j(l.$$.fragment), G(r, "display", "contents"), G(r, "--a5e-field-wrapper-gap", "0.75rem");
    },
    m(a, c) {
      R(e, a, c), T(a, t, c), R(s, a, c), T(a, n, c), T(a, r, c), R(l, r, null), o = !0;
    },
    p(a, c) {
      const f = {};
      c & /*$$scope, $effect*/
      524290 && (f.$$scope = { dirty: c, ctx: a }), e.$set(f);
      const d = {};
      c & /*$$scope, $effect*/
      524290 && (d.$$scope = { dirty: c, ctx: a }), s.$set(d);
      const p = {};
      c & /*$$scope, parsedSecondsValue, unit, durationType, $effect*/
      524303 && (p.$$scope = { dirty: c, ctx: a }), l.$set(p);
    },
    i(a) {
      o || (w(e.$$.fragment, a), w(s.$$.fragment, a), w(l.$$.fragment, a), o = !0);
    },
    o(a) {
      O(e.$$.fragment, a), O(s.$$.fragment, a), O(l.$$.fragment, a), o = !1;
    },
    d(a) {
      a && (C(t), C(n)), N(e, a), N(s, a), a && l && C(r), N(l, a);
    }
  };
}
u(FR, "create_if_block$U");
function gfe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.effects.default",
      checked: (
        /*$effect*/
        i[1].system.default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$effect*/
      2 && (l.checked = /*$effect*/
      s[1].system.default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(gfe, "create_default_slot_2$j");
function bfe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.effects.applyToSelf",
      checked: (
        /*$effect*/
        i[1].system.applyToSelf ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$effect*/
      2 && (l.checked = /*$effect*/
      s[1].system.applyToSelf ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(bfe, "create_default_slot_1$k");
function _fe(i) {
  let e, t, s, n = K("A5E.effects.durationTypes.plural.rounds") + "", l, r, o, a, c, f, d, p, m, g = K("A5E.effects.durationTypes.plural.turns") + "", h, _, y, v, k, S, D, I;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("label"), l = Q(n), o = F(), a = E("input"), d = F(), p = E("div"), m = E("label"), h = Q(g), y = F(), v = E("input"), b(s, "for", r = /*$effect*/
      i[1].id + "-rounds"), b(s, "class", "u-pointer u-text-bold"), b(a, "type", "number"), b(a, "class", "a5e-input a5e-input--small a5e-input--slim"), b(a, "id", c = /*$effect*/
      i[1].id + "-rounds"), a.value = f = /*$effect*/
      i[1].duration.rounds ?? 0, b(t, "class", "u-flex u-flex-col u-gap-md"), b(m, "for", _ = /*$effect*/
      i[1].id + "-turns"), b(m, "class", "u-pointer u-text-bold"), b(v, "type", "number"), b(v, "class", "a5e-input a5e-input--small a5e-input--slim"), b(v, "name", ""), b(v, "id", k = /*$effect*/
      i[1].id + "-turns"), v.value = S = /*$effect*/
      i[1].duration.turns ?? 0, b(p, "class", "u-flex u-flex-col u-gap-md"), b(e, "class", "u-flex u-gap-xl");
    },
    m(M, L) {
      T(M, e, L), A(e, t), A(t, s), A(s, l), A(t, o), A(t, a), A(e, d), A(e, p), A(p, m), A(m, h), A(p, y), A(p, v), D || (I = [
        W(
          a,
          "change",
          /*change_handler_2*/
          i[12]
        ),
        W(
          v,
          "change",
          /*change_handler_3*/
          i[13]
        )
      ], D = !0);
    },
    p(M, L) {
      L & /*$effect*/
      2 && r !== (r = /*$effect*/
      M[1].id + "-rounds") && b(s, "for", r), L & /*$effect*/
      2 && c !== (c = /*$effect*/
      M[1].id + "-rounds") && b(a, "id", c), L & /*$effect*/
      2 && f !== (f = /*$effect*/
      M[1].duration.rounds ?? 0) && a.value !== f && (a.value = f), L & /*$effect*/
      2 && _ !== (_ = /*$effect*/
      M[1].id + "-turns") && b(m, "for", _), L & /*$effect*/
      2 && k !== (k = /*$effect*/
      M[1].id + "-turns") && b(v, "id", k), L & /*$effect*/
      2 && S !== (S = /*$effect*/
      M[1].duration.turns ?? 0) && v.value !== S && (v.value = S);
    },
    d(M) {
      M && C(e), D = !1, Me(I);
    }
  };
}
u(_fe, "create_if_block_2$t");
function yfe(i) {
  let e, t, s, n, l, r, o = ue(Object.entries(
    /*A5E*/
    i[5].effectDurationUnits
  )), a = [];
  for (let c = 0; c < o.length; c += 1)
    a[c] = RR(MR(i, o, c));
  return {
    c() {
      e = E("div"), t = E("input"), s = F(), n = E("select");
      for (let c = 0; c < a.length; c += 1)
        a[c].c();
      b(t, "class", "a5e-input a5e-input--small a5e-input--slim"), b(t, "type", "number"), t.value = /*parsedSecondsValue*/
      i[3], b(n, "class", "u-w-fit"), b(e, "class", "u-flex u-gap-md");
    },
    m(c, f) {
      T(c, e, f), A(e, t), A(e, s), A(e, n);
      for (let d = 0; d < a.length; d += 1)
        a[d] && a[d].m(n, null);
      l || (r = [
        W(
          t,
          "change",
          /*change_handler*/
          i[10]
        ),
        W(
          n,
          "change",
          /*change_handler_1*/
          i[11]
        )
      ], l = !0);
    },
    p(c, f) {
      if (f & /*parsedSecondsValue*/
      8 && t.value !== /*parsedSecondsValue*/
      c[3] && (t.value = /*parsedSecondsValue*/
      c[3]), f & /*Object, A5E, unit*/
      33) {
        o = ue(Object.entries(
          /*A5E*/
          c[5].effectDurationUnits
        ));
        let d;
        for (d = 0; d < o.length; d += 1) {
          const p = MR(c, o, d);
          a[d] ? a[d].p(p, f) : (a[d] = RR(p), a[d].c(), a[d].m(n, null));
        }
        for (; d < a.length; d += 1)
          a[d].d(1);
        a.length = o.length;
      }
    },
    d(c) {
      c && C(e), Le(a, c), l = !1, Me(r);
    }
  };
}
u(yfe, "create_if_block_1$D");
function RR(i) {
  let e, t = K(
    /*label*/
    i[16]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = Q(t), n = F(), e.__value = /*durationUnit*/
      i[15], He(e, e.__value), e.selected = l = /*durationUnit*/
      i[15] === /*unit*/
      i[0];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*unit*/
      1 && l !== (l = /*durationUnit*/
      r[15] === /*unit*/
      r[0]) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(RR, "create_each_block$A");
function vfe(i) {
  let e, t, s, n;
  e = new Ke({
    props: {
      options: Object.entries(
        /*A5E*/
        i[5].effectDurationTypes
      ),
      selected: (
        /*durationType*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[9]
  );
  function l(a, c) {
    if (
      /*durationType*/
      a[2] === "seconds"
    ) return yfe;
    if (
      /*durationType*/
      a[2] === "rounds"
    ) return _fe;
  }
  u(l, "select_block_type");
  let r = l(i), o = r && r(i);
  return {
    c() {
      j(e.$$.fragment), t = F(), o && o.c(), s = $e();
    },
    m(a, c) {
      R(e, a, c), T(a, t, c), o && o.m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      const f = {};
      c & /*durationType*/
      4 && (f.selected = /*durationType*/
      a[2]), e.$set(f), r === (r = l(a)) && o ? o.p(a, c) : (o && o.d(1), o = r && r(a), o && (o.c(), o.m(s.parentNode, s)));
    },
    i(a) {
      n || (w(e.$$.fragment, a), n = !0);
    },
    o(a) {
      O(e.$$.fragment, a), n = !1;
    },
    d(a) {
      a && (C(t), C(s)), N(e, a), o && o.d(a);
    }
  };
}
u(vfe, "create_default_slot$N");
function kfe(i) {
  let e, t, s = (
    /*$effect*/
    i[1].system.effectType === "onUse" && FR(i)
  );
  return {
    c() {
      e = E("article"), s && s.c(), b(e, "class", "svelte-mfjn5x");
    },
    m(n, l) {
      T(n, e, l), s && s.m(e, null), t = !0;
    },
    p(n, [l]) {
      /*$effect*/
      n[1].system.effectType === "onUse" ? s ? (s.p(n, l), l & /*$effect*/
      2 && w(s, 1)) : (s = FR(n), s.c(), w(s, 1), s.m(e, null)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d();
    }
  };
}
u(kfe, "create_fragment$1F");
function wfe(i, e, t) {
  let s, n, l, r;
  const o = de("effect");
  pe(i, o, (v) => t(1, r = v));
  const { A5E: a } = CONFIG, c = { seconds: 1, minutes: 60, hours: 3600 };
  function f(v, k, S = null) {
    const D = {
      "flags.a5e.duration.unit": S ?? l,
      "duration.seconds": null,
      "duration.rounds": v === "seconds" ? null : r.duration.rounds,
      "duration.turns": v === "seconds" ? null : r.duration.turns
    };
    if (v === "seconds") {
      let I;
      S && l !== S ? (D["flags.a5e.duration.unit"] = S, I = Math.max(0, s * c[S])) : I = Math.max(0, k * c[l]), D["duration.seconds"] = I;
    } else ["rounds", "turns"].includes(v) && (D[`duration.${v}`] = Math.max(0, k));
    r.update(D);
  }
  u(f, "updateEffectDuration");
  const d = /* @__PURE__ */ u(({ detail: v }) => r.update({ "system.default": v }), "updateSelection_handler"), p = /* @__PURE__ */ u(({ detail: v }) => r.update({ "system.applyToSelf": v }), "updateSelection_handler_1"), m = /* @__PURE__ */ u(({ detail: v }) => r.update({ "flags.a5e.duration.type": v }), "updateSelection_handler_2"), g = /* @__PURE__ */ u(({ target: v }) => f(n, Number(v.value)), "change_handler"), h = /* @__PURE__ */ u(({ target: v }) => f("seconds", s, v.value), "change_handler_1"), _ = /* @__PURE__ */ u(({ target: v }) => f("rounds", Number(v.value)), "change_handler_2"), y = /* @__PURE__ */ u(({ target: v }) => f("turns", Number(v.value)), "change_handler_3");
  return i.$$.update = () => {
    var v, k, S, D, I, M;
    i.$$.dirty & /*$effect*/
    2 && t(0, l = ((S = (k = (v = r.flags) == null ? void 0 : v.a5e) == null ? void 0 : k.duration) == null ? void 0 : S.unit) ?? "minutes"), i.$$.dirty & /*$effect, unit*/
    3 && t(3, s = Math.floor((r.duration.seconds ?? 0) / c[l])), i.$$.dirty & /*$effect*/
    2 && t(2, n = ((M = (I = (D = r.flags) == null ? void 0 : D.a5e) == null ? void 0 : I.duration) == null ? void 0 : M.type) ?? "seconds");
  }, [
    l,
    r,
    n,
    s,
    o,
    a,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
u(wfe, "instance$1z");
const rC = class rC extends re {
  constructor(e) {
    super(), oe(this, e, wfe, kfe, le, {});
  }
};
u(rC, "EffectsPropertiesTab");
let wv = rC;
function $fe(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return {
    c() {
      e = E("header"), t = E("img"), l = F(), r = E("div"), o = E("input"), b(t, "class", "effect-image svelte-uzecrd"), ze(t.src, s = /*$effect*/
      i[0].img ?? /*$effect*/
      i[0].icon) || b(t, "src", s), b(t, "alt", n = /*$effect*/
      i[0].name), b(o, "type", "text"), b(o, "class", "effect-name svelte-uzecrd"), b(o, "name", "name"), o.value = a = /*$effect*/
      i[0].name, b(o, "placeholder", "A5E.Name"), b(r, "class", "name__wrapper svelte-uzecrd"), b(e, "class", "sheet-header svelte-uzecrd");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(e, l), A(e, r), A(r, o), c || (f = [
        W(
          t,
          "click",
          /*click_handler*/
          i[2]
        ),
        W(
          o,
          "change",
          /*change_handler*/
          i[3]
        )
      ], c = !0);
    },
    p(d, [p]) {
      p & /*$effect*/
      1 && !ze(t.src, s = /*$effect*/
      d[0].img ?? /*$effect*/
      d[0].icon) && b(t, "src", s), p & /*$effect*/
      1 && n !== (n = /*$effect*/
      d[0].name) && b(t, "alt", n), p & /*$effect*/
      1 && a !== (a = /*$effect*/
      d[0].name) && o.value !== a && (o.value = a);
    },
    i: se,
    o: se,
    d(d) {
      d && C(e), c = !1, Me(f);
    }
  };
}
u($fe, "create_fragment$1E");
function Afe(i, e, t) {
  let s;
  const n = de("effect");
  return pe(i, n, (o) => t(0, s = o)), de("appId"), [s, n, /* @__PURE__ */ u(() => gg(s, { type: "effect" }), "click_handler"), /* @__PURE__ */ u(({ target: o }) => te(s, o.name, o.value), "change_handler")];
}
u(Afe, "instance$1y");
const oC = class oC extends re {
  constructor(e) {
    super(), oe(this, e, Afe, $fe, le, {});
  }
};
u(oC, "EffectSheetHeader");
let $v = oC;
function Efe(i) {
  let e, t, s, n, l, r, o;
  t = new $v({}), n = new Wn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[4]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[3]
  );
  var a = (
    /*currentTab*/
    i[1].component
  );
  function c(f, d) {
    return {};
  }
  return u(c, "switch_props"), a && (r = et(a, c())), {
    c() {
      e = E("main"), j(t.$$.fragment), s = F(), j(n.$$.fragment), l = F(), r && j(r.$$.fragment), b(e, "class", "svelte-1rqyzyo");
    },
    m(f, d) {
      T(f, e, d), R(t, e, null), A(e, s), R(n, e, null), A(e, l), r && R(r, e, null), o = !0;
    },
    p(f, d) {
      const p = {};
      if (d & /*currentTab*/
      2 && (p.currentTab = /*currentTab*/
      f[1]), n.$set(p), d & /*currentTab*/
      2 && a !== (a = /*currentTab*/
      f[1].component)) {
        if (r) {
          ae();
          const m = r;
          O(m.$$.fragment, 1, 0, () => {
            N(m, 1);
          }), ce();
        }
        a ? (r = et(a, c()), j(r.$$.fragment), w(r.$$.fragment, 1), R(r, e, null)) : r = null;
      }
    },
    i(f) {
      o || (w(t.$$.fragment, f), w(n.$$.fragment, f), r && w(r.$$.fragment, f), o = !0);
    },
    o(f) {
      O(t.$$.fragment, f), O(n.$$.fragment, f), r && O(r.$$.fragment, f), o = !1;
    },
    d(f) {
      f && C(e), N(t), N(n), r && N(r);
    }
  };
}
u(Efe, "create_default_slot$M");
function Sfe(i) {
  let e, t, s;
  function n(r) {
    i[8](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Efe] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        2050 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(Sfe, "create_fragment$1D");
function Cfe(i, e, t) {
  let s, { appId: n, document: l, sheet: r } = de("#external").application, { appId: o = n, document: a = l, sheet: c = r } = e, { elementRoot: f } = e;
  const d = a;
  pe(i, d, (y) => t(9, s = y));
  function p(y) {
    t(1, h = g[y.detail]);
  }
  u(p, "updateCurrentTab");
  let m = s.system.effectType;
  const g = [
    {
      name: "description",
      label: "A5E.ItemSheetLabelDescriptionTab",
      component: pv
    },
    {
      name: "properties",
      label: "A5E.ItemSheetLabelPropertiesTab",
      component: wv,
      display: m === "onUse"
    },
    {
      name: "effects",
      label: "A5E.TabEffects",
      component: kv
    }
  ];
  let h = g[0];
  lt("appId", o), lt("effect", d), lt("sheet", c);
  function _(y) {
    f = y, t(0, f);
  }
  return u(_, "applicationshell_elementRoot_binding"), i.$$set = (y) => {
    "appId" in y && t(5, o = y.appId), "document" in y && t(6, a = y.document), "sheet" in y && t(7, c = y.sheet), "elementRoot" in y && t(0, f = y.elementRoot);
  }, [
    f,
    h,
    d,
    p,
    g,
    o,
    a,
    c,
    _
  ];
}
u(Cfe, "instance$1x");
var Xa;
let Tfe = (Xa = class extends re {
  constructor(e) {
    super(), oe(this, e, Cfe, Sfe, le, {
      appId: 5,
      document: 6,
      sheet: 7,
      elementRoot: 0
    });
  }
  get appId() {
    return this.$$.ctx[5];
  }
  set appId(e) {
    this.$$set({ appId: e }), Xe();
  }
  get document() {
    return this.$$.ctx[6];
  }
  set document(e) {
    this.$$set({ document: e }), Xe();
  }
  get sheet() {
    return this.$$.ctx[7];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
}, u(Xa, "ActiveEffectConfig"), Xa);
const aC = class aC extends Gs {
  /**
   * @inheritDoc
   */
  constructor(e, t = {}) {
    var l;
    t.svelte ?? (t.svelte = {}), super(
      foundry.utils.mergeObject(t, {
        baseApplication: "ActiveEffectConfig",
        id: e.parent ? `effect-${e.parent.id}-${e.id}` : `effect-${e.id}`,
        title: `Configure Active Effect: ${e.name}`,
        svelte: {
          class: Tfe,
          props: {
            document: null
          }
        },
        resizable: !0,
        focusAuto: !1,
        width: 555,
        height: 500
      })
    ), this.activeEffect = e, this.options.svelte.props.document = new Zt(e, {
      delete: this.close.bind(this)
    }), this.options.svelte.props.sheet = this, this.statusEffectList = {}, CONFIG.statusEffects.filter((r) => r.id).map((r) => ({ id: r.id, label: K(r.label) })).sort((r, o) => r.label < o.label ? -1 : 1).forEach((r) => {
      this.statusEffectList[r.id] = r.label;
    });
    const n = ((l = e.parent) == null ? void 0 : l.documentName) === "Actor" ? game.a5e.activeEffects.options[this.activeEffect.parent.type] : game.a5e.activeEffects.options.all;
    this.optionsList = n.allOptions;
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/Application.html#options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      baseApplication: "ActiveEffectConfig",
      classes: ["a5e-sheet", "a5e-sheet--active-effect"],
      minimizable: !0,
      resizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
  get object() {
    return this.activeEffect;
  }
  get title() {
    return `${game.i18n.localize("EFFECT.ConfigTitle")}: ${this.activeEffect.name}`;
  }
  get isActorEffect() {
    var e;
    return ((e = this.activeEffect) == null ? void 0 : e.parent.documentName) === "Actor";
  }
  get isActionEffect() {
    var e;
    return ((e = this.activeEffect) == null ? void 0 : e.parent.documentName) === "Action";
  }
  get isItemEffect() {
    var e;
    return ((e = this.activeEffect) == null ? void 0 : e.parent.documentName) === "Item";
  }
  _getHeaderButtons() {
    const e = super._getHeaderButtons();
    return this.activeEffect.pack || e.unshift({
      label: "Sheet Configuration",
      class: "configure-sheet",
      icon: "fas fa-cog fa-fw",
      title: "Configure Sheet",
      onclick: /* @__PURE__ */ u(({ event: t }) => this._onConfigureSheet(t), "onclick")
    }), e;
  }
  _onConfigureSheet(e) {
    e && e.preventDefault(), new DocumentSheetConfig(this.activeEffect, {
      top: this.position.top + 40
    }).render(!0);
  }
};
u(aC, "ActiveEffectConfigA5e");
let Av = aC;
function Ofe(i) {
  var o, a, c, f, d, p, m;
  if (!i) return 0;
  const t = Object.values(i.classes ?? {}).reduce(
    (g, h) => {
      const _ = h.maxHP ?? 0;
      return _ && g.push([_, h.name]), g;
    },
    []
  ).map(([g]) => g).join(" + "), s = (((f = (c = (a = (o = i.system) == null ? void 0 : o.abilities) == null ? void 0 : a.con) == null ? void 0 : c.check) == null ? void 0 : f.mod) ?? 0) * i.levels.character, n = ((m = (p = (d = i.system) == null ? void 0 : d.attributes) == null ? void 0 : p.hp) == null ? void 0 : m.bonus) ?? 0, l = mt(i.BonusesManager.getHitPointsBonusFormula(), i.getRollData()) ?? 0;
  return mt(
    `${t} + ${s} + ${n} + ${l}`,
    i.getRollData()
  );
}
u(Ofe, "getTotalHp");
function NR(i, e, t) {
  const s = i.slice();
  return s[21] = e[t][0], s[22] = e[t][1], s;
}
u(NR, "get_each_context$z");
function Dfe(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("div"), t = E("input"), n = F(), l = E("button"), l.innerHTML = '<i class="fas fa-solid fa-rotate-left"></i>', b(t, "class", "a5e-input a5e-input--slim slug-input svelte-1pbz7l6"), t.value = s = /*$item*/
      i[0].system.slug || /*$item*/
      i[0].slug || "", b(t, "type", "text"), b(l, "class", "slug-reset-button svelte-1pbz7l6"), G(e, "display", "flex"), G(e, "gap", "0.5rem");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, n), A(e, l), r || (o = [
        W(
          t,
          "change",
          /*change_handler*/
          i[8]
        ),
        W(
          l,
          "click",
          /*click_handler*/
          i[9]
        )
      ], r = !0);
    },
    p(a, c) {
      c & /*$item*/
      1 && s !== (s = /*$item*/
      a[0].system.slug || /*$item*/
      a[0].slug || "") && t.value !== s && (t.value = s);
    },
    d(a) {
      a && C(e), r = !1, Me(o);
    }
  };
}
u(Dfe, "create_default_slot_9$3");
function Ife(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--slim a5e-input--small"), b(e, "type", "number"), b(e, "min", "0"), e.value = t = /*$item*/
      i[0].system.archetypeLevel;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.archetypeLevel) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Ife, "create_default_slot_8$4");
function Pfe(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--slim a5e-input--small"), b(e, "type", "number"), b(e, "min", "0"), e.value = t = /*$item*/
      i[0].system.maxLevel;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_2*/
        i[11]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.maxLevel) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Pfe, "create_default_slot_7$7");
function Mfe(i) {
  let e, t, s, n, l, r, o, a, c;
  return e = new ie({
    props: {
      heading: "Class Identifier",
      $$slots: { default: [Dfe] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "Archetype Level",
      hint: "The level at which the archetypes are first chosen.",
      $$slots: { default: [Ife] },
      $$scope: { ctx: i }
    }
  }), o = new ie({
    props: {
      heading: "Max Class Level",
      $$slots: { default: [Pfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), r = F(), a = E("div"), j(o.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-header-item-justification", "flex-start"), G(t, "--a5e-field-wrapper-header-gap", "0.5rem"), G(l, "display", "contents"), G(l, "--a5e-field-wrapper-header-gap", "0.5rem"), G(a, "display", "contents"), G(a, "--a5e-field-wrapper-header-gap", "0.5rem");
    },
    m(f, d) {
      T(f, t, d), R(e, t, null), T(f, s, d), T(f, l, d), R(n, l, null), T(f, r, d), T(f, a, d), R(o, a, null), c = !0;
    },
    p(f, d) {
      const p = {};
      d & /*$$scope, $item*/
      33554433 && (p.$$scope = { dirty: d, ctx: f }), e.$set(p);
      const m = {};
      d & /*$$scope, $item*/
      33554433 && (m.$$scope = { dirty: d, ctx: f }), n.$set(m);
      const g = {};
      d & /*$$scope, $item*/
      33554433 && (g.$$scope = { dirty: d, ctx: f }), o.$set(g);
    },
    i(f) {
      c || (w(e.$$.fragment, f), w(n.$$.fragment, f), w(o.$$.fragment, f), c = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(n.$$.fragment, f), O(o.$$.fragment, f), c = !1;
    },
    d(f) {
      f && (C(s), C(r)), f && e && C(t), N(e, f), f && n && C(l), N(n, f), f && o && C(a), N(o, f);
    }
  };
}
u(Mfe, "create_default_slot_6$9");
function jR(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "Hit Dice Used",
      $$slots: { default: [Ffe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, classLevel, $item*/
      33554437 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(jR, "create_if_block_4$f");
function Ffe(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--small a5e-input--slim"), b(e, "type", "number"), b(
        e,
        "max",
        /*classLevel*/
        i[2]
      ), b(e, "min", "0"), e.value = t = /*$item*/
      i[0].system.hp.hitDiceUsed;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_3*/
        i[13]
      ), s = !0);
    },
    p(l, r) {
      r & /*classLevel*/
      4 && b(
        e,
        "max",
        /*classLevel*/
        l[2]
      ), r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.hp.hitDiceUsed) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Ffe, "create_default_slot_5$b");
function Rfe(i) {
  let e, t, s, n;
  e = new Ke({
    props: {
      heading: "Hit Dice Size",
      options: (
        /*hitDiceSize*/
        i[7]
      ),
      selected: (
        /*$item*/
        i[0].system.hp.hitDiceSize
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  );
  let l = (
    /*$item*/
    i[0].actor && jR(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), l && l.c(), s = $e();
    },
    m(r, o) {
      R(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$item*/
      1 && (a.selected = /*$item*/
      r[0].system.hp.hitDiceSize), e.$set(a), /*$item*/
      r[0].actor ? l ? (l.p(r, o), o & /*$item*/
      1 && w(l, 1)) : (l = jR(r), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ae(), O(l, 1, 1, () => {
        l = null;
      }), ce());
    },
    i(r) {
      n || (w(e.$$.fragment, r), w(l), n = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(l), n = !1;
    },
    d(r) {
      r && (C(t), C(s)), N(e, r), l && l.d(r);
    }
  };
}
u(Rfe, "create_default_slot_4$c");
function LR(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Hit Points",
      $$slots: { default: [Nfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, hpData, $item*/
      33554435 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(LR, "create_if_block_2$s");
function BR(i) {
  let e, t = (
    /*level*/
    i[21] + ""
  ), s, n, l, r, o, a, c = (
    /*$item*/
    i[0].actor.system.abilities.con.check.mod + ""
  ), f, d, p, m = (
    /*hpData*/
    i[1].hpBonusPerLevel + ""
  ), g, h, _, y = (
    /*hp*/
    i[22] + /*$item*/
    i[0].actor.system.abilities.con.check.mod + /*hpData*/
    i[1].hpBonusPerLevel + ""
  ), v, k, S;
  function D(...I) {
    return (
      /*change_handler_4*/
      i[14](
        /*level*/
        i[21],
        ...I
      )
    );
  }
  return u(D, "change_handler_4"), {
    c() {
      e = E("span"), s = Q(t), n = F(), l = E("input"), o = F(), a = E("span"), f = Q(c), d = F(), p = E("span"), g = Q(m), h = F(), _ = E("span"), v = Q(y), b(e, "class", "a5e-class-hp-table__field svelte-1pbz7l6"), b(l, "class", "a5e-class-hp-table__field--input svelte-1pbz7l6"), b(l, "type", "number"), l.value = r = /*hp*/
      i[22] ?? 0, b(l, "min", "0"), b(a, "class", "a5e-class-hp-table__field svelte-1pbz7l6"), b(p, "class", "a5e-class-hp-table__field svelte-1pbz7l6"), b(_, "class", "a5e-class-hp-table__field svelte-1pbz7l6");
    },
    m(I, M) {
      T(I, e, M), A(e, s), T(I, n, M), T(I, l, M), T(I, o, M), T(I, a, M), A(a, f), T(I, d, M), T(I, p, M), A(p, g), T(I, h, M), T(I, _, M), A(_, v), k || (S = W(l, "change", D), k = !0);
    },
    p(I, M) {
      i = I, M & /*$item*/
      1 && t !== (t = /*level*/
      i[21] + "") && be(s, t), M & /*$item*/
      1 && r !== (r = /*hp*/
      i[22] ?? 0) && l.value !== r && (l.value = r), M & /*$item*/
      1 && c !== (c = /*$item*/
      i[0].actor.system.abilities.con.check.mod + "") && be(f, c), M & /*hpData*/
      2 && m !== (m = /*hpData*/
      i[1].hpBonusPerLevel + "") && be(g, m), M & /*$item, hpData*/
      3 && y !== (y = /*hp*/
      i[22] + /*$item*/
      i[0].actor.system.abilities.con.check.mod + /*hpData*/
      i[1].hpBonusPerLevel + "") && be(v, y);
    },
    d(I) {
      I && (C(e), C(n), C(l), C(o), C(a), C(d), C(p), C(h), C(_)), k = !1, S();
    }
  };
}
u(BR, "create_if_block_3$i");
function qR(i) {
  let e, t = (
    /*hp*/
    i[22] && BR(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*hp*/
      s[22] ? t ? t.p(s, n) : (t = BR(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(qR, "create_each_block$z");
function Nfe(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m = (
    /*hpData*/
    i[1].otherHpBonuses + ""
  ), g, h, _, y, v, k = (
    /*hpData*/
    i[1].totalHp + ""
  ), S, D = ue(Object.entries(
    /*$item*/
    i[0].system.hp.levels
  )), I = [];
  for (let M = 0; M < D.length; M += 1)
    I[M] = qR(NR(i, D, M));
  return {
    c() {
      e = E("div"), t = E("header"), t.innerHTML = '<h3 class="a5e-class-hp-table__heading svelte-1pbz7l6">Level</h3> <h3 class="a5e-class-hp-table__heading svelte-1pbz7l6">Base HP</h3> <h3 class="a5e-class-hp-table__heading svelte-1pbz7l6">Con Mod</h3> <h3 class="a5e-class-hp-table__heading svelte-1pbz7l6">Bonus HP</h3> <h3 class="a5e-class-hp-table__heading svelte-1pbz7l6">Total HP</h3>', s = F(), n = E("hr"), l = F();
      for (let M = 0; M < I.length; M += 1)
        I[M].c();
      r = F(), o = E("hr"), a = F(), c = E("footer"), f = E("h3"), f.textContent = "Other Bonuses", d = F(), p = E("span"), g = Q(m), h = F(), _ = E("h3"), _.textContent = "Total HP", y = F(), v = E("span"), S = Q(k), b(t, "class", "a5e-class-hp-table__header svelte-1pbz7l6"), b(n, "class", "a5e-class-hp-table__rule svelte-1pbz7l6"), b(o, "class", "a5e-class-hp-table__rule svelte-1pbz7l6"), b(f, "class", "a5e-class-hp-table__heading a5e-class-hp-table__heading--footer svelte-1pbz7l6"), b(p, "class", "a5e-class-hp-table__field svelte-1pbz7l6"), b(_, "class", "a5e-class-hp-table__heading a5e-class-hp-table__heading--footer svelte-1pbz7l6"), b(v, "class", "a5e-class-hp-table__field a5e-class-hp-table__field--total svelte-1pbz7l6"), b(c, "class", "a5e-class-hp-table__footer svelte-1pbz7l6"), b(e, "class", "a5e-class-hp-table svelte-1pbz7l6");
    },
    m(M, L) {
      T(M, e, L), A(e, t), A(e, s), A(e, n), A(e, l);
      for (let B = 0; B < I.length; B += 1)
        I[B] && I[B].m(e, null);
      A(e, r), A(e, o), A(e, a), A(e, c), A(c, f), A(c, d), A(c, p), A(p, g), A(c, h), A(c, _), A(c, y), A(c, v), A(v, S);
    },
    p(M, L) {
      if (L & /*Object, $item, hpData, Number*/
      3) {
        D = ue(Object.entries(
          /*$item*/
          M[0].system.hp.levels
        ));
        let B;
        for (B = 0; B < D.length; B += 1) {
          const z = NR(M, D, B);
          I[B] ? I[B].p(z, L) : (I[B] = qR(z), I[B].c(), I[B].m(e, r));
        }
        for (; B < I.length; B += 1)
          I[B].d(1);
        I.length = D.length;
      }
      L & /*hpData*/
      2 && m !== (m = /*hpData*/
      M[1].otherHpBonuses + "") && be(g, m), L & /*hpData*/
      2 && k !== (k = /*hpData*/
      M[1].totalHp + "") && be(S, k);
    },
    d(M) {
      M && C(e), Le(I, M);
    }
  };
}
u(Nfe, "create_default_slot_3$g");
function GR(i) {
  let e, t, s, n;
  return e = new Ke({
    props: {
      heading: "Default Spellcasting Ability",
      options: Object.entries(
        /*abilities*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[0].system.spellcasting.ability.base
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[15]
  ), s = new tt({
    props: {
      heading: "Optional Spellcasting Abilities",
      options: Object.entries(
        /*abilitiesWithoutNone*/
        i[5]
      ),
      selected: (
        /*$item*/
        i[0].system.spellcasting.ability.options
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$item*/
      1 && (o.selected = /*$item*/
      l[0].system.spellcasting.ability.base), e.$set(o);
      const a = {};
      r & /*$item*/
      1 && (a.selected = /*$item*/
      l[0].system.spellcasting.ability.options), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(GR, "create_if_block_1$C");
function zR(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "Spellcasting Ability",
      options: Object.entries(
        /*abilities*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[0].system.spellcasting.ability.value
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.spellcasting.ability.value), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(zR, "create_if_block$T");
function jfe(i) {
  let e, t, s, n, l = !/*$item*/
  i[0].parent && GR(i), r = (
    /*$item*/
    i[0].parent && zR(i)
  );
  return s = new Ke({
    props: {
      heading: "Caster Type",
      options: Object.entries(
        /*casterTypes*/
        i[6]
      ),
      selected: (
        /*$item*/
        i[0].system.spellcasting.casterType
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[18]
  ), {
    c() {
      l && l.c(), e = F(), r && r.c(), t = F(), j(s.$$.fragment);
    },
    m(o, a) {
      l && l.m(o, a), T(o, e, a), r && r.m(o, a), T(o, t, a), R(s, o, a), n = !0;
    },
    p(o, a) {
      /*$item*/
      o[0].parent ? l && (ae(), O(l, 1, 1, () => {
        l = null;
      }), ce()) : l ? (l.p(o, a), a & /*$item*/
      1 && w(l, 1)) : (l = GR(o), l.c(), w(l, 1), l.m(e.parentNode, e)), /*$item*/
      o[0].parent ? r ? (r.p(o, a), a & /*$item*/
      1 && w(r, 1)) : (r = zR(o), r.c(), w(r, 1), r.m(t.parentNode, t)) : r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce());
      const c = {};
      a & /*$item*/
      1 && (c.selected = /*$item*/
      o[0].system.spellcasting.casterType), s.$set(c);
    },
    i(o) {
      n || (w(l), w(r), w(s.$$.fragment, o), n = !0);
    },
    o(o) {
      O(l), O(r), O(s.$$.fragment, o), n = !1;
    },
    d(o) {
      o && (C(e), C(t)), l && l.d(o), r && r.d(o), N(s, o);
    }
  };
}
u(jfe, "create_default_slot_2$i");
function Lfe(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*$item*/
      i[0].system.wealth;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_5*/
        i[19]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.wealth) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Lfe, "create_default_slot_1$j");
function Bfe(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "Enter a number value or a roll formula",
      $$slots: { default: [Lfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $item*/
      33554433 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Bfe, "create_default_slot$L");
function qfe(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g;
  t = new De({
    props: {
      heading: "Metadata",
      $$slots: { default: [Mfe] },
      $$scope: { ctx: i }
    }
  }), l = new De({
    props: {
      heading: "Hit Dice",
      $$slots: { default: [Rfe] },
      $$scope: { ctx: i }
    }
  });
  let h = (
    /*$item*/
    i[0].actor && LR(i)
  );
  return c = new De({
    props: {
      heading: "Spell Casting",
      $$slots: { default: [jfe] },
      $$scope: { ctx: i }
    }
  }), p = new De({
    props: {
      heading: "Wealth",
      $$slots: { default: [Bfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("article"), s = E("div"), j(t.$$.fragment), n = F(), r = E("div"), j(l.$$.fragment), o = F(), h && h.c(), a = F(), f = E("div"), j(c.$$.fragment), d = F(), m = E("div"), j(p.$$.fragment), G(s, "display", "contents"), G(s, "--a5e-section-body-gap", "0.75rem"), G(r, "display", "contents"), G(r, "--a5e-section-body-gap", "0.75rem"), G(f, "display", "contents"), G(f, "--a5e-section-body-gap", "0.75rem"), G(m, "display", "contents"), G(m, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(_, y) {
      T(_, e, y), A(e, s), R(t, s, null), A(e, n), A(e, r), R(l, r, null), A(e, o), h && h.m(e, null), A(e, a), A(e, f), R(c, f, null), A(e, d), A(e, m), R(p, m, null), g = !0;
    },
    p(_, [y]) {
      const v = {};
      y & /*$$scope, $item*/
      33554433 && (v.$$scope = { dirty: y, ctx: _ }), t.$set(v);
      const k = {};
      y & /*$$scope, classLevel, $item*/
      33554437 && (k.$$scope = { dirty: y, ctx: _ }), l.$set(k), /*$item*/
      _[0].actor ? h ? (h.p(_, y), y & /*$item*/
      1 && w(h, 1)) : (h = LR(_), h.c(), w(h, 1), h.m(e, a)) : h && (ae(), O(h, 1, 1, () => {
        h = null;
      }), ce());
      const S = {};
      y & /*$$scope, $item*/
      33554433 && (S.$$scope = { dirty: y, ctx: _ }), c.$set(S);
      const D = {};
      y & /*$$scope, $item*/
      33554433 && (D.$$scope = { dirty: y, ctx: _ }), p.$set(D);
    },
    i(_) {
      g || (w(t.$$.fragment, _), w(l.$$.fragment, _), w(h), w(c.$$.fragment, _), w(p.$$.fragment, _), g = !0);
    },
    o(_) {
      O(t.$$.fragment, _), O(l.$$.fragment, _), O(h), O(c.$$.fragment, _), O(p.$$.fragment, _), g = !1;
    },
    d(_) {
      _ && C(e), N(t), N(l), h && h.d(), N(c), N(p);
    }
  };
}
u(qfe, "create_fragment$1C");
function Gfe(i, e, t) {
  let s, n, l;
  const r = de("item");
  pe(i, r, (L) => t(0, l = L));
  const o = { none: "None", ...CONFIG.A5E.abilities }, a = CONFIG.A5E.abilities, c = CONFIG.A5E.casterTypes;
  function f() {
    const L = l.actor;
    if (!L)
      return {
        totalHp: 0,
        hpBonusPerLevel: 0,
        otherHpBonuses: 0
      };
    const B = Ofe(l.parent), z = mt(L.BonusesManager.getHitPointsBonusPerLevelFormula() ?? 0, L == null ? void 0 : L.getRollData()) ?? 0, U = (mt(L.BonusesManager.getHitPointsBonusFormula() ?? 0, L.getRollData()) ?? 0) - z * L.levels.character, H = L.system.attributes.hp.bonus;
    return {
      totalHp: B,
      hpBonusPerLevel: z,
      otherHpBonuses: U + H
    };
  }
  u(f, "getHpData");
  const d = [[6, "d6"], [8, "d8"], [10, "d10"], [12, "d12"]], p = /* @__PURE__ */ u(({ target: L }) => {
    te(l, "system.slug", L.value.slugify({ strict: !0 }));
  }, "change_handler"), m = /* @__PURE__ */ u(() => te(l, "system.slug", ""), "click_handler"), g = /* @__PURE__ */ u(({ target: L }) => te(l, "system.archetypeLevel", Number(L.value)), "change_handler_1"), h = /* @__PURE__ */ u(({ target: L }) => te(l, "system.maxLevel", Number(L.value)), "change_handler_2"), _ = /* @__PURE__ */ u(({ detail: L }) => te(l, "system.hp.hitDiceSize", L), "updateSelection_handler"), y = /* @__PURE__ */ u(({ target: L }) => te(l, "system.hp.hitDiceUsed", Number(L.value)), "change_handler_3"), v = /* @__PURE__ */ u((L, { target: B }) => te(l, `system.hp.levels.${L}`, Number(B.value)), "change_handler_4"), k = /* @__PURE__ */ u(({ detail: L }) => {
    te(l, "system.spellcasting.ability.options", []), te(l, "system.spellcasting.ability.base", L);
  }, "updateSelection_handler_1"), S = /* @__PURE__ */ u(({ detail: L }) => {
    te(l, "system.spellcasting.ability.base", "none"), te(l, "system.spellcasting.ability.options", L);
  }, "updateSelection_handler_2"), D = /* @__PURE__ */ u(({ detail: L }) => te(l, "system.spellcasting.ability.value", L), "updateSelection_handler_3"), I = /* @__PURE__ */ u(({ detail: L }) => te(l, "system.spellcasting.casterType", L), "updateSelection_handler_4"), M = /* @__PURE__ */ u(({ target: L }) => te(l, "system.wealth", L.value), "change_handler_5");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(2, s = l.system.classLevels), i.$$.dirty & /*$item*/
    1 && t(1, n = f(l.actor));
  }, [
    l,
    n,
    s,
    r,
    o,
    a,
    c,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    v,
    k,
    S,
    D,
    I,
    M
  ];
}
u(Gfe, "instance$1w");
const cC = class cC extends re {
  constructor(e) {
    super(), oe(this, e, Gfe, qfe, le, {});
  }
};
u(cC, "ClassPropertiesTab");
let Ev = cC;
function HR(i, e, t) {
  const s = i.slice();
  return s[13] = e[t][0], s[14] = e[t][1], s[16] = t, s;
}
u(HR, "get_each_context$y");
function UR(i, e, t) {
  const s = i.slice();
  return s[17] = e[t][0], s[18] = e[t][1], s;
}
u(UR, "get_each_context_1$5");
function zfe(i) {
  let e, t, s, n, l, r, o;
  function a(...c) {
    return (
      /*change_handler_1*/
      i[8](
        /*idx*/
        i[16],
        ...c
      )
    );
  }
  return u(a, "change_handler_1"), {
    c() {
      e = E("div"), t = E("input"), n = F(), l = E("button"), l.innerHTML = '<i class="fas fa-solid fa-rotate-left"></i>', b(t, "class", "a5e-input a5e-input--slim slug-input svelte-1jzok14"), t.value = s = /*slug*/
      i[13] || "", b(t, "type", "text"), b(l, "class", "slug-reset-button svelte-1jzok14"), G(e, "display", "flex"), G(e, "gap", "0.5rem");
    },
    m(c, f) {
      T(c, e, f), A(e, t), A(e, n), A(e, l), r || (o = [
        W(t, "change", a),
        W(l, "click", Jfe)
      ], r = !0);
    },
    p(c, f) {
      i = c, f & /*resources*/
      2 && s !== (s = /*slug*/
      i[13] || "") && t.value !== s && (t.value = s);
    },
    d(c) {
      c && C(e), r = !1, Me(o);
    }
  };
}
u(zfe, "create_default_slot_6$8");
function Hfe(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "Resource Identifier",
      $$slots: { default: [zfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-header-item-justification", "flex-start"), G(t, "--a5e-field-wrapper-header-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, resources*/
      2097154 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Hfe, "create_default_slot_5$a");
function Ufe(i) {
  let e, t, s, n, l;
  function r(...o) {
    return (
      /*change_handler_2*/
      i[9](
        /*idx*/
        i[16],
        /*level*/
        i[17],
        ...o
      )
    );
  }
  return u(r, "change_handler_2"), {
    c() {
      e = E("input"), s = F(), b(e, "class", "a5e-input a5e-input--slim"), e.value = t = /*value*/
      i[18], b(e, "type", "text");
    },
    m(o, a) {
      T(o, e, a), T(o, s, a), n || (l = W(e, "change", r), n = !0);
    },
    p(o, a) {
      i = o, a & /*resources*/
      2 && t !== (t = /*value*/
      i[18]) && e.value !== t && (e.value = t);
    },
    d(o) {
      o && (C(e), C(s)), n = !1, l();
    }
  };
}
u(Ufe, "create_default_slot_4$b");
function VR(i) {
  let e, t, s;
  return e = new ie({
    props: {
      heading: "Level " + /*level*/
      i[17],
      $$slots: { default: [Ufe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-margin", "auto"), G(t, "--a5e-field-wrapper-header-item-justification", "center");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*resources*/
      2 && (r.heading = "Level " + /*level*/
      n[17]), l & /*$$scope, resources*/
      2097154 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(VR, "create_each_block_1$5");
function Vfe(i) {
  let e, t, s = ue(Object.entries(
    /*resource*/
    i[14].reference
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = VR(UR(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("div");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "a5e-class-resource-reference-container svelte-1jzok14");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o & /*Object, resources, updateResource*/
      18) {
        s = ue(Object.entries(
          /*resource*/
          r[14].reference
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = UR(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = VR(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(Vfe, "create_default_slot_3$f");
function Wfe(i) {
  let e, t;
  function s(...n) {
    return (
      /*updateSelection_handler*/
      i[10](
        /*idx*/
        i[16],
        ...n
      )
    );
  }
  return u(s, "updateSelection_handler"), e = new Te({
    props: {
      checked: (
        /*resource*/
        i[14].consumable
      ),
      label: "Resource is consumable"
    }
  }), e.$on("updateSelection", s), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      i = n;
      const r = {};
      l & /*resources*/
      2 && (r.checked = /*resource*/
      i[14].consumable), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(Wfe, "create_default_slot_2$h");
function Kfe(i) {
  let e, t;
  function s(...n) {
    return (
      /*updateSelection_handler_1*/
      i[11](
        /*idx*/
        i[16],
        ...n
      )
    );
  }
  return u(s, "updateSelection_handler_1"), e = new Te({
    props: {
      checked: (
        /*resource*/
        i[14].displayOnCore
      ),
      label: "Show on Core Page"
    }
  }), e.$on("updateSelection", s), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      i = n;
      const r = {};
      l & /*resources*/
      2 && (r.checked = /*resource*/
      i[14].displayOnCore), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(Kfe, "create_default_slot_1$i");
function Yfe(i) {
  let e, t, s, n, l, r;
  e = new ie({
    props: {
      $$slots: { default: [Wfe] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      $$slots: { default: [Kfe] },
      $$scope: { ctx: i }
    }
  });
  function o(...a) {
    return (
      /*updateSelection_handler_2*/
      i[12](
        /*idx*/
        i[16],
        ...a
      )
    );
  }
  return u(o, "updateSelection_handler_2"), l = new Ke({
    props: {
      heading: "Recovery",
      options: Object.entries(
        /*recoveryOptions*/
        i[5]
      ),
      selected: (
        /*resource*/
        i[14].recovery || ""
      )
    }
  }), l.$on("updateSelection", o), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(a, c) {
      R(e, a, c), T(a, t, c), R(s, a, c), T(a, n, c), R(l, a, c), r = !0;
    },
    p(a, c) {
      i = a;
      const f = {};
      c & /*$$scope, resources*/
      2097154 && (f.$$scope = { dirty: c, ctx: i }), e.$set(f);
      const d = {};
      c & /*$$scope, resources*/
      2097154 && (d.$$scope = { dirty: c, ctx: i }), s.$set(d);
      const p = {};
      c & /*resources*/
      2 && (p.selected = /*resource*/
      i[14].recovery || ""), l.$set(p);
    },
    i(a) {
      r || (w(e.$$.fragment, a), w(s.$$.fragment, a), w(l.$$.fragment, a), r = !0);
    },
    o(a) {
      O(e.$$.fragment, a), O(s.$$.fragment, a), O(l.$$.fragment, a), r = !1;
    },
    d(a) {
      a && (C(t), C(n)), N(e, a), N(s, a), N(l, a);
    }
  };
}
u(Yfe, "create_default_slot$K");
function WR(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v;
  function k(...D) {
    return (
      /*change_handler*/
      i[6](
        /*idx*/
        i[16],
        ...D
      )
    );
  }
  u(k, "change_handler");
  function S() {
    return (
      /*click_handler*/
      i[7](
        /*slug*/
        i[13]
      )
    );
  }
  return u(S, "click_handler"), o = new De({
    props: {
      heading: "Metadata",
      $$slots: { default: [Hfe] },
      $$scope: { ctx: i }
    }
  }), f = new De({
    props: {
      heading: "Level Information",
      $$slots: { default: [Vfe] },
      $$scope: { ctx: i }
    }
  }), m = new De({
    props: {
      heading: "Consumable Data",
      $$slots: { default: [Yfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("div"), t = E("input"), n = F(), l = E("button"), l.innerHTML = '<i class="fas fa-trash"></i>', r = F(), a = E("div"), j(o.$$.fragment), c = F(), d = E("div"), j(f.$$.fragment), p = F(), g = E("div"), j(m.$$.fragment), h = F(), b(t, "class", "a5e-input a5e-class-resource-name svelte-1jzok14"), b(t, "type", "text"), b(t, "placeholder", "New Resource"), t.value = s = /*resource*/
      i[14].name, b(l, "class", "a5e-class-resource-delete-button svelte-1jzok14"), G(a, "display", "contents"), G(a, "--a5e-section-body-gap", "0.75rem"), G(d, "display", "contents"), G(d, "--a5e-section-body-gap", "0.75rem"), G(g, "display", "contents"), G(g, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "a5e-class-resource svelte-1jzok14");
    },
    m(D, I) {
      T(D, e, I), A(e, t), A(e, n), A(e, l), A(e, r), A(e, a), R(o, a, null), A(e, c), A(e, d), R(f, d, null), A(e, p), A(e, g), R(m, g, null), A(e, h), _ = !0, y || (v = [
        W(t, "change", k),
        W(l, "click", S)
      ], y = !0);
    },
    p(D, I) {
      i = D, (!_ || I & /*resources*/
      2 && s !== (s = /*resource*/
      i[14].name) && t.value !== s) && (t.value = s);
      const M = {};
      I & /*$$scope, resources*/
      2097154 && (M.$$scope = { dirty: I, ctx: i }), o.$set(M);
      const L = {};
      I & /*$$scope, resources*/
      2097154 && (L.$$scope = { dirty: I, ctx: i }), f.$set(L);
      const B = {};
      I & /*$$scope, resources*/
      2097154 && (B.$$scope = { dirty: I, ctx: i }), m.$set(B);
    },
    i(D) {
      _ || (w(o.$$.fragment, D), w(f.$$.fragment, D), w(m.$$.fragment, D), _ = !0);
    },
    o(D) {
      O(o.$$.fragment, D), O(f.$$.fragment, D), O(m.$$.fragment, D), _ = !1;
    },
    d(D) {
      D && C(e), N(o), N(f), N(m), y = !1, Me(v);
    }
  };
}
u(WR, "create_each_block$y");
function Xfe(i) {
  let e, t, s, n, l, r = ue(
    /*resources*/
    i[1]
  ), o = [];
  for (let c = 0; c < r.length; c += 1)
    o[c] = WR(HR(i, r, c));
  const a = /* @__PURE__ */ u((c) => O(o[c], 1, 1, () => {
    o[c] = null;
  }), "out");
  return n = new Tn({ props: { documentName: "Resource" } }), n.$on(
    "press",
    /*addResource*/
    i[3]
  ), {
    c() {
      e = E("div");
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      t = F(), s = E("div"), j(n.$$.fragment), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(s, "class", "sticky-add-button svelte-1jzok14");
    },
    m(c, f) {
      T(c, e, f);
      for (let d = 0; d < o.length; d += 1)
        o[d] && o[d].m(e, null);
      T(c, t, f), T(c, s, f), R(n, s, null), l = !0;
    },
    p(c, [f]) {
      if (f & /*Object, recoveryOptions, resources, updateResource, $item*/
      51) {
        r = ue(
          /*resources*/
          c[1]
        );
        let d;
        for (d = 0; d < r.length; d += 1) {
          const p = HR(c, r, d);
          o[d] ? (o[d].p(p, f), w(o[d], 1)) : (o[d] = WR(p), o[d].c(), w(o[d], 1), o[d].m(e, null));
        }
        for (ae(), d = r.length; d < o.length; d += 1)
          a(d);
        ce();
      }
    },
    i(c) {
      if (!l) {
        for (let f = 0; f < r.length; f += 1)
          w(o[f]);
        w(n.$$.fragment, c), l = !0;
      }
    },
    o(c) {
      o = o.filter(Boolean);
      for (let f = 0; f < o.length; f += 1)
        O(o[f]);
      O(n.$$.fragment, c), l = !1;
    },
    d(c) {
      c && (C(e), C(t), C(s)), Le(o, c), N(n);
    }
  };
}
u(Xfe, "create_fragment$1B");
const Jfe = /* @__PURE__ */ u(() => null, "click_handler_1");
function Zfe(i, e, t) {
  let s, n;
  const l = de("item");
  pe(i, l, (_) => t(0, n = _));
  function r() {
    n.resources.add();
  }
  u(r, "addResource");
  function o(_, y, v) {
    const k = n.system.resources.map((D) => foundry.utils.deepClone(D)), S = k.at(_);
    if (S) {
      if (S[y] = v, y.includes("reference.")) {
        const [, D] = y.split("."), I = parseInt(D, 10);
        Object.keys(S.reference ?? {}).forEach((M) => {
          parseInt(M, 10) >= I && (S.reference[M] = v);
        });
      }
      k[_] = S, te(n, "system.resources", k);
    }
  }
  u(o, "updateResource");
  const a = foundry.utils.deepClone(CONFIG.A5E.resourceRecoveryOptions);
  delete a.recharge;
  const c = /* @__PURE__ */ u((_, { target: y }) => {
    o(_, "name", y == null ? void 0 : y.value);
  }, "change_handler"), f = /* @__PURE__ */ u((_) => n.resources.remove(_), "click_handler"), d = /* @__PURE__ */ u((_, { target: y }) => {
    o(_, "slug", y == null ? void 0 : y.value);
  }, "change_handler_1"), p = /* @__PURE__ */ u((_, y, { target: v }) => {
    o(
      _,
      `reference.${y}`,
      // @ts-ignore
      v.value
    );
  }, "change_handler_2"), m = /* @__PURE__ */ u((_, { detail: y }) => o(_, "consumable", y), "updateSelection_handler"), g = /* @__PURE__ */ u((_, { detail: y }) => o(_, "displayOnCore", y), "updateSelection_handler_1"), h = /* @__PURE__ */ u((_, { detail: y }) => {
    o(_, "recovery", y);
  }, "updateSelection_handler_2");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(1, s = [...n.resources]);
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c,
    f,
    d,
    p,
    m,
    g,
    h
  ];
}
u(Zfe, "instance$1v");
const uC = class uC extends re {
  constructor(e) {
    super(), oe(this, e, Zfe, Xfe, le, {});
  }
};
u(uC, "ClassResourcesTab");
let Gp = uC;
function Qfe(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("div"), t = E("input"), n = F(), l = E("button"), l.innerHTML = '<i class="fas fa-solid fa-rotate-left"></i>', b(t, "class", "a5e-input a5e-input--slim slug-input svelte-1h2m060"), t.value = s = /*$item*/
      i[0].system.slug || /*$item*/
      i[0].slug || "", b(t, "type", "text"), b(l, "class", "slug-reset-button svelte-1h2m060"), G(e, "display", "flex"), G(e, "gap", "0.5rem");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, n), A(e, l), r || (o = [
        W(
          t,
          "change",
          /*change_handler*/
          i[7]
        ),
        W(
          l,
          "click",
          /*click_handler*/
          i[8]
        )
      ], r = !0);
    },
    p(a, c) {
      c & /*$item*/
      1 && s !== (s = /*$item*/
      a[0].system.slug || /*$item*/
      a[0].slug || "") && t.value !== s && (t.value = s);
    },
    d(a) {
      a && C(e), r = !1, Me(o);
    }
  };
}
u(Qfe, "create_default_slot_3$e");
function xfe(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--slim"), b(e, "type", "text"), e.value = t = /*$item*/
      i[0].system.class || "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[11]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.class || "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(xfe, "create_default_slot_2$g");
function ede(i) {
  let e, t, s, n, l, r, o, a, c;
  return e = new ie({
    props: {
      heading: "Sub Class Identifier",
      $$slots: { default: [Qfe] },
      $$scope: { ctx: i }
    }
  }), n = new Ke({
    props: {
      heading: "A5E Classes",
      options: Object.entries(
        /*classes*/
        i[5]
      ),
      selected: (
        /*$item*/
        i[0].system.class
      ),
      allowDeselect: !0
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[9]
  ), r = new Ke({
    props: {
      heading: "5E Classes",
      options: Object.entries(
        /*classes5e*/
        i[6]
      ),
      selected: (
        /*$item*/
        i[0].system.class
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[10]
  ), a = new ie({
    props: {
      heading: "Custom Class",
      hint: "Enter the identifier for a custom class.",
      $$slots: { default: [xfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), o = F(), j(a.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-header-item-justification", "flex-start"), G(t, "--a5e-field-wrapper-header-gap", "0.5rem");
    },
    m(f, d) {
      T(f, t, d), R(e, t, null), T(f, s, d), R(n, f, d), T(f, l, d), R(r, f, d), T(f, o, d), R(a, f, d), c = !0;
    },
    p(f, d) {
      const p = {};
      d & /*$$scope, $item*/
      65537 && (p.$$scope = { dirty: d, ctx: f }), e.$set(p);
      const m = {};
      d & /*$item*/
      1 && (m.selected = /*$item*/
      f[0].system.class), n.$set(m);
      const g = {};
      d & /*$item*/
      1 && (g.selected = /*$item*/
      f[0].system.class), r.$set(g);
      const h = {};
      d & /*$$scope, $item*/
      65537 && (h.$$scope = { dirty: d, ctx: f }), a.$set(h);
    },
    i(f) {
      c || (w(e.$$.fragment, f), w(n.$$.fragment, f), w(r.$$.fragment, f), w(a.$$.fragment, f), c = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(n.$$.fragment, f), O(r.$$.fragment, f), O(a.$$.fragment, f), c = !1;
    },
    d(f) {
      f && (C(s), C(l), C(o)), f && e && C(t), N(e, f), N(n, f), N(r, f), N(a, f);
    }
  };
}
u(ede, "create_default_slot_1$h");
function KR(i) {
  let e, t, s, n;
  return e = new Ke({
    props: {
      heading: "Default Spellcasting Ability",
      options: Object.entries(
        /*abilities*/
        i[2]
      ),
      selected: (
        /*$item*/
        i[0].system.spellcasting.ability.base
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[12]
  ), s = new tt({
    props: {
      heading: "Optional Spellcasting Abilities",
      options: Object.entries(
        /*abilitiesWithoutNone*/
        i[3]
      ),
      selected: (
        /*$item*/
        i[0].system.spellcasting.ability.options
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[13]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$item*/
      1 && (o.selected = /*$item*/
      l[0].system.spellcasting.ability.base), e.$set(o);
      const a = {};
      r & /*$item*/
      1 && (a.selected = /*$item*/
      l[0].system.spellcasting.ability.options), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(KR, "create_if_block_1$B");
function YR(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "Spellcasting Ability",
      options: Object.entries(
        /*abilities*/
        i[2]
      ),
      selected: (
        /*$item*/
        i[0].system.spellcasting.ability.value
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[14]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.spellcasting.ability.value), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(YR, "create_if_block$S");
function tde(i) {
  let e, t, s, n, l = !/*$item*/
  i[0].parent && KR(i), r = (
    /*$item*/
    i[0].parent && YR(i)
  );
  return s = new Ke({
    props: {
      heading: "Caster Type",
      options: Object.entries(
        /*casterTypes*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[0].system.spellcasting.casterType
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[15]
  ), {
    c() {
      l && l.c(), e = F(), r && r.c(), t = F(), j(s.$$.fragment);
    },
    m(o, a) {
      l && l.m(o, a), T(o, e, a), r && r.m(o, a), T(o, t, a), R(s, o, a), n = !0;
    },
    p(o, a) {
      /*$item*/
      o[0].parent ? l && (ae(), O(l, 1, 1, () => {
        l = null;
      }), ce()) : l ? (l.p(o, a), a & /*$item*/
      1 && w(l, 1)) : (l = KR(o), l.c(), w(l, 1), l.m(e.parentNode, e)), /*$item*/
      o[0].parent ? r ? (r.p(o, a), a & /*$item*/
      1 && w(r, 1)) : (r = YR(o), r.c(), w(r, 1), r.m(t.parentNode, t)) : r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce());
      const c = {};
      a & /*$item*/
      1 && (c.selected = /*$item*/
      o[0].system.spellcasting.casterType), s.$set(c);
    },
    i(o) {
      n || (w(l), w(r), w(s.$$.fragment, o), n = !0);
    },
    o(o) {
      O(l), O(r), O(s.$$.fragment, o), n = !1;
    },
    d(o) {
      o && (C(e), C(t)), l && l.d(o), r && r.d(o), N(s, o);
    }
  };
}
u(tde, "create_default_slot$J");
function sde(i) {
  let e, t, s, n, l, r, o;
  return t = new De({
    props: {
      heading: "Metadata",
      $$slots: { default: [ede] },
      $$scope: { ctx: i }
    }
  }), l = new De({
    props: {
      heading: "Spell Casting",
      $$slots: { default: [tde] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("article"), s = E("div"), j(t.$$.fragment), n = F(), r = E("div"), j(l.$$.fragment), G(s, "display", "contents"), G(s, "--a5e-section-body-gap", "0.75rem"), G(r, "display", "contents"), G(r, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(a, c) {
      T(a, e, c), A(e, s), R(t, s, null), A(e, n), A(e, r), R(l, r, null), o = !0;
    },
    p(a, [c]) {
      const f = {};
      c & /*$$scope, $item*/
      65537 && (f.$$scope = { dirty: c, ctx: a }), t.$set(f);
      const d = {};
      c & /*$$scope, $item*/
      65537 && (d.$$scope = { dirty: c, ctx: a }), l.$set(d);
    },
    i(a) {
      o || (w(t.$$.fragment, a), w(l.$$.fragment, a), o = !0);
    },
    o(a) {
      O(t.$$.fragment, a), O(l.$$.fragment, a), o = !1;
    },
    d(a) {
      a && C(e), N(t), N(l);
    }
  };
}
u(sde, "create_fragment$1A");
function nde(i, e, t) {
  let s;
  const n = de("item");
  pe(i, n, (k) => t(0, s = k));
  const l = { none: "None", ...CONFIG.A5E.abilities }, r = CONFIG.A5E.abilities, { casterTypes: o, classes: a, classes5e: c } = CONFIG.A5E;
  return [
    s,
    n,
    l,
    r,
    o,
    a,
    c,
    /* @__PURE__ */ u(({ target: k }) => {
      te(s, "system.slug", k.value.slugify({ strict: !0 }));
    }, "change_handler"),
    /* @__PURE__ */ u(() => te(s, "system.slug", ""), "click_handler"),
    /* @__PURE__ */ u(({ detail: k }) => {
      te(s, "system.class", k);
    }, "updateSelection_handler"),
    /* @__PURE__ */ u(({ detail: k }) => {
      te(s, "system.class", k);
    }, "updateSelection_handler_1"),
    /* @__PURE__ */ u(({ target: k }) => te(s, "system.class", k.value), "change_handler_1"),
    /* @__PURE__ */ u(({ detail: k }) => {
      te(s, "system.spellcasting.ability.options", []), te(s, "system.spellcasting.ability.base", k);
    }, "updateSelection_handler_2"),
    /* @__PURE__ */ u(({ detail: k }) => {
      te(s, "system.spellcasting.ability.base", "none"), te(s, "system.spellcasting.ability.options", k);
    }, "updateSelection_handler_3"),
    /* @__PURE__ */ u(({ detail: k }) => te(s, "system.spellcasting.ability.value", k), "updateSelection_handler_4"),
    /* @__PURE__ */ u(({ detail: k }) => te(s, "system.spellcasting.casterType", k), "updateSelection_handler_5")
  ];
}
u(nde, "instance$1u");
const fC = class fC extends re {
  constructor(e) {
    super(), oe(this, e, nde, sde, le, {});
  }
};
u(fC, "ArchetypePropertiesTab");
let Sv = fC;
function XR(i) {
  let e, t, s, n, l;
  return e = new pc({
    props: { summaryData: (
      /*summaryData*/
      i[0]
    ) }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), n = E("hr"), G(t, "display", "contents"), G(t, "--inline-padding", "0.25rem"), b(n, "class", "a5e-rule a5e-rule--card");
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), T(r, s, o), T(r, n, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*summaryData*/
      1 && (a.summaryData = /*summaryData*/
      r[0]), e.$set(a);
    },
    i(r) {
      l || (w(e.$$.fragment, r), l = !0);
    },
    o(r) {
      O(e.$$.fragment, r), l = !1;
    },
    d(r) {
      r && (C(s), C(n)), r && e && C(t), N(e, r);
    }
  };
}
u(XR, "create_if_block$R");
function ide(i) {
  let e = Object.values(
    /*summaryData*/
    i[0] ?? {}
  ).some(Boolean), t, s, n, l = e && XR(i);
  return s = new wr({
    props: {
      document: (
        /*item*/
        i[2]
      ),
      content: (
        /*content*/
        i[1]
      ),
      updatePath: "system.description"
    }
  }), {
    c() {
      l && l.c(), t = F(), j(s.$$.fragment);
    },
    m(r, o) {
      l && l.m(r, o), T(r, t, o), R(s, r, o), n = !0;
    },
    p(r, [o]) {
      o & /*summaryData*/
      1 && (e = Object.values(
        /*summaryData*/
        r[0] ?? {}
      ).some(Boolean)), e ? l ? (l.p(r, o), o & /*summaryData*/
      1 && w(l, 1)) : (l = XR(r), l.c(), w(l, 1), l.m(t.parentNode, t)) : l && (ae(), O(l, 1, 1, () => {
        l = null;
      }), ce());
      const a = {};
      o & /*content*/
      2 && (a.content = /*content*/
      r[1]), s.$set(a);
    },
    i(r) {
      n || (w(l), w(s.$$.fragment, r), n = !0);
    },
    o(r) {
      O(l), O(s.$$.fragment, r), n = !1;
    },
    d(r) {
      r && C(t), l && l.d(r), N(s, r);
    }
  };
}
u(ide, "create_fragment$1z");
function lde(i, e, t) {
  let s, n, { summaryData: l = {} } = e;
  const r = de("item");
  return pe(i, r, (o) => t(3, n = o)), i.$$set = (o) => {
    "summaryData" in o && t(0, l = o.summaryData);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item*/
    8 && t(1, s = n.system.description);
  }, [l, s, r, n];
}
u(lde, "instance$1t");
const dC = class dC extends re {
  constructor(e) {
    super(), oe(this, e, lde, ide, le, { summaryData: 0 });
  }
};
u(dC, "ItemDescriptionTab");
let zl = dC;
function JR(i) {
  let e, t = !/*sheetIsLocked*/
  i[2] && ZR(i);
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*sheetIsLocked*/
      s[2] ? t && (t.d(1), t = null) : t ? t.p(s, n) : (t = ZR(s), t.c(), t.m(e.parentNode, e));
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(JR, "create_if_block$Q");
function ZR(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g;
  return {
    c() {
      e = E("div"), t = E("i"), s = F(), n = E("ul"), l = E("li"), r = E("button"), o = F(), a = E("li"), c = E("button"), f = F(), d = E("li"), p = E("button"), b(t, "class", "track-icon fa-solid fa-ellipsis-vertical svelte-hzlxus"), b(r, "class", "action-button fas fa-cog svelte-hzlxus"), b(r, "data-tooltip", "A5E.ButtonToolTipConfigure"), b(r, "data-tooltip-direction", "UP"), b(c, "class", "action-button fa-solid fa-clone svelte-hzlxus"), b(c, "data-tooltip", "A5E.ButtonToolTipDuplicate"), b(c, "data-tooltip-direction", "UP"), b(p, "class", "action-button delete-button fas fa-trash svelte-hzlxus"), b(p, "data-tooltip", "A5E.ButtonToolTipDelete"), b(p, "data-tooltip-direction", "UP"), b(n, "class", "track-items svelte-hzlxus"), b(e, "class", "track svelte-hzlxus");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(e, s), A(e, n), A(n, l), A(l, r), A(n, o), A(n, a), A(a, c), A(n, f), A(n, d), A(d, p), m || (g = [
        W(r, "click", Ve(
          /*click_handler_2*/
          i[8]
        )),
        W(c, "click", Ve(
          /*click_handler_3*/
          i[9]
        )),
        W(p, "click", Ve(
          /*click_handler_4*/
          i[10]
        )),
        W(e, "click", Ve(
          /*click_handler*/
          i[6]
        ))
      ], m = !0);
    },
    p: se,
    d(h) {
      h && C(e), m = !1, Me(g);
    }
  };
}
u(ZR, "create_if_block_1$A");
function rde(i) {
  let e, t, s, n, l, r, o, a, c = (
    /*grant*/
    (i[0].label || "New Grant") + ""
  ), f, d, p, m, g, h, _ = (
    /*$item*/
    i[1].isOwner && JR(i)
  );
  return {
    c() {
      var y, v;
      e = E("li"), t = E("button"), s = E("img"), r = F(), o = E("div"), a = E("div"), f = Q(c), d = F(), p = E("div"), p.innerHTML = "", m = F(), _ && _.c(), b(s, "class", "grant-image svelte-hzlxus"), ze(s.src, n = /*grant*/
      ((y = i[0]) == null ? void 0 : y.img) || /*$item*/
      ((v = i[1]) == null ? void 0 : v.img) || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label || "New Grant"), b(t, "class", "grant-activate-button svelte-hzlxus"), t.disabled = !0, Z(t, "disable-pointer-events", !/*$item*/
      i[1].isOwner), b(a, "class", "name svelte-hzlxus"), b(o, "class", "name-wrapper svelte-hzlxus"), b(p, "class", "indicator-wrapper svelte-hzlxus"), b(e, "class", "a5e-item a5e-item--grant"), b(e, "draggable", "true");
    },
    m(y, v) {
      T(y, e, v), A(e, t), A(t, s), A(e, r), A(e, o), A(o, a), A(a, f), A(e, d), A(e, p), A(e, m), _ && _.m(e, null), g || (h = [
        W(t, "click", Ve(
          /*click_handler_1*/
          i[7]
        )),
        W(
          e,
          "dragstart",
          /*_onDragStart*/
          i[4]
        ),
        W(e, "auxclick", st(
          /*onAuxClick*/
          i[5]
        ))
      ], g = !0);
    },
    p(y, [v]) {
      var k, S;
      v & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      ((k = y[0]) == null ? void 0 : k.img) || /*$item*/
      ((S = y[1]) == null ? void 0 : S.img) || "icons/svg/upgrade.svg") && b(s, "src", n), v & /*grant*/
      1 && l !== (l = /*grant*/
      y[0].label || "New Grant") && b(s, "alt", l), v & /*$item*/
      2 && Z(t, "disable-pointer-events", !/*$item*/
      y[1].isOwner), v & /*grant*/
      1 && c !== (c = /*grant*/
      (y[0].label || "New Grant") + "") && be(f, c), /*$item*/
      y[1].isOwner ? _ ? _.p(y, v) : (_ = JR(y), _.c(), _.m(e, null)) : _ && (_.d(1), _ = null);
    },
    i: se,
    o: se,
    d(y) {
      y && C(e), _ && _.d(), g = !1, Me(h);
    }
  };
}
u(rde, "create_fragment$1y");
function ode(i, e, t) {
  let s, n, { grant: l } = e;
  const r = de("item");
  pe(i, r, (h) => t(1, n = h));
  function o(h) {
    var y;
    const _ = {
      grantId: l._id,
      itemUuid: n.uuid,
      type: "Grant"
    };
    return (y = h.dataTransfer) == null ? void 0 : y.setData("text/plain", JSON.stringify(_));
  }
  u(o, "_onDragStart");
  async function a() {
    c && l.configureGrant();
  }
  u(a, "onAuxClick");
  let c = game.settings.get("a5e", "itemRightClickConfigure") ?? !1;
  function f(h) {
    bt.call(this, i, h);
  }
  u(f, "click_handler");
  const d = /* @__PURE__ */ u(({ target: h }) => {
  }, "click_handler_1"), p = /* @__PURE__ */ u(() => l.configureGrant(), "click_handler_2"), m = /* @__PURE__ */ u(() => n.grants.duplicate(l._id), "click_handler_3"), g = /* @__PURE__ */ u(() => l.deleteGrant(), "click_handler_4");
  return i.$$set = (h) => {
    "grant" in h && t(0, l = h.grant);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item*/
    2 && t(2, s = !n.isOwner);
  }, [
    l,
    n,
    s,
    r,
    o,
    a,
    f,
    d,
    p,
    m,
    g
  ];
}
u(ode, "instance$1s");
const pC = class pC extends re {
  constructor(e) {
    super(), oe(this, e, ode, rde, le, { grant: 0 });
  }
};
u(pC, "ItemGrantListComponent");
let Cv = pC;
function QR(i, e, t) {
  const s = i.slice();
  return s[11] = e[t], s;
}
u(QR, "get_each_context$x");
function xR(i, e, t) {
  const s = i.slice();
  return s[14] = e[t], s;
}
u(xR, "get_each_context_1$4");
function eN(i) {
  let e, t, s, n, l = [], r = /* @__PURE__ */ new Map(), o, a;
  function c() {
    return (
      /*func*/
      i[7](
        /*grantType*/
        i[11]
      )
    );
  }
  u(c, "func"), t = new De({
    props: {
      heading: `A5E.grants.headingsPlural.${/*grantType*/
      i[11]}`,
      headerButtons: [
        {
          classes: "add-button",
          handler: c,
          label: K("A5E.ButtonAddGrant", {
            type: K(`A5E.grants.headings.${/*grantType*/
            i[11]}`)
          })
        }
      ]
    }
  });
  let f = ue(
    /*grants*/
    i[2].byType(
      /*grantType*/
      i[11]
    )
  );
  const d = /* @__PURE__ */ u((p) => (
    /*grant*/
    p[14]._id
  ), "get_key");
  for (let p = 0; p < f.length; p += 1) {
    let m = xR(i, f, p), g = d(m);
    r.set(g, l[p] = tN(g, m));
  }
  return {
    c() {
      e = E("li"), j(t.$$.fragment), s = F(), n = E("ul");
      for (let p = 0; p < l.length; p += 1)
        l[p].c();
      o = F(), b(n, "class", "a5e-item-list"), b(e, "class", "grant-config-list__item svelte-110366l");
    },
    m(p, m) {
      T(p, e, m), R(t, e, null), A(e, s), A(e, n);
      for (let g = 0; g < l.length; g += 1)
        l[g] && l[g].m(n, null);
      A(e, o), a = !0;
    },
    p(p, m) {
      i = p, m & /*grants, Object, itemGrantTypes, grantTemplateConfiguration*/
      21 && (f = ue(
        /*grants*/
        i[2].byType(
          /*grantType*/
          i[11]
        )
      ), ae(), l = Lt(l, m, d, 1, i, f, r, n, cn, tN, null, xR), ce());
    },
    i(p) {
      if (!a) {
        w(t.$$.fragment, p);
        for (let m = 0; m < f.length; m += 1)
          w(l[m]);
        a = !0;
      }
    },
    o(p) {
      O(t.$$.fragment, p);
      for (let m = 0; m < l.length; m += 1)
        O(l[m]);
      a = !1;
    },
    d(p) {
      p && C(e), N(t);
      for (let m = 0; m < l.length; m += 1)
        l[m].d();
    }
  };
}
u(eN, "create_if_block$P");
function tN(i, e) {
  let t, s, n, l, r, o;
  return s = new Cv({ props: { grant: (
    /*grant*/
    e[14]
  ) } }), {
    key: i,
    first: null,
    c() {
      t = $e(), n = E("div"), j(s.$$.fragment), G(n, "display", "contents"), G(n, "--grantTemplateAreas", l = /*grantTemplateConfiguration*/
      e[0].areas), G(n, "--grantTemplateColumns", r = /*grantTemplateConfiguration*/
      e[0].columns), this.first = t;
    },
    m(a, c) {
      T(a, t, c), T(a, n, c), R(s, n, null), o = !0;
    },
    p(a, c) {
      e = a, c & /*grantTemplateConfiguration*/
      1 && l !== (l = /*grantTemplateConfiguration*/
      e[0].areas) && G(n, "--grantTemplateAreas", l), c & /*grantTemplateConfiguration*/
      1 && r !== (r = /*grantTemplateConfiguration*/
      e[0].columns) && G(n, "--grantTemplateColumns", r);
      const f = {};
      c & /*grants*/
      4 && (f.grant = /*grant*/
      e[14]), s.$set(f);
    },
    i(a) {
      o || (w(s.$$.fragment, a), o = !0);
    },
    o(a) {
      O(s.$$.fragment, a), o = !1;
    },
    d(a) {
      a && C(t), a && s && C(n), N(s, a);
    }
  };
}
u(tN, "create_each_block_1$4");
function sN(i, e) {
  let t, s = (
    /*grants*/
    e[2].byType(
      /*grantType*/
      e[11]
    ).length
  ), n, l, r = s && eN(e);
  return {
    key: i,
    first: null,
    c() {
      t = $e(), r && r.c(), n = $e(), this.first = t;
    },
    m(o, a) {
      T(o, t, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      e = o, a & /*grants*/
      4 && (s = /*grants*/
      e[2].byType(
        /*grantType*/
        e[11]
      ).length), s ? r ? (r.p(e, a), a & /*grants*/
      4 && w(r, 1)) : (r = eN(e), r.c(), w(r, 1), r.m(n.parentNode, n)) : r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce());
    },
    i(o) {
      l || (w(r), l = !0);
    },
    o(o) {
      O(r), l = !1;
    },
    d(o) {
      o && (C(t), C(n)), r && r.d(o);
    }
  };
}
u(sN, "create_each_block$x");
function ade(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r, o, a, c = ue(Object.keys(
    /*itemGrantTypes*/
    i[4]
  ));
  const f = /* @__PURE__ */ u((d) => (
    /*grantType*/
    d[11]
  ), "get_key");
  for (let d = 0; d < c.length; d += 1) {
    let p = QR(i, c, d), m = f(p);
    n.set(m, s[d] = sN(m, p));
  }
  return o = new Tn({
    props: {
      menuList: (
        /*menuList*/
        i[1]
      ),
      offset: { x: -165, y: -230 },
      documentName: "Grant"
    }
  }), o.$on(
    "press",
    /*press_handler*/
    i[8]
  ), {
    c() {
      e = E("div"), t = E("ul");
      for (let d = 0; d < s.length; d += 1)
        s[d].c();
      l = F(), r = E("div"), j(o.$$.fragment), b(t, "class", "grant-config-list svelte-110366l"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(r, "class", "sticky-add-button svelte-110366l");
    },
    m(d, p) {
      T(d, e, p), A(e, t);
      for (let m = 0; m < s.length; m += 1)
        s[m] && s[m].m(t, null);
      T(d, l, p), T(d, r, p), R(o, r, null), a = !0;
    },
    p(d, [p]) {
      p & /*grants, Object, itemGrantTypes, grantTemplateConfiguration, addGrant*/
      53 && (c = ue(Object.keys(
        /*itemGrantTypes*/
        d[4]
      )), ae(), s = Lt(s, p, f, 1, d, c, n, t, cn, sN, null, QR), ce());
      const m = {};
      p & /*menuList*/
      2 && (m.menuList = /*menuList*/
      d[1]), o.$set(m);
    },
    i(d) {
      if (!a) {
        for (let p = 0; p < c.length; p += 1)
          w(s[p]);
        w(o.$$.fragment, d), a = !0;
      }
    },
    o(d) {
      for (let p = 0; p < s.length; p += 1)
        O(s[p]);
      O(o.$$.fragment, d), a = !1;
    },
    d(d) {
      d && (C(e), C(l), C(r));
      for (let p = 0; p < s.length; p += 1)
        s[p].d();
      N(o);
    }
  };
}
u(ade, "create_fragment$1x");
function cde(i, e, t) {
  let s, n, l, r, o;
  const a = de("item");
  pe(i, a, (g) => t(6, o = g));
  const c = CONFIG.A5E.itemGrants;
  function f() {
    let g = "icon name indicators", h = "min-content 1fr min-content";
    return (o.documentName === "Item" || !l) && (g += " menu", h += " 2rem"), { areas: `"${g}"`, columns: h };
  }
  u(f, "getGrantTemplateConfiguration");
  function d(g) {
    const h = { grantType: g, optional: !1 };
    dc.addGrant(o, h);
  }
  u(d, "addGrant");
  const p = /* @__PURE__ */ u((g) => d(g), "func"), m = /* @__PURE__ */ u(({ detail: g }) => d(g), "press_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    64 && t(2, s = o.grants), i.$$.dirty & /*$item*/
    64 && (l = !o.isOwner);
  }, t(1, n = Object.entries(c).reduce(
    (g, [h, _]) => (g.push([h, _]), g),
    []
  )), t(0, r = f()), [
    r,
    n,
    s,
    a,
    c,
    d,
    o,
    p,
    m
  ];
}
u(cde, "instance$1r");
const mC = class mC extends re {
  constructor(e) {
    super(), oe(this, e, cde, ade, le, {});
  }
};
u(mC, "ItemGrantsTab");
let Er = mC;
function nN(i) {
  let e, t, s = K("A5E.Prerequisite") + "", n, l, r, o, a, c, f;
  return {
    c() {
      e = E("div"), t = E("label"), n = Q(s), l = Q(":"), r = F(), o = E("input"), b(t, "class", "prerequisite-label svelte-qtluzc"), b(
        t,
        "for",
        /*appId*/
        i[4] + "-prerequisites"
      ), b(
        o,
        "id",
        /*appId*/
        i[4] + "-prerequisites"
      ), b(o, "type", "text"), b(o, "name", "system.prerequisite"), o.value = a = /*$item*/
      i[1].system.prerequisite, b(o, "class", "prerequisite-input svelte-qtluzc"), b(o, "placeholder", K("A5E.None")), b(e, "class", "prerequisites svelte-qtluzc");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, n), A(t, l), A(e, r), A(e, o), c || (f = W(
        o,
        "change",
        /*change_handler_1*/
        i[12]
      ), c = !0);
    },
    p(d, p) {
      p & /*$item*/
      2 && a !== (a = /*$item*/
      d[1].system.prerequisite) && o.value !== a && (o.value = a);
    },
    d(d) {
      d && C(e), c = !1, f();
    }
  };
}
u(nN, "create_if_block_4$e");
function iN(i) {
  let e, t, s, n, l, r, o, a, c, f = (
    /*$item*/
    i[1].actor && /*$item*/
    i[1].system.requiresAttunement && lN(i)
  );
  return {
    c() {
      e = E("div"), t = E("button"), n = F(), f && f.c(), l = F(), r = E("button"), b(t, "class", "header-button fa-solid fa-circle-question svelte-qtluzc"), t.disabled = !/*isGM*/
      i[7], b(t, "data-tooltip", s = /*$item*/
      i[1].system.unidentified ? "A5E.ButtonToolTipUnidentified" : "A5E.ButtonToolTipIdentified"), b(t, "data-tooltip-direction", "UP"), Z(
        t,
        "active",
        /*$item*/
        i[1].system.unidentified
      ), Z(t, "locked", !/*isGM*/
      i[7]), b(r, "class", "header-button fas svelte-qtluzc"), b(r, "data-tooltip", o = /*damagedStates*/
      i[6][
        /*$item*/
        i[1].system.damagedState ?? 0
      ]), b(r, "data-tooltip-direction", "UP"), Z(
        r,
        "fa-heart",
        /*$item*/
        i[1].system.damagedState === /*DAMAGED_STATES*/
        i[5].INTACT
      ), Z(
        r,
        "fa-heart-crack",
        /*$item*/
        i[1].system.damagedState === /*DAMAGED_STATES*/
        i[5].DAMAGED
      ), Z(
        r,
        "fa-heart-pulse",
        /*$item*/
        i[1].system.damagedState === /*DAMAGED_STATES*/
        i[5].BROKEN
      ), Z(r, "active", [
        /*DAMAGED_STATES*/
        i[5].DAMAGED,
        /*DAMAGED_STATES*/
        i[5].BROKEN
      ].includes(
        /*$item*/
        i[1].system.damagedState
      )), b(e, "class", "button-container svelte-qtluzc");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(e, n), f && f.m(e, null), A(e, l), A(e, r), a || (c = [
        W(t, "click", Ve(
          /*click_handler_1*/
          i[13]
        )),
        W(r, "click", Ve(
          /*click_handler_3*/
          i[15]
        ))
      ], a = !0);
    },
    p(d, p) {
      p & /*$item*/
      2 && s !== (s = /*$item*/
      d[1].system.unidentified ? "A5E.ButtonToolTipUnidentified" : "A5E.ButtonToolTipIdentified") && b(t, "data-tooltip", s), p & /*$item*/
      2 && Z(
        t,
        "active",
        /*$item*/
        d[1].system.unidentified
      ), /*$item*/
      d[1].actor && /*$item*/
      d[1].system.requiresAttunement ? f ? f.p(d, p) : (f = lN(d), f.c(), f.m(e, l)) : f && (f.d(1), f = null), p & /*$item*/
      2 && o !== (o = /*damagedStates*/
      d[6][
        /*$item*/
        d[1].system.damagedState ?? 0
      ]) && b(r, "data-tooltip", o), p & /*$item, DAMAGED_STATES*/
      34 && Z(
        r,
        "fa-heart",
        /*$item*/
        d[1].system.damagedState === /*DAMAGED_STATES*/
        d[5].INTACT
      ), p & /*$item, DAMAGED_STATES*/
      34 && Z(
        r,
        "fa-heart-crack",
        /*$item*/
        d[1].system.damagedState === /*DAMAGED_STATES*/
        d[5].DAMAGED
      ), p & /*$item, DAMAGED_STATES*/
      34 && Z(
        r,
        "fa-heart-pulse",
        /*$item*/
        d[1].system.damagedState === /*DAMAGED_STATES*/
        d[5].BROKEN
      ), p & /*DAMAGED_STATES, $item*/
      34 && Z(r, "active", [
        /*DAMAGED_STATES*/
        d[5].DAMAGED,
        /*DAMAGED_STATES*/
        d[5].BROKEN
      ].includes(
        /*$item*/
        d[1].system.damagedState
      ));
    },
    d(d) {
      d && C(e), f && f.d(), a = !1, Me(c);
    }
  };
}
u(iN, "create_if_block_2$r");
function lN(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "header-button fa-solid fa-link svelte-qtluzc"), b(e, "data-tooltip", t = /*$item*/
      i[1].system.attuned ? K("A5E.ButtonToolTipBreakAttunement", { item: (
        /*$item*/
        i[1].name
      ) }) : K("A5E.ButtonToolTipAttune", { item: (
        /*$item*/
        i[1].name
      ) })), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "active",
        /*$item*/
        i[1].system.attuned
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = W(e, "click", Ve(
        /*click_handler_2*/
        i[14]
      )), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      2 && t !== (t = /*$item*/
      l[1].system.attuned ? K("A5E.ButtonToolTipBreakAttunement", { item: (
        /*$item*/
        l[1].name
      ) }) : K("A5E.ButtonToolTipAttune", { item: (
        /*$item*/
        l[1].name
      ) })) && b(e, "data-tooltip", t), r & /*$item*/
      2 && Z(
        e,
        "active",
        /*$item*/
        l[1].system.attuned
      );
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(lN, "create_if_block_3$h");
function rN(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "class-level-input svelte-qtluzc"), b(e, "type", "number"), b(e, "min", "1"), b(e, "max", "20"), e.value = t = /*$item*/
      i[1].system.classLevels;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_2*/
        i[16]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      2 && t !== (t = /*$item*/
      l[1].system.classLevels) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(rN, "create_if_block_1$z");
function oN(i) {
  let e, t = K("A5E.FulfilDestiny") + "", s, n, l;
  return {
    c() {
      e = E("button"), s = Q(t), b(e, "class", "fulfil-button svelte-qtluzc"), e.disabled = /*disableFulfil*/
      i[0];
    },
    m(r, o) {
      T(r, e, o), A(e, s), n || (l = W(
        e,
        "click",
        /*click_handler_4*/
        i[17]
      ), n = !0);
    },
    p(r, o) {
      o & /*disableFulfil*/
      1 && (e.disabled = /*disableFulfil*/
      r[0]);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(oN, "create_if_block$O");
function ude(i) {
  let e, t, s, n, l, r, o, a, c, f, d = (
    /*prerequisiteTypes*/
    i[9].includes(
      /*$item*/
      i[1].type
    )
  ), p, m, g, h, _, y, v = d && nN(i), k = (
    /*$item*/
    i[1].type === "object" && iN(i)
  ), S = (
    /*$item*/
    i[1].type === "class" && /*$item*/
    i[1].actor && rN(i)
  ), D = (
    /*$item*/
    i[1].type === "destiny" && oN(i)
  );
  return {
    c() {
      e = E("header"), t = E("img"), r = F(), o = E("div"), a = E("input"), f = F(), v && v.c(), p = F(), k && k.c(), m = F(), S && S.c(), g = F(), h = E("div"), D && D.c(), b(t, "class", "item-image svelte-qtluzc"), ze(t.src, s = /*$item*/
      i[1].img) || b(t, "src", s), b(t, "alt", n = /*$item*/
      i[1].name), b(t, "title", l = /*$item*/
      i[1].name), b(a, "class", "item-name svelte-qtluzc"), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*$item*/
      i[1].name, b(a, "placeholder", "A5E.Name"), b(o, "class", "name-wrapper svelte-qtluzc"), b(h, "class", "u-flex u-flex-shrink-0 u-align-center u-gap-xl"), b(e, "class", "sheet-header svelte-qtluzc");
    },
    m(I, M) {
      T(I, e, M), A(e, t), A(e, r), A(e, o), A(o, a), A(o, f), v && v.m(o, null), A(e, p), k && k.m(e, null), A(e, m), S && S.m(e, null), A(e, g), A(e, h), D && D.m(h, null), _ || (y = [
        W(
          t,
          "click",
          /*click_handler*/
          i[10]
        ),
        W(
          a,
          "change",
          /*change_handler*/
          i[11]
        )
      ], _ = !0);
    },
    p(I, [M]) {
      M & /*$item*/
      2 && !ze(t.src, s = /*$item*/
      I[1].img) && b(t, "src", s), M & /*$item*/
      2 && n !== (n = /*$item*/
      I[1].name) && b(t, "alt", n), M & /*$item*/
      2 && l !== (l = /*$item*/
      I[1].name) && b(t, "title", l), M & /*$item*/
      2 && c !== (c = /*$item*/
      I[1].name) && a.value !== c && (a.value = c), M & /*$item*/
      2 && (d = /*prerequisiteTypes*/
      I[9].includes(
        /*$item*/
        I[1].type
      )), d ? v ? v.p(I, M) : (v = nN(I), v.c(), v.m(o, null)) : v && (v.d(1), v = null), /*$item*/
      I[1].type === "object" ? k ? k.p(I, M) : (k = iN(I), k.c(), k.m(e, m)) : k && (k.d(1), k = null), /*$item*/
      I[1].type === "class" && /*$item*/
      I[1].actor ? S ? S.p(I, M) : (S = rN(I), S.c(), S.m(e, g)) : S && (S.d(1), S = null), /*$item*/
      I[1].type === "destiny" ? D ? D.p(I, M) : (D = oN(I), D.c(), D.m(h, null)) : D && (D.d(1), D = null);
    },
    i: se,
    o: se,
    d(I) {
      I && C(e), v && v.d(), k && k.d(), S && S.d(), D && D.d(), _ = !1, Me(y);
    }
  };
}
u(ude, "create_fragment$1w");
function fde(i, e, t) {
  var D;
  let s;
  async function n() {
    const I = await fromUuid(s.system.fulfillmentFeature);
    !I || !s.actor || (s.actor.getFlag("a5e", "destinyFulfilled") ?? !1) || (await s.actor.createEmbeddedDocuments("Item", [I]), await s.actor.setFlag("a5e", "destinyFulfilled", !0), t(0, p = !0));
  }
  u(n, "fulfilDestiny");
  async function l(I) {
    I = parseInt(I, 10);
    const M = s.system.classLevels, L = Math.abs(M - I), B = Math.sign(I - M);
    for (let z = 0; z < L; z++)
      B === 1 ? await s.update({
        "system.classLevels": Math.min(s.system.classLevels + 1, s.system.maxLevel)
      }) : await s.update({
        "system.classLevels": s.system.classLevels - 1
      });
  }
  u(l, "updateClassLevel");
  const r = de("appId"), { DAMAGED_STATES: o, damagedStates: a } = CONFIG.A5E, { isGM: c } = game.user, f = de("item");
  pe(i, f, (I) => t(1, s = I));
  const d = ["maneuver", "feature", "spell"];
  let p = ((D = s.actor) == null ? void 0 : D.getFlag("a5e", "destinyFulfilled")) ?? !0;
  return [
    p,
    s,
    n,
    l,
    r,
    o,
    a,
    c,
    f,
    d,
    /* @__PURE__ */ u(() => gg(s), "click_handler"),
    /* @__PURE__ */ u(({ target: I }) => te(s, I.name, I.value), "change_handler"),
    /* @__PURE__ */ u(({ target: I }) => te(s, I.name, I.value), "change_handler_1"),
    /* @__PURE__ */ u(() => s.toggleUnidentified(), "click_handler_1"),
    /* @__PURE__ */ u(() => s.toggleAttunement(), "click_handler_2"),
    /* @__PURE__ */ u(() => s.toggleDamagedState(), "click_handler_3"),
    /* @__PURE__ */ u(({ target: I }) => l(I.value), "change_handler_2"),
    /* @__PURE__ */ u(() => n(), "click_handler_4")
  ];
}
u(fde, "instance$1q");
const hC = class hC extends re {
  constructor(e) {
    super(), oe(this, e, fde, ude, le, {});
  }
};
u(hC, "ItemSheetHeader");
let Hl = hC;
function dde(i) {
  let e, t, s, n, l, r, o, a, c;
  t = new Hl({}), n = new Wn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[4]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  var f = (
    /*currentTab*/
    i[1].component
  );
  function d(p, m) {
    return {};
  }
  return u(d, "switch_props"), f && (r = et(f, d())), {
    c() {
      e = E("main"), j(t.$$.fragment), s = F(), j(n.$$.fragment), l = F(), r && j(r.$$.fragment), b(e, "class", "svelte-y36y3r");
    },
    m(p, m) {
      T(p, e, m), R(t, e, null), A(e, s), R(n, e, null), A(e, l), r && R(r, e, null), o = !0, a || (c = W(e, "drop", Ve(st(
        /*drop_handler*/
        i[7]
      ))), a = !0);
    },
    p(p, m) {
      const g = {};
      if (m & /*currentTab*/
      2 && (g.currentTab = /*currentTab*/
      p[1]), n.$set(g), m & /*currentTab*/
      2 && f !== (f = /*currentTab*/
      p[1].component)) {
        if (r) {
          ae();
          const h = r;
          O(h.$$.fragment, 1, 0, () => {
            N(h, 1);
          }), ce();
        }
        f ? (r = et(f, d()), j(r.$$.fragment), w(r.$$.fragment, 1), R(r, e, null)) : r = null;
      }
    },
    i(p) {
      o || (w(t.$$.fragment, p), w(n.$$.fragment, p), r && w(r.$$.fragment, p), o = !0);
    },
    o(p) {
      O(t.$$.fragment, p), O(n.$$.fragment, p), r && O(r.$$.fragment, p), o = !1;
    },
    d(p) {
      p && C(e), N(t), N(n), r && N(r), a = !1, c();
    }
  };
}
u(dde, "create_default_slot$I");
function pde(i) {
  let e, t, s;
  function n(r) {
    i[8](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [dde] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        1026 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(pde, "create_fragment$1v");
function mde(i, e, t) {
  let { document: s, sheet: n } = de("#external").application, { document: l = s, sheet: r = n } = e, { elementRoot: o } = e;
  const a = l;
  function c(h) {
    t(1, p = d[h.detail]);
  }
  u(c, "updateCurrentTab");
  function f(h) {
    const _ = h.dataTransfer.getData("text/plain");
    if (!_) return;
    const y = JSON.parse(_);
    r._onDropDocument(y);
  }
  u(f, "onDrop");
  const d = [
    {
      name: "description",
      label: "A5E.Description",
      component: zl
    },
    {
      name: "properties",
      label: "A5E.ItemSheetLabelPropertiesTab",
      component: Sv
    },
    {
      name: "resources",
      label: "A5E.TabResources",
      component: Gp
    },
    {
      name: "grants",
      label: "A5E.TabGrants",
      component: Er
    }
  ];
  let p = d[0];
  lt("item", a);
  const m = /* @__PURE__ */ u((h) => f(h), "drop_handler");
  function g(h) {
    o = h, t(0, o);
  }
  return u(g, "applicationshell_elementRoot_binding"), i.$$set = (h) => {
    "document" in h && t(5, l = h.document), "sheet" in h && t(6, r = h.sheet), "elementRoot" in h && t(0, o = h.elementRoot);
  }, [
    o,
    p,
    c,
    f,
    d,
    l,
    r,
    m,
    g
  ];
}
u(mde, "instance$1p");
const gC = class gC extends re {
  constructor(e) {
    super(), oe(this, e, mde, pde, le, { document: 5, sheet: 6, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[5];
  }
  set document(e) {
    this.$$set({ document: e }), Xe();
  }
  get sheet() {
    return this.$$.ctx[6];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
};
u(gC, "ArchetypeSheet");
let Tv = gC;
function hde(i) {
  let e, t, s, n, l, r, o, a, c;
  t = new Hl({}), n = new Wn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[4]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  var f = (
    /*currentTab*/
    i[1].component
  );
  function d(p, m) {
    return {};
  }
  return u(d, "switch_props"), f && (r = et(f, d())), {
    c() {
      e = E("main"), j(t.$$.fragment), s = F(), j(n.$$.fragment), l = F(), r && j(r.$$.fragment), b(e, "class", "svelte-y36y3r");
    },
    m(p, m) {
      T(p, e, m), R(t, e, null), A(e, s), R(n, e, null), A(e, l), r && R(r, e, null), o = !0, a || (c = W(e, "drop", Ve(st(
        /*drop_handler*/
        i[7]
      ))), a = !0);
    },
    p(p, m) {
      const g = {};
      if (m & /*currentTab*/
      2 && (g.currentTab = /*currentTab*/
      p[1]), n.$set(g), m & /*currentTab*/
      2 && f !== (f = /*currentTab*/
      p[1].component)) {
        if (r) {
          ae();
          const h = r;
          O(h.$$.fragment, 1, 0, () => {
            N(h, 1);
          }), ce();
        }
        f ? (r = et(f, d()), j(r.$$.fragment), w(r.$$.fragment, 1), R(r, e, null)) : r = null;
      }
    },
    i(p) {
      o || (w(t.$$.fragment, p), w(n.$$.fragment, p), r && w(r.$$.fragment, p), o = !0);
    },
    o(p) {
      O(t.$$.fragment, p), O(n.$$.fragment, p), r && O(r.$$.fragment, p), o = !1;
    },
    d(p) {
      p && C(e), N(t), N(n), r && N(r), a = !1, c();
    }
  };
}
u(hde, "create_default_slot$H");
function gde(i) {
  let e, t, s;
  function n(r) {
    i[8](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [hde] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        1026 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(gde, "create_fragment$1u");
function bde(i, e, t) {
  let { document: s, sheet: n } = de("#external").application, { document: l = s, sheet: r = n } = e, { elementRoot: o } = e;
  const a = l;
  function c(h) {
    t(1, p = d[h.detail]);
  }
  u(c, "updateCurrentTab");
  function f(h) {
    const _ = h.dataTransfer.getData("text/plain");
    if (!_) return;
    const y = JSON.parse(_);
    r._onDropDocument(y);
  }
  u(f, "onDrop");
  const d = [
    {
      name: "description",
      label: "A5E.Description",
      component: zl
    },
    {
      name: "grants",
      label: "A5E.TabGrants",
      component: Er
    }
  ];
  let p = d[0];
  lt("item", a);
  const m = /* @__PURE__ */ u((h) => f(h), "drop_handler");
  function g(h) {
    o = h, t(0, o);
  }
  return u(g, "applicationshell_elementRoot_binding"), i.$$set = (h) => {
    "document" in h && t(5, l = h.document), "sheet" in h && t(6, r = h.sheet), "elementRoot" in h && t(0, o = h.elementRoot);
  }, [
    o,
    p,
    c,
    f,
    d,
    l,
    r,
    m,
    g
  ];
}
u(bde, "instance$1o");
const bC = class bC extends re {
  constructor(e) {
    super(), oe(this, e, bde, gde, le, { document: 5, sheet: 6, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[5];
  }
  set document(e) {
    this.$$set({ document: e }), Xe();
  }
  get sheet() {
    return this.$$.ctx[6];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
};
u(bC, "BackgroundSheet");
let Ov = bC;
function _de(i) {
  let e, t, s, n, l, r, o, a, c;
  t = new Hl({}), n = new Wn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[4]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  var f = (
    /*currentTab*/
    i[1].component
  );
  function d(p, m) {
    return {};
  }
  return u(d, "switch_props"), f && (r = et(f, d())), {
    c() {
      e = E("main"), j(t.$$.fragment), s = F(), j(n.$$.fragment), l = F(), r && j(r.$$.fragment), b(e, "class", "svelte-y36y3r");
    },
    m(p, m) {
      T(p, e, m), R(t, e, null), A(e, s), R(n, e, null), A(e, l), r && R(r, e, null), o = !0, a || (c = W(e, "drop", Ve(st(
        /*drop_handler*/
        i[7]
      ))), a = !0);
    },
    p(p, m) {
      const g = {};
      if (m & /*currentTab*/
      2 && (g.currentTab = /*currentTab*/
      p[1]), n.$set(g), m & /*currentTab*/
      2 && f !== (f = /*currentTab*/
      p[1].component)) {
        if (r) {
          ae();
          const h = r;
          O(h.$$.fragment, 1, 0, () => {
            N(h, 1);
          }), ce();
        }
        f ? (r = et(f, d()), j(r.$$.fragment), w(r.$$.fragment, 1), R(r, e, null)) : r = null;
      }
    },
    i(p) {
      o || (w(t.$$.fragment, p), w(n.$$.fragment, p), r && w(r.$$.fragment, p), o = !0);
    },
    o(p) {
      O(t.$$.fragment, p), O(n.$$.fragment, p), r && O(r.$$.fragment, p), o = !1;
    },
    d(p) {
      p && C(e), N(t), N(n), r && N(r), a = !1, c();
    }
  };
}
u(_de, "create_default_slot$G");
function yde(i) {
  let e, t, s;
  function n(r) {
    i[8](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [_de] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        1026 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(yde, "create_fragment$1t");
function vde(i, e, t) {
  let { document: s, sheet: n } = de("#external").application, { document: l = s, sheet: r = n } = e, { elementRoot: o } = e;
  const a = l;
  function c(h) {
    t(1, p = d[h.detail]);
  }
  u(c, "updateCurrentTab");
  function f(h) {
    const _ = h.dataTransfer.getData("text/plain");
    if (!_) return;
    const y = JSON.parse(_);
    r._onDropDocument(y);
  }
  u(f, "onDrop");
  const d = [
    {
      name: "description",
      label: "A5E.Description",
      component: zl
    },
    {
      name: "properties",
      label: "A5E.ItemSheetLabelPropertiesTab",
      component: Ev
    },
    {
      name: "resources",
      label: "A5E.TabResources",
      component: Gp
    },
    {
      name: "grants",
      label: "A5E.TabGrants",
      component: Er
    }
  ];
  let p = d[0];
  lt("item", a);
  const m = /* @__PURE__ */ u((h) => f(h), "drop_handler");
  function g(h) {
    o = h, t(0, o);
  }
  return u(g, "applicationshell_elementRoot_binding"), i.$$set = (h) => {
    "document" in h && t(5, l = h.document), "sheet" in h && t(6, r = h.sheet), "elementRoot" in h && t(0, o = h.elementRoot);
  }, [
    o,
    p,
    c,
    f,
    d,
    l,
    r,
    m,
    g
  ];
}
u(vde, "instance$1n");
const _C = class _C extends re {
  constructor(e) {
    super(), oe(this, e, vde, yde, le, { document: 5, sheet: 6, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[5];
  }
  set document(e) {
    this.$$set({ document: e }), Xe();
  }
  get sheet() {
    return this.$$.ctx[6];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
};
u(_C, "ClassSheet");
let Dv = _C;
function kde(i) {
  let e, t, s, n, l, r, o, a, c;
  t = new Hl({}), n = new Wn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[4]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  var f = (
    /*currentTab*/
    i[1].component
  );
  function d(p, m) {
    return {};
  }
  return u(d, "switch_props"), f && (r = et(f, d())), {
    c() {
      e = E("main"), j(t.$$.fragment), s = F(), j(n.$$.fragment), l = F(), r && j(r.$$.fragment), b(e, "class", "svelte-y36y3r");
    },
    m(p, m) {
      T(p, e, m), R(t, e, null), A(e, s), R(n, e, null), A(e, l), r && R(r, e, null), o = !0, a || (c = W(e, "drop", Ve(st(
        /*drop_handler*/
        i[7]
      ))), a = !0);
    },
    p(p, m) {
      const g = {};
      if (m & /*currentTab*/
      2 && (g.currentTab = /*currentTab*/
      p[1]), n.$set(g), m & /*currentTab*/
      2 && f !== (f = /*currentTab*/
      p[1].component)) {
        if (r) {
          ae();
          const h = r;
          O(h.$$.fragment, 1, 0, () => {
            N(h, 1);
          }), ce();
        }
        f ? (r = et(f, d()), j(r.$$.fragment), w(r.$$.fragment, 1), R(r, e, null)) : r = null;
      }
    },
    i(p) {
      o || (w(t.$$.fragment, p), w(n.$$.fragment, p), r && w(r.$$.fragment, p), o = !0);
    },
    o(p) {
      O(t.$$.fragment, p), O(n.$$.fragment, p), r && O(r.$$.fragment, p), o = !1;
    },
    d(p) {
      p && C(e), N(t), N(n), r && N(r), a = !1, c();
    }
  };
}
u(kde, "create_default_slot$F");
function wde(i) {
  let e, t, s;
  function n(r) {
    i[8](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [kde] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        1026 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(wde, "create_fragment$1s");
function $de(i, e, t) {
  let { document: s, sheet: n } = de("#external").application, { document: l = s, sheet: r = n } = e, { elementRoot: o } = e;
  const a = l;
  function c(h) {
    t(1, p = d[h.detail]);
  }
  u(c, "updateCurrentTab");
  function f(h) {
    const _ = h.dataTransfer.getData("text/plain");
    if (!_) return;
    const y = JSON.parse(_);
    r._onDropDocument(y);
  }
  u(f, "onDrop");
  const d = [
    {
      name: "description",
      label: "A5E.Description",
      component: zl
    },
    {
      name: "grants",
      label: "A5E.TabGrants",
      component: Er
    }
  ];
  let p = d[0];
  lt("item", a);
  const m = /* @__PURE__ */ u((h) => f(h), "drop_handler");
  function g(h) {
    o = h, t(0, o);
  }
  return u(g, "applicationshell_elementRoot_binding"), i.$$set = (h) => {
    "document" in h && t(5, l = h.document), "sheet" in h && t(6, r = h.sheet), "elementRoot" in h && t(0, o = h.elementRoot);
  }, [
    o,
    p,
    c,
    f,
    d,
    l,
    r,
    m,
    g
  ];
}
u($de, "instance$1m");
const yC = class yC extends re {
  constructor(e) {
    super(), oe(this, e, $de, wde, le, { document: 5, sheet: 6, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[5];
  }
  set document(e) {
    this.$$set({ document: e }), Xe();
  }
  get sheet() {
    return this.$$.ctx[6];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
};
u(yC, "CultureSheet");
let Iv = yC;
function Ade(i) {
  let e, t, s;
  return {
    c() {
      e = E("div"), e.innerHTML = '<i class="drop-icon fa-sold fa-plus svelte-14j8i7m"></i>', b(e, "class", "drop-area svelte-14j8i7m");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(e, "drop", Ve(st(
        /*drop_handler_1*/
        i[5]
      ))), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(Ade, "create_else_block$j");
function Ede(i) {
  let e, t, s, n, l, r, o, a, c = (
    /*doc*/
    i[1].name + ""
  ), f, d, p, m, g;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("img"), o = F(), a = E("h3"), f = Q(c), d = F(), p = E("button"), b(s, "class", "document-image svelte-14j8i7m"), ze(s.src, n = /*doc*/
      i[1].img) || b(s, "src", n), b(s, "alt", l = /*doc*/
      i[1].name), b(s, "title", r = /*doc*/
      i[1].name), b(a, "class", "svelte-14j8i7m"), b(p, "class", "a5e-button a5e-button--delete delete-button fas fa-trash svelte-14j8i7m"), b(p, "data-tooltip", "A5E.ButtonToolTipDelete"), b(p, "data-tooltip-direction", "UP"), b(t, "class", "document-wrapper svelte-14j8i7m"), b(e, "class", "drop-area svelte-14j8i7m");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(t, s), A(t, o), A(t, a), A(a, f), A(t, d), A(t, p), m || (g = [
        W(
          p,
          "click",
          /*click_handler*/
          i[3]
        ),
        W(e, "drop", Ve(st(
          /*drop_handler*/
          i[4]
        )))
      ], m = !0);
    },
    p(h, _) {
      _ & /*doc*/
      2 && !ze(s.src, n = /*doc*/
      h[1].img) && b(s, "src", n), _ & /*doc*/
      2 && l !== (l = /*doc*/
      h[1].name) && b(s, "alt", l), _ & /*doc*/
      2 && r !== (r = /*doc*/
      h[1].name) && b(s, "title", r), _ & /*doc*/
      2 && c !== (c = /*doc*/
      h[1].name + "") && be(f, c);
    },
    d(h) {
      h && C(e), m = !1, Me(g);
    }
  };
}
u(Ede, "create_if_block$N");
function Sde(i) {
  let e;
  function t(l, r) {
    return (
      /*doc*/
      l[1] ? Ede : Ade
    );
  }
  u(t, "select_block_type");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("section"), n.c(), b(e, "class", "drop-container svelte-14j8i7m");
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, [r]) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    i: se,
    o: se,
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(Sde, "create_fragment$1r");
function Cde(i, e, t) {
  let s, { uuid: n = "" } = e;
  const l = ft(), r = /* @__PURE__ */ u((c) => l("document-deleted", [c, n]), "click_handler"), o = /* @__PURE__ */ u((c) => {
    l("document-dropped", [c, s]);
  }, "drop_handler"), a = /* @__PURE__ */ u((c) => l("document-dropped", [c, s]), "drop_handler_1");
  return i.$$set = (c) => {
    "uuid" in c && t(0, n = c.uuid);
  }, i.$$.update = () => {
    i.$$.dirty & /*uuid*/
    1 && t(1, s = fromUuidSync(n));
  }, [n, s, l, r, o, a];
}
u(Cde, "instance$1l");
const vC = class vC extends re {
  constructor(e) {
    super(), oe(this, e, Cde, Sde, le, { uuid: 0 });
  }
};
u(vC, "DropAreaSingular");
let Zc = vC;
function Tde(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _;
  return l = new Zc({
    props: {
      uuid: (
        /*source*/
        i[2]
      ),
      singleDocument: !0
    }
  }), l.$on(
    "document-dropped",
    /*document_dropped_handler*/
    i[7]
  ), l.$on(
    "document-deleted",
    /*document_deleted_handler*/
    i[8]
  ), f = new Zc({
    props: {
      uuid: (
        /*inspiration*/
        i[1]
      ),
      singleDocument: !0
    }
  }), f.$on(
    "document-dropped",
    /*document_dropped_handler_1*/
    i[9]
  ), f.$on(
    "document-deleted",
    /*document_deleted_handler_1*/
    i[10]
  ), h = new Zc({
    props: {
      uuid: (
        /*fulfillment*/
        i[0]
      ),
      singleDocument: !0
    }
  }), h.$on(
    "document-dropped",
    /*document_dropped_handler_2*/
    i[11]
  ), h.$on(
    "document-deleted",
    /*document_deleted_handler_2*/
    i[12]
  ), {
    c() {
      e = E("article"), t = E("section"), s = E("h3"), s.textContent = `${K("A5E.DestinyFeatureSource")}`, n = F(), j(l.$$.fragment), r = F(), o = E("section"), a = E("h3"), a.textContent = `${K("A5E.DestinyFeatureInspiration")}`, c = F(), j(f.$$.fragment), d = F(), p = E("section"), m = E("h3"), m.textContent = `${K("A5E.DestinyFeatureFulfillment")}`, g = F(), j(h.$$.fragment), b(s, "class", "section-title svelte-bonyjz"), b(t, "class", "section-wrapper drop-area svelte-bonyjz"), b(a, "class", "section-title svelte-bonyjz"), b(o, "class", "section-wrapper drop-area svelte-bonyjz"), b(m, "class", "section-title svelte-bonyjz"), b(p, "class", "section-wrapper drop-area svelte-bonyjz"), b(e, "class", "svelte-bonyjz");
    },
    m(y, v) {
      T(y, e, v), A(e, t), A(t, s), A(t, n), R(l, t, null), A(e, r), A(e, o), A(o, a), A(o, c), R(f, o, null), A(e, d), A(e, p), A(p, m), A(p, g), R(h, p, null), _ = !0;
    },
    p(y, [v]) {
      const k = {};
      v & /*source*/
      4 && (k.uuid = /*source*/
      y[2]), l.$set(k);
      const S = {};
      v & /*inspiration*/
      2 && (S.uuid = /*inspiration*/
      y[1]), f.$set(S);
      const D = {};
      v & /*fulfillment*/
      1 && (D.uuid = /*fulfillment*/
      y[0]), h.$set(D);
    },
    i(y) {
      _ || (w(l.$$.fragment, y), w(f.$$.fragment, y), w(h.$$.fragment, y), _ = !0);
    },
    o(y) {
      O(l.$$.fragment, y), O(f.$$.fragment, y), O(h.$$.fragment, y), _ = !1;
    },
    d(y) {
      y && C(e), N(l), N(f), N(h);
    }
  };
}
u(Tde, "create_fragment$1q");
function Ode(i, e, t) {
  let s, n, l, r;
  const o = de("item");
  pe(i, o, (_) => t(6, r = _));
  async function a(_, y) {
    var k;
    const [v] = _.detail;
    try {
      const { uuid: S } = JSON.parse(v.dataTransfer.getData("text/plain")), D = await Item.fromDropData({ uuid: S });
      if ((D == null ? void 0 : D.type) !== "feature" || ((k = D == null ? void 0 : D.system) == null ? void 0 : k.featureType) !== "destiny") return ui.notifications.warn(K("A5E.validations.warnings.InvalidForeignDocument"));
      r.update({ [`system.${y}`]: S });
    } catch (S) {
      console.error(S);
    }
  }
  u(a, "addFeature");
  function c(_, y) {
    r.update({ [`system.${y}`]: "" });
  }
  u(c, "deleteFeature");
  const f = /* @__PURE__ */ u((_) => a(_, "sourceOfInspiration"), "document_dropped_handler"), d = /* @__PURE__ */ u((_) => c(_, "sourceOfInspiration"), "document_deleted_handler"), p = /* @__PURE__ */ u((_) => a(_, "inspirationFeature"), "document_dropped_handler_1"), m = /* @__PURE__ */ u((_) => c(_, "inspirationFeature"), "document_deleted_handler_1"), g = /* @__PURE__ */ u((_) => a(_, "fulfillmentFeature"), "document_dropped_handler_2"), h = /* @__PURE__ */ u((_) => c(_, "fulfillmentFeature"), "document_deleted_handler_2");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    64 && t(2, s = r.system.sourceOfInspiration || null), i.$$.dirty & /*$item*/
    64 && t(1, n = r.system.inspirationFeature || null), i.$$.dirty & /*$item*/
    64 && t(0, l = r.system.fulfillmentFeature || null);
  }, [
    l,
    n,
    s,
    o,
    a,
    c,
    r,
    f,
    d,
    p,
    m,
    g,
    h
  ];
}
u(Ode, "instance$1k");
const kC = class kC extends re {
  constructor(e) {
    super(), oe(this, e, Ode, Tde, le, {});
  }
};
u(kC, "DestinyFeaturesTab");
let Pv = kC;
function Dde(i) {
  let e, t, s, n, l, r, o;
  t = new Hl({}), n = new Wn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[3]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  var a = (
    /*currentTab*/
    i[1].component
  );
  function c(f, d) {
    return {};
  }
  return u(c, "switch_props"), a && (r = et(a, c())), {
    c() {
      e = E("main"), j(t.$$.fragment), s = F(), j(n.$$.fragment), l = F(), r && j(r.$$.fragment), b(e, "class", "svelte-y36y3r");
    },
    m(f, d) {
      T(f, e, d), R(t, e, null), A(e, s), R(n, e, null), A(e, l), r && R(r, e, null), o = !0;
    },
    p(f, d) {
      const p = {};
      if (d & /*currentTab*/
      2 && (p.currentTab = /*currentTab*/
      f[1]), n.$set(p), d & /*currentTab*/
      2 && a !== (a = /*currentTab*/
      f[1].component)) {
        if (r) {
          ae();
          const m = r;
          O(m.$$.fragment, 1, 0, () => {
            N(m, 1);
          }), ce();
        }
        a ? (r = et(a, c()), j(r.$$.fragment), w(r.$$.fragment, 1), R(r, e, null)) : r = null;
      }
    },
    i(f) {
      o || (w(t.$$.fragment, f), w(n.$$.fragment, f), r && w(r.$$.fragment, f), o = !0);
    },
    o(f) {
      O(t.$$.fragment, f), O(n.$$.fragment, f), r && O(r.$$.fragment, f), o = !1;
    },
    d(f) {
      f && C(e), N(t), N(n), r && N(r);
    }
  };
}
u(Dde, "create_default_slot$E");
function Ide(i) {
  let e, t, s;
  function n(r) {
    i[5](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Dde] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        130 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(Ide, "create_fragment$1p");
function Pde(i, e, t) {
  let { document: s } = de("#external").application, { document: n = s } = e, { elementRoot: l } = e;
  const r = n;
  function o(d) {
    t(1, c = a[d.detail]);
  }
  u(o, "updateCurrentTab");
  const a = [
    {
      name: "description",
      label: "A5E.Description",
      component: zl
    },
    {
      name: "features",
      label: "A5E.TabFeatures",
      component: Pv
    }
  ];
  let c = a[0];
  lt("item", r);
  function f(d) {
    l = d, t(0, l);
  }
  return u(f, "applicationshell_elementRoot_binding"), i.$$set = (d) => {
    "document" in d && t(4, n = d.document), "elementRoot" in d && t(0, l = d.elementRoot);
  }, [
    l,
    c,
    o,
    a,
    n,
    f
  ];
}
u(Pde, "instance$1j");
const wC = class wC extends re {
  constructor(e) {
    super(), oe(this, e, Pde, Ide, le, { document: 4, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[4];
  }
  set document(e) {
    this.$$set({ document: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
};
u(wC, "DestinySheet");
let Mv = wC;
function Mde(i) {
  let e, t, s, n, l, r, o, a, c;
  t = new Hl({}), n = new Wn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[4]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  var f = (
    /*currentTab*/
    i[1].component
  );
  function d(p, m) {
    return {};
  }
  return u(d, "switch_props"), f && (r = et(f, d())), {
    c() {
      e = E("main"), j(t.$$.fragment), s = F(), j(n.$$.fragment), l = F(), r && j(r.$$.fragment), b(e, "class", "svelte-1rqyzyo");
    },
    m(p, m) {
      T(p, e, m), R(t, e, null), A(e, s), R(n, e, null), A(e, l), r && R(r, e, null), o = !0, a || (c = W(e, "drop", Ve(st(
        /*drop_handler*/
        i[7]
      ))), a = !0);
    },
    p(p, m) {
      const g = {};
      if (m & /*currentTab*/
      2 && (g.currentTab = /*currentTab*/
      p[1]), n.$set(g), m & /*currentTab*/
      2 && f !== (f = /*currentTab*/
      p[1].component)) {
        if (r) {
          ae();
          const h = r;
          O(h.$$.fragment, 1, 0, () => {
            N(h, 1);
          }), ce();
        }
        f ? (r = et(f, d()), j(r.$$.fragment), w(r.$$.fragment, 1), R(r, e, null)) : r = null;
      }
    },
    i(p) {
      o || (w(t.$$.fragment, p), w(n.$$.fragment, p), r && w(r.$$.fragment, p), o = !0);
    },
    o(p) {
      O(t.$$.fragment, p), O(n.$$.fragment, p), r && O(r.$$.fragment, p), o = !1;
    },
    d(p) {
      p && C(e), N(t), N(n), r && N(r), a = !1, c();
    }
  };
}
u(Mde, "create_default_slot$D");
function Fde(i) {
  let e, t, s;
  function n(r) {
    i[8](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Mde] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        1026 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(Fde, "create_fragment$1o");
function Rde(i, e, t) {
  let { document: s, sheet: n } = de("#external").application, { document: l = s, sheet: r = n } = e, { elementRoot: o } = e;
  const a = l;
  function c(h) {
    t(1, p = d[h.detail]);
  }
  u(c, "updateCurrentTab");
  function f(h) {
    const _ = h.dataTransfer.getData("text/plain");
    if (!_) return;
    const y = JSON.parse(_);
    r._onDropDocument(y);
  }
  u(f, "onDrop");
  const d = [
    {
      name: "description",
      label: "A5E.Description",
      component: zl
    },
    {
      name: "grants",
      label: "A5E.TabGrants",
      component: Er
    }
  ];
  let p = d[0];
  lt("item", a);
  const m = /* @__PURE__ */ u((h) => f(h), "drop_handler");
  function g(h) {
    o = h, t(0, o);
  }
  return u(g, "applicationshell_elementRoot_binding"), i.$$set = (h) => {
    "document" in h && t(5, l = h.document), "sheet" in h && t(6, r = h.sheet), "elementRoot" in h && t(0, o = h.elementRoot);
  }, [
    o,
    p,
    c,
    f,
    d,
    l,
    r,
    m,
    g
  ];
}
u(Rde, "instance$1i");
const $C = class $C extends re {
  constructor(e) {
    super(), oe(this, e, Rde, Fde, le, { document: 5, sheet: 6, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[5];
  }
  set document(e) {
    this.$$set({ document: e }), Xe();
  }
  get sheet() {
    return this.$$.ctx[6];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
};
u($C, "HeritageSheet");
let Fv = $C;
function aN(i, e, t) {
  const s = i.slice();
  return s[15] = e[t][0], s[16] = e[t][1], s;
}
u(aN, "get_each_context$w");
function cN(i, e) {
  var q;
  let t, s, n, l, r = (
    /*action*/
    ((q = e[16]) == null ? void 0 : q.name) + ""
  ), o, a, c, f, d, p, m, g, h, _, y, v, k, S;
  function D() {
    return (
      /*click_handler*/
      e[9](
        /*id*/
        e[15]
      )
    );
  }
  u(D, "click_handler");
  function I() {
    return (
      /*click_handler_1*/
      e[10](
        /*id*/
        e[15]
      )
    );
  }
  u(I, "click_handler_1");
  function M() {
    return (
      /*click_handler_2*/
      e[11](
        /*id*/
        e[15]
      )
    );
  }
  u(M, "click_handler_2");
  function L() {
    return (
      /*click_handler_3*/
      e[12](
        /*id*/
        e[15]
      )
    );
  }
  u(L, "click_handler_3");
  function B(...U) {
    return (
      /*dragstart_handler*/
      e[13](
        /*id*/
        e[15],
        ...U
      )
    );
  }
  u(B, "dragstart_handler");
  function z() {
    return (
      /*auxclick_handler*/
      e[14](
        /*id*/
        e[15]
      )
    );
  }
  return u(z, "auxclick_handler"), {
    key: i,
    first: null,
    c() {
      var U;
      t = E("li"), s = E("img"), l = F(), o = Q(r), a = F(), c = E("div"), f = E("button"), d = F(), p = E("button"), m = F(), g = E("button"), h = F(), _ = E("button"), y = F(), b(s, "class", "a5e-item__image a5e-item__image--action"), ze(s.src, n = /*action*/
      ((U = e[16]) == null ? void 0 : U.img) ?? /*$item*/
      e[0].img ?? "icons/svg/item-bag.svg") || b(s, "src", n), b(s, "alt", ""), b(f, "class", "action-button fas fa-shield svelte-1k97xs9"), b(f, "data-tooltip", "Set Default"), b(f, "data-tooltip-direction", "UP"), Z(
        f,
        "default",
        /*id*/
        e[15] === /*defaultAction*/
        e[1]
      ), b(p, "class", "action-button fas fa-cog svelte-1k97xs9"), b(p, "data-tooltip", "A5E.ButtonToolTipConfigure"), b(p, "data-tooltip-direction", "UP"), b(g, "class", "action-button fa-solid fa-clone svelte-1k97xs9"), b(g, "data-tooltip", "A5E.ButtonToolTipDuplicate"), b(g, "data-tooltip-direction", "UP"), b(_, "class", "action-button delete-button fas fa-trash svelte-1k97xs9"), b(_, "data-tooltip", "A5E.ButtonToolTipDelete"), b(_, "data-tooltip-direction", "UP"), b(c, "class", "action-buttons svelte-1k97xs9"), b(t, "class", "a5e-item a5e-item--action"), b(t, "data-action-id", v = /*id*/
      e[15]), b(t, "draggable", "true"), this.first = t;
    },
    m(U, H) {
      T(U, t, H), A(t, s), A(t, l), A(t, o), A(t, a), A(t, c), A(c, f), A(c, d), A(c, p), A(c, m), A(c, g), A(c, h), A(c, _), A(t, y), k || (S = [
        W(f, "click", D),
        W(p, "click", I),
        W(g, "click", M),
        W(_, "click", L),
        W(t, "dragstart", B),
        W(t, "auxclick", z)
      ], k = !0);
    },
    p(U, H) {
      var V, Y;
      e = U, H & /*$item*/
      1 && !ze(s.src, n = /*action*/
      ((V = e[16]) == null ? void 0 : V.img) ?? /*$item*/
      e[0].img ?? "icons/svg/item-bag.svg") && b(s, "src", n), H & /*$item*/
      1 && r !== (r = /*action*/
      ((Y = e[16]) == null ? void 0 : Y.name) + "") && be(o, r), H & /*Object, $item, defaultAction*/
      3 && Z(
        f,
        "default",
        /*id*/
        e[15] === /*defaultAction*/
        e[1]
      ), H & /*$item*/
      1 && v !== (v = /*id*/
      e[15]) && b(t, "data-action-id", v);
    },
    d(U) {
      U && C(t), k = !1, Me(S);
    }
  };
}
u(cN, "create_each_block$w");
function Nde(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n = ue(Object.entries(
    /*$item*/
    i[0].system.actions ?? {}
  ));
  const l = /* @__PURE__ */ u((r) => (
    /*id*/
    r[15]
  ), "get_key");
  for (let r = 0; r < n.length; r += 1) {
    let o = aN(i, n, r), a = l(o);
    s.set(a, t[r] = cN(a, o));
  }
  return {
    c() {
      e = E("ul");
      for (let r = 0; r < t.length; r += 1)
        t[r].c();
      b(e, "class", "a5e-item-list");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < t.length; a += 1)
        t[a] && t[a].m(e, null);
    },
    p(r, o) {
      o & /*Object, $item, _onDragStart, configureAction, deleteAction, duplicateAction, defaultAction, setDefault*/
      499 && (n = ue(Object.entries(
        /*$item*/
        r[0].system.actions ?? {}
      )), t = Lt(t, o, l, 1, r, n, s, e, an, cN, null, aN));
    },
    d(r) {
      r && C(e);
      for (let o = 0; o < t.length; o += 1)
        t[o].d();
    }
  };
}
u(Nde, "create_default_slot$C");
function jde(i) {
  let e, t, s, n;
  return t = new De({
    props: {
      heading: "A5E.TabActions",
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*addAction*/
            i[3]
          ),
          label: "A5E.ButtonAddAction"
        }
      ],
      $$slots: { default: [Nde] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("div"), s = E("div"), j(t.$$.fragment), G(s, "display", "contents"), G(s, "--a5e-section-gap", "0.125rem"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(l, r) {
      T(l, e, r), A(e, s), R(t, s, null), n = !0;
    },
    p(l, [r]) {
      const o = {};
      r & /*$$scope, $item, defaultAction*/
      524291 && (o.$$scope = { dirty: r, ctx: l }), t.$set(o);
    },
    i(l) {
      n || (w(t.$$.fragment, l), n = !0);
    },
    o(l) {
      O(t.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(e), N(t);
    }
  };
}
u(jde, "create_fragment$1n");
function Lde(i, e, t) {
  let s, n;
  const l = de("item");
  pe(i, l, (v) => t(0, n = v));
  function r() {
    n.actions.add();
  }
  u(r, "addAction");
  function o(v) {
    n.actions.duplicate(v);
  }
  u(o, "duplicateAction");
  function a(v) {
    n.actions.configure(v);
  }
  u(a, "configureAction");
  function c(v) {
    n.actions.remove(v);
  }
  u(c, "deleteAction");
  function f(v) {
    n.actions.setDefaultAction(v);
  }
  u(f, "setDefault");
  async function d(v, k) {
    var D;
    const S = {
      actionId: k,
      itemUuid: n.uuid,
      type: "Action"
    };
    return (D = v.dataTransfer) == null ? void 0 : D.setData("text/plain", JSON.stringify(S));
  }
  u(d, "_onDragStart");
  const p = /* @__PURE__ */ u((v) => f(v), "click_handler"), m = /* @__PURE__ */ u((v) => a(v), "click_handler_1"), g = /* @__PURE__ */ u((v) => o(v), "click_handler_2"), h = /* @__PURE__ */ u((v) => c(v), "click_handler_3"), _ = /* @__PURE__ */ u((v, k) => d(k, v), "dragstart_handler"), y = /* @__PURE__ */ u((v) => a(v), "auxclick_handler");
  return i.$$.update = () => {
    var v;
    i.$$.dirty & /*$item*/
    1 && t(1, s = (v = n.actions.default) == null ? void 0 : v.id);
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
u(Lde, "instance$1h");
const AC = class AC extends re {
  constructor(e) {
    super(), oe(this, e, Lde, jde, le, {});
  }
};
u(AC, "ItemActionsTab");
let Rv = AC;
function Bde(i) {
  let e, t, s, n, l, r = (
    /*selectedAmmunitionProperties*/
    (i[2] || K("A5E.None")) + ""
  ), o;
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.AmmunitionProperties")}:`, n = F(), l = E("dd"), o = Q(r), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o);
    },
    p(a, c) {
      c & /*selectedAmmunitionProperties*/
      4 && r !== (r = /*selectedAmmunitionProperties*/
      (a[2] || K("A5E.None")) + "") && be(o, r);
    },
    i: se,
    o: se,
    d(a) {
      a && C(e);
    }
  };
}
u(Bde, "create_else_block$i");
function qde(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "A5E.AmmunitionProperties",
      options: Object.entries(
        /*ammunitionProperties*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[0].system.ammunitionProperties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[5]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.ammunitionProperties), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(qde, "create_if_block$M");
function Gde(i) {
  let e, t, s, n;
  const l = [qde, Bde], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[1] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(Gde, "create_default_slot$B");
function zde(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Ammunition Configuration",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[6]
          )
        }
      ],
      $$slots: { default: [Gde] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-heading-gap", "0.5rem"), G(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      2 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[6]
          )
        }
      ]), l & /*$$scope, $item, editMode, selectedAmmunitionProperties*/
      263 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(zde, "create_fragment$1m");
function Hde(i, e, t) {
  let s, n;
  function l(d) {
    const p = d.system.ammunitionProperties.map((m) => o[m] ?? m);
    return p.sort((m, g) => m.localeCompare(g)), p.join(", ");
  }
  u(l, "prepareAmmunitionProperties");
  const r = de("item");
  pe(i, r, (d) => t(0, n = d));
  const o = CONFIG.A5E.ammunitionProperties;
  let a = !1;
  const c = /* @__PURE__ */ u((d) => te(n, "system.ammunitionProperties", d.detail), "updateSelection_handler"), f = /* @__PURE__ */ u(() => t(1, a = !a), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(2, s = l(n));
  }, [
    n,
    a,
    s,
    r,
    o,
    c,
    f
  ];
}
u(Hde, "instance$1g");
const EC = class EC extends re {
  constructor(e) {
    super(), oe(this, e, Hde, zde, le, {});
  }
};
u(EC, "AmmunitionConfiguration");
let Nv = EC;
function uN(i, e, t) {
  const s = i.slice();
  return s[14] = e[t][0], s[15] = e[t][1], s;
}
u(uN, "get_each_context$v");
function Ude(i) {
  var J, fe, ke, ee, ne;
  let e, t, s, n, l, r = (
    /*$item*/
    (((J = i[1].system.ac) == null ? void 0 : J.formula) ?? "") + ""
  ), o, a, c, f, d, p, m = (
    /*$item*/
    (((fe = i[1].system.ac) == null ? void 0 : fe.maxDex) ?? 0) + ""
  ), g, h, _, y, v, k, S = (
    /*$item*/
    (((ke = i[1].system.ac) == null ? void 0 : ke.minStr) ?? 0) + ""
  ), D, I, M, L, B, z, q = (
    /*armorModes*/
    i[4][
      /*$item*/
      (ee = i[1].system.ac) == null ? void 0 : ee.mode
    ] + ""
  ), U, H, V = !["armor", "shield"].includes(
    /*$item*/
    (ne = i[1].system) == null ? void 0 : ne.objectType
  ), Y = V && fN(i);
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.armorClass.formula")}:`, n = F(), l = E("dd"), o = Q(r), a = F(), c = E("div"), f = E("dt"), f.textContent = `${K("A5E.armorClass.maxDex")}:`, d = F(), p = E("dd"), g = Q(m), h = F(), _ = E("div"), y = E("dt"), y.textContent = `${K("A5E.armorClass.minStr")}:`, v = F(), k = E("dd"), D = Q(S), I = F(), M = E("div"), L = E("dt"), L.textContent = `${K("A5E.armorClass.mode")}:`, B = F(), z = E("dd"), U = Q(q), H = F(), Y && Y.c(), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(f, "class", "u-text-bold"), b(p, "class", "u-m-0 u-p-0"), b(c, "class", "u-flex u-gap-md"), b(y, "class", "u-text-bold"), b(k, "class", "u-m-0 u-p-0"), b(_, "class", "u-flex u-gap-md"), b(L, "class", "u-text-bold"), b(z, "class", "u-m-0 u-p-0"), b(M, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(Ee, Pe) {
      T(Ee, e, Pe), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o), A(t, a), A(e, c), A(c, f), A(c, d), A(c, p), A(p, g), A(c, h), A(e, _), A(_, y), A(_, v), A(_, k), A(k, D), A(_, I), A(e, M), A(M, L), A(M, B), A(M, z), A(z, U), A(M, H), Y && Y.m(e, null);
    },
    p(Ee, Pe) {
      var ye, me, Ce, Je, Ne;
      Pe & /*$item*/
      2 && r !== (r = /*$item*/
      (((ye = Ee[1].system.ac) == null ? void 0 : ye.formula) ?? "") + "") && be(o, r), Pe & /*$item*/
      2 && m !== (m = /*$item*/
      (((me = Ee[1].system.ac) == null ? void 0 : me.maxDex) ?? 0) + "") && be(g, m), Pe & /*$item*/
      2 && S !== (S = /*$item*/
      (((Ce = Ee[1].system.ac) == null ? void 0 : Ce.minStr) ?? 0) + "") && be(D, S), Pe & /*$item*/
      2 && q !== (q = /*armorModes*/
      Ee[4][
        /*$item*/
        (Je = Ee[1].system.ac) == null ? void 0 : Je.mode
      ] + "") && be(U, q), Pe & /*$item*/
      2 && (V = !["armor", "shield"].includes(
        /*$item*/
        (Ne = Ee[1].system) == null ? void 0 : Ne.objectType
      )), V ? Y ? Y.p(Ee, Pe) : (Y = fN(Ee), Y.c(), Y.m(e, null)) : Y && (Y.d(1), Y = null);
    },
    i: se,
    o: se,
    d(Ee) {
      Ee && C(e), Y && Y.d();
    }
  };
}
u(Ude, "create_else_block$h");
function Vde(i) {
  var p, m;
  let e, t, s, n, l, r, o = !["armor", "shield"].includes(
    /*$item*/
    (p = i[1].system) == null ? void 0 : p.objectType
  ), a, c;
  e = new ie({
    props: {
      heading: "A5E.armorClass.formula",
      $$slots: { default: [Wde] },
      $$scope: { ctx: i }
    }
  }), s = new De({
    props: {
      $$slots: { default: [Jde] },
      $$scope: { ctx: i }
    }
  });
  let f = (
    /*$item*/
    ((m = i[1].system) == null ? void 0 : m.objectType) === "armor" && pN(i)
  ), d = o && mN(i);
  return {
    c() {
      j(e.$$.fragment), t = F(), n = E("div"), j(s.$$.fragment), l = F(), f && f.c(), r = F(), d && d.c(), a = $e(), G(n, "display", "contents"), G(n, "--a5e-section-body-direction", "row");
    },
    m(g, h) {
      R(e, g, h), T(g, t, h), T(g, n, h), R(s, n, null), T(g, l, h), f && f.m(g, h), T(g, r, h), d && d.m(g, h), T(g, a, h), c = !0;
    },
    p(g, h) {
      var v, k;
      const _ = {};
      h & /*$$scope, $item*/
      262146 && (_.$$scope = { dirty: h, ctx: g }), e.$set(_);
      const y = {};
      h & /*$$scope, $item*/
      262146 && (y.$$scope = { dirty: h, ctx: g }), s.$set(y), /*$item*/
      ((v = g[1].system) == null ? void 0 : v.objectType) === "armor" ? f ? (f.p(g, h), h & /*$item*/
      2 && w(f, 1)) : (f = pN(g), f.c(), w(f, 1), f.m(r.parentNode, r)) : f && (ae(), O(f, 1, 1, () => {
        f = null;
      }), ce()), h & /*$item*/
      2 && (o = !["armor", "shield"].includes(
        /*$item*/
        (k = g[1].system) == null ? void 0 : k.objectType
      )), o ? d ? (d.p(g, h), h & /*$item*/
      2 && w(d, 1)) : (d = mN(g), d.c(), w(d, 1), d.m(a.parentNode, a)) : d && (ae(), O(d, 1, 1, () => {
        d = null;
      }), ce());
    },
    i(g) {
      c || (w(e.$$.fragment, g), w(s.$$.fragment, g), w(f), w(d), c = !0);
    },
    o(g) {
      O(e.$$.fragment, g), O(s.$$.fragment, g), O(f), O(d), c = !1;
    },
    d(g) {
      g && (C(t), C(l), C(r), C(a)), N(e, g), g && s && C(n), N(s, g), f && f.d(g), d && d.d(g);
    }
  };
}
u(Vde, "create_if_block$L");
function fN(i) {
  var g, h;
  let e, t, s, n, l = (
    /*$item*/
    (((g = i[1].system.ac) == null ? void 0 : g.requiresNoShield) ?? !1) + ""
  ), r, o, a, c, f, d, p = (
    /*$item*/
    (((h = i[1].system.ac) == null ? void 0 : h.requiresUnarmored) ?? !1) + ""
  ), m;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = `${K("A5E.armorClass.requiresNoShield")}:`, s = F(), n = E("dd"), r = Q(l), o = F(), a = E("div"), c = E("dt"), c.textContent = `${K("A5E.armorClass.requiresUnarmored")}:`, f = F(), d = E("dd"), m = Q(p), b(t, "class", "u-text-bold"), b(n, "class", "u-m-0 u-p-0"), b(e, "class", "u-flex u-gap-md"), b(c, "class", "u-text-bold"), b(d, "class", "u-m-0 u-p-0"), b(a, "class", "u-flex u-gap-md");
    },
    m(_, y) {
      T(_, e, y), A(e, t), A(e, s), A(e, n), A(n, r), A(e, o), T(_, a, y), A(a, c), A(a, f), A(a, d), A(d, m);
    },
    p(_, y) {
      var v, k;
      y & /*$item*/
      2 && l !== (l = /*$item*/
      (((v = _[1].system.ac) == null ? void 0 : v.requiresNoShield) ?? !1) + "") && be(r, l), y & /*$item*/
      2 && p !== (p = /*$item*/
      (((k = _[1].system.ac) == null ? void 0 : k.requiresUnarmored) ?? !1) + "") && be(m, p);
    },
    d(_) {
      _ && (C(e), C(a));
    }
  };
}
u(fN, "create_if_block_3$g");
function Wde(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "text"), b(e, "name", "system.ac.baseFormula"), b(
        e,
        "id",
        /*appId*/
        i[3] + "-ac-base-formula"
      ), e.value = t = /*$item*/
      ((l = i[1].system.ac) == null ? void 0 : l.baseFormula) ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*$item, modes*/
      34 && t !== (t = /*$item*/
      ((o = l[1].system.ac) == null ? void 0 : o.baseFormula) ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Wde, "create_default_slot_8$3");
function Kde(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "number"), b(e, "data-dtype", "Number"), b(e, "name", "system.ac.maxDex"), b(
        e,
        "id",
        /*appId*/
        i[3] + "-ac-max-dex"
      ), e.value = t = /*$item*/
      ((l = i[1].system.ac) == null ? void 0 : l.maxDex) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*$item, modes*/
      34 && t !== (t = /*$item*/
      ((o = l[1].system.ac) == null ? void 0 : o.maxDex) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Kde, "create_default_slot_7$6");
function Yde(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "number"), b(e, "data-dtype", "Number"), b(e, "name", "system.ac.minStr"), b(
        e,
        "id",
        /*appId*/
        i[3] + "-ac-min-str"
      ), e.value = t = /*$item*/
      ((l = i[1].system.ac) == null ? void 0 : l.minStr) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_2*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*$item, modes*/
      34 && t !== (t = /*$item*/
      ((o = l[1].system.ac) == null ? void 0 : o.minStr) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Yde, "create_default_slot_6$7");
function dN(i) {
  let e, t = (
    /*label*/
    i[14] + ""
  ), s, n;
  return {
    c() {
      e = E("option"), s = Q(t), n = F(), e.__value = /*mode*/
      i[15], He(e, e.__value);
    },
    m(l, r) {
      T(l, e, r), A(e, s), A(e, n);
    },
    p: se,
    d(l) {
      l && C(e);
    }
  };
}
u(dN, "create_each_block$v");
function Xde(i) {
  let e, t, s, n, l = ue(
    /*modes*/
    i[5]
  ), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = dN(uN(i, l, o));
  return {
    c() {
      e = E("select");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      b(e, "name", "system.ac.mode"), b(
        e,
        "id",
        /*appId*/
        i[3] + "-ac-mode"
      );
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(e, null);
      Ys(
        e,
        /*$item*/
        i[1].system.ac.mode
      ), s || (n = W(
        e,
        "change",
        /*change_handler_3*/
        i[9]
      ), s = !0);
    },
    p(o, a) {
      if (a & /*modes*/
      32) {
        l = ue(
          /*modes*/
          o[5]
        );
        let c;
        for (c = 0; c < l.length; c += 1) {
          const f = uN(o, l, c);
          r[c] ? r[c].p(f, a) : (r[c] = dN(f), r[c].c(), r[c].m(e, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
      a & /*$item, modes*/
      34 && t !== (t = /*$item*/
      o[1].system.ac.mode) && Ys(
        e,
        /*$item*/
        o[1].system.ac.mode
      );
    },
    d(o) {
      o && C(e), Le(r, o), s = !1, n();
    }
  };
}
u(Xde, "create_default_slot_5$9");
function Jde(i) {
  let e, t, s, n, l, r;
  return e = new ie({
    props: {
      heading: "A5E.armorClass.maxDex",
      $$slots: { default: [Kde] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      heading: "A5E.armorClass.minStr",
      $$slots: { default: [Yde] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      heading: "A5E.armorClass.mode",
      $$slots: { default: [Xde] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), R(s, o, a), T(o, n, a), R(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, $item*/
      262146 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const f = {};
      a & /*$$scope, $item*/
      262146 && (f.$$scope = { dirty: a, ctx: o }), s.$set(f);
      const d = {};
      a & /*$$scope, $item*/
      262146 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(s.$$.fragment, o), O(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (C(t), C(n)), N(e, o), N(s, o), N(l, o);
    }
  };
}
u(Jde, "create_default_slot_4$a");
function pN(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [Zde] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $item*/
      262146 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(pN, "create_if_block_2$q");
function Zde(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.armorClass.grantsDisadvantage",
      checked: (
        /*$item*/
        ((s = i[1].system.ac) == null ? void 0 : s.grantsDisadvantage) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[10]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*$item*/
      2 && (r.checked = /*$item*/
      ((o = n[1].system.ac) == null ? void 0 : o.grantsDisadvantage) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(Zde, "create_default_slot_3$d");
function mN(i) {
  let e, t, s, n;
  return e = new ie({
    props: {
      $$slots: { default: [Qde] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      $$slots: { default: [xde] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, $item*/
      262146 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, $item*/
      262146 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(mN, "create_if_block_1$y");
function Qde(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.armorClass.requiresNoShield",
      checked: (
        /*$item*/
        ((s = i[1].system.ac) == null ? void 0 : s.requiresNoShield) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[11]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*$item*/
      2 && (r.checked = /*$item*/
      ((o = n[1].system.ac) == null ? void 0 : o.requiresNoShield) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(Qde, "create_default_slot_2$f");
function xde(i) {
  var s;
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.armorClass.requiresUnarmored",
      checked: (
        /*$item*/
        ((s = i[1].system.ac) == null ? void 0 : s.requiresUnarmored) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[12]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*$item*/
      2 && (r.checked = /*$item*/
      ((o = n[1].system.ac) == null ? void 0 : o.requiresUnarmored) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(xde, "create_default_slot_1$g");
function epe(i) {
  let e, t, s, n;
  const l = [Vde, Ude], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[0] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(epe, "create_default_slot$A");
function tpe(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.TabArmorClassProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[13]
          )
        }
      ],
      $$slots: { default: [epe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-heading-gap", "0.5rem"), G(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      1 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[13]
          )
        }
      ]), l & /*$$scope, $item, editMode*/
      262147 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(tpe, "create_fragment$1l");
function spe(i, e, t) {
  let s;
  const n = de("item");
  pe(i, n, (y) => t(1, s = y));
  const l = de("appId"), { armorModes: r } = CONFIG.A5E, o = [
    ["Add", CONFIG.A5E.ARMOR_MODES.ADD],
    ["Override", CONFIG.A5E.ARMOR_MODES.OVERRIDE]
  ];
  let a = !1;
  return [
    a,
    s,
    n,
    l,
    r,
    o,
    /* @__PURE__ */ u(({ target: y }) => te(s, y.name, y.value), "change_handler"),
    /* @__PURE__ */ u(({ target: y }) => te(s, y.name, Number(y.value)), "change_handler_1"),
    /* @__PURE__ */ u(({ target: y }) => te(s, y.name, Number(y.value)), "change_handler_2"),
    /* @__PURE__ */ u(({ target: y }) => te(s, y.name, Number(y.value)), "change_handler_3"),
    /* @__PURE__ */ u(({ detail: y }) => te(s, "system.ac.grantsDisadvantage", y), "updateSelection_handler"),
    /* @__PURE__ */ u(({ detail: y }) => te(s, "system.ac.requiresNoShield", y), "updateSelection_handler_1"),
    /* @__PURE__ */ u(({ detail: y }) => te(s, "system.ac.requiresUnarmored", y), "updateSelection_handler_2"),
    /* @__PURE__ */ u(() => t(0, a = !a), "func")
  ];
}
u(spe, "instance$1f");
const SC = class SC extends re {
  constructor(e) {
    super(), oe(this, e, spe, tpe, le, {});
  }
};
u(SC, "ArmorClassConfiguration");
let zp = SC;
function npe(i) {
  let e, t, s, n, l, r, o, a, c, f, d = (
    /*selectedArmorProperties*/
    (i[4] || K("A5E.None")) + ""
  ), p, m, g, h, _, y, v;
  function k(L, B) {
    return (
      /*$item*/
      L[0].system.armorCategory ? rpe : lpe
    );
  }
  u(k, "select_block_type_1");
  let S = k(i), D = S(i), I = (
    /*selectedArmorMods*/
    i[5] && hN(i)
  ), M = (
    /*repairabilityDC*/
    i[2] != "0" && gN(i)
  );
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.ArmorCategory")}:`, n = F(), l = E("dd"), D.c(), r = F(), o = E("div"), a = E("dt"), a.textContent = `${K("A5E.ArmorProperties")}:`, c = F(), f = E("dd"), p = Q(d), m = F(), I && I.c(), g = E("div"), h = E("dt"), h.textContent = `${K("A5E.Repairability")}:`, _ = F(), y = E("dd"), M && M.c(), v = Q(
        /*selectedRepairabilityProperties*/
        i[3]
      ), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(a, "class", "u-text-bold"), b(f, "class", "u-m-0 u-p-0"), b(o, "class", "u-flex u-gap-md"), b(h, "class", "u-text-bold"), b(y, "class", "u-m-0 u-p-0"), b(g, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(L, B) {
      T(L, e, B), A(e, t), A(t, s), A(t, n), A(t, l), D.m(l, null), A(t, r), A(e, o), A(o, a), A(o, c), A(o, f), A(f, p), A(o, m), I && I.m(e, null), A(e, g), A(g, h), A(g, _), A(g, y), M && M.m(y, null), A(y, v);
    },
    p(L, B) {
      S === (S = k(L)) && D ? D.p(L, B) : (D.d(1), D = S(L), D && (D.c(), D.m(l, null))), B & /*selectedArmorProperties*/
      16 && d !== (d = /*selectedArmorProperties*/
      (L[4] || K("A5E.None")) + "") && be(p, d), /*selectedArmorMods*/
      L[5] ? I ? I.p(L, B) : (I = hN(L), I.c(), I.m(e, g)) : I && (I.d(1), I = null), /*repairabilityDC*/
      L[2] != "0" ? M ? M.p(L, B) : (M = gN(L), M.c(), M.m(y, v)) : M && (M.d(1), M = null), B & /*selectedRepairabilityProperties*/
      8 && be(
        v,
        /*selectedRepairabilityProperties*/
        L[3]
      );
    },
    i: se,
    o: se,
    d(L) {
      L && C(e), D.d(), I && I.d(), M && M.d();
    }
  };
}
u(npe, "create_else_block$g");
function ipe(i) {
  let e, t, s, n, l, r, o, a, c;
  return e = new Ke({
    props: {
      heading: "A5E.ArmorCategory",
      options: Object.entries(
        /*armorTypes*/
        i[8]
      ),
      selected: (
        /*$item*/
        i[0].system.armorCategory
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), s = new tt({
    props: {
      heading: "A5E.ArmorProperties",
      options: Object.entries(
        /*armorProperties*/
        i[9]
      ),
      selected: (
        /*$item*/
        i[0].system.armorProperties
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), l = new tt({
    props: {
      heading: "A5E.ArmorMods",
      options: Object.entries(
        /*armorMods*/
        i[10]
      ),
      selected: (
        /*$item*/
        i[0].system.armorMods
      )
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[14]
  ), o = new De({
    props: {
      $$slots: { default: [ape] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), a = E("div"), j(o.$$.fragment), G(a, "display", "contents"), G(a, "--a5e-section-body-direction", "row");
    },
    m(f, d) {
      R(e, f, d), T(f, t, d), R(s, f, d), T(f, n, d), R(l, f, d), T(f, r, d), T(f, a, d), R(o, a, null), c = !0;
    },
    p(f, d) {
      const p = {};
      d & /*$item*/
      1 && (p.selected = /*$item*/
      f[0].system.armorCategory), e.$set(p);
      const m = {};
      d & /*$item*/
      1 && (m.selected = /*$item*/
      f[0].system.armorProperties), s.$set(m);
      const g = {};
      d & /*$item*/
      1 && (g.selected = /*$item*/
      f[0].system.armorMods), l.$set(g);
      const h = {};
      d & /*$$scope, $item*/
      2097153 && (h.$$scope = { dirty: d, ctx: f }), o.$set(h);
    },
    i(f) {
      c || (w(e.$$.fragment, f), w(s.$$.fragment, f), w(l.$$.fragment, f), w(o.$$.fragment, f), c = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(s.$$.fragment, f), O(l.$$.fragment, f), O(o.$$.fragment, f), c = !1;
    },
    d(f) {
      f && (C(t), C(n), C(r)), N(e, f), N(s, f), N(l, f), f && o && C(a), N(o, f);
    }
  };
}
u(ipe, "create_if_block$K");
function lpe(i) {
  let e = K("A5E.Unknown") + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p: se,
    d(s) {
      s && C(t);
    }
  };
}
u(lpe, "create_else_block_1$4");
function rpe(i) {
  let e = (
    /*armorTypes*/
    (i[8][
      /*$item*/
      i[0].system.armorCategory
    ] ?? /*$item*/
    i[0].system.armorCategory) + ""
  ), t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*$item*/
      1 && e !== (e = /*armorTypes*/
      (s[8][
        /*$item*/
        s[0].system.armorCategory
      ] ?? /*$item*/
      s[0].system.armorCategory) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(rpe, "create_if_block_3$f");
function hN(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = `${K("A5E.ArmorMods")}:`, s = F(), n = E("dd"), l = Q(
        /*selectedArmorMods*/
        i[5]
      ), r = F(), b(t, "class", "u-text-bold"), b(n, "class", "u-m-0 u-p-0"), b(e, "class", "u-flex u-gap-md");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(e, n), A(n, l), A(e, r);
    },
    p(o, a) {
      a & /*selectedArmorMods*/
      32 && be(
        l,
        /*selectedArmorMods*/
        o[5]
      );
    },
    d(o) {
      o && C(e);
    }
  };
}
u(hN, "create_if_block_2$p");
function gN(i) {
  let e, t, s;
  return {
    c() {
      e = Q("DC "), t = Q(
        /*repairabilityDC*/
        i[2]
      ), s = Q(`,
                    `);
    },
    m(n, l) {
      T(n, e, l), T(n, t, l), T(n, s, l);
    },
    p(n, l) {
      l & /*repairabilityDC*/
      4 && be(
        t,
        /*repairabilityDC*/
        n[2]
      );
    },
    d(n) {
      n && (C(e), C(t), C(s));
    }
  };
}
u(gN, "create_if_block_1$x");
function ope(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "data-dtype", "Number"), b(e, "name", "system.repairabilityDC"), b(
        e,
        "id",
        /*appId*/
        i[7] + "-repairabilityDC"
      ), e.value = t = /*$item*/
      i[0].system.repairabilityDC ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.repairabilityDC ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(ope, "create_default_slot_2$e");
function ape(i) {
  let e, t, s, n;
  return e = new ie({
    props: {
      heading: "A5E.RepairabilityDC",
      $$slots: { default: [ope] },
      $$scope: { ctx: i }
    }
  }), s = new tt({
    props: {
      heading: "A5E.RepairabilityTools",
      options: Object.entries(
        /*repairTools*/
        i[11]
      ),
      selected: (
        /*$item*/
        i[0].system.repairTools
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, $item*/
      2097153 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$item*/
      1 && (a.selected = /*$item*/
      l[0].system.repairTools), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(ape, "create_default_slot_1$f");
function cpe(i) {
  let e, t, s, n;
  const l = [ipe, npe], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[1] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(cpe, "create_default_slot$z");
function upe(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Armor Configuration",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[17]
          )
        }
      ],
      $$slots: { default: [cpe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-heading-gap", "0.5rem"), G(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      2 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[17]
          )
        }
      ]), l & /*$$scope, $item, editMode, selectedRepairabilityProperties, repairabilityDC, selectedArmorMods, selectedArmorProperties*/
      2097215 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(upe, "create_fragment$1k");
function fpe(i) {
  return i.system.repairabilityDC;
}
u(fpe, "getRepairabilityDC");
function dpe(i, e, t) {
  let s, n, l, r, o;
  function a(L) {
    let B = L.system.armorMods.map((z) => h[z] ?? z);
    return B.sort((z, q) => z.localeCompare(q)), B = B.map((z) => K(z)), B.join(", ");
  }
  u(a, "prepareArmorMods");
  function c(L) {
    const B = L.system.armorProperties.map((z) => g[z] ?? z);
    return B.sort((z, q) => z.localeCompare(q)), B.join(", ");
  }
  u(c, "prepareArmorProperties");
  function f(L) {
    let B = L.system.repairTools.map((z) => _[z] ?? z);
    return B = B.map((z) => K(z)), B.sort((z, q) => z.localeCompare(q)), B.join(", ");
  }
  u(f, "prepareRepairabilityProperties");
  const d = de("item");
  pe(i, d, (L) => t(0, o = L));
  const p = de("appId"), { armor: m, armorProperties: g, armorMods: h, repairTools: _ } = CONFIG.A5E;
  let y = !1;
  const v = /* @__PURE__ */ u((L) => te(o, "system.armorCategory", L.detail), "updateSelection_handler"), k = /* @__PURE__ */ u((L) => te(o, "system.armorProperties", L.detail), "updateSelection_handler_1"), S = /* @__PURE__ */ u((L) => te(o, "system.armorMods", L.detail), "updateSelection_handler_2"), D = /* @__PURE__ */ u(({ target: L }) => te(o, L.name, Number(L.value)), "change_handler"), I = /* @__PURE__ */ u((L) => te(o, "system.repairTools", L.detail), "updateSelection_handler_3"), M = /* @__PURE__ */ u(() => t(1, y = !y), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(5, s = a(o)), i.$$.dirty & /*$item*/
    1 && t(4, n = c(o)), i.$$.dirty & /*$item*/
    1 && t(3, l = f(o)), i.$$.dirty & /*$item*/
    1 && t(2, r = fpe(o));
  }, [
    o,
    y,
    r,
    l,
    n,
    s,
    d,
    p,
    m,
    g,
    h,
    _,
    v,
    k,
    S,
    D,
    I,
    M
  ];
}
u(dpe, "instance$1e");
const CC = class CC extends re {
  constructor(e) {
    super(), oe(this, e, dpe, upe, le, {});
  }
};
u(CC, "ArmorConfiguration");
let jv = CC;
function ppe(i) {
  let e, t, s, n, l, r = (K(
    /*A5E*/
    i[3].capacityTypes[
      /*$item*/
      i[1].system.capacity.type
    ]
  ) ?? K("A5E.None")) + "", o, a, c, f, d, p, m = (
    /*$item*/
    (i[1].system.capacity.value ?? 0) + ""
  ), g, h, _, y, v, k, S = (
    /*$item*/
    i[1].system.capacity.weightlessContents ? "Yes" : "No"
  ), D;
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = "Capacity Type:", n = F(), l = E("dd"), o = Q(r), a = F(), c = E("div"), f = E("dt"), f.textContent = "Max Capacity:", d = F(), p = E("dd"), g = Q(m), h = F(), _ = E("div"), y = E("dt"), y.textContent = "Has Weightless Contents:", v = F(), k = E("dd"), D = Q(S), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(f, "class", "u-text-bold"), b(p, "class", "u-m-0 u-p-0"), b(c, "class", "u-flex u-gap-md"), b(y, "class", "u-text-bold"), b(k, "class", "u-m-0 u-p-0"), b(_, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(I, M) {
      T(I, e, M), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o), A(t, a), A(e, c), A(c, f), A(c, d), A(c, p), A(p, g), A(c, h), A(e, _), A(_, y), A(_, v), A(_, k), A(k, D);
    },
    p(I, M) {
      M & /*$item*/
      2 && r !== (r = (K(
        /*A5E*/
        I[3].capacityTypes[
          /*$item*/
          I[1].system.capacity.type
        ]
      ) ?? K("A5E.None")) + "") && be(o, r), M & /*$item*/
      2 && m !== (m = /*$item*/
      (I[1].system.capacity.value ?? 0) + "") && be(g, m), M & /*$item*/
      2 && S !== (S = /*$item*/
      I[1].system.capacity.weightlessContents ? "Yes" : "No") && be(D, S);
    },
    i: se,
    o: se,
    d(I) {
      I && C(e);
    }
  };
}
u(ppe, "create_else_block$f");
function mpe(i) {
  let e, t, s, n, l, r;
  return e = new Ke({
    props: {
      heading: "Capacity Type",
      options: Object.entries(
        /*A5E*/
        i[3].capacityTypes
      ),
      selected: (
        /*$item*/
        i[1].system.capacity.type
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), s = new ie({
    props: {
      heading: "Max Capacity",
      $$slots: { default: [hpe] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      $$slots: { default: [gpe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), R(s, o, a), T(o, n, a), R(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$item*/
      2 && (c.selected = /*$item*/
      o[1].system.capacity.type), e.$set(c);
      const f = {};
      a & /*$$scope, $item*/
      258 && (f.$$scope = { dirty: a, ctx: o }), s.$set(f);
      const d = {};
      a & /*$$scope, $item*/
      258 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(s.$$.fragment, o), O(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (C(t), C(n)), N(e, o), N(s, o), N(l, o);
    }
  };
}
u(mpe, "create_if_block$J");
function hpe(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--small a5e-input--slim"), b(e, "type", "number"), b(e, "min", "0"), e.value = t = /*$item*/
      i[1].system.capacity.value;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[5]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      2 && t !== (t = /*$item*/
      l[1].system.capacity.value) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(hpe, "create_default_slot_2$d");
function gpe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Has Weightless Contents",
      checked: (
        /*$item*/
        i[1].system.capacity.weightlessContents
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[6]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.capacity.weightlessContents), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(gpe, "create_default_slot_1$e");
function bpe(i) {
  let e, t, s, n;
  const l = [mpe, ppe], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[0] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(bpe, "create_default_slot$y");
function _pe(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.TabContainerProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[7]
          )
        }
      ],
      $$slots: { default: [bpe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-heading-gap", "0.5rem"), G(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      1 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[7]
          )
        }
      ]), l & /*$$scope, $item, editMode*/
      259 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(_pe, "create_fragment$1j");
function ype(i, e, t) {
  let s;
  const n = de("item");
  pe(i, n, (d) => t(1, s = d));
  const { A5E: l } = CONFIG;
  let r = !1;
  return [
    r,
    s,
    n,
    l,
    /* @__PURE__ */ u(({ detail: d }) => te(s, "system.capacity.type", d), "updateSelection_handler"),
    /* @__PURE__ */ u(({ target: d }) => te(
      s,
      "system.capacity.value",
      // @ts-ignore
      Number(d.value)
    ), "change_handler"),
    /* @__PURE__ */ u(({ detail: d }) => te(s, "system.capacity.weightlessContents", d), "updateSelection_handler_1"),
    /* @__PURE__ */ u(() => t(0, r = !r), "func")
  ];
}
u(ype, "instance$1d");
const TC = class TC extends re {
  constructor(e) {
    super(), oe(this, e, ype, _pe, le, {});
  }
};
u(TC, "ContainerConfiguration");
let Lv = TC;
function vpe(i) {
  let e, t, s, n, l, r = (
    /*featureTypes*/
    (i[6][
      /*$item*/
      i[1].system.featureType
    ] ?? K("A5E.None")) + ""
  ), o, a, c = ["class", "knack"].includes(
    /*$item*/
    i[1].system.featureType
  ) && /*$item*/
  i[1].system.classes, f = c && bN(i);
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.FeatureTypePrompt")}:`, n = F(), l = E("dd"), o = Q(r), a = F(), f && f.c(), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o), A(t, a), f && f.m(e, null);
    },
    p(d, p) {
      p & /*$item*/
      2 && r !== (r = /*featureTypes*/
      (d[6][
        /*$item*/
        d[1].system.featureType
      ] ?? K("A5E.None")) + "") && be(o, r), p & /*$item*/
      2 && (c = ["class", "knack"].includes(
        /*$item*/
        d[1].system.featureType
      ) && /*$item*/
      d[1].system.classes), c ? f ? f.p(d, p) : (f = bN(d), f.c(), f.m(e, null)) : f && (f.d(1), f = null);
    },
    i: se,
    o: se,
    d(d) {
      d && C(e), f && f.d();
    }
  };
}
u(vpe, "create_else_block$e");
function kpe(i) {
  let e, t, s = ["class", "knack"].includes(
    /*$item*/
    i[1].system.featureType
  ), n, l, r, o, a;
  e = new Ke({
    props: {
      heading: "A5E.FeatureTypePrompt",
      options: Object.entries(
        /*featureTypes*/
        i[6]
      ),
      selected: (
        /*$item*/
        i[1].system.featureType
      ),
      allowDeselect: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  );
  let c = s && _N(i);
  return l = new ie({
    props: {
      $$slots: { default: [$pe] },
      $$scope: { ctx: i }
    }
  }), o = new ie({
    props: {
      $$slots: { default: [Ape] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), c && c.c(), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment);
    },
    m(f, d) {
      R(e, f, d), T(f, t, d), c && c.m(f, d), T(f, n, d), R(l, f, d), T(f, r, d), R(o, f, d), a = !0;
    },
    p(f, d) {
      const p = {};
      d & /*$item*/
      2 && (p.selected = /*$item*/
      f[1].system.featureType), e.$set(p), d & /*$item*/
      2 && (s = ["class", "knack"].includes(
        /*$item*/
        f[1].system.featureType
      )), s ? c ? (c.p(f, d), d & /*$item*/
      2 && w(c, 1)) : (c = _N(f), c.c(), w(c, 1), c.m(n.parentNode, n)) : c && (ae(), O(c, 1, 1, () => {
        c = null;
      }), ce());
      const m = {};
      d & /*$$scope, $item*/
      16386 && (m.$$scope = { dirty: d, ctx: f }), l.$set(m);
      const g = {};
      d & /*$$scope, $item*/
      16386 && (g.$$scope = { dirty: d, ctx: f }), o.$set(g);
    },
    i(f) {
      a || (w(e.$$.fragment, f), w(c), w(l.$$.fragment, f), w(o.$$.fragment, f), a = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(c), O(l.$$.fragment, f), O(o.$$.fragment, f), a = !1;
    },
    d(f) {
      f && (C(t), C(n), C(r)), N(e, f), c && c.d(f), N(l, f), N(o, f);
    }
  };
}
u(kpe, "create_if_block$I");
function bN(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = "Class:", s = F(), n = E("dd"), n.textContent = `${/*getClassSummary*/
      i[2]()}`, b(t, "class", "u-text-bold"), b(n, "class", "u-m-0 u-p-0"), b(e, "class", "u-flex u-gap-md");
    },
    m(l, r) {
      T(l, e, r), A(e, t), A(e, s), A(e, n);
    },
    p: se,
    d(l) {
      l && C(e);
    }
  };
}
u(bN, "create_if_block_2$o");
function _N(i) {
  let e, t, s, n, l, r;
  return e = new Ke({
    props: {
      heading: "A5E Classes",
      options: Object.entries(
        /*classes*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[1].system.classes
      ),
      allowDeselect: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), s = new Ke({
    props: {
      heading: "5E Classes",
      options: Object.entries(
        /*classes5e*/
        i[5]
      ),
      selected: (
        /*$item*/
        i[1].system.classes
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[9]
  ), l = new ie({
    props: {
      heading: "Custom Class",
      hint: "Enter the identifier for a custom class.",
      $$slots: { default: [wpe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), R(s, o, a), T(o, n, a), R(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$item*/
      2 && (c.selected = /*$item*/
      o[1].system.classes), e.$set(c);
      const f = {};
      a & /*$item*/
      2 && (f.selected = /*$item*/
      o[1].system.classes), s.$set(f);
      const d = {};
      a & /*$$scope, $item*/
      16386 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(s.$$.fragment, o), O(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (C(t), C(n)), N(e, o), N(s, o), N(l, o);
    }
  };
}
u(_N, "create_if_block_1$w");
function wpe(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--slim"), b(e, "type", "text"), e.value = t = /*$item*/
      i[1].system.classes || "";
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      2 && t !== (t = /*$item*/
      l[1].system.classes || "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(wpe, "create_default_slot_3$c");
function $pe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.SpellConcentration",
      checked: (
        /*$item*/
        i[1].system.concentration
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[11]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.concentration), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u($pe, "create_default_slot_2$c");
function Ape(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.RequiresBloodied",
      checked: (
        /*$item*/
        i[1].system.requiresBloodied
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[12]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.requiresBloodied), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Ape, "create_default_slot_1$d");
function Epe(i) {
  let e, t, s, n;
  const l = [kpe, vpe], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[0] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(Epe, "create_default_slot$x");
function Spe(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.TabFeatureProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[13]
          )
        }
      ],
      $$slots: { default: [Epe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-heading-gap", "0.5rem"), G(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      1 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[13]
          )
        }
      ]), l & /*$$scope, $item, editMode*/
      16387 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Spe, "create_fragment$1i");
function Cpe(i, e, t) {
  let s;
  function n() {
    const y = s.system.classes;
    return K(r[y] ?? o[y]) || y;
  }
  u(n, "getClassSummary");
  const l = de("item");
  pe(i, l, (y) => t(1, s = y));
  const { classes: r, classes5e: o, featureTypes: a } = CONFIG.A5E;
  let c = !1;
  return [
    c,
    s,
    n,
    l,
    r,
    o,
    a,
    /* @__PURE__ */ u((y) => te(s, "system.featureType", y.detail), "updateSelection_handler"),
    /* @__PURE__ */ u(({ detail: y }) => {
      te(s, "system.classes", y);
    }, "updateSelection_handler_1"),
    /* @__PURE__ */ u(({ detail: y }) => {
      te(s, "system.classes", y);
    }, "updateSelection_handler_2"),
    /* @__PURE__ */ u(({ target: y }) => te(s, "system.classes", y.value), "change_handler"),
    /* @__PURE__ */ u(({ detail: y }) => {
      te(s, "system.concentration", y);
    }, "updateSelection_handler_3"),
    /* @__PURE__ */ u(({ detail: y }) => {
      te(s, "system.requiresBloodied", y);
    }, "updateSelection_handler_4"),
    /* @__PURE__ */ u(() => t(0, c = !c), "func")
  ];
}
u(Cpe, "instance$1c");
const OC = class OC extends re {
  constructor(e) {
    super(), oe(this, e, Cpe, Spe, le, {});
  }
};
u(OC, "FeatureConfiguration");
let Bv = OC;
function QB(i) {
  return Object.entries(i).map(([e, t]) => [Number(e), t]);
}
u(QB, "objectEntriesNumberKeyConverter");
function Tpe(i) {
  let e, t, s, n, l, r = (
    /*maneuverDegrees*/
    i[4][
      /*$item*/
      i[1].system.degree
    ] + ""
  ), o, a, c, f = (
    /*$item*/
    i[1].system.degree > 0 && /*$item*/
    i[1].system.isStance && yN()
  ), d = (
    /*$item*/
    i[1].system.degree > 0 && vN(i)
  );
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.ManeuverDegreePrompt")}:`, n = F(), l = E("dd"), o = Q(r), a = F(), f && f.c(), c = F(), d && d.c(), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(p, m) {
      T(p, e, m), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o), A(l, a), f && f.m(l, null), A(t, c), d && d.m(e, null);
    },
    p(p, m) {
      m & /*$item*/
      2 && r !== (r = /*maneuverDegrees*/
      p[4][
        /*$item*/
        p[1].system.degree
      ] + "") && be(o, r), /*$item*/
      p[1].system.degree > 0 && /*$item*/
      p[1].system.isStance ? f || (f = yN(), f.c(), f.m(l, null)) : f && (f.d(1), f = null), /*$item*/
      p[1].system.degree > 0 ? d ? d.p(p, m) : (d = vN(p), d.c(), d.m(e, null)) : d && (d.d(1), d = null);
    },
    i: se,
    o: se,
    d(p) {
      p && C(e), f && f.d(), d && d.d();
    }
  };
}
u(Tpe, "create_else_block$d");
function Ope(i) {
  let e, t, s, n;
  e = new Ke({
    props: {
      heading: "A5E.ManeuverDegreePrompt",
      options: QB(
        /*maneuverDegrees*/
        i[4]
      ),
      selected: parseInt(
        /*$item*/
        i[1].system.degree,
        10
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  );
  let l = (
    /*$item*/
    i[1].system.degree > 0 && kN(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), l && l.c(), s = $e();
    },
    m(r, o) {
      R(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$item*/
      2 && (a.selected = parseInt(
        /*$item*/
        r[1].system.degree,
        10
      )), e.$set(a), /*$item*/
      r[1].system.degree > 0 ? l ? (l.p(r, o), o & /*$item*/
      2 && w(l, 1)) : (l = kN(r), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ae(), O(l, 1, 1, () => {
        l = null;
      }), ce());
    },
    i(r) {
      n || (w(e.$$.fragment, r), w(l), n = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(l), n = !1;
    },
    d(r) {
      r && (C(t), C(s)), N(e, r), l && l.d(r);
    }
  };
}
u(Ope, "create_if_block$H");
function yN(i) {
  let e = K("A5E.ManeuverStance") + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(yN, "create_if_block_3$e");
function vN(i) {
  let e, t, s, n, l = (
    /*maneuverTraditions*/
    (i[5][
      /*$item*/
      i[1].system.tradition
    ] ?? K("A5E.None")) + ""
  ), r, o, a, c, f, d, p = (
    /*$item*/
    (i[1].system.exertionCost || 0) + ""
  ), m;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = `${K("A5E.ManeuverTraditionPrompt")}:`, s = F(), n = E("dd"), r = Q(l), o = F(), a = E("div"), c = E("dt"), c.textContent = `${K("A5E.ItemExertionCost")}:`, f = F(), d = E("dd"), m = Q(p), b(t, "class", "u-text-bold"), b(n, "class", "u-m-0 u-p-0"), b(e, "class", "u-flex u-gap-md"), b(c, "class", "u-text-bold"), b(d, "class", "u-m-0 u-p-0"), b(a, "class", "u-flex u-gap-md");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(e, s), A(e, n), A(n, r), A(e, o), T(g, a, h), A(a, c), A(a, f), A(a, d), A(d, m);
    },
    p(g, h) {
      h & /*$item*/
      2 && l !== (l = /*maneuverTraditions*/
      (g[5][
        /*$item*/
        g[1].system.tradition
      ] ?? K("A5E.None")) + "") && be(r, l), h & /*$item*/
      2 && p !== (p = /*$item*/
      (g[1].system.exertionCost || 0) + "") && be(m, p);
    },
    d(g) {
      g && (C(e), C(a));
    }
  };
}
u(vN, "create_if_block_2$n");
function kN(i) {
  let e, t, s, n, l, r, o, a;
  return e = new Ke({
    props: {
      heading: "A5E.ManeuverTraditionPrompt",
      options: Object.entries(
        /*maneuverTraditions*/
        i[5]
      ),
      selected: (
        /*$item*/
        i[1].system.tradition
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[7]
  ), s = new ie({
    props: {
      $$slots: { default: [Dpe] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      $$slots: { default: [Ipe] },
      $$scope: { ctx: i }
    }
  }), o = new ie({
    props: {
      heading: "A5E.ItemExertionCost",
      $$slots: { default: [Ppe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment);
    },
    m(c, f) {
      R(e, c, f), T(c, t, f), R(s, c, f), T(c, n, f), R(l, c, f), T(c, r, f), R(o, c, f), a = !0;
    },
    p(c, f) {
      const d = {};
      f & /*$item*/
      2 && (d.selected = /*$item*/
      c[1].system.tradition), e.$set(d);
      const p = {};
      f & /*$$scope, $item*/
      4098 && (p.$$scope = { dirty: f, ctx: c }), s.$set(p);
      const m = {};
      f & /*$$scope, $item*/
      4098 && (m.$$scope = { dirty: f, ctx: c }), l.$set(m);
      const g = {};
      f & /*$$scope, $item*/
      4098 && (g.$$scope = { dirty: f, ctx: c }), o.$set(g);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(s.$$.fragment, c), w(l.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      O(e.$$.fragment, c), O(s.$$.fragment, c), O(l.$$.fragment, c), O(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (C(t), C(n), C(r)), N(e, c), N(s, c), N(l, c), N(o, c);
    }
  };
}
u(kN, "create_if_block_1$v");
function Dpe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.ManeuverIsStance",
      checked: (
        /*$item*/
        i[1].system.isStance
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.isStance), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Dpe, "create_default_slot_3$b");
function Ipe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.SpellConcentration",
      checked: (
        /*$item*/
        i[1].system.concentration
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[9]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.concentration), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Ipe, "create_default_slot_2$b");
function Ppe(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "type", "number"), b(t, "data-dtype", "Number"), b(t, "name", "system.exertionCost"), t.value = s = /*$item*/
      i[1].system.exertionCost, b(
        t,
        "id",
        /*appId*/
        i[3] + "-exertion-cost"
      ), b(e, "class", "u-w-20");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = W(
        t,
        "change",
        /*change_handler*/
        i[10]
      ), n = !0);
    },
    p(r, o) {
      o & /*$item*/
      2 && s !== (s = /*$item*/
      r[1].system.exertionCost) && t.value !== s && (t.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Ppe, "create_default_slot_1$c");
function Mpe(i) {
  let e, t, s, n;
  const l = [Ope, Tpe], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[0] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(Mpe, "create_default_slot$w");
function Fpe(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.TabManeuverProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[11]
          )
        }
      ],
      $$slots: { default: [Mpe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-heading-gap", "0.5rem"), G(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      1 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[11]
          )
        }
      ]), l & /*$$scope, $item, editMode*/
      4099 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Fpe, "create_fragment$1h");
function Rpe(i, e, t) {
  let s;
  const n = de("item");
  pe(i, n, (h) => t(1, s = h));
  const l = de("appId"), { maneuverDegrees: r, maneuverTraditions: o } = CONFIG.A5E;
  let a = !1;
  return [
    a,
    s,
    n,
    l,
    r,
    o,
    /* @__PURE__ */ u((h) => te(s, "system.degree", h.detail), "updateSelection_handler"),
    /* @__PURE__ */ u((h) => te(s, "system.tradition", h.detail), "updateSelection_handler_1"),
    /* @__PURE__ */ u(({ detail: h }) => {
      te(s, "system.isStance", h);
    }, "updateSelection_handler_2"),
    /* @__PURE__ */ u(({ detail: h }) => {
      te(s, "system.concentration", h);
    }, "updateSelection_handler_3"),
    /* @__PURE__ */ u(({ target: h }) => te(s, h.name, Number(h.value)), "change_handler"),
    /* @__PURE__ */ u(() => t(0, a = !a), "func")
  ];
}
u(Rpe, "instance$1b");
const DC = class DC extends re {
  constructor(e) {
    super(), oe(this, e, Rpe, Fpe, le, {});
  }
};
u(DC, "ManeuverConfiguration");
let qv = DC;
function Npe(i) {
  let e, t, s, n, l, r = (
    /*selectedMaterialProperties*/
    (i[2] || K("A5E.None")) + ""
  ), o;
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.MaterialProperties")}:`, n = F(), l = E("dd"), o = Q(r), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o);
    },
    p(a, c) {
      c & /*selectedMaterialProperties*/
      4 && r !== (r = /*selectedMaterialProperties*/
      (a[2] || K("A5E.None")) + "") && be(o, r);
    },
    i: se,
    o: se,
    d(a) {
      a && C(e);
    }
  };
}
u(Npe, "create_else_block$c");
function jpe(i) {
  let e, t, s = (
    /*$item*/
    i[0].system.materialProperties.includes("flaw")
  ), n, l = (
    /*$item*/
    i[0].system.materialProperties.includes("spacefaring")
  ), r, o;
  e = new tt({
    props: {
      heading: "A5E.MaterialProperties",
      options: Object.entries(
        /*materialProperties*/
        i[5]
      ),
      selected: (
        /*$item*/
        i[0].system.materialProperties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  );
  let a = s && wN(i), c = l && $N(i);
  return {
    c() {
      j(e.$$.fragment), t = F(), a && a.c(), n = F(), c && c.c(), r = $e();
    },
    m(f, d) {
      R(e, f, d), T(f, t, d), a && a.m(f, d), T(f, n, d), c && c.m(f, d), T(f, r, d), o = !0;
    },
    p(f, d) {
      const p = {};
      d & /*$item*/
      1 && (p.selected = /*$item*/
      f[0].system.materialProperties), e.$set(p), d & /*$item*/
      1 && (s = /*$item*/
      f[0].system.materialProperties.includes("flaw")), s ? a ? (a.p(f, d), d & /*$item*/
      1 && w(a, 1)) : (a = wN(f), a.c(), w(a, 1), a.m(n.parentNode, n)) : a && (ae(), O(a, 1, 1, () => {
        a = null;
      }), ce()), d & /*$item*/
      1 && (l = /*$item*/
      f[0].system.materialProperties.includes("spacefaring")), l ? c ? (c.p(f, d), d & /*$item*/
      1 && w(c, 1)) : (c = $N(f), c.c(), w(c, 1), c.m(r.parentNode, r)) : c && (ae(), O(c, 1, 1, () => {
        c = null;
      }), ce());
    },
    i(f) {
      o || (w(e.$$.fragment, f), w(a), w(c), o = !0);
    },
    o(f) {
      O(e.$$.fragment, f), O(a), O(c), o = !1;
    },
    d(f) {
      f && (C(t), C(n), C(r)), N(e, f), a && a.d(f), c && c.d(f);
    }
  };
}
u(jpe, "create_if_block$G");
function wN(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Flaw Properties",
      options: Object.entries(
        /*flaws*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[0].system.flaws
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.flaws), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(wN, "create_if_block_2$m");
function $N(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "Spacefaring Mod Port Property",
      options: Object.entries(
        /*modPorts*/
        i[6]
      ),
      selected: (
        /*$item*/
        i[0].system.modPorts
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[9]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.modPorts), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u($N, "create_if_block_1$u");
function Lpe(i) {
  let e, t, s, n;
  const l = [jpe, Npe], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[1] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(Lpe, "create_default_slot$v");
function Bpe(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.MaterialProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[10]
          )
        }
      ],
      $$slots: { default: [Lpe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-heading-gap", "0.5rem"), G(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      2 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[10]
          )
        }
      ]), l & /*$$scope, $item, editMode, selectedMaterialProperties*/
      2055 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Bpe, "create_fragment$1g");
function qpe(i, e, t) {
  let s, n;
  const l = de("item");
  pe(i, l, (g) => t(0, n = g));
  const { flaws: r, materialProperties: o, modPorts: a } = CONFIG.A5E;
  let c = !1;
  const f = /* @__PURE__ */ u((g) => te(n, "system.materialProperties", g.detail), "updateSelection_handler"), d = /* @__PURE__ */ u((g) => te(n, "system.flaws", g.detail), "updateSelection_handler_1"), p = /* @__PURE__ */ u((g) => te(n, "system.modPorts", g.detail), "updateSelection_handler_2"), m = /* @__PURE__ */ u(() => t(1, c = !c), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(2, s = z9(n).filter(Boolean).join(", "));
  }, [
    n,
    c,
    s,
    l,
    r,
    o,
    a,
    f,
    d,
    p,
    m
  ];
}
u(qpe, "instance$1a");
const IC = class IC extends re {
  constructor(e) {
    super(), oe(this, e, qpe, Bpe, le, {});
  }
};
u(IC, "MaterialConfiguration");
let Gv = IC;
function Gpe(i) {
  let e, t, s, n, l, r = (
    /*A5E*/
    (i[4].objectTypes[
      /*$item*/
      i[1].system.objectType
    ] ?? K("A5E.None")) + ""
  ), o, a, c, f, d, p, m = K(
    /*A5E*/
    i[4].itemRarity[
      /*$item*/
      i[1].system.rarity
    ] ?? /*$item*/
    i[1].system.rarity
  ) + "", g, h, _, y, v, k, S, D, I, M, L, B, z = (
    /*$item*/
    i[1].system.weight + ""
  ), q, U, H = K("A5E.DetailsWeightLbs") + "", V, Y, J, fe, ke, ee, ne, Ee = (
    /*$item*/
    (i[1].system.quantity || 0) + ""
  ), Pe, ye, me, Ce, Je, Ne, Re = (
    /*$item*/
    (i[1].system.price ?? K("A5E.None")) + ""
  ), ge, je, Be = (
    /*showVRCTechLevel*/
    i[7] && Hpe(i)
  );
  function Ze(Fe, xe) {
    return (
      /*$item*/
      Fe[1].system.requiresAttunement ? Vpe : Upe
    );
  }
  u(Ze, "select_block_type_1");
  let Ge = Ze(i), Se = Ge(i), _e = (
    /*$item*/
    i[1].system.bulky && AN()
  ), we = (
    /*$item*/
    i[1].system.craftingComponents != "" && EN(i)
  );
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.ObjectTypePrompt")}:`, n = F(), l = E("dd"), o = Q(r), a = F(), c = E("div"), f = E("dt"), f.textContent = `${K("A5E.ItemRarity")}:`, d = F(), p = E("dd"), g = Q(m), h = F(), Be && Be.c(), _ = E("div"), y = E("dt"), y.textContent = `${K("A5E.Attunement")}:`, v = F(), k = E("dd"), Se.c(), S = F(), D = E("hr"), I = E("div"), M = E("dt"), M.textContent = `${K("A5E.ItemWeight")}:`, L = F(), B = E("dd"), q = Q(z), U = F(), V = Q(H), Y = F(), _e && _e.c(), J = F(), fe = E("div"), ke = E("dt"), ke.textContent = `${K("A5E.ItemQuantity")}:`, ee = F(), ne = E("dd"), Pe = Q(Ee), ye = F(), me = E("div"), Ce = E("dt"), Ce.textContent = `${K("A5E.ItemPrice")}:`, Je = F(), Ne = E("dd"), ge = Q(Re), je = F(), we && we.c(), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(f, "class", "u-text-bold"), b(p, "class", "u-m-0 u-p-0"), b(c, "class", "u-flex u-gap-md"), b(y, "class", "u-text-bold"), b(k, "class", "align-center u-flex u-gap-sm u-m-0 u-p-0"), b(_, "class", "u-flex u-gap-md"), b(D, "class", "a5e-rule u-my-sm"), b(M, "class", "u-text-bold"), b(B, "class", "align-center u-flex u-gap-sm u-m-0 u-p-0"), b(I, "class", "u-flex u-gap-md"), b(ke, "class", "u-text-bold"), b(ne, "class", "u-m-0 u-p-0"), b(fe, "class", "u-flex u-gap-md"), b(Ce, "class", "u-text-bold"), b(Ne, "class", "u-m-0 u-p-0"), b(me, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(Fe, xe) {
      T(Fe, e, xe), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o), A(t, a), A(e, c), A(c, f), A(c, d), A(c, p), A(p, g), A(c, h), Be && Be.m(e, null), A(e, _), A(_, y), A(_, v), A(_, k), Se.m(k, null), A(_, S), A(e, D), A(e, I), A(I, M), A(I, L), A(I, B), A(B, q), A(B, U), A(B, V), A(B, Y), _e && _e.m(B, null), A(I, J), A(e, fe), A(fe, ke), A(fe, ee), A(fe, ne), A(ne, Pe), A(fe, ye), A(e, me), A(me, Ce), A(me, Je), A(me, Ne), A(Ne, ge), A(me, je), we && we.m(e, null);
    },
    p(Fe, xe) {
      xe & /*$item*/
      2 && r !== (r = /*A5E*/
      (Fe[4].objectTypes[
        /*$item*/
        Fe[1].system.objectType
      ] ?? K("A5E.None")) + "") && be(o, r), xe & /*$item*/
      2 && m !== (m = K(
        /*A5E*/
        Fe[4].itemRarity[
          /*$item*/
          Fe[1].system.rarity
        ] ?? /*$item*/
        Fe[1].system.rarity
      ) + "") && be(g, m), /*showVRCTechLevel*/
      Fe[7] && Be.p(Fe, xe), Ge === (Ge = Ze(Fe)) && Se ? Se.p(Fe, xe) : (Se.d(1), Se = Ge(Fe), Se && (Se.c(), Se.m(k, null))), xe & /*$item*/
      2 && z !== (z = /*$item*/
      Fe[1].system.weight + "") && be(q, z), /*$item*/
      Fe[1].system.bulky ? _e || (_e = AN(), _e.c(), _e.m(B, null)) : _e && (_e.d(1), _e = null), xe & /*$item*/
      2 && Ee !== (Ee = /*$item*/
      (Fe[1].system.quantity || 0) + "") && be(Pe, Ee), xe & /*$item*/
      2 && Re !== (Re = /*$item*/
      (Fe[1].system.price ?? K("A5E.None")) + "") && be(ge, Re), /*$item*/
      Fe[1].system.craftingComponents != "" ? we ? we.p(Fe, xe) : (we = EN(Fe), we.c(), we.m(e, null)) : we && (we.d(1), we = null);
    },
    i: se,
    o: se,
    d(Fe) {
      Fe && C(e), Be && Be.d(), Se.d(), _e && _e.d(), we && we.d();
    }
  };
}
u(Gpe, "create_else_block$b");
function zpe(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S, D;
  e = new Ke({
    props: {
      heading: "A5E.ObjectTypePrompt",
      options: Object.entries(
        /*A5E*/
        i[4].objectTypes
      ),
      selected: (
        /*$item*/
        i[1].system.objectType
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[9]
  ), s = new Ke({
    props: {
      heading: "A5E.ItemRarity",
      options: Object.entries(
        /*A5E*/
        i[4].itemRarity
      ),
      selected: (
        /*$item*/
        i[1].system.rarity
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[10]
  );
  let I = (
    /*showVRCTechLevel*/
    i[7] && Wpe(i)
  );
  r = new De({
    props: {
      $$slots: { default: [Xpe] },
      $$scope: { ctx: i }
    }
  }), c = new ie({
    props: {
      heading: "A5E.ItemWeight",
      $$slots: { default: [Jpe] },
      $$scope: { ctx: i }
    }
  }), p = new Ke({
    props: {
      heading: "A5E.ItemEquippedState",
      options: Object.entries(
        /*A5E*/
        i[4].equippedStates
      ),
      selected: (
        /*$item*/
        i[1].system.equippedState
      )
    }
  }), p.$on(
    "updateSelection",
    /*updateSelection_handler_10*/
    i[20]
  ), g = new ie({
    props: {
      heading: "A5E.ItemQuantity",
      $$slots: { default: [Zpe] },
      $$scope: { ctx: i }
    }
  }), _ = new ie({
    props: {
      heading: "A5E.ItemPrice",
      $$slots: { default: [Qpe] },
      $$scope: { ctx: i }
    }
  }), v = new ie({
    props: {
      heading: "A5E.CraftingComponents",
      $$slots: { default: [xpe] },
      $$scope: { ctx: i }
    }
  });
  let M = !/*hideBrokenAndDamaged*/
  i[6] && eme(i);
  return {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), I && I.c(), l = F(), o = E("div"), j(r.$$.fragment), a = F(), f = E("div"), j(c.$$.fragment), d = F(), j(p.$$.fragment), m = F(), j(g.$$.fragment), h = F(), j(_.$$.fragment), y = F(), j(v.$$.fragment), k = F(), M && M.c(), S = $e(), G(o, "display", "contents"), G(o, "--a5e-section-body-direction", "row"), G(o, "--a5e-section-body-gap", "0.75rem"), G(f, "display", "contents"), G(f, "--a5e-field-wrapper-gap", "0.375rem 1rem"), G(f, "--a5e-field-wrapper-direction", "row"), G(f, "--a5e-field-wrapper-header-width", "100%");
    },
    m(L, B) {
      R(e, L, B), T(L, t, B), R(s, L, B), T(L, n, B), I && I.m(L, B), T(L, l, B), T(L, o, B), R(r, o, null), T(L, a, B), T(L, f, B), R(c, f, null), T(L, d, B), R(p, L, B), T(L, m, B), R(g, L, B), T(L, h, B), R(_, L, B), T(L, y, B), R(v, L, B), T(L, k, B), M && M.m(L, B), T(L, S, B), D = !0;
    },
    p(L, B) {
      const z = {};
      B & /*$item*/
      2 && (z.selected = /*$item*/
      L[1].system.objectType), e.$set(z);
      const q = {};
      B & /*$item*/
      2 && (q.selected = /*$item*/
      L[1].system.rarity), s.$set(q), /*showVRCTechLevel*/
      L[7] && I.p(L, B);
      const U = {};
      B & /*$$scope, $item*/
      67108866 && (U.$$scope = { dirty: B, ctx: L }), r.$set(U);
      const H = {};
      B & /*$$scope, $item*/
      67108866 && (H.$$scope = { dirty: B, ctx: L }), c.$set(H);
      const V = {};
      B & /*$item*/
      2 && (V.selected = /*$item*/
      L[1].system.equippedState), p.$set(V);
      const Y = {};
      B & /*$$scope, $item*/
      67108866 && (Y.$$scope = { dirty: B, ctx: L }), g.$set(Y);
      const J = {};
      B & /*$$scope, $item*/
      67108866 && (J.$$scope = { dirty: B, ctx: L }), _.$set(J);
      const fe = {};
      B & /*$$scope, $item*/
      67108866 && (fe.$$scope = { dirty: B, ctx: L }), v.$set(fe), /*hideBrokenAndDamaged*/
      L[6] || M.p(L, B);
    },
    i(L) {
      D || (w(e.$$.fragment, L), w(s.$$.fragment, L), w(I), w(r.$$.fragment, L), w(c.$$.fragment, L), w(p.$$.fragment, L), w(g.$$.fragment, L), w(_.$$.fragment, L), w(v.$$.fragment, L), w(M), D = !0);
    },
    o(L) {
      O(e.$$.fragment, L), O(s.$$.fragment, L), O(I), O(r.$$.fragment, L), O(c.$$.fragment, L), O(p.$$.fragment, L), O(g.$$.fragment, L), O(_.$$.fragment, L), O(v.$$.fragment, L), O(M), D = !1;
    },
    d(L) {
      L && (C(t), C(n), C(l), C(a), C(d), C(m), C(h), C(y), C(k), C(S)), N(e, L), N(s, L), I && I.d(L), L && r && C(o), N(r, L), L && c && C(f), N(c, L), N(p, L), N(g, L), N(_, L), N(v, L), M && M.d(L);
    }
  };
}
u(zpe, "create_if_block$F");
function Hpe(i) {
  let e, t, s, n, l = K(
    /*A5E*/
    i[4].itemTechLevels[
      /*$item*/
      i[1].system.techLevel
    ] ?? /*$item*/
    i[1].system.techLevel
  ) + "", r, o;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = `${K("A5E.ItemTechnologyLevel")}:`, s = F(), n = E("dd"), r = Q(l), o = F(), b(t, "class", "u-text-bold"), b(n, "class", "u-m-0 u-p-0"), b(e, "class", "u-flex u-gap-md");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, s), A(e, n), A(n, r), A(e, o);
    },
    p(a, c) {
      c & /*$item*/
      2 && l !== (l = K(
        /*A5E*/
        a[4].itemTechLevels[
          /*$item*/
          a[1].system.techLevel
        ] ?? /*$item*/
        a[1].system.techLevel
      ) + "") && be(r, l);
    },
    d(a) {
      a && C(e);
    }
  };
}
u(Hpe, "create_if_block_10$3");
function Upe(i) {
  let e = K("A5E.AttunementNotRequired") + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p: se,
    d(s) {
      s && C(t);
    }
  };
}
u(Upe, "create_else_block_1$3");
function Vpe(i) {
  let e = K("A5E.AttunementRequired") + "", t, s, n = K(
    /*$item*/
    i[1].system.attuned ? "A5E.Attuned" : "A5E.AttunedNot"
  ) + "", l, r;
  return {
    c() {
      t = Q(e), s = Q(`

                        (`), l = Q(n), r = Q(")");
    },
    m(o, a) {
      T(o, t, a), T(o, s, a), T(o, l, a), T(o, r, a);
    },
    p(o, a) {
      a & /*$item*/
      2 && n !== (n = K(
        /*$item*/
        o[1].system.attuned ? "A5E.Attuned" : "A5E.AttunedNot"
      ) + "") && be(l, n);
    },
    d(o) {
      o && (C(t), C(s), C(l), C(r));
    }
  };
}
u(Vpe, "create_if_block_9$4");
function AN(i) {
  let e, t = K("A5E.ItemBulky") + "", s, n;
  return {
    c() {
      e = Q("("), s = Q(t), n = Q(")");
    },
    m(l, r) {
      T(l, e, r), T(l, s, r), T(l, n, r);
    },
    d(l) {
      l && (C(e), C(s), C(n));
    }
  };
}
u(AN, "create_if_block_8$5");
function EN(i) {
  let e, t, s, n, l = (
    /*$item*/
    (i[1].system.craftingComponents ?? K("A5E.None")) + ""
  ), r;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = `${K("A5E.CraftingComponents")}:`, s = F(), n = E("dd"), r = Q(l), b(t, "class", "u-text-bold"), b(n, "class", "u-m-0 u-p-0"), b(e, "class", "u-flex u-gap-md");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(e, n), A(n, r);
    },
    p(o, a) {
      a & /*$item*/
      2 && l !== (l = /*$item*/
      (o[1].system.craftingComponents ?? K("A5E.None")) + "") && be(r, l);
    },
    d(o) {
      o && C(e);
    }
  };
}
u(EN, "create_if_block_7$7");
function Wpe(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "A5E.ItemTechnologyLevel",
      options: Object.entries(
        /*A5E*/
        i[4].itemTechLevels
      ),
      selected: (
        /*$item*/
        i[1].system.techLevel
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[11]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.selected = /*$item*/
      s[1].system.techLevel), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Wpe, "create_if_block_6$9");
function SN(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.AttunementPrompt",
      checked: (
        /*$item*/
        i[1].system.attuned
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[13]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.attuned), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(SN, "create_if_block_5$a");
function Kpe(i) {
  let e, t, s, n;
  return e = new Te({
    props: {
      label: "A5E.PlotItem",
      checked: (
        /*$item*/
        i[1].system.plotItem
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[14]
  ), s = new Te({
    props: {
      label: "A5E.ItemUnidentified",
      checked: (
        /*$item*/
        i[1].system.unidentified
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[15]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$item*/
      2 && (o.checked = /*$item*/
      l[1].system.plotItem), e.$set(o);
      const a = {};
      r & /*$item*/
      2 && (a.checked = /*$item*/
      l[1].system.unidentified), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(Kpe, "create_if_block_4$d");
function CN(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.Supply",
      checked: (
        /*$item*/
        i[1].system.supply
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.supply), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(CN, "create_if_block_3$d");
function Ype(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.Implant",
      checked: (
        /*$item*/
        i[1].system.implant
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_8*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.implant), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Ype, "create_if_block_2$l");
function Xpe(i) {
  let e, t, s, n, l, r, o;
  e = new Te({
    props: {
      label: "A5E.AttunementRequiredPrompt",
      checked: (
        /*$item*/
        i[1].system.requiresAttunement
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[12]
  );
  let a = (
    /*$item*/
    i[1].actor && /*$item*/
    i[1].system.requiresAttunement && SN(i)
  ), c = (
    /*isGM*/
    i[5] && Kpe(i)
  ), f = (
    /*$item*/
    i[1].system.objectType == "consumable" && CN(i)
  ), d = (
    /*showVRCImplants*/
    i[8] && Ype(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), a && a.c(), s = F(), c && c.c(), n = F(), f && f.c(), l = F(), d && d.c(), r = $e();
    },
    m(p, m) {
      R(e, p, m), T(p, t, m), a && a.m(p, m), T(p, s, m), c && c.m(p, m), T(p, n, m), f && f.m(p, m), T(p, l, m), d && d.m(p, m), T(p, r, m), o = !0;
    },
    p(p, m) {
      const g = {};
      m & /*$item*/
      2 && (g.checked = /*$item*/
      p[1].system.requiresAttunement), e.$set(g), /*$item*/
      p[1].actor && /*$item*/
      p[1].system.requiresAttunement ? a ? (a.p(p, m), m & /*$item*/
      2 && w(a, 1)) : (a = SN(p), a.c(), w(a, 1), a.m(s.parentNode, s)) : a && (ae(), O(a, 1, 1, () => {
        a = null;
      }), ce()), /*isGM*/
      p[5] && c.p(p, m), /*$item*/
      p[1].system.objectType == "consumable" ? f ? (f.p(p, m), m & /*$item*/
      2 && w(f, 1)) : (f = CN(p), f.c(), w(f, 1), f.m(l.parentNode, l)) : f && (ae(), O(f, 1, 1, () => {
        f = null;
      }), ce()), /*showVRCImplants*/
      p[8] && d.p(p, m);
    },
    i(p) {
      o || (w(e.$$.fragment, p), w(a), w(c), w(f), w(d), o = !0);
    },
    o(p) {
      O(e.$$.fragment, p), O(a), O(c), O(f), O(d), o = !1;
    },
    d(p) {
      p && (C(t), C(s), C(n), C(l), C(r)), N(e, p), a && a.d(p), c && c.d(p), f && f.d(p), d && d.d(p);
    }
  };
}
u(Xpe, "create_default_slot_5$8");
function Jpe(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return o = new Te({
    props: {
      label: "A5E.ItemBulky",
      checked: (
        /*$item*/
        i[1].system.bulky
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_9*/
    i[19]
  ), {
    c() {
      e = E("div"), t = E("input"), n = F(), l = E("span"), l.textContent = `${K("A5E.DetailsWeightLbs")}`, r = F(), j(o.$$.fragment), b(t, "type", "number"), b(t, "data-dtype", "Number"), b(t, "name", "system.weight"), b(
        t,
        "id",
        /*appId*/
        i[3] + "-weight"
      ), t.value = s = /*$item*/
      i[1].system.weight, b(e, "class", "u-align-center u-flex u-gap-md u-w-30");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(e, n), A(e, l), T(d, r, p), R(o, d, p), a = !0, c || (f = W(
        t,
        "change",
        /*change_handler*/
        i[18]
      ), c = !0);
    },
    p(d, p) {
      (!a || p & /*$item*/
      2 && s !== (s = /*$item*/
      d[1].system.weight) && t.value !== s) && (t.value = s);
      const m = {};
      p & /*$item*/
      2 && (m.checked = /*$item*/
      d[1].system.bulky), o.$set(m);
    },
    i(d) {
      a || (w(o.$$.fragment, d), a = !0);
    },
    o(d) {
      O(o.$$.fragment, d), a = !1;
    },
    d(d) {
      d && (C(e), C(r)), N(o, d), c = !1, f();
    }
  };
}
u(Jpe, "create_default_slot_4$9");
function Zpe(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "type", "number"), b(t, "data-dtype", "Number"), b(t, "min", "0"), b(t, "max", "9999"), b(t, "name", "system.quantity"), b(t, "id", `${/*appId*/
      i[3]}-quantity`), t.value = s = /*$item*/
      i[1].system.quantity, b(e, "class", "u-w-20");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = W(
        t,
        "change",
        /*change_handler_1*/
        i[21]
      ), n = !0);
    },
    p(r, o) {
      o & /*$item*/
      2 && s !== (s = /*$item*/
      r[1].system.quantity) && t.value !== s && (t.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Zpe, "create_default_slot_3$a");
function Qpe(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "u-pl-lg"), b(t, "type", "text"), b(t, "name", "system.price"), b(t, "id", `${/*appId*/
      i[3]}-price`), t.value = s = /*$item*/
      i[1].system.price, b(e, "class", "u-align-center u-flex u-gap-md u-w-30");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = W(
        t,
        "change",
        /*change_handler_2*/
        i[22]
      ), n = !0);
    },
    p(r, o) {
      o & /*$item*/
      2 && s !== (s = /*$item*/
      r[1].system.price) && t.value !== s && (t.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Qpe, "create_default_slot_2$a");
function xpe(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "u-pl-lg"), b(e, "type", "text"), b(e, "name", "system.craftingComponents"), e.value = t = /*$item*/
      i[1].system.craftingComponents, b(e, "id", `${/*appId*/
      i[3]}-craftingComponents`);
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_3*/
        i[23]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      2 && t !== (t = /*$item*/
      l[1].system.craftingComponents) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(xpe, "create_default_slot_1$b");
function eme(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "A5E.ItemCondition",
      options: Object.entries(
        /*A5E*/
        i[4].damagedStates
      ),
      selected: (
        /*$item*/
        i[1].system.damagedState
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_11*/
    i[24]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.selected = /*$item*/
      s[1].system.damagedState), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(eme, "create_if_block_1$t");
function tme(i) {
  let e, t, s, n;
  const l = [zpe, Gpe], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[0] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(tme, "create_default_slot$u");
function sme(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.TabObjectProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[25]
          )
        }
      ],
      $$slots: { default: [tme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-heading-gap", "0.5rem"), G(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      1 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[25]
          )
        }
      ]), l & /*$$scope, $item, editMode*/
      67108867 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(sme, "create_fragment$1f");
function nme(i, e, t) {
  let s;
  const n = de("item");
  pe(i, n, (H) => t(1, s = H));
  const l = de("appId"), { A5E: r } = CONFIG, { isGM: o } = game.user;
  let a = !1, c = game.settings.get("a5e", "hideBrokenAndDamaged"), f = game.settings.get("a5e", "showVRCTechLevel"), d = game.settings.get("a5e", "showVRCImplants");
  return [
    a,
    s,
    n,
    l,
    r,
    o,
    c,
    f,
    d,
    /* @__PURE__ */ u((H) => te(s, "system.objectType", H.detail), "updateSelection_handler"),
    /* @__PURE__ */ u((H) => te(s, "system.rarity", H.detail), "updateSelection_handler_1"),
    /* @__PURE__ */ u((H) => te(s, "system.techLevel", H.detail), "updateSelection_handler_2"),
    /* @__PURE__ */ u(({ detail: H }) => te(s, "system.requiresAttunement", H), "updateSelection_handler_3"),
    /* @__PURE__ */ u(({ detail: H }) => te(s, "system.attuned", H), "updateSelection_handler_4"),
    /* @__PURE__ */ u(({ detail: H }) => te(s, "system.plotItem", H), "updateSelection_handler_5"),
    /* @__PURE__ */ u(({ detail: H }) => te(s, "system.unidentified", H), "updateSelection_handler_6"),
    /* @__PURE__ */ u(({ detail: H }) => te(s, "system.supply", H), "updateSelection_handler_7"),
    /* @__PURE__ */ u(({ detail: H }) => te(s, "system.implant", H), "updateSelection_handler_8"),
    /* @__PURE__ */ u(({ target: H }) => te(s, H.name, Number(H.value)), "change_handler"),
    /* @__PURE__ */ u(({ detail: H }) => te(s, "system.bulky", H), "updateSelection_handler_9"),
    /* @__PURE__ */ u(({ detail: H }) => te(s, "system.equippedState", parseInt(H, 10)), "updateSelection_handler_10"),
    /* @__PURE__ */ u(({ target: H }) => te(s, H.name, Number(H.value)), "change_handler_1"),
    /* @__PURE__ */ u(({ target: H }) => te(s, H.name, H.value), "change_handler_2"),
    /* @__PURE__ */ u(({ target: H }) => te(s, H.name, H.value), "change_handler_3"),
    /* @__PURE__ */ u(({ detail: H }) => te(s, "system.damagedState", parseInt(H, 10)), "updateSelection_handler_11"),
    /* @__PURE__ */ u(() => t(0, a = !a), "func")
  ];
}
u(nme, "instance$19");
const PC = class PC extends re {
  constructor(e) {
    super(), oe(this, e, nme, sme, le, {});
  }
};
u(PC, "ObjectConfiguration");
let zv = PC;
function TN(i) {
  return i.sort((e, t) => e.toLowerCase().localeCompare(t.toLowerCase()));
}
u(TN, "localeSort");
function ON(i, e, t) {
  const s = i.slice();
  return s[8] = e[t], s;
}
u(ON, "get_each_context$u");
function ime(i) {
  let e, t, s, n, l, r, o, a, c, f;
  function d(y, v) {
    return (
      /*$item*/
      y[1].system.shieldCategory ? ome : rme
    );
  }
  u(d, "select_block_type_1");
  let p = d(i), m = p(i);
  function g(y, v) {
    var k;
    return (
      /*$item*/
      (k = y[1].system.shieldProperties) != null && k.length ? cme : ame
    );
  }
  u(g, "select_block_type_2");
  let h = g(i), _ = h(i);
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.ShieldCategory")}:`, n = F(), l = E("dd"), m.c(), r = F(), o = E("div"), a = E("dt"), a.textContent = `${K("A5E.ShieldProperties")}:`, c = F(), f = E("dd"), _.c(), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(a, "class", "u-text-bold"), b(f, "class", "u-m-0 u-p-0"), b(o, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(y, v) {
      T(y, e, v), A(e, t), A(t, s), A(t, n), A(t, l), m.m(l, null), A(t, r), A(e, o), A(o, a), A(o, c), A(o, f), _.m(f, null);
    },
    p(y, v) {
      p === (p = d(y)) && m ? m.p(y, v) : (m.d(1), m = p(y), m && (m.c(), m.m(l, null))), h === (h = g(y)) && _ ? _.p(y, v) : (_.d(1), _ = h(y), _ && (_.c(), _.m(f, null)));
    },
    i: se,
    o: se,
    d(y) {
      y && C(e), m.d(), _.d();
    }
  };
}
u(ime, "create_else_block$a");
function lme(i) {
  let e, t, s, n;
  return e = new Ke({
    props: {
      heading: "A5E.ShieldCategory",
      options: Object.entries(
        /*shieldTypes*/
        i[3]
      ),
      selected: (
        /*$item*/
        i[1].system.shieldCategory
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[5]
  ), s = new tt({
    props: {
      heading: "A5E.ShieldProperties",
      options: Object.entries(
        /*shieldProperties*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[1].system.shieldProperties
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[6]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$item*/
      2 && (o.selected = /*$item*/
      l[1].system.shieldCategory), e.$set(o);
      const a = {};
      r & /*$item*/
      2 && (a.selected = /*$item*/
      l[1].system.shieldProperties), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(lme, "create_if_block$E");
function rme(i) {
  let e = K("A5E.Unknown") + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p: se,
    d(s) {
      s && C(t);
    }
  };
}
u(rme, "create_else_block_2$1");
function ome(i) {
  let e = (
    /*shieldTypes*/
    (i[3][
      /*$item*/
      i[1].system.shieldCategory
    ] ?? /*$item*/
    i[1].system.shieldCategory) + ""
  ), t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*$item*/
      2 && e !== (e = /*shieldTypes*/
      (s[3][
        /*$item*/
        s[1].system.shieldCategory
      ] ?? /*$item*/
      s[1].system.shieldCategory) + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(ome, "create_if_block_2$k");
function ame(i) {
  let e = K("A5E.None") + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p: se,
    d(s) {
      s && C(t);
    }
  };
}
u(ame, "create_else_block_1$2");
function cme(i) {
  let e, t = ue(TN(
    /*$item*/
    i[1].system.shieldProperties
  )), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = DN(ON(i, t, n));
  return {
    c() {
      e = E("ul");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "u-comma-list u-flex u-flex-shrink-0 u-gap-ch u-list-style-none u-m-0 u-p-0 u-w-fit ");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*$item, shieldProperties*/
      18) {
        t = ue(TN(
          /*$item*/
          n[1].system.shieldProperties
        ));
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = ON(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = DN(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(cme, "create_if_block_1$s");
function DN(i) {
  let e, t = (
    /*shieldProperties*/
    (i[4][
      /*property*/
      i[8]
    ] ?? /*property*/
    i[8]) + ""
  ), s, n, l;
  return {
    c() {
      e = E("li"), s = Q(t), n = F(), b(e, "key", l = /*property*/
      i[8]);
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*$item*/
      2 && t !== (t = /*shieldProperties*/
      (r[4][
        /*property*/
        r[8]
      ] ?? /*property*/
      r[8]) + "") && be(s, t), o & /*$item*/
      2 && l !== (l = /*property*/
      r[8]) && b(e, "key", l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(DN, "create_each_block$u");
function ume(i) {
  let e, t, s, n;
  const l = [lme, ime], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[0] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(ume, "create_default_slot$t");
function fme(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.ShieldConfiguration",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[7]
          )
        }
      ],
      $$slots: { default: [ume] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-heading-gap", "0.5rem"), G(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      1 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[7]
          )
        }
      ]), l & /*$$scope, $item, editMode*/
      2051 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(fme, "create_fragment$1e");
function dme(i, e, t) {
  let s;
  const n = de("item");
  pe(i, n, (d) => t(1, s = d));
  let l = !1;
  const { shieldTypes: r, shieldProperties: o } = CONFIG.A5E;
  return [
    l,
    s,
    n,
    r,
    o,
    /* @__PURE__ */ u((d) => te(s, "system.shieldCategory", d.detail), "updateSelection_handler"),
    /* @__PURE__ */ u((d) => te(s, "system.shieldProperties", d.detail), "updateSelection_handler_1"),
    /* @__PURE__ */ u(() => t(0, l = !l), "func")
  ];
}
u(dme, "instance$18");
const MC = class MC extends re {
  constructor(e) {
    super(), oe(this, e, dme, fme, le, {});
  }
};
u(MC, "ShieldConfiguration");
let Hv = MC;
function IN(i, e, t) {
  const s = i.slice();
  return s[29] = e[t][0], s[30] = e[t][1], s;
}
u(IN, "get_each_context$t");
function pme(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [gme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$item, selectedSpellComponents, selectedSecondarySpellSchools*/
      13 | n[1] & /*$$scope*/
      4 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(pme, "create_else_block$9");
function mme(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v;
  e = new tt({
    props: {
      heading: "Classes",
      hint: "Select the classes that are eligible to select this spell.",
      options: Object.entries(
        /*classSpellLists*/
        i[6]
      ),
      selected: (
        /*$item*/
        i[0].system.classes
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), s = new Ke({
    props: {
      heading: "A5E.SpellLevel",
      options: QB(
        /*spellLevels*/
        i[9]
      ),
      selected: (
        /*$item*/
        i[0].system.level
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), l = new Ke({
    props: {
      heading: "A5E.SpellSchoolPrimary",
      options: Object.entries(
        /*spellSchools*/
        i[10].primary
      ),
      selected: (
        /*$item*/
        i[0].system.schools.primary
      )
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[14]
  );
  let k = (
    /*showVRCPsionicDisciplines*/
    i[11] && bme(i)
  );
  a = new tt({
    props: {
      heading: "A5E.SpellSchoolSecondaryPlural",
      options: Object.entries(
        /*spellSchools*/
        i[10].secondary
      ),
      selected: (
        /*$item*/
        i[0].system.schools.secondary
      )
    }
  }), a.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[16]
  ), f = new ie({
    props: {
      heading: "A5E.SpellComponents",
      $$slots: { default: [_me] },
      $$scope: { ctx: i }
    }
  });
  let S = (
    /*$item*/
    i[0].system.components.material && FN(i)
  );
  return m = new De({
    props: {
      $$slots: { default: [vme] },
      $$scope: { ctx: i }
    }
  }), _ = new De({
    props: {
      $$slots: { default: [wme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), k && k.c(), o = F(), j(a.$$.fragment), c = F(), j(f.$$.fragment), d = F(), S && S.c(), p = F(), g = E("div"), j(m.$$.fragment), h = F(), y = E("div"), j(_.$$.fragment), G(g, "display", "contents"), G(g, "--a5e-section-body-direction", "row"), G(g, "--a5e-section-body-gap", "0.75rem"), G(y, "display", "contents"), G(y, "--a5e-section-body-direction", "row"), G(y, "--a5e-section-body-gap", "0.75rem");
    },
    m(D, I) {
      R(e, D, I), T(D, t, I), R(s, D, I), T(D, n, I), R(l, D, I), T(D, r, I), k && k.m(D, I), T(D, o, I), R(a, D, I), T(D, c, I), R(f, D, I), T(D, d, I), S && S.m(D, I), T(D, p, I), T(D, g, I), R(m, g, null), T(D, h, I), T(D, y, I), R(_, y, null), v = !0;
    },
    p(D, I) {
      const M = {};
      I[0] & /*$item*/
      1 && (M.selected = /*$item*/
      D[0].system.classes), e.$set(M);
      const L = {};
      I[0] & /*$item*/
      1 && (L.selected = /*$item*/
      D[0].system.level), s.$set(L);
      const B = {};
      I[0] & /*$item*/
      1 && (B.selected = /*$item*/
      D[0].system.schools.primary), l.$set(B), /*showVRCPsionicDisciplines*/
      D[11] && k.p(D, I);
      const z = {};
      I[0] & /*$item*/
      1 && (z.selected = /*$item*/
      D[0].system.schools.secondary), a.$set(z);
      const q = {};
      I[0] & /*$item*/
      1 | I[1] & /*$$scope*/
      4 && (q.$$scope = { dirty: I, ctx: D }), f.$set(q), /*$item*/
      D[0].system.components.material ? S ? (S.p(D, I), I[0] & /*$item*/
      1 && w(S, 1)) : (S = FN(D), S.c(), w(S, 1), S.m(p.parentNode, p)) : S && (ae(), O(S, 1, 1, () => {
        S = null;
      }), ce());
      const U = {};
      I[0] & /*$item*/
      1 | I[1] & /*$$scope*/
      4 && (U.$$scope = { dirty: I, ctx: D }), m.$set(U);
      const H = {};
      I[0] & /*$item*/
      1 | I[1] & /*$$scope*/
      4 && (H.$$scope = { dirty: I, ctx: D }), _.$set(H);
    },
    i(D) {
      v || (w(e.$$.fragment, D), w(s.$$.fragment, D), w(l.$$.fragment, D), w(k), w(a.$$.fragment, D), w(f.$$.fragment, D), w(S), w(m.$$.fragment, D), w(_.$$.fragment, D), v = !0);
    },
    o(D) {
      O(e.$$.fragment, D), O(s.$$.fragment, D), O(l.$$.fragment, D), O(k), O(a.$$.fragment, D), O(f.$$.fragment, D), O(S), O(m.$$.fragment, D), O(_.$$.fragment, D), v = !1;
    },
    d(D) {
      D && (C(t), C(n), C(r), C(o), C(c), C(d), C(p), C(h)), N(e, D), N(s, D), N(l, D), k && k.d(D), N(a, D), N(f, D), S && S.d(D), D && m && C(g), N(m, D), D && _ && C(y), N(_, D);
    }
  };
}
u(mme, "create_if_block$D");
function hme(i) {
  let e, t, s, n, l = (K(
    /*psionicDisciplines*/
    i[7][
      /*$item*/
      i[0].system.discipline
    ]
  ) || K("A5E.None")) + "", r, o;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = `${K("A5E.PsionicDiscipline")}:`, s = F(), n = E("dd"), r = Q(l), o = F(), b(t, "class", "summary-list__label svelte-159ccn2"), b(n, "class", "summary-list__value svelte-159ccn2"), b(e, "class", "summary-list__item svelte-159ccn2");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, s), A(e, n), A(n, r), A(e, o);
    },
    p(a, c) {
      c[0] & /*$item*/
      1 && l !== (l = (K(
        /*psionicDisciplines*/
        a[7][
          /*$item*/
          a[0].system.discipline
        ]
      ) || K("A5E.None")) + "") && be(r, l);
    },
    d(a) {
      a && C(e);
    }
  };
}
u(hme, "create_if_block_6$8");
function PN(i) {
  let e, t, s, n, l = (
    /*$item*/
    i[0].system.materials + ""
  ), r;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = `${K("A5E.SpellMaterials")}:`, s = F(), n = E("dd"), r = Q(l), b(t, "class", "summary-list__label svelte-159ccn2"), b(n, "class", "summary-list__value svelte-159ccn2"), b(e, "class", "summary-list__item svelte-159ccn2");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(e, n), A(n, r);
    },
    p(o, a) {
      a[0] & /*$item*/
      1 && l !== (l = /*$item*/
      o[0].system.materials + "") && be(r, l);
    },
    d(o) {
      o && C(e);
    }
  };
}
u(PN, "create_if_block_5$9");
function gme(i) {
  let e, t, s, n, l, r = (
    /*spellLevels*/
    i[9][
      /*$item*/
      i[0].system.level
    ] + ""
  ), o, a, c, f, d, p, m = (
    /*spellSchools*/
    (i[10].primary[
      /*$item*/
      i[0].system.schools.primary
    ] || K("A5E.None")) + ""
  ), g, h, _, y, v, k, S = (
    /*selectedSecondarySpellSchools*/
    (i[2] || K("A5E.None")) + ""
  ), D, I, M, L, B, z, q, U = (
    /*selectedSpellComponents*/
    (i[3] || K("A5E.None")) + ""
  ), H, V, Y = (
    /*showVRCPsionicDisciplines*/
    i[11] && hme(i)
  ), J = (
    /*$item*/
    i[0].system.components.material && /*$item*/
    i[0].system.materials && PN(i)
  );
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.SpellLevel")}:`, n = F(), l = E("dd"), o = Q(r), a = F(), c = E("div"), f = E("dt"), f.textContent = `${K("A5E.SpellSchoolPrimary")}:`, d = F(), p = E("dd"), g = Q(m), h = F(), _ = E("div"), y = E("dt"), y.textContent = `${K("A5E.SpellSchoolSecondaryPlural")}:`, v = F(), k = E("dd"), D = Q(S), I = F(), Y && Y.c(), M = E("hr"), L = E("div"), B = E("dt"), B.textContent = `${K("A5E.SpellComponents")}:`, z = F(), q = E("dd"), H = Q(U), V = F(), J && J.c(), b(s, "class", "summary-list__label svelte-159ccn2"), b(l, "class", "summary-list__value svelte-159ccn2"), b(t, "class", "summary-list__item svelte-159ccn2"), b(f, "class", "summary-list__label svelte-159ccn2"), b(p, "class", "summary-list__value svelte-159ccn2"), b(c, "class", "summary-list__item svelte-159ccn2"), b(y, "class", "summary-list__label svelte-159ccn2"), b(k, "class", "summary-list__value svelte-159ccn2"), b(_, "class", "summary-list__item svelte-159ccn2"), b(M, "class", "a5e-rule u-my-sm"), b(B, "class", "summary-list__label svelte-159ccn2"), b(q, "class", "summary-list__value svelte-159ccn2"), b(L, "class", "summary-list__item svelte-159ccn2"), b(e, "class", "summary-list svelte-159ccn2");
    },
    m(fe, ke) {
      T(fe, e, ke), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o), A(t, a), A(e, c), A(c, f), A(c, d), A(c, p), A(p, g), A(c, h), A(e, _), A(_, y), A(_, v), A(_, k), A(k, D), A(_, I), Y && Y.m(e, null), A(e, M), A(e, L), A(L, B), A(L, z), A(L, q), A(q, H), A(L, V), J && J.m(e, null);
    },
    p(fe, ke) {
      ke[0] & /*$item*/
      1 && r !== (r = /*spellLevels*/
      fe[9][
        /*$item*/
        fe[0].system.level
      ] + "") && be(o, r), ke[0] & /*$item*/
      1 && m !== (m = /*spellSchools*/
      (fe[10].primary[
        /*$item*/
        fe[0].system.schools.primary
      ] || K("A5E.None")) + "") && be(g, m), ke[0] & /*selectedSecondarySpellSchools*/
      4 && S !== (S = /*selectedSecondarySpellSchools*/
      (fe[2] || K("A5E.None")) + "") && be(D, S), /*showVRCPsionicDisciplines*/
      fe[11] && Y.p(fe, ke), ke[0] & /*selectedSpellComponents*/
      8 && U !== (U = /*selectedSpellComponents*/
      (fe[3] || K("A5E.None")) + "") && be(H, U), /*$item*/
      fe[0].system.components.material && /*$item*/
      fe[0].system.materials ? J ? J.p(fe, ke) : (J = PN(fe), J.c(), J.m(e, null)) : J && (J.d(1), J = null);
    },
    d(fe) {
      fe && C(e), Y && Y.d(), J && J.d();
    }
  };
}
u(gme, "create_default_slot_6$6");
function bme(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "A5E.PsionicDiscipline",
      options: Object.entries(
        /*psionicDisciplines*/
        i[7]
      ),
      selected: (
        /*$item*/
        i[0].system.discipline
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[15]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.discipline), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(bme, "create_if_block_4$c");
function MN(i) {
  let e, t;
  function s() {
    return (
      /*tagToggle_handler*/
      i[17](
        /*value*/
        i[29]
      )
    );
  }
  return u(s, "tagToggle_handler"), e = new po({
    props: {
      label: (
        /*label*/
        i[30]
      ),
      value: (
        /*value*/
        i[29]
      ),
      active: (
        /*$item*/
        i[0].system.components[
          /*value*/
          i[29]
        ]
      )
    }
  }), e.$on("tagToggle", s), {
    c() {
      j(e.$$.fragment);
    },
    m(n, l) {
      R(e, n, l), t = !0;
    },
    p(n, l) {
      i = n;
      const r = {};
      l[0] & /*$item*/
      1 && (r.active = /*$item*/
      i[0].system.components[
        /*value*/
        i[29]
      ]), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      O(e.$$.fragment, n), t = !1;
    },
    d(n) {
      N(e, n);
    }
  };
}
u(MN, "create_each_block$t");
function _me(i) {
  let e, t, s = ue(Object.entries(
    /*spellComponents*/
    i[8]
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = MN(IN(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "u-flex u-flex-wrap u-gap-sm u-list-style-none u-m-0 u-p-0 u-text-xs u-w-full");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o[0] & /*spellComponents, $item*/
      257) {
        s = ue(Object.entries(
          /*spellComponents*/
          r[8]
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = IN(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = MN(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(_me, "create_default_slot_5$7");
function FN(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.SpellMaterials",
      $$slots: { default: [yme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$item*/
      1 | n[1] & /*$$scope*/
      4 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(FN, "create_if_block_3$c");
function yme(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "name", "system.materials"), e.value = t = /*$item*/
      i[0].system.materials;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[18]
      ), s = !0);
    },
    p(l, r) {
      r[0] & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.materials) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(yme, "create_default_slot_4$8");
function RN(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Always Prepared",
      checked: Number(
        /*$item*/
        i[0].system.prepared ?? 0
      ) === /*PREPARED_STATES*/
      i[5].ALWAYS_PREPARED
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[21]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$item*/
      1 && (l.checked = Number(
        /*$item*/
        s[0].system.prepared ?? 0
      ) === /*PREPARED_STATES*/
      s[5].ALWAYS_PREPARED), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(RN, "create_if_block_2$j");
function NN(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.SpellRitual",
      checked: (
        /*$item*/
        i[0].system.ritual
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_8*/
    i[22]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$item*/
      1 && (l.checked = /*$item*/
      s[0].system.ritual), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(NN, "create_if_block_1$r");
function vme(i) {
  let e, t, s, n, l, r, o, a;
  e = new Te({
    props: {
      label: "A5E.SpellConcentration",
      checked: (
        /*$item*/
        i[0].system.concentration
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[19]
  ), s = new Te({
    props: {
      label: "A5E.ItemPrepared",
      checked: (
        /*$item*/
        i[0].system.prepared
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[20]
  );
  let c = (
    /*$item*/
    i[0].system.prepared && RN(i)
  ), f = (
    /*$item*/
    i[0].system.level > 0 && NN(i)
  );
  return o = new Te({
    props: {
      label: "A5E.SpellRare",
      checked: (
        /*$item*/
        i[0].system.rare
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_9*/
    i[23]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), c && c.c(), l = F(), f && f.c(), r = F(), j(o.$$.fragment);
    },
    m(d, p) {
      R(e, d, p), T(d, t, p), R(s, d, p), T(d, n, p), c && c.m(d, p), T(d, l, p), f && f.m(d, p), T(d, r, p), R(o, d, p), a = !0;
    },
    p(d, p) {
      const m = {};
      p[0] & /*$item*/
      1 && (m.checked = /*$item*/
      d[0].system.concentration), e.$set(m);
      const g = {};
      p[0] & /*$item*/
      1 && (g.checked = /*$item*/
      d[0].system.prepared), s.$set(g), /*$item*/
      d[0].system.prepared ? c ? (c.p(d, p), p[0] & /*$item*/
      1 && w(c, 1)) : (c = RN(d), c.c(), w(c, 1), c.m(l.parentNode, l)) : c && (ae(), O(c, 1, 1, () => {
        c = null;
      }), ce()), /*$item*/
      d[0].system.level > 0 ? f ? (f.p(d, p), p[0] & /*$item*/
      1 && w(f, 1)) : (f = NN(d), f.c(), w(f, 1), f.m(r.parentNode, r)) : f && (ae(), O(f, 1, 1, () => {
        f = null;
      }), ce());
      const h = {};
      p[0] & /*$item*/
      1 && (h.checked = /*$item*/
      d[0].system.rare), o.$set(h);
    },
    i(d) {
      a || (w(e.$$.fragment, d), w(s.$$.fragment, d), w(c), w(f), w(o.$$.fragment, d), a = !0);
    },
    o(d) {
      O(e.$$.fragment, d), O(s.$$.fragment, d), O(c), O(f), O(o.$$.fragment, d), a = !1;
    },
    d(d) {
      d && (C(t), C(n), C(l), C(r)), N(e, d), N(s, d), c && c.d(d), f && f.d(d), N(o, d);
    }
  };
}
u(vme, "create_default_slot_3$9");
function kme(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.RequiresBloodied",
      checked: (
        /*$item*/
        i[0].system.requiresBloodied
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_10*/
    i[24]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$item*/
      1 && (l.checked = /*$item*/
      s[0].system.requiresBloodied), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(kme, "create_default_slot_2$9");
function wme(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [kme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$item*/
      1 | n[1] & /*$$scope*/
      4 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(wme, "create_default_slot_1$a");
function $me(i) {
  let e, t, s, n;
  const l = [mme, pme], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[1] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u($me, "create_default_slot$s");
function Ame(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.TabSpellConfiguration",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[25]
          )
        }
      ],
      $$slots: { default: [$me] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-heading-gap", "0.5rem"), G(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l[0] & /*editMode*/
      2 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[25]
          )
        }
      ]), l[0] & /*$item, editMode, selectedSpellComponents, selectedSecondarySpellSchools*/
      15 | l[1] & /*$$scope*/
      4 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Ame, "create_fragment$1d");
function Eme(i, e, t) {
  let s, n, l;
  function r(J) {
    return Object.entries(J.system.components).filter(([fe, ke]) => ke).map(([fe]) => m[fe] ?? fe).join(", ");
  }
  u(r, "prepareSpellComponents");
  function o(J) {
    const fe = J.system.schools.secondary.map((ke) => h.secondary[ke] ?? ke);
    return fe.sort((ke, ee) => ke.localeCompare(ee)), fe.join(", ");
  }
  u(o, "prepareSecondarySpellSchools");
  const a = de("item");
  pe(i, a, (J) => t(0, l = J));
  const { PREPARED_STATES: c, classSpellLists: f, psionicDisciplines: d, spellComponents: p, spellComponentAbbreviations: m, spellLevels: g, spellSchools: h } = CONFIG.A5E;
  let _ = !1, y = game.settings.get("a5e", "showVRCPsionicDisciplines");
  const v = /* @__PURE__ */ u((J) => te(l, "system.classes", J.detail), "updateSelection_handler"), k = /* @__PURE__ */ u((J) => te(l, "system.level", J.detail), "updateSelection_handler_1"), S = /* @__PURE__ */ u((J) => te(l, "system.schools.primary", J.detail), "updateSelection_handler_2"), D = /* @__PURE__ */ u((J) => te(l, "system.discipline", J.detail), "updateSelection_handler_3"), I = /* @__PURE__ */ u((J) => te(l, "system.schools.secondary", J.detail), "updateSelection_handler_4"), M = /* @__PURE__ */ u((J) => te(l, `system.components.${J}`, !l.system.components[J]), "tagToggle_handler"), L = /* @__PURE__ */ u(({ target: J }) => te(l, J.name, J.value), "change_handler"), B = /* @__PURE__ */ u(({ detail: J }) => {
    te(l, "system.concentration", J);
  }, "updateSelection_handler_5"), z = /* @__PURE__ */ u(({ detail: J }) => {
    te(l, "system.prepared", J);
  }, "updateSelection_handler_6"), q = /* @__PURE__ */ u(({ detail: J }) => {
    te(l, "system.prepared", J ? 2 : 1);
  }, "updateSelection_handler_7"), U = /* @__PURE__ */ u(({ detail: J }) => {
    te(l, "system.ritual", J);
  }, "updateSelection_handler_8"), H = /* @__PURE__ */ u(({ detail: J }) => {
    te(l, "system.rare", J);
  }, "updateSelection_handler_9"), V = /* @__PURE__ */ u(({ detail: J }) => {
    te(l, "system.requiresBloodied", J);
  }, "updateSelection_handler_10"), Y = /* @__PURE__ */ u(() => t(1, _ = !_), "func");
  return i.$$.update = () => {
    i.$$.dirty[0] & /*$item*/
    1 && t(3, s = r(l)), i.$$.dirty[0] & /*$item*/
    1 && t(2, n = o(l));
  }, [
    l,
    _,
    n,
    s,
    a,
    c,
    f,
    d,
    p,
    g,
    h,
    y,
    v,
    k,
    S,
    D,
    I,
    M,
    L,
    B,
    z,
    q,
    U,
    H,
    V,
    Y
  ];
}
u(Eme, "instance$17");
const FC = class FC extends re {
  constructor(e) {
    super(), oe(this, e, Eme, Ame, le, {}, null, [-1, -1]);
  }
};
u(FC, "SpellConfiguration");
let Uv = FC;
function Sme(i) {
  const { energyProperties: e, weaponAugments: t } = CONFIG.A5E;
  if (i.system.energyProperties) {
    const s = e[i.system.energyProperties];
    return K("A5E.weaponAugments.energySpecific", { type: s });
  }
  return t.energy;
}
u(Sme, "getEnergyProperties");
function Cme(i) {
  const { weaponAugments: e } = CONFIG.A5E;
  return i.system.weaponAugments.map((t) => {
    switch (t) {
      case "energy":
        return Sme(i);
      default:
        return K(e[t]) ?? null;
    }
  }).filter(Boolean);
}
u(Cme, "getWeaponAugments");
function Tme(i) {
  let e, t, s, n, l, r = (
    /*selectedWeaponProperties*/
    (i[3] || K("A5E.None")) + ""
  ), o, a, c = (
    /*selectedWeaponAugments*/
    i[2] && jN(i)
  );
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.WeaponProperties")}:`, n = F(), l = E("dd"), o = Q(r), a = F(), c && c.c(), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(f, d) {
      T(f, e, d), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o), A(t, a), c && c.m(e, null);
    },
    p(f, d) {
      d & /*selectedWeaponProperties*/
      8 && r !== (r = /*selectedWeaponProperties*/
      (f[3] || K("A5E.None")) + "") && be(o, r), /*selectedWeaponAugments*/
      f[2] ? c ? c.p(f, d) : (c = jN(f), c.c(), c.m(e, null)) : c && (c.d(1), c = null);
    },
    i: se,
    o: se,
    d(f) {
      f && C(e), c && c.d();
    }
  };
}
u(Tme, "create_else_block$8");
function Ome(i) {
  let e, t, s, n, l = (
    /*$item*/
    i[0].system.weaponProperties.includes("breaker")
  ), r, o = (
    /*$item*/
    i[0].system.weaponProperties.includes("defensive")
  ), a, c = (
    /*$item*/
    i[0].system.weaponAugments.includes("energy")
  ), f, d = (
    /*$item*/
    i[0].system.weaponProperties.includes("mounted")
  ), p, m = (
    /*$item*/
    i[0].system.weaponProperties.includes("versatile")
  ), g, h;
  e = new tt({
    props: {
      heading: "A5E.WeaponProperties",
      options: Object.entries(
        /*weaponProperties*/
        i[10]
      ),
      selected: (
        /*$item*/
        i[0].system.weaponProperties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[11]
  ), s = new tt({
    props: {
      heading: "A5E.WeaponAugments",
      options: Object.entries(
        /*weaponAugments*/
        i[9]
      ),
      selected: (
        /*$item*/
        i[0].system.weaponAugments
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[12]
  );
  let _ = l && LN(i), y = o && BN(i), v = c && qN(i), k = d && GN(i), S = m && zN(i);
  return {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), _ && _.c(), r = F(), y && y.c(), a = F(), v && v.c(), f = F(), k && k.c(), p = F(), S && S.c(), g = $e();
    },
    m(D, I) {
      R(e, D, I), T(D, t, I), R(s, D, I), T(D, n, I), _ && _.m(D, I), T(D, r, I), y && y.m(D, I), T(D, a, I), v && v.m(D, I), T(D, f, I), k && k.m(D, I), T(D, p, I), S && S.m(D, I), T(D, g, I), h = !0;
    },
    p(D, I) {
      const M = {};
      I & /*$item*/
      1 && (M.selected = /*$item*/
      D[0].system.weaponProperties), e.$set(M);
      const L = {};
      I & /*$item*/
      1 && (L.selected = /*$item*/
      D[0].system.weaponAugments), s.$set(L), I & /*$item*/
      1 && (l = /*$item*/
      D[0].system.weaponProperties.includes("breaker")), l ? _ ? (_.p(D, I), I & /*$item*/
      1 && w(_, 1)) : (_ = LN(D), _.c(), w(_, 1), _.m(r.parentNode, r)) : _ && (ae(), O(_, 1, 1, () => {
        _ = null;
      }), ce()), I & /*$item*/
      1 && (o = /*$item*/
      D[0].system.weaponProperties.includes("defensive")), o ? y ? (y.p(D, I), I & /*$item*/
      1 && w(y, 1)) : (y = BN(D), y.c(), w(y, 1), y.m(a.parentNode, a)) : y && (ae(), O(y, 1, 1, () => {
        y = null;
      }), ce()), I & /*$item*/
      1 && (c = /*$item*/
      D[0].system.weaponAugments.includes("energy")), c ? v ? (v.p(D, I), I & /*$item*/
      1 && w(v, 1)) : (v = qN(D), v.c(), w(v, 1), v.m(f.parentNode, f)) : v && (ae(), O(v, 1, 1, () => {
        v = null;
      }), ce()), I & /*$item*/
      1 && (d = /*$item*/
      D[0].system.weaponProperties.includes("mounted")), d ? k ? (k.p(D, I), I & /*$item*/
      1 && w(k, 1)) : (k = GN(D), k.c(), w(k, 1), k.m(p.parentNode, p)) : k && (ae(), O(k, 1, 1, () => {
        k = null;
      }), ce()), I & /*$item*/
      1 && (m = /*$item*/
      D[0].system.weaponProperties.includes("versatile")), m ? S ? (S.p(D, I), I & /*$item*/
      1 && w(S, 1)) : (S = zN(D), S.c(), w(S, 1), S.m(g.parentNode, g)) : S && (ae(), O(S, 1, 1, () => {
        S = null;
      }), ce());
    },
    i(D) {
      h || (w(e.$$.fragment, D), w(s.$$.fragment, D), w(_), w(y), w(v), w(k), w(S), h = !0);
    },
    o(D) {
      O(e.$$.fragment, D), O(s.$$.fragment, D), O(_), O(y), O(v), O(k), O(S), h = !1;
    },
    d(D) {
      D && (C(t), C(n), C(r), C(a), C(f), C(p), C(g)), N(e, D), N(s, D), _ && _.d(D), y && y.d(D), v && v.d(D), k && k.d(D), S && S.d(D);
    }
  };
}
u(Ome, "create_if_block$C");
function jN(i) {
  let e, t, s, n, l = (
    /*selectedWeaponAugments*/
    (i[2] || K("A5E.None")) + ""
  ), r;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = `${K("A5E.WeaponAugments")}:`, s = F(), n = E("dd"), r = Q(l), b(t, "class", "u-text-bold"), b(n, "class", "u-m-0 u-p-0"), b(e, "class", "u-flex u-gap-md");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(e, n), A(n, r);
    },
    p(o, a) {
      a & /*selectedWeaponAugments*/
      4 && l !== (l = /*selectedWeaponAugments*/
      (o[2] || K("A5E.None")) + "") && be(r, l);
    },
    d(o) {
      o && C(e);
    }
  };
}
u(jN, "create_if_block_6$7");
function LN(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Breaker Property",
      options: Object.entries(
        /*breakerProperties*/
        i[5]
      ),
      selected: (
        /*$item*/
        i[0].system.breakerProperties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[13]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.breakerProperties), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(LN, "create_if_block_5$8");
function BN(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "Defensive Property",
      options: Object.entries(
        /*defensiveProperties*/
        i[6]
      ),
      selected: (
        /*$item*/
        i[0].system.defensiveProperties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[14]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.defensiveProperties), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(BN, "create_if_block_4$b");
function qN(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "Energy Property",
      options: Object.entries(
        /*energyProperties*/
        i[7]
      ),
      selected: (
        /*$item*/
        i[0].system.energyProperties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[15]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.energyProperties), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(qN, "create_if_block_3$b");
function GN(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Mounted Property",
      options: Object.entries(
        /*versatileOptions*/
        i[8]
      ),
      selected: (
        /*$item*/
        i[0].system.mounted
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.mounted), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(GN, "create_if_block_2$i");
function zN(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "Versatile Property",
      options: Object.entries(
        /*versatileOptions*/
        i[8]
      ),
      selected: (
        /*$item*/
        i[0].system.versatile
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.versatile), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(zN, "create_if_block_1$q");
function Dme(i) {
  let e, t, s, n;
  const l = [Ome, Tme], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[1] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(Dme, "create_default_slot$r");
function Ime(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.TabWeaponProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[18]
          )
        }
      ],
      $$slots: { default: [Dme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-heading-gap", "0.5rem"), G(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      2 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[18]
          )
        }
      ]), l & /*$$scope, $item, editMode, selectedWeaponAugments, selectedWeaponProperties*/
      524303 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Ime, "create_fragment$1c");
function Pme(i, e, t) {
  let s, n, l;
  const r = de("item");
  pe(i, r, (I) => t(0, l = I));
  const { breakerProperties: o, defensiveProperties: a, energyProperties: c, versatileOptions: f, weaponAugments: d, weaponProperties: p } = CONFIG.A5E;
  let m = !1;
  const g = /* @__PURE__ */ u((I) => te(l, "system.weaponProperties", I.detail), "updateSelection_handler"), h = /* @__PURE__ */ u((I) => te(l, "system.weaponAugments", I.detail), "updateSelection_handler_1"), _ = /* @__PURE__ */ u((I) => te(l, "system.breakerProperties", I.detail), "updateSelection_handler_2"), y = /* @__PURE__ */ u((I) => te(l, "system.defensiveProperties", I.detail), "updateSelection_handler_3"), v = /* @__PURE__ */ u((I) => te(l, "system.energyProperties", I.detail), "updateSelection_handler_4"), k = /* @__PURE__ */ u((I) => te(l, "system.mounted", I.detail), "updateSelection_handler_5"), S = /* @__PURE__ */ u((I) => te(l, "system.versatile", I.detail), "updateSelection_handler_6"), D = /* @__PURE__ */ u(() => t(1, m = !m), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(3, s = H9(l).filter(Boolean).join(", ")), i.$$.dirty & /*$item*/
    1 && t(2, n = Cme(l).filter(Boolean).join(", "));
  }, [
    l,
    m,
    n,
    s,
    r,
    o,
    a,
    c,
    f,
    d,
    p,
    g,
    h,
    _,
    y,
    v,
    k,
    S,
    D
  ];
}
u(Pme, "instance$16");
const RC = class RC extends re {
  constructor(e) {
    super(), oe(this, e, Pme, Ime, le, {});
  }
};
u(RC, "WeaponConfiguration");
let Vv = RC;
function HN(i, e, t) {
  const s = i.slice();
  return s[13] = e[t][0], s[14] = e[t][1], s;
}
u(HN, "get_each_context$s");
function Mme(i) {
  let e, t, s, n = (
    /*usesSummary*/
    (i[3] || K("A5E.None")) + ""
  ), l, r;
  return {
    c() {
      e = E("dl"), t = E("dt"), t.textContent = `${K("A5E.Uses")}:`, s = E("dd"), l = Q(n), b(t, "class", "u-text-bold"), b(s, "class", "align-center u-flex u-gap-sm u-m-0 u-p-0"), b(s, "data-tooltip", r = /*$item*/
      i[0].system.uses.per === "recharge" ? (
        /*$item*/
        i[0].system.uses.recharge.formula
      ) : null), b(s, "data-tooltip-direction", "UP"), b(e, "class", "a5e-box u-flex u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(s, l);
    },
    p(o, a) {
      a & /*usesSummary*/
      8 && n !== (n = /*usesSummary*/
      (o[3] || K("A5E.None")) + "") && be(l, n), a & /*$item*/
      1 && r !== (r = /*$item*/
      o[0].system.uses.per === "recharge" ? (
        /*$item*/
        o[0].system.uses.recharge.formula
      ) : null) && b(s, "data-tooltip", r);
    },
    i: se,
    o: se,
    d(o) {
      o && C(e);
    }
  };
}
u(Mme, "create_else_block$7");
function Fme(i) {
  let e, t, s, n, l;
  e = new De({
    props: {
      $$slots: { default: [Lme] },
      $$scope: { ctx: i }
    }
  });
  let r = (
    /*$item*/
    i[0].system.uses.per === "recharge" && WN(i)
  );
  return {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), r && r.c(), n = $e(), G(t, "display", "contents"), G(t, "--a5e-section-body-direction", "row"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, $item, isClassResource*/
      131077 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c), /*$item*/
      o[0].system.uses.per === "recharge" ? r ? (r.p(o, a), a & /*$item*/
      1 && w(r, 1)) : (r = WN(o), r.c(), w(r, 1), r.m(n.parentNode, n)) : r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce());
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(r), l = !1;
    },
    d(o) {
      o && (C(s), C(n)), o && e && C(t), N(e, o), r && r.d(o);
    }
  };
}
u(Fme, "create_if_block$B");
function UN(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "A5E.UsesCurrent",
      $$slots: { default: [Rme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $item*/
      131073 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(UN, "create_if_block_2$h");
function Rme(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "number"), b(e, "d-type", "Number"), b(e, "name", "system.uses.value"), e.value = t = /*$item*/
      i[0].system.uses.value;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.uses.value) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Rme, "create_default_slot_7$5");
function Nme(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "name", "system.uses.max"), e.value = t = /*$item*/
      i[0].system.uses.max;
    },
    m(l, r) {
      T(l, e, r), s || (n = W(
        e,
        "change",
        /*change_handler_1*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.uses.max) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Nme, "create_default_slot_6$5");
function VN(i) {
  let e, t = K(
    /*name*/
    i[14]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = Q(t), n = F(), b(
        e,
        "key",
        /*key*/
        i[13]
      ), e.__value = /*key*/
      i[13], He(e, e.__value), e.selected = l = /*$item*/
      i[0].system.uses.per === /*key*/
      i[13];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*$item*/
      1 && l !== (l = /*$item*/
      r[0].system.uses.per === /*key*/
      r[13]) && (e.selected = l);
    },
    d(r) {
      r && C(e);
    }
  };
}
u(VN, "create_each_block$s");
function jme(i) {
  let e, t, s, n, l = ue(Object.entries(
    /*resourceRecoveryOptions*/
    i[5]
  )), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = VN(HN(i, l, o));
  return {
    c() {
      e = E("select"), t = E("option");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      t.__value = "", He(t, t.__value), b(e, "class", "u-h-8 u-w-40"), b(e, "name", "system.uses.per");
    },
    m(o, a) {
      T(o, e, a), A(e, t);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(e, null);
      s || (n = W(
        e,
        "change",
        /*change_handler_2*/
        i[8]
      ), s = !0);
    },
    p(o, a) {
      if (a & /*Object, resourceRecoveryOptions, $item*/
      33) {
        l = ue(Object.entries(
          /*resourceRecoveryOptions*/
          o[5]
        ));
        let c;
        for (c = 0; c < l.length; c += 1) {
          const f = HN(o, l, c);
          r[c] ? r[c].p(f, a) : (r[c] = VN(f), r[c].c(), r[c].m(e, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
    },
    d(o) {
      o && C(e), Le(r, o), s = !1, n();
    }
  };
}
u(jme, "create_default_slot_5$6");
function Lme(i) {
  let e, t, s, n, l, r = !/*isClassResource*/
  i[2] && UN(i);
  return t = new ie({
    props: {
      heading: "A5E.UsesMax",
      $$slots: { default: [Nme] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      heading: "A5E.UsesPer",
      $$slots: { default: [jme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      r && r.c(), e = F(), j(t.$$.fragment), s = F(), j(n.$$.fragment);
    },
    m(o, a) {
      r && r.m(o, a), T(o, e, a), R(t, o, a), T(o, s, a), R(n, o, a), l = !0;
    },
    p(o, a) {
      /*isClassResource*/
      o[2] ? r && (ae(), O(r, 1, 1, () => {
        r = null;
      }), ce()) : r ? (r.p(o, a), a & /*isClassResource*/
      4 && w(r, 1)) : (r = UN(o), r.c(), w(r, 1), r.m(e.parentNode, e));
      const c = {};
      a & /*$$scope, $item*/
      131073 && (c.$$scope = { dirty: a, ctx: o }), t.$set(c);
      const f = {};
      a & /*$$scope, $item*/
      131073 && (f.$$scope = { dirty: a, ctx: o }), n.$set(f);
    },
    i(o) {
      l || (w(r), w(t.$$.fragment, o), w(n.$$.fragment, o), l = !0);
    },
    o(o) {
      O(r), O(t.$$.fragment, o), O(n.$$.fragment, o), l = !1;
    },
    d(o) {
      o && (C(e), C(s)), r && r.d(o), N(t, o), N(n, o);
    }
  };
}
u(Lme, "create_default_slot_4$7");
function WN(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.ItemRechargeConfiguration",
      $$slots: { default: [Gme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-direction", "row"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, $item*/
      131073 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(WN, "create_if_block_1$p");
function Bme(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("input"), b(e, "id", t = /*$item*/
      i[0].id + "-recharge-formula"), b(e, "type", "text"), e.value = s = /*$item*/
      i[0].system.uses.recharge.formula, b(e, "placeholder", "1d6");
    },
    m(r, o) {
      T(r, e, o), n || (l = W(
        e,
        "change",
        /*change_handler_3*/
        i[9]
      ), n = !0);
    },
    p(r, o) {
      o & /*$item*/
      1 && t !== (t = /*$item*/
      r[0].id + "-recharge-formula") && b(e, "id", t), o & /*$item*/
      1 && s !== (s = /*$item*/
      r[0].system.uses.recharge.formula) && e.value !== s && (e.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Bme, "create_default_slot_3$8");
function qme(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("input"), b(e, "id", t = /*$item*/
      i[0].id + "-recharge-threshold"), b(e, "class", "u-text-center"), b(e, "type", "number"), e.value = s = /*$item*/
      i[0].system.uses.recharge.threshold;
    },
    m(r, o) {
      T(r, e, o), n || (l = W(
        e,
        "change",
        /*change_handler_4*/
        i[10]
      ), n = !0);
    },
    p(r, o) {
      o & /*$item*/
      1 && t !== (t = /*$item*/
      r[0].id + "-recharge-threshold") && b(e, "id", t), o & /*$item*/
      1 && s !== (s = /*$item*/
      r[0].system.uses.recharge.threshold) && e.value !== s && (e.value = s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(qme, "create_default_slot_2$8");
function Gme(i) {
  let e, t, s, n;
  return e = new ie({
    props: {
      heading: "A5E.ItemRechargeFormula",
      $$slots: { default: [Bme] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      heading: "A5E.ItemRechargeThreshold",
      $$slots: { default: [qme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, $item*/
      131073 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, $item*/
      131073 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(Gme, "create_default_slot_1$9");
function zme(i) {
  let e, t, s, n;
  const l = [Fme, Mme], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[1] ? 0 : 1
    );
  }
  return u(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let f = e;
      e = o(a), e === f ? r[e].p(a, c) : (ae(), O(r[f], 1, 1, () => {
        r[f] = null;
      }), ce(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(zme, "create_default_slot$q");
function Hme(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.ItemUsesConfiguration",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[11]
          )
        }
      ],
      $$slots: { default: [zme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-heading-gap", "0.5rem"), G(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      2 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[11]
          )
        }
      ]), l & /*$$scope, $item, isClassResource, editMode, usesSummary*/
      131087 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Hme, "create_fragment$1b");
function Ume(i, e, t) {
  let s, n, l;
  function r(_) {
    var S;
    const { uses: y } = _.system, v = _.actor ? mt((y == null ? void 0 : y.max) ?? 0, ((S = _.actor) == null ? void 0 : S.getRollData(_)) ?? {}) : y == null ? void 0 : y.max;
    let k;
    if (y.value && v) k = `${y.value} / ${v}`;
    else if (y.value && !v) k = y.value;
    else if (!y.value && v) k = `0 / ${v}`;
    else return null;
    return y.per === "recharge" ? k = `${k} (Recharges on ${y.recharge.threshold})` : y.per && (k = `${k} (Per ${a[y.per]})`), k;
  }
  u(r, "prepareUsesSummary");
  const o = de("item");
  pe(i, o, (_) => t(0, l = _));
  const { resourceRecoveryOptions: a } = CONFIG.A5E;
  let c = !1;
  const f = /* @__PURE__ */ u(({ target: _ }) => te(l, _.name, Number(_.value)), "change_handler"), d = /* @__PURE__ */ u(({ target: _ }) => {
    hc(_.value), te(l, _.name, _.value);
  }, "change_handler_1"), p = /* @__PURE__ */ u(({ target: _ }) => te(l, _.name, _.value), "change_handler_2"), m = /* @__PURE__ */ u(({ target: _ }) => {
    hc(_.value), te(l, "system.uses.recharge.formula", _.value);
  }, "change_handler_3"), g = /* @__PURE__ */ u(({ target: _ }) => te(l, "system.uses.recharge.threshold", Number(_.value)), "change_handler_4"), h = /* @__PURE__ */ u(() => t(1, c = !c), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(3, s = r(l)), i.$$.dirty & /*$item*/
    1 && t(2, n = j5(l.system.uses.max ?? ""));
  }, [
    l,
    c,
    n,
    s,
    o,
    a,
    f,
    d,
    p,
    m,
    g,
    h
  ];
}
u(Ume, "instance$15");
const NC = class NC extends re {
  constructor(e) {
    super(), oe(this, e, Ume, Hme, le, {});
  }
};
u(NC, "UsesConfiguration");
let Wv = NC;
function Vme(i) {
  let e, t;
  return e = new Uv({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p: se,
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Vme, "create_if_block_8$4");
function Wme(i) {
  let e, t, s, n, l, r, o, a, c;
  e = new zv({}), s = new Gv({});
  const f = [
    xme,
    Qme,
    Zme,
    Jme,
    Xme
  ], d = [];
  function p(m, g) {
    return (
      /*$item*/
      m[0].system.objectType === "ammunition" ? 0 : (
        /*$item*/
        m[0].system.objectType === "armor" ? 1 : (
          /*$item*/
          m[0].system.objectType === "container" ? 2 : (
            /*$item*/
            m[0].system.objectType === "shield" ? 3 : (
              /*$item*/
              m[0].system.objectType === "weapon" ? 4 : -1
            )
          )
        )
      )
    );
  }
  return u(p, "select_block_type_1"), ~(l = p(i)) && (r = d[l] = f[l](i)), a = new zp({}), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), r && r.c(), o = F(), j(a.$$.fragment);
    },
    m(m, g) {
      R(e, m, g), T(m, t, g), R(s, m, g), T(m, n, g), ~l && d[l].m(m, g), T(m, o, g), R(a, m, g), c = !0;
    },
    p(m, g) {
      let h = l;
      l = p(m), l !== h && (r && (ae(), O(d[h], 1, 1, () => {
        d[h] = null;
      }), ce()), ~l ? (r = d[l], r || (r = d[l] = f[l](m), r.c()), w(r, 1), r.m(o.parentNode, o)) : r = null);
    },
    i(m) {
      c || (w(e.$$.fragment, m), w(s.$$.fragment, m), w(r), w(a.$$.fragment, m), c = !0);
    },
    o(m) {
      O(e.$$.fragment, m), O(s.$$.fragment, m), O(r), O(a.$$.fragment, m), c = !1;
    },
    d(m) {
      m && (C(t), C(n), C(o)), N(e, m), N(s, m), ~l && d[l].d(m), N(a, m);
    }
  };
}
u(Wme, "create_if_block_2$g");
function Kme(i) {
  let e, t;
  return e = new qv({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p: se,
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Kme, "create_if_block_1$o");
function Yme(i) {
  let e, t, s, n;
  return e = new Bv({}), s = new zp({}), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p: se,
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(Yme, "create_if_block$A");
function Xme(i) {
  let e, t;
  return e = new Vv({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Xme, "create_if_block_7$6");
function Jme(i) {
  let e, t;
  return e = new Hv({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Jme, "create_if_block_6$6");
function Zme(i) {
  let e, t;
  return e = new Lv({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Zme, "create_if_block_5$7");
function Qme(i) {
  let e, t;
  return e = new jv({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Qme, "create_if_block_4$a");
function xme(i) {
  let e, t;
  return e = new Nv({}), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(xme, "create_if_block_3$a");
function ehe(i) {
  let e, t, s, n, l, r;
  const o = [Yme, Kme, Wme, Vme], a = [];
  function c(f, d) {
    return (
      /*$item*/
      f[0].type === "feature" ? 0 : (
        /*$item*/
        f[0].type === "maneuver" ? 1 : (
          /*$item*/
          f[0].type === "object" ? 2 : (
            /*$item*/
            f[0].type === "spell" ? 3 : -1
          )
        )
      )
    );
  }
  return u(c, "select_block_type"), ~(t = c(i)) && (s = a[t] = o[t](i)), l = new Wv({}), {
    c() {
      e = E("div"), s && s.c(), n = F(), j(l.$$.fragment), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(f, d) {
      T(f, e, d), ~t && a[t].m(e, null), A(e, n), R(l, e, null), r = !0;
    },
    p(f, [d]) {
      let p = t;
      t = c(f), t === p ? ~t && a[t].p(f, d) : (s && (ae(), O(a[p], 1, 1, () => {
        a[p] = null;
      }), ce()), ~t ? (s = a[t], s ? s.p(f, d) : (s = a[t] = o[t](f), s.c()), w(s, 1), s.m(e, n)) : s = null);
    },
    i(f) {
      r || (w(s), w(l.$$.fragment, f), r = !0);
    },
    o(f) {
      O(s), O(l.$$.fragment, f), r = !1;
    },
    d(f) {
      f && C(e), ~t && a[t].d(), N(l);
    }
  };
}
u(ehe, "create_fragment$1a");
function the(i, e, t) {
  let s;
  const n = de("item");
  return pe(i, n, (l) => t(0, s = l)), [s, n];
}
u(the, "instance$14");
const jC = class jC extends re {
  constructor(e) {
    super(), oe(this, e, the, ehe, le, {});
  }
};
u(jC, "ItemPropertiesTab");
let Kv = jC;
function she(i) {
  let e, t;
  return e = new wr({
    props: {
      document: (
        /*item*/
        i[1]
      ),
      content: (
        /*content*/
        i[0]
      ),
      updatePath: "system.secretDescription"
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*content*/
      1 && (l.content = /*content*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(she, "create_fragment$19");
function nhe(i, e, t) {
  let s, n;
  const l = de("item");
  return pe(i, l, (r) => t(2, n = r)), i.$$.update = () => {
    i.$$.dirty & /*$item*/
    4 && t(0, s = n.system.secretDescription);
  }, [s, l, n];
}
u(nhe, "instance$13");
const LC = class LC extends re {
  constructor(e) {
    super(), oe(this, e, nhe, she, le, {});
  }
};
u(LC, "ItemGmNotesTab");
let Yv = LC;
function ihe(i) {
  let e, t;
  return e = new wr({
    props: {
      document: (
        /*item*/
        i[1]
      ),
      content: (
        /*content*/
        i[0]
      ),
      updatePath: "system.unidentifiedDescription"
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*content*/
      1 && (l.content = /*content*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(ihe, "create_fragment$18");
function lhe(i, e, t) {
  let s, n;
  const l = de("item");
  return pe(i, l, (r) => t(2, n = r)), i.$$.update = () => {
    i.$$.dirty & /*$item*/
    4 && t(0, s = n.system.unidentifiedDescription);
  }, [s, l, n];
}
u(lhe, "instance$12");
const BC = class BC extends re {
  constructor(e) {
    super(), oe(this, e, lhe, ihe, le, {});
  }
};
u(BC, "ItemUnidentifiedDescriptionTab");
let Xv = BC;
function KN(i, e, t) {
  const s = i.slice();
  return s[5] = e[t][0], s[6] = e[t][1], s;
}
u(KN, "get_each_context$r");
function YN(i) {
  let e, t;
  return e = new Ll({
    props: {
      $$slots: { default: [rhe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope*/
      512 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(YN, "create_if_block_1$n");
function rhe(i) {
  let e, t, s, n, l, r;
  return e = new Nl({ props: { reducerType: Gg } }), s = new jl({
    props: {
      reducerType: Gg,
      documentName: "ActiveEffect"
    }
  }), l = new Tn({
    props: {
      reducerType: Gg,
      documentName: "ActiveEffect",
      options: { effectType: "passive" }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), R(s, o, a), T(o, n, a), R(l, o, a), r = !0;
    },
    p: se,
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(s.$$.fragment, o), O(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (C(t), C(n)), N(e, o), N(s, o), N(l, o);
    }
  };
}
u(rhe, "create_default_slot$p");
function XN(i) {
  let e, t;
  return e = new Eu({
    props: {
      label: (
        /*subTypes*/
        i[4][
          /*label*/
          i[5]
        ]
      ),
      effects: (
        /*effects*/
        i[6]
      )
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$activeEffects*/
      2 && (l.label = /*subTypes*/
      s[4][
        /*label*/
        s[5]
      ]), n & /*$activeEffects*/
      2 && (l.effects = /*effects*/
      s[6]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(XN, "create_if_block$z");
function JN(i) {
  let e, t, s = (
    /*effects*/
    i[6].length && /*label*/
    i[5] !== "onUse" && XN(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*effects*/
      n[6].length && /*label*/
      n[5] !== "onUse" ? s ? (s.p(n, l), l & /*$activeEffects*/
      2 && w(s, 1)) : (s = XN(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(JN, "create_each_block$r");
function ohe(i) {
  let e, t, s, n = (
    /*$item*/
    i[0].isOwner && YN(i)
  ), l = ue(Object.entries(
    /*$activeEffects*/
    i[1]._types
  )), r = [];
  for (let a = 0; a < l.length; a += 1)
    r[a] = JN(KN(i, l, a));
  const o = /* @__PURE__ */ u((a) => O(r[a], 1, 1, () => {
    r[a] = null;
  }), "out");
  return {
    c() {
      n && n.c(), e = F(), t = E("section");
      for (let a = 0; a < r.length; a += 1)
        r[a].c();
      b(t, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(a, c) {
      n && n.m(a, c), T(a, e, c), T(a, t, c);
      for (let f = 0; f < r.length; f += 1)
        r[f] && r[f].m(t, null);
      s = !0;
    },
    p(a, [c]) {
      if (/*$item*/
      a[0].isOwner ? n ? (n.p(a, c), c & /*$item*/
      1 && w(n, 1)) : (n = YN(a), n.c(), w(n, 1), n.m(e.parentNode, e)) : n && (ae(), O(n, 1, 1, () => {
        n = null;
      }), ce()), c & /*subTypes, Object, $activeEffects*/
      18) {
        l = ue(Object.entries(
          /*$activeEffects*/
          a[1]._types
        ));
        let f;
        for (f = 0; f < l.length; f += 1) {
          const d = KN(a, l, f);
          r[f] ? (r[f].p(d, c), w(r[f], 1)) : (r[f] = JN(d), r[f].c(), w(r[f], 1), r[f].m(t, null));
        }
        for (ae(), f = l.length; f < r.length; f += 1)
          o(f);
        ce();
      }
    },
    i(a) {
      if (!s) {
        w(n);
        for (let c = 0; c < l.length; c += 1)
          w(r[c]);
        s = !0;
      }
    },
    o(a) {
      O(n), r = r.filter(Boolean);
      for (let c = 0; c < r.length; c += 1)
        O(r[c]);
      s = !1;
    },
    d(a) {
      a && (C(e), C(t)), n && n.d(a), Le(r, a);
    }
  };
}
u(ohe, "create_fragment$17");
const Gg = "activeEffects";
function ahe(i, e, t) {
  let s, n;
  const l = de("item");
  pe(i, l, (a) => t(0, s = a));
  const { activeEffects: r } = l;
  pe(i, r, (a) => t(1, n = a));
  const o = CONFIG.A5E.itemActiveEffectTypesPlural;
  return [s, n, l, r, o];
}
u(ahe, "instance$11");
const qC = class qC extends re {
  constructor(e) {
    super(), oe(this, e, ahe, ohe, le, {});
  }
};
u(qC, "ItemEffectsTab");
let Jv = qC;
function ZN(i, e, t) {
  const s = i.slice();
  return s[8] = e[t][0], s[9] = e[t][1], s[10] = e[t][2], s;
}
u(ZN, "get_each_context$q");
function QN(i) {
  let e, t, s, n, l, r;
  function o(...a) {
    return (
      /*change_handler*/
      i[6](
        /*docId*/
        i[8],
        ...a
      )
    );
  }
  return u(o, "change_handler"), {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "number-input svelte-1goc674"), b(t, "type", "number"), b(t, "id", s = /*doc*/
      i[9].uuid + "-quantityOverride"), t.value = n = /*quantityOverride*/
      i[10] || /*doc*/
      i[9].system.quantity || 1, b(t, "min", "1"), b(e, "class", "quantity-wrapper svelte-1goc674");
    },
    m(a, c) {
      T(a, e, c), A(e, t), l || (r = W(t, "change", o), l = !0);
    },
    p(a, c) {
      i = a, c & /*docs*/
      2 && s !== (s = /*doc*/
      i[9].uuid + "-quantityOverride") && b(t, "id", s), c & /*docs*/
      2 && n !== (n = /*quantityOverride*/
      i[10] || /*doc*/
      i[9].system.quantity || 1) && t.value !== n && (t.value = n);
    },
    d(a) {
      a && C(e), l = !1, r();
    }
  };
}
u(QN, "create_if_block$y");
function xN(i) {
  var y;
  let e, t, s, n, l, r, o = (
    /*doc*/
    ((y = i[9]) == null ? void 0 : y.name) + ""
  ), a, c, f, d, p, m, g, h = (
    /*doc*/
    i[9].isEmbedded && QN(i)
  );
  function _() {
    return (
      /*click_handler*/
      i[7](
        /*doc*/
        i[9]
      )
    );
  }
  return u(_, "click_handler"), {
    c() {
      e = E("li"), t = E("img"), l = F(), r = E("h3"), a = Q(o), c = F(), h && h.c(), f = F(), d = E("button"), p = F(), b(t, "class", "document-img svelte-1goc674"), ze(t.src, s = /*doc*/
      i[9].img) || b(t, "src", s), b(t, "alt", n = /*doc*/
      i[9].name), b(r, "class", "svelte-1goc674"), b(d, "class", "a5e-button a5e-button--delete delete-button fas fa-trash svelte-1goc674"), b(d, "data-tooltip", "A5E.ButtonToolTipDelete"), b(d, "data-tooltip-direction", "UP"), b(e, "class", "document-wrapper svelte-1goc674");
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(e, l), A(e, r), A(r, a), A(e, c), h && h.m(e, null), A(e, f), A(e, d), A(e, p), m || (g = W(d, "click", _), m = !0);
    },
    p(v, k) {
      var S;
      i = v, k & /*docs*/
      2 && !ze(t.src, s = /*doc*/
      i[9].img) && b(t, "src", s), k & /*docs*/
      2 && n !== (n = /*doc*/
      i[9].name) && b(t, "alt", n), k & /*docs*/
      2 && o !== (o = /*doc*/
      ((S = i[9]) == null ? void 0 : S.name) + "") && be(a, o), /*doc*/
      i[9].isEmbedded ? h ? h.p(i, k) : (h = QN(i), h.c(), h.m(e, f)) : h && (h.d(1), h = null);
    },
    d(v) {
      v && C(e), h && h.d(), m = !1, g();
    }
  };
}
u(xN, "create_each_block$q");
function che(i) {
  let e, t, s, n, l, r;
  s = new ho({
    props: { type: "uuid", documentType: "Item" }
  }), s.$on(
    "document-dropped",
    /*document_dropped_handler*/
    i[5]
  );
  let o = ue(
    /*docs*/
    i[1]
  ), a = [];
  for (let c = 0; c < o.length; c += 1)
    a[c] = xN(ZN(i, o, c));
  return {
    c() {
      e = E("article"), t = E("section"), j(s.$$.fragment), n = F(), l = E("ul");
      for (let c = 0; c < a.length; c += 1)
        a[c].c();
      b(l, "class", "document-list svelte-1goc674"), b(t, "class", "section-wrapper svelte-1goc674"), b(e, "class", "svelte-1goc674");
    },
    m(c, f) {
      T(c, e, f), A(e, t), R(s, t, null), A(t, n), A(t, l);
      for (let d = 0; d < a.length; d += 1)
        a[d] && a[d].m(l, null);
      r = !0;
    },
    p(c, [f]) {
      if (f & /*deleteEquipment, docs, $item, parseInt*/
      19) {
        o = ue(
          /*docs*/
          c[1]
        );
        let d;
        for (d = 0; d < o.length; d += 1) {
          const p = ZN(c, o, d);
          a[d] ? a[d].p(p, f) : (a[d] = xN(p), a[d].c(), a[d].m(l, null));
        }
        for (; d < a.length; d += 1)
          a[d].d(1);
        a.length = o.length;
      }
    },
    i(c) {
      r || (w(s.$$.fragment, c), r = !0);
    },
    o(c) {
      O(s.$$.fragment, c), r = !1;
    },
    d(c) {
      c && C(e), N(s), Le(a, c);
    }
  };
}
u(che, "create_fragment$16");
function uhe(i, e, t) {
  let s, n;
  const l = de("item");
  pe(i, l, (d) => t(0, n = d));
  async function r({ uuid: d }) {
    var g, h, _;
    let p;
    try {
      const y = await Item.fromDropData({ uuid: d });
      n.isEmbedded ? p = (g = await n.actor.createEmbeddedDocuments("Item", [y])) == null ? void 0 : g[0] : p = y;
    } catch (y) {
      console.error(y);
      return;
    }
    if (!p || p.type !== "object") {
      ui.notifications.error("Document must be an Object.");
      return;
    }
    await n.containerItems.add(p.uuid);
    const m = ((h = n == null ? void 0 : n.parent) == null ? void 0 : h.documentName) === "Actor" ? n.parent : null;
    m && m.uuid === ((_ = n.parent) == null ? void 0 : _.uuid) && await p.update({ "system.containerId": n.uuid });
  }
  u(r, "updateEquipment");
  async function o(d) {
    var g, h;
    console.log(d);
    const p = await fromUuid(d);
    await n.containerItems.remove(d);
    const m = ((g = n == null ? void 0 : n.parent) == null ? void 0 : g.documentName) === "Actor" ? n.parent : null;
    !m || !p || m.uuid === ((h = n.parent) == null ? void 0 : h.uuid) && await p.update({ "system.containerId": "" });
  }
  u(o, "deleteEquipment");
  const a = /* @__PURE__ */ u(({ detail: d }) => r(d), "document_dropped_handler"), c = /* @__PURE__ */ u((d, { target: p }) => {
    te(
      n,
      `system.items.${d}.quantityOverride`,
      // @ts-ignore
      parseInt((p == null ? void 0 : p.value) ?? 1)
    );
  }, "change_handler"), f = /* @__PURE__ */ u((d) => o(d.uuid), "click_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(1, s = Object.entries(n.system.items ?? {}).map(([d, p]) => [d, fromUuidSync(p.uuid), p.quantityOverride]).filter(([, d]) => !!d));
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c,
    f
  ];
}
u(uhe, "instance$10");
const GC = class GC extends re {
  constructor(e) {
    super(), oe(this, e, uhe, che, le, {});
  }
};
u(GC, "ItemEquipmentTab");
let Zv = GC;
function fhe(i) {
  let e, t, s, n, l, r, o, a, c;
  t = new Hl({}), n = new Wn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[6]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[3]
  );
  var f = (
    /*currentTab*/
    i[1].component
  );
  function d(p, m) {
    return {
      props: { summaryData: (
        /*summaryData*/
        p[2]
      ) }
    };
  }
  return u(d, "switch_props"), f && (r = et(f, d(i))), {
    c() {
      e = E("main"), j(t.$$.fragment), s = F(), j(n.$$.fragment), l = F(), r && j(r.$$.fragment), b(e, "class", "svelte-y36y3r");
    },
    m(p, m) {
      T(p, e, m), R(t, e, null), A(e, s), R(n, e, null), A(e, l), r && R(r, e, null), o = !0, a || (c = W(e, "drop", Ve(st(
        /*drop_handler*/
        i[11]
      ))), a = !0);
    },
    p(p, m) {
      const g = {};
      if (m & /*currentTab*/
      2 && (g.currentTab = /*currentTab*/
      p[1]), n.$set(g), m & /*currentTab*/
      2 && f !== (f = /*currentTab*/
      p[1].component)) {
        if (r) {
          ae();
          const h = r;
          O(h.$$.fragment, 1, 0, () => {
            N(h, 1);
          }), ce();
        }
        f ? (r = et(f, d(p)), j(r.$$.fragment), w(r.$$.fragment, 1), R(r, e, null)) : r = null;
      } else if (f) {
        const h = {};
        m & /*summaryData*/
        4 && (h.summaryData = /*summaryData*/
        p[2]), r.$set(h);
      }
    },
    i(p) {
      o || (w(t.$$.fragment, p), w(n.$$.fragment, p), r && w(r.$$.fragment, p), o = !0);
    },
    o(p) {
      O(t.$$.fragment, p), O(n.$$.fragment, p), r && O(r.$$.fragment, p), o = !1;
    },
    d(p) {
      p && C(e), N(t), N(n), r && N(r), a = !1, c();
    }
  };
}
u(fhe, "create_default_slot$o");
function dhe(i) {
  let e, t, s;
  function n(r) {
    i[12](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [fhe] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab, summaryData*/
        8198 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(dhe, "create_fragment$15");
function phe(i, e, t) {
  var k;
  let s, n, { appId: l, document: r, sheet: o } = de("#external").application, { appId: a = l, document: c = r, sheet: f = o } = e, { elementRoot: d } = e;
  function p(S) {
    t(1, _ = h[S.detail]);
  }
  u(p, "updateCurrentTab");
  const m = c;
  pe(i, m, (S) => t(10, n = S));
  function g(S) {
    const D = S.dataTransfer.getData("text/plain");
    if (!D) return;
    const I = JSON.parse(D);
    f._onDropDocument(I);
  }
  u(g, "onDrop");
  const h = [
    {
      name: "description",
      label: "A5E.ItemSheetLabelDescriptionTab",
      component: zl,
      display: !n.system.unidentified || game.user.isGM
    },
    {
      name: "unidentifiedDescription",
      label: "A5E.ItemSheetLabelUnidentifiedDescriptionTab",
      component: Xv,
      display: n.type === "object" && (n.system.unidentified || game.user.isGM)
    },
    {
      name: "gmNotes",
      label: "GM Notes",
      component: Yv,
      display: game.user.isGM
    },
    {
      name: "properties",
      label: "A5E.ItemSheetLabelPropertiesTab",
      component: Kv,
      display: !n.system.unidentified || game.user.isGM
    },
    {
      name: "equipment",
      label: "A5E.Equipment",
      component: Zv,
      display: n.type === "object" && n.system.objectType === "container" && (!n.system.unidentified || game.user.isGM)
    },
    {
      name: "actions",
      label: "A5E.ItemSheetLabelActionsTab",
      component: Rv,
      display: !n.system.unidentified || game.user.isGM
    },
    {
      name: "effects",
      label: "A5E.TabEffects",
      component: Jv,
      display: !n.system.unidentified || game.user.isGM
    },
    {
      name: "grants",
      label: "A5E.TabGrants",
      component: Er,
      display: n.type === "feature"
    },
    {
      name: "macro",
      label: "A5E.TabMacro",
      component: Op,
      display: ["feature", "maneuver", "object", "spell"].includes(n.type)
    }
  ];
  let _ = (k = n.system) != null && k.unidentified && !game.user.isGM ? h[1] : h[0];
  lt("item", m), lt("appId", a);
  const y = /* @__PURE__ */ u((S) => g(S), "drop_handler");
  function v(S) {
    d = S, t(0, d);
  }
  return u(v, "applicationshell_elementRoot_binding"), i.$$set = (S) => {
    "appId" in S && t(7, a = S.appId), "document" in S && t(8, c = S.document), "sheet" in S && t(9, f = S.sheet), "elementRoot" in S && t(0, d = S.elementRoot);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1024 && t(2, s = nd(n));
  }, [
    d,
    _,
    s,
    p,
    m,
    g,
    h,
    a,
    c,
    f,
    n,
    y,
    v
  ];
}
u(phe, "instance$$");
var Ja;
let mhe = (Ja = class extends re {
  constructor(e) {
    super(), oe(this, e, phe, dhe, le, {
      appId: 7,
      document: 8,
      sheet: 9,
      elementRoot: 0
    });
  }
  get appId() {
    return this.$$.ctx[7];
  }
  set appId(e) {
    this.$$set({ appId: e }), Xe();
  }
  get document() {
    return this.$$.ctx[8];
  }
  set document(e) {
    this.$$set({ document: e }), Xe();
  }
  get sheet() {
    return this.$$.ctx[9];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
}, u(Ja, "ItemSheet"), Ja);
var Li, xB, Qv, eq, tq, uo;
let e8 = (uo = class extends Gs {
  /**
   * @inheritDoc
   */
  constructor(t, s = {}) {
    var l, r;
    s.svelte ?? (s.svelte = {}), [CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE, CONST.DOCUMENT_OWNERSHIP_LEVELS.LIMITED].includes(
      t.permission
    ) ? (s.classes = ["a5e-sheet", "a5e-sheet--item", "a5e-actor-sheet--limited"], s.svelte.class = Rp, s.width = 512, s.resizable = !1) : (s.svelte.class = uo.getSheetComponent(t.type), s.classes = ["a5e-sheet", "a5e-sheet--item"], s.width = 555, s.height = 592, s.resizable = !0);
    const n = t.parent ? (l = t == null ? void 0 : t.parent) != null && l.isToken ? ((r = t == null ? void 0 : t.parent) == null ? void 0 : r.parent.id) ?? t.parent.id : t.parent.id : null;
    super(
      foundry.utils.mergeObject(s, {
        baseApplication: "ItemSheet",
        id: n ? `item-sheet-${n}-${t.id}` : `item-sheet-${t.id}`,
        classes: ["a5e-sheet", "a5e-sheet--item"],
        title: t.name,
        focusAuto: t.type !== "heritage",
        svelte: {
          props: {}
        }
      })
    );
    x(this, Li);
    qe(this, "item");
    this.item = t, this.options.svelte.props.document = new gp(
      this.item,
      // @ts-expect-error
      { delete: this.close.bind(this) }
    ), this.options.svelte.props.sheet = this;
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/Application.html#options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      baseApplication: "ItemSheet",
      classes: ["a5e-sheet", "a5e-item-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
  get object() {
    return this.item;
  }
  get document() {
    return this.item;
  }
  _getHeaderButtons() {
    const t = super._getHeaderButtons();
    return this.item.pack || (t.unshift({
      label: "Sheet Configuration",
      class: "configure-sheet",
      icon: "fas fa-cog fa-fw",
      title: "Configure Sheet",
      onclick: /* @__PURE__ */ u(({ event: s }) => this._onConfigureSheet(s), "onclick")
    }), t.unshift({
      label: "Revitalize",
      icon: "fa-solid fa-arrows-rotate",
      onclick: /* @__PURE__ */ u(() => this.item.revitalize(), "onclick")
    })), this.item.pack && t.unshift({
      label: "Import",
      class: "import",
      icon: "fas fa-download",
      onclick: /* @__PURE__ */ u(({ event: s }) => this._onImport(s), "onclick")
    }), t;
  }
  _onImport(t) {
    return t && t.preventDefault(), this.item.collection.importFromCompendium(this.item.compendium, this.item.id);
  }
  _onConfigureSheet(t) {
    t && t.preventDefault(), new DocumentSheetConfig(this.item, { top: this.position.top + 40 }).render(!0);
  }
  async _onDropDocument(t) {
    ["archetype", "background", "class", "culture", "heritage"].includes(this.item.type) ? t.type === "Grant" && await X(this, Li, Qv).call(this, t) : (t.type === "Action" && await X(this, Li, xB).call(this, t), t.type === "Grant" && await X(this, Li, Qv).call(this, t), t.type === "Item" && await X(this, Li, eq).call(this, t));
  }
  static getSheetComponent(t) {
    return t === "archetype" ? Tv : t === "background" ? Ov : t === "class" ? Dv : t === "culture" ? Iv : t === "destiny" ? Mv : t === "heritage" ? Fv : mhe;
  }
  async _render(t = !1, s = {}) {
    var d, p;
    await super._render(t, s);
    const l = this.element[0].querySelector(".window-header .window-title");
    if (l.querySelector(".document-id-link")) return;
    const o = this.item.id, a = this.item.uuid, c = CONFIG.A5E.products[(p = (d = this.item) == null ? void 0 : d.system) == null ? void 0 : p.source];
    if (c != null && c.abbreviation) {
      const m = document.createElement("a");
      m.classList.add("a5e-document-source-link"), m.setAttribute("alt", c == null ? void 0 : c.title), m.dataset.tooltip = On(c), m.dataset.tooltipClass = "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source", m.dataset.tooltipDirection = "DOWN", m.innerHTML = `<i class="fa-solid fa-book-open"></i> ${c == null ? void 0 : c.abbreviation}`, m.href = c == null ? void 0 : c.url, m.target = "_blank", l.append(m);
    }
    const f = document.createElement("a");
    f.classList.add("document-id-link"), f.setAttribute("alt", "Copy Document ID"), f.dataset.tooltip = "Copy Document ID", f.dataset.tooltipDirection = "UP", f.innerHTML = '<i class="fa-solid fa-passport"></i>', f.addEventListener("click", (m) => {
      m.preventDefault(), game.clipboard.copyPlainText(o), ui.notifications.info(
        game.i18n.format("DOCUMENT.IdCopiedClipboard", {
          label: "Item",
          type: "id",
          id: o
        })
      );
    }), f.addEventListener("contextmenu", (m) => {
      m.preventDefault(), game.clipboard.copyPlainText(a), ui.notifications.info(
        game.i18n.format("DOCUMENT.IdCopiedClipboard", {
          label: "Item",
          type: "uuid",
          id: a
        })
      );
    }), l.append(f);
  }
}, Li = new WeakSet(), xB = /* @__PURE__ */ u(async function(t) {
  var a;
  const { actionId: s, itemUuid: n } = t;
  if (!s || !n) return;
  const l = await fromUuid(n), r = (a = l == null ? void 0 : l.actions.get(s)) == null ? void 0 : a.toObject();
  if (!r) return;
  r.img = l == null ? void 0 : l.img;
  const o = [...r.effects].map((c) => {
    var f;
    return (f = l.effects.get(c)) == null ? void 0 : f.toObject();
  }).filter((c) => !!c);
  if (o.length) {
    const c = (await this.item.createEmbeddedDocuments("ActiveEffect", o)).map(
      (f) => f.id
    );
    r.effects = c;
  }
  this.item.actions.add(r);
}, "#onDropAction"), Qv = /* @__PURE__ */ u(async function(t) {
  const { grantId: s, itemUuid: n } = t;
  if (!s || !n) return;
  const l = await fromUuid(n), r = foundry.utils.duplicate(l == null ? void 0 : l.grants.get(s));
  r && (r.img ?? (r.img = l == null ? void 0 : l.img), await this.item.grants.add(r));
}, "#onDropGrant"), eq = /* @__PURE__ */ u(async function(t) {
  const { uuid: s } = t, n = await fromUuid(s);
  n && n.isType("spell") && X(this, Li, tq).call(this, n);
}, "#onDropItem"), tq = /* @__PURE__ */ u(async function(t) {
  const s = [...t.actions.values()];
  for await (const n of s) {
    const l = n.toObject();
    l.img = t.img, l.description ?? (l.description = t.system.description), l.descriptionOutputs = ["action"];
    const r = [...l.effects].map((o) => {
      var a;
      return (a = t.effects.get(o)) == null ? void 0 : a.toObject();
    }).filter((o) => !!o);
    if (r.length) {
      const o = (await this.item.createEmbeddedDocuments("ActiveEffect", r)).map(
        (a) => a.id
      );
      l.effects = o;
    }
    this.item.actions.add(l);
  }
}, "#onDropSpell"), u(uo, "ItemSheet"), uo);
const zC = class zC extends Roll {
  constructor(e, t, s) {
    if (super(e, t, s), !(this.terms[0] instanceof Die && this.terms[0].faces === 20))
      throw new Error(
        `Invalid D20Roll formula provided: ${this._formula}. D20Roll formulae must begin with a 20-sided die term.`
      );
  }
  static get TOOLTIP_TEMPLATE() {
    return "systems/a5e/templates/chat/roll-tooltip.hbs";
  }
};
u(zC, "D20Roll");
let Qc = zC;
const HC = class HC {
  constructor(e) {
    qe(this, "initialLayer");
    qe(this, "moveTime", 0);
    qe(this, "events", {});
    qe(this, "token");
    this.token = e, this.initialLayer = canvas.activeLayer;
  }
  async preview() {
    var e;
    return this.token.draw(), (e = this.token.layer.preview) == null || e.addChild(this.token), this.activatePreviewListeners();
  }
  activatePreviewListeners() {
    return new Promise((e, t) => {
      var s, n;
      this.events = {
        cancel: this._onCancel.bind(this),
        confirm: this._onConfirm.bind(this),
        move: this._onMove.bind(this),
        rotate: this._onRotate.bind(this),
        resolve: e,
        reject: t
      }, (s = canvas.stage) == null || s.on("mousemove", this.events.move), (n = canvas.stage) == null || n.on("mousedown", this.events.confirm), canvas.app && (canvas.app.view.oncontextmenu = this.events.cancel, canvas.app.view.onwheel = this.events.rotate);
    });
  }
  _cleanup() {
    var e, t;
    (e = canvas.stage) == null || e.off("mousemove", this.events.move), (t = canvas.stage) == null || t.off("mousedown", this.events.confirm), canvas.app && (canvas.app.view.oncontextmenu = null, canvas.app.view.onwheel = null);
  }
  _onMove(e) {
    var c, f, d;
    e.stopPropagation();
    const t = Date.now();
    if (t - this.moveTime <= 10) return;
    const s = e.data.getLocalPosition(this.token.layer), n = (((c = canvas.grid) == null ? void 0 : c.w) ?? 0) / 2, l = (((f = canvas.grid) == null ? void 0 : f.h) ?? 0) / 2, r = s.x - (this.token.document.width ?? 1) * n, o = s.y - (this.token.document.height ?? 1) * l, a = e.shiftKey ? { x: r, y: o } : (d = canvas.grid) == null ? void 0 : d.getSnappedPoint({ x: r, y: o });
    this.token.document.updateSource({ x: a.x, y: a.y }), this.token.refresh(), this.moveTime = t;
  }
  _onRotate(e) {
    e.ctrlKey && e.preventDefault(), e.stopPropagation();
    const t = Math.sign(e.deltaY), s = this.token.rotation + t * Math.PI / 6;
    this.token.document.updateSource({ rotation: s }), this.token.refresh();
  }
  _onCancel(e) {
    var t;
    this.token.layer._onDragLeftCancel(e ?? {}), this._cleanup(), (t = this.token.layer.preview) == null || t.removeChild(this.token), this.token.destroy(), this.events.reject();
  }
  _onConfirm() {
    var n, l, r;
    this._cleanup();
    const { token: e } = this, t = ((n = canvas.grid) == null ? void 0 : n.type) === CONST.GRID_TYPES.GRIDLESS ? 0 : 2, s = (l = canvas.grid) == null ? void 0 : l.getSnappedPoint(
      { x: e.document.x, y: e.document.y },
      { mode: t }
    );
    e.document.updateSource({ x: s.x, y: s.y }), e.refresh(), e.destroy(), this.events.resolve(
      // @ts-expect-error
      (r = canvas.scene) == null ? void 0 : r.createEmbeddedDocuments("Token", [e.document.toObject()])
    );
  }
};
u(HC, "TokenPreviewManager");
let xv = HC;
const Ic = {
  iconScale: /* @__PURE__ */ u((i) => i >= 5 ? 2.5 : i >= 4 ? 2.25 : i >= 3 ? 1.55 : i >= 2 ? 1.25 : 1.4, "iconScale"),
  maxIcons: /* @__PURE__ */ u((i) => i >= 3 ? 22 : i >= 2 ? 17 : i >= 1 ? 14 : 10, "maxIcons"),
  ringOffset: /* @__PURE__ */ u((i) => i >= 5 ? 0.125 : i >= 3 || i >= 2 ? 0.225 : i >= 1 ? 0.425 : 1.45, "ringOffset"),
  ringRotation: /* @__PURE__ */ u((i) => i >= 3 ? 0.02 : i >= 2 ? 0.03 : (i >= 1, 0.035), "ringRotation"),
  sizeOffset: /* @__PURE__ */ u((i) => i >= 5 || i >= 3 ? 1.08 : i >= 2 ? 1.12 : i >= 1 ? 1.25 : 1.45, "sizeOffset")
};
let zg = null;
const UC = class UC extends Token {
  /**
   * Get an array of icon paths which represent valid status effect choices
   * @private
   */
  _getStatusEffectChoices() {
    var s;
    const e = {};
    for (const n of CONFIG.statusEffects)
      n.hud !== !1 && (e[n.id] = {
        _id: n._id,
        id: n.id,
        title: game.i18n.localize(n.name),
        src: n.img,
        isActive: !1,
        isOverlay: !1
      });
    const t = ((s = this.actor) == null ? void 0 : s.effects) || [];
    for (const n of t)
      for (const l of n.statuses) {
        const r = e[l];
        if (r) {
          if (r._id) {
            if (r._id !== n.id) continue;
          } else if (n.statuses.size !== 1) continue;
          r.isActive = !0, n.getFlag("core", "overlay") && (r.isOverlay = !0);
          break;
        }
      }
    for (const n of Object.values(e))
      n.cssClass = [
        n.isActive ? "active" : null,
        n.isOverlay ? "overlay" : null
      ].filterJoin(" ");
    return e;
  }
  _getActiveConditions() {
    return Object.values(this._getStatusEffectChoices()).reduce((e, t) => (t.isActive && e.push(t.id), e), []);
  }
  _addStatusEffect({ id: e, src: t }, { overlay: s } = {}) {
    return ["corruption", "fatigue", "exhaustion", "inebriated", "strife"].includes(e) ? this.actor.toggleStatusEffect(e, { active: !0, overlay: s }) : this._getActiveConditions().includes(e) ? this._removeStatusEffect({ id: e, src: t }, { overlay: s }) : this.actor.toggleStatusEffect(e, { active: !0, overlay: s });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _removeStatusEffect({ id: e, src: t }, { overlay: s } = {}) {
    return ["corruption", "fatigue", "exhaustion", "inebriated", "strife"].includes(e) ? this.actor.toggleStatusEffect(e, { active: !1, overlay: s }) : this.actor.toggleStatusEffect(e, { active: !1, overlay: s });
  }
  /** @inheritdoc */
  _drawBar(e, t, s) {
    return s.attribute === "attributes.hp" ? this._drawHPBar(e, t, s) : super._drawBar(e, t, s);
  }
  /* -------------------------------------------- */
  /**
   * Specialized drawing function for HP bars.
   *
   * @param {number} number      The Bar number
   * @param {PIXI.Graphics} bar  The Bar container
   * @private
   */
  _drawHPBar(e, t) {
    const { value: s, max: n, temp: l } = this.document.actor.system.attributes.hp, r = Math.clamp(l, 0, n) / n, o = Math.clamp(s, 0, n) / n, a = Math.clamp(s, 0, n) / n, c = 0, f = PIXI.utils.rgb2hex([1 - a / 2, a, 0]), d = CONFIG.A5E.tokenHPColors, { w: p } = this;
    let m = Math.max(canvas.dimensions.size / 12, 8);
    this.document.height >= 2 && (m *= 1.6);
    const g = Math.clamp(m / 8, 1, 2), h = g + 1;
    t.clear(), t.beginFill(c, 0.5).lineStyle(g, c, 1).drawRoundedRect(0, 0, p, m, 3), t.beginFill(f, 1).lineStyle(g, c, 1).drawRoundedRect(0, 0, o * p, m, 2), l > 0 && t.beginFill(d.temp, 1).lineStyle(0).drawRoundedRect(h, h, r * p - 2 * h, m - 2 * h, 1);
    const _ = e === 0 ? this.h - m : 0;
    t.position.set(0, _);
  }
  // ********************************************************************
  //                            Radial Effects
  // ********************************************************************
  _refreshEffects() {
    var o, a;
    if (super._refreshEffects(), !game.settings.get("a5e", "enableRadialEffects")) return;
    const e = this.effects.children[0];
    if (!(e instanceof PIXI.Graphics)) return;
    e.clear();
    const t = this.effects.children.filter((c) => !(c === this.effects.overlay || c === this.effects.bg)), s = Math.max(this.document.height, this.document.width), n = ((a = (o = this == null ? void 0 : this.scene) == null ? void 0 : o.grid) == null ? void 0 : a.size) ?? 100, l = Ic.maxIcons(s) ?? 10;
    let r = 0;
    t.forEach((c, f) => {
      var B;
      if (!(c instanceof PIXI.Sprite)) return;
      f !== 0 && f % l === 0 && (r += 1), c.anchor.set(0.5);
      const d = Ic.iconScale(s) ?? 1.4, p = n / 100, m = 12 * d * p;
      c.width = m, c.height = m;
      const g = f / l, h = ((B = this == null ? void 0 : this.document) == null ? void 0 : B.width) ?? 1, _ = Ic.ringOffset(s) * r, v = ((Ic.sizeOffset(s) ?? 1.4) + _) * h * n, k = r % 2 === 0 ? 0 : Ic.ringRotation(s), S = (0.5 + 1 / l * Math.PI) * Math.PI, D = (g + k) * 2 * Math.PI + S, I = Math.cos(D) * v, M = Math.sin(D) * v;
      c.position.x = I / 2 + n * h / 2, c.position.y = -1 * M / 2 + n * h / 2;
      const L = c.width / 2;
      e.lineStyle(1 * p / 2, 15325089, 1, 0), e.drawCircle(c.position.x, c.position.y, L + 1 * p), e.beginFill(0, 0.6), e.drawCircle(c.position.x, c.position.y, L + 1 * p), e.endFill();
    });
  }
  /**
   * @override
   */
  async _drawEffect(e, t, s = !1) {
    if (!game.settings.get("a5e", "enableRadialEffects")) return super._drawEffect(e, t);
    if (!e) return null;
    const n = await loadTexture(e, { fallback: "icons/svg/hazard.svg" }), l = new PIXI.Sprite(n);
    if (s)
      return t && (l.tint = t), this.effects.addChild(l);
    if (!zg) {
      zg = PIXI.RenderTexture.create(110, 110);
      const a = new PIXI.Graphics().beginFill(16777215).drawCircle(55, 55, 55).endFill(), c = new PIXI.filters.BlurFilter(2);
      a.filters = [c], canvas.app.renderer.render(a, zg);
    }
    const r = Math.min(l.width, l.height), o = new PIXI.Graphics().beginFill(16777215).drawCircle(55, 55, 55).endFill();
    return o.width = r, o.height = r, o.x = -l.width / 2, o.y = -l.height / 2, l.mask = o, l.addChild(o), t && (l.tint = t), this.effects.addChild(l);
  }
  /**
   * @override
   */
  async _drawOverlay(e, t) {
    if (!game.settings.get("a5e", "enableRadialEffects")) return super._drawOverlay(e, t);
    const s = await this._drawEffect(e, t, !0);
    return s && (s.alpha = 0.8), this.effects.overlay = s ?? null, s;
  }
  // ********************************************************************
  //                         Token Preview Draw
  // ********************************************************************
  async drawPreview() {
    return new xv(this).preview();
  }
};
u(UC, "TokenA5e");
let Hp = UC;
const VC = class VC extends TokenDocument {
  constructor() {
    super(...arguments);
    qe(this, "overrides", this.overrides ?? {});
    qe(this, "automateVision");
    qe(this, "charOnlyVisionAutomation");
  }
  get scene() {
    return this.parent;
  }
  prepareBaseData() {
    super.prepareBaseData(), this.applyActiveEffects();
  }
  applyActiveEffects() {
    var t;
    this.overrides = {}, this.actor && lc.applyEffects(
      this,
      ((t = this.actor.effects) == null ? void 0 : t.contents) ?? [],
      "afterDerived",
      null,
      (s) => s.key.startsWith("@token")
    );
  }
  _prepareDetectionModes() {
    this.automateVision ?? (this.automateVision = game.settings.storage.get("world").getItem("a5e.automateVisionRules") ?? !1), this.charOnlyVisionAutomation ?? (this.charOnlyVisionAutomation = game.settings.storage.get("world").getItem("a5e.visionRulesApplyToCharactersOnly") ?? !0);
    const { actor: t, scene: s } = this;
    if (!this.automateVision || !s || !t) {
      super._prepareDetectionModes();
      return;
    }
    if (t.type === "npc" && this.charOnlyVisionAutomation) {
      super._prepareDetectionModes();
      return;
    }
    this.sight.enabled = !0;
    const n = { id: "lightPerception", enabled: !0, range: null }, l = { id: "basicSight", enabled: !0, range: 0 };
    this.detectionModes = [n, l], this.sight.attenuation = 0.1, this.sight.brightness = 0, this.sight.contrast = 0, this.sight.range = 0, this.sight.saturation = 0;
    const { visionData: r } = t, o = r.hasDarkvision ? "darkvision" : "basic";
    this.sight.visionMode = o;
    const { defaults: a } = CONFIG.Canvas.visionModes[o].vision;
    this.sight.visionMode = o, this.sight.brightness = a.brightness ?? 0, this.sight.saturation = a.saturation ?? 0, o === "darkvision" && (this.sight.range = r.senses.darkvision.distance, l.range = r.senses.darkvision.distance, this.sight.saturation = -1), r.hasBlindsight && this.detectionModes.push({
      id: "blindsight",
      enabled: !0,
      range: r.senses.blindsight.distance ?? 0
    }), r.hasTremorsense && this.detectionModes.push({
      id: "feelTremor",
      enabled: !0,
      range: r.senses.tremorsense.distance ?? 0
    }), r.hasTruesight && this.detectionModes.push({
      id: "seeInvisibility",
      enabled: !0,
      range: r.senses.truesight.distance ?? 0
    });
  }
  updateTokenSize() {
    const { actor: t } = this;
    if (!t) return;
    const { size: s } = t.system.traits, n = CONFIG.A5E.tokenDimensions[s];
    this.width = n ?? this.width ?? 1, this.height = n ?? this.height ?? 1;
  }
  /**
   * Overrides base functionality and doesn't update unlinked tokens.
   * @override
   * */
  _onUpdateBaseActor(t = {}, s = {}) {
    if (!this.isLinked && this.delta) {
      this.delta.updateSyntheticActor();
      for (const n of Object.values(this.delta.collections))
        n.initialize({ full: !0 });
    }
    this._onRelatedUpdate(t, s), this._updateCanvas(t);
  }
  // Update canvas if there are changes that affect the canvas
  _updateCanvas(t) {
    var n, l;
    if (!((n = this.scene) != null && n.isInFocus) && !((l = this.scene) != null && l.isView) || !this.automateVision || !this.sight.enabled) return;
    Object.keys(foundry.utils.flattenObject(t)).some((r) => r.startsWith("system.attributes.senses")) && (canvas.perception.update({ initializeVision: !0 }, !0), this.reset());
  }
  /** @inheritdoc */
  getBarAttribute(t, { alternative: s } = {}) {
    const n = super.getBarAttribute(t, { alternative: s });
    return n && n.attribute === "attributes.hp" && (n.value += parseInt(
      foundry.utils.getProperty(this.actor.system, "attributes.hp.temp") || 0,
      10
    ), n.max += parseInt(
      foundry.utils.getProperty(this.actor.system, "attributes.hp.temp") || 0,
      10
    )), n;
  }
};
u(VC, "TokenDocumentA5e");
let Up = VC;
const hhe = new Proxy(fc, {
  construct(i, e) {
    const t = CONFIG.A5E.Actor.documentClasses[e[0].type] ?? fc;
    return new t(...e);
  }
}), ghe = new Proxy(ku, {
  construct(i, e) {
    var s;
    const t = CONFIG.A5E.Item.documentClasses[(s = e[0]) == null ? void 0 : s.type] ?? bc;
    return new t(...e);
  }
}), WC = class WC extends DetectionMode {
  constructor() {
    super({
      angle: !1,
      id: "blindsight",
      label: "A5E.SenseBlindsight",
      type: DetectionMode.DETECTION_TYPES.OTHER,
      walls: !0
    });
  }
  static getDetectionFilter() {
    return this._detectionFilter ?? (this._detectionFilter = OutlineOverlayFilter.create({
      outlineColor: [1, 1, 1, 1],
      knockout: !0,
      wave: !0
    })), this._detectionFilter;
  }
  _canDetect() {
    return !0;
  }
  _testLOS(e, t, s, n) {
    return !CONFIG.Canvas.polygonBackends.sight.testCollision({ x: e.x, y: e.y }, n.point, {
      type: "sight",
      mode: "any",
      source: e,
      useThreshold: !1
    });
  }
};
u(WC, "DetectionModeBlindSight");
let ek = WC;
function bhe() {
  CONFIG.Canvas.detectionModes.blindsight = new ek();
}
u(bhe, "prepareDetectionModes");
function _he(i) {
  let e, t, s, n, l, r, o = (
    /*filterSelections*/
    i[1][
      /*filterKey*/
      i[0]
    ].inclusiveMode == 1 ? "AND" : "OR"
  ), a, c, f, d = (
    /*filterSelections*/
    i[1][
      /*filterKey*/
      i[0]
    ].exclusiveMode == 1 ? "AND" : "OR"
  ), p, m, g, h, _, y;
  return g = new Pp({
    props: {
      color: "red",
      options: Object.entries(
        /*options*/
        i[3]
      ),
      selected: [
        /*filterSelections*/
        i[1][
          /*filterKey*/
          i[0]
        ].inclusive,
        /*filterSelections*/
        i[1][
          /*filterKey*/
          i[0]
        ].exclusive
      ]
    }
  }), g.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), {
    c() {
      e = E("header"), t = E("h3"), s = Q(
        /*heading*/
        i[2]
      ), n = F(), l = E("div"), r = E("button"), a = Q(o), c = F(), f = E("button"), p = Q(d), m = F(), j(g.$$.fragment), b(t, "class", "a5efc-filter-heading svelte-gn2v02"), b(r, "class", "a5efc-filter-mode-button a5efc-filter-mode-button--inclusive svelte-gn2v02"), b(r, "data-tooltip", "Toggle Inclusive Filter Mode"), b(r, "data-tooltip-direction", "UP"), b(f, "class", "a5efc-filter-mode-button a5efc-filter-mode-button--exclusive svelte-gn2v02"), b(f, "data-tooltip", "Toggle Exclusive Filter Mode"), b(f, "data-tooltip-direction", "UP"), b(l, "class", "a5efc-filter-mode-button-wrapper svelte-gn2v02"), b(e, "class", "a5efc-filter-header svelte-gn2v02");
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(t, s), A(e, n), A(e, l), A(l, r), A(r, a), A(l, c), A(l, f), A(f, p), T(v, m, k), R(g, v, k), h = !0, _ || (y = [
        W(
          r,
          "click",
          /*click_handler*/
          i[5]
        ),
        W(
          f,
          "click",
          /*click_handler_1*/
          i[6]
        )
      ], _ = !0);
    },
    p(v, k) {
      (!h || k & /*heading*/
      4) && be(
        s,
        /*heading*/
        v[2]
      ), (!h || k & /*filterSelections, filterKey*/
      3) && o !== (o = /*filterSelections*/
      v[1][
        /*filterKey*/
        v[0]
      ].inclusiveMode == 1 ? "AND" : "OR") && be(a, o), (!h || k & /*filterSelections, filterKey*/
      3) && d !== (d = /*filterSelections*/
      v[1][
        /*filterKey*/
        v[0]
      ].exclusiveMode == 1 ? "AND" : "OR") && be(p, d);
      const S = {};
      k & /*options*/
      8 && (S.options = Object.entries(
        /*options*/
        v[3]
      )), k & /*filterSelections, filterKey*/
      3 && (S.selected = [
        /*filterSelections*/
        v[1][
          /*filterKey*/
          v[0]
        ].inclusive,
        /*filterSelections*/
        v[1][
          /*filterKey*/
          v[0]
        ].exclusive
      ]), g.$set(S);
    },
    i(v) {
      h || (w(g.$$.fragment, v), h = !0);
    },
    o(v) {
      O(g.$$.fragment, v), h = !1;
    },
    d(v) {
      v && (C(e), C(m)), N(g, v), _ = !1, Me(y);
    }
  };
}
u(_he, "create_default_slot$n");
function yhe(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [_he] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*$$scope, options, filterSelections, filterKey, heading*/
      271 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(yhe, "create_fragment$14");
function vhe(i, e, t) {
  let { filterKey: s } = e, { filterSelections: n } = e, { heading: l } = e, { options: r } = e;
  const o = ft(), a = /* @__PURE__ */ u(() => o("updateInclusiveMode", !n[s].inclusiveMode == 1), "click_handler"), c = /* @__PURE__ */ u(() => o("updateExclusiveMode", !n[s].exclusiveMode == 1), "click_handler_1");
  function f(d) {
    bt.call(this, i, d);
  }
  return u(f, "updateSelection_handler"), i.$$set = (d) => {
    "filterKey" in d && t(0, s = d.filterKey), "filterSelections" in d && t(1, n = d.filterSelections), "heading" in d && t(2, l = d.heading), "options" in d && t(3, r = d.options);
  }, [
    s,
    n,
    l,
    r,
    o,
    a,
    c,
    f
  ];
}
u(vhe, "instance$_");
const KC = class KC extends re {
  constructor(e) {
    super(), oe(this, e, vhe, yhe, le, {
      filterKey: 0,
      filterSelections: 1,
      heading: 2,
      options: 3
    });
  }
};
u(KC, "CompendiumFilterCategory");
let Sr = KC;
function t8(i) {
  return Object.prototype.toString.call(i) === "[object Date]";
}
u(t8, "is_date");
function tk(i, e, t, s) {
  if (typeof t == "number" || t8(t)) {
    const n = s - t, l = (t - e) / (i.dt || 1 / 60), r = i.opts.stiffness * n, o = i.opts.damping * l, a = (r - o) * i.inv_mass, c = (l + a) * i.dt;
    return Math.abs(c) < i.opts.precision && Math.abs(n) < i.opts.precision ? s : (i.settled = !1, t8(t) ? new Date(t.getTime() + c) : t + c);
  } else {
    if (Array.isArray(t))
      return t.map(
        (n, l) => tk(i, e[l], t[l], s[l])
      );
    if (typeof t == "object") {
      const n = {};
      for (const l in t)
        n[l] = tk(i, e[l], t[l], s[l]);
      return n;
    } else
      throw new Error(`Cannot spring ${typeof t} values`);
  }
}
u(tk, "tick_spring");
function khe(i, e = {}) {
  const t = Mt(i), { stiffness: s = 0.15, damping: n = 0.8, precision: l = 0.01 } = e;
  let r, o, a, c = i, f = i, d = 1, p = 0, m = !1;
  function g(_, y = {}) {
    f = _;
    const v = a = {};
    return i == null || y.hard || h.stiffness >= 1 && h.damping >= 1 ? (m = !0, r = uu(), c = _, t.set(i = f), Promise.resolve()) : (y.soft && (p = 1 / ((y.soft === !0 ? 0.5 : +y.soft) * 60), d = 0), o || (r = uu(), m = !1, o = rg((k) => {
      if (m)
        return m = !1, o = null, !1;
      d = Math.min(d + p, 1);
      const S = {
        inv_mass: d,
        opts: h,
        settled: !0,
        dt: (k - r) * 60 / 1e3
      }, D = tk(S, c, i, f);
      return r = k, c = i, t.set(i = D), S.settled && (o = null), !S.settled;
    })), new Promise((k) => {
      o.promise.then(() => {
        v === a && k();
      });
    }));
  }
  u(g, "set");
  const h = {
    set: g,
    update: /* @__PURE__ */ u((_, y) => g(_(f, i), y), "update"),
    subscribe: t.subscribe,
    stiffness: s,
    damping: n,
    precision: l
  };
  return h;
}
u(khe, "spring");
function s8(i, e, t) {
  const s = i.slice();
  return s[37] = e[t], s[39] = t, s;
}
u(s8, "get_each_context$p");
function n8(i) {
  let e, t, s, n, l = (
    /*all*/
    (i[6] === "label" || /*first*/
    i[7] === "label") && i8(i)
  );
  return {
    c() {
      e = E("span"), l && l.c(), b(e, "class", "pip first"), b(e, "style", t = /*orientationStart*/
      i[14] + ": 0%;"), Z(
        e,
        "selected",
        /*isSelected*/
        i[18](
          /*min*/
          i[0]
        )
      ), Z(
        e,
        "in-range",
        /*inRange*/
        i[17](
          /*min*/
          i[0]
        )
      );
    },
    m(r, o) {
      T(r, e, o), l && l.m(e, null), s || (n = [
        W(
          e,
          "pointerdown",
          /*pointerdown_handler*/
          i[30]
        ),
        W(
          e,
          "pointerup",
          /*pointerup_handler*/
          i[31]
        )
      ], s = !0);
    },
    p(r, o) {
      /*all*/
      r[6] === "label" || /*first*/
      r[7] === "label" ? l ? l.p(r, o) : (l = i8(r), l.c(), l.m(e, null)) : l && (l.d(1), l = null), o[0] & /*orientationStart*/
      16384 && t !== (t = /*orientationStart*/
      r[14] + ": 0%;") && b(e, "style", t), o[0] & /*isSelected, min*/
      262145 && Z(
        e,
        "selected",
        /*isSelected*/
        r[18](
          /*min*/
          r[0]
        )
      ), o[0] & /*inRange, min*/
      131073 && Z(
        e,
        "in-range",
        /*inRange*/
        r[17](
          /*min*/
          r[0]
        )
      );
    },
    d(r) {
      r && C(e), l && l.d(), s = !1, Me(n);
    }
  };
}
u(n8, "create_if_block_9$3");
function i8(i) {
  let e, t, s, n = (
    /*formatter*/
    i[12](
      /*fixFloat*/
      i[16](
        /*min*/
        i[0]
      ),
      0,
      0
    ) + ""
  ), l, r = (
    /*prefix*/
    i[10] && l8(i)
  ), o = (
    /*suffix*/
    i[11] && r8(i)
  );
  return {
    c() {
      e = E("span"), r && r.c(), t = $e(), s = new bn(!1), l = $e(), o && o.c(), s.a = l, b(e, "class", "pipVal");
    },
    m(a, c) {
      T(a, e, c), r && r.m(e, null), A(e, t), s.m(n, e), A(e, l), o && o.m(e, null);
    },
    p(a, c) {
      /*prefix*/
      a[10] ? r ? r.p(a, c) : (r = l8(a), r.c(), r.m(e, t)) : r && (r.d(1), r = null), c[0] & /*formatter, fixFloat, min*/
      69633 && n !== (n = /*formatter*/
      a[12](
        /*fixFloat*/
        a[16](
          /*min*/
          a[0]
        ),
        0,
        0
      ) + "") && s.p(n), /*suffix*/
      a[11] ? o ? o.p(a, c) : (o = r8(a), o.c(), o.m(e, null)) : o && (o.d(1), o = null);
    },
    d(a) {
      a && C(e), r && r.d(), o && o.d();
    }
  };
}
u(i8, "create_if_block_10$2");
function l8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = Q(
        /*prefix*/
        i[10]
      ), b(e, "class", "pipVal-prefix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*prefix*/
      1024 && be(
        t,
        /*prefix*/
        s[10]
      );
    },
    d(s) {
      s && C(e);
    }
  };
}
u(l8, "create_if_block_12");
function r8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = Q(
        /*suffix*/
        i[11]
      ), b(e, "class", "pipVal-suffix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*suffix*/
      2048 && be(
        t,
        /*suffix*/
        s[11]
      );
    },
    d(s) {
      s && C(e);
    }
  };
}
u(r8, "create_if_block_11$1");
function o8(i) {
  let e, t = ue(Array(
    /*pipCount*/
    i[20] + 1
  )), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = d8(s8(i, t, n));
  return {
    c() {
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      e = $e();
    },
    m(n, l) {
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(n, l);
      T(n, e, l);
    },
    p(n, l) {
      if (l[0] & /*orientationStart, percentOf, pipVal, isSelected, inRange, labelDown, labelUp, suffix, formatter, prefix, all, rest, min, max, pipCount*/
      8314435) {
        t = ue(Array(
          /*pipCount*/
          n[20] + 1
        ));
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = s8(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = d8(o), s[r].c(), s[r].m(e.parentNode, e));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(o8, "create_if_block_4$9");
function a8(i) {
  let e, t, s, n, l, r = (
    /*all*/
    (i[6] === "label" || /*rest*/
    i[9] === "label") && c8(i)
  );
  function o(...a) {
    return (
      /*pointerup_handler_1*/
      i[33](
        /*i*/
        i[39],
        ...a
      )
    );
  }
  return u(o, "pointerup_handler_1"), {
    c() {
      e = E("span"), r && r.c(), t = F(), b(e, "class", "pip"), b(e, "style", s = /*orientationStart*/
      i[14] + ": " + /*percentOf*/
      i[15](
        /*pipVal*/
        i[19](
          /*i*/
          i[39]
        )
      ) + "%;"), Z(
        e,
        "selected",
        /*isSelected*/
        i[18](
          /*pipVal*/
          i[19](
            /*i*/
            i[39]
          )
        )
      ), Z(
        e,
        "in-range",
        /*inRange*/
        i[17](
          /*pipVal*/
          i[19](
            /*i*/
            i[39]
          )
        )
      );
    },
    m(a, c) {
      T(a, e, c), r && r.m(e, null), A(e, t), n || (l = [
        W(
          e,
          "pointerdown",
          /*pointerdown_handler_1*/
          i[32]
        ),
        W(e, "pointerup", o)
      ], n = !0);
    },
    p(a, c) {
      i = a, /*all*/
      i[6] === "label" || /*rest*/
      i[9] === "label" ? r ? r.p(i, c) : (r = c8(i), r.c(), r.m(e, t)) : r && (r.d(1), r = null), c[0] & /*orientationStart, percentOf, pipVal*/
      573440 && s !== (s = /*orientationStart*/
      i[14] + ": " + /*percentOf*/
      i[15](
        /*pipVal*/
        i[19](
          /*i*/
          i[39]
        )
      ) + "%;") && b(e, "style", s), c[0] & /*isSelected, pipVal*/
      786432 && Z(
        e,
        "selected",
        /*isSelected*/
        i[18](
          /*pipVal*/
          i[19](
            /*i*/
            i[39]
          )
        )
      ), c[0] & /*inRange, pipVal*/
      655360 && Z(
        e,
        "in-range",
        /*inRange*/
        i[17](
          /*pipVal*/
          i[19](
            /*i*/
            i[39]
          )
        )
      );
    },
    d(a) {
      a && C(e), r && r.d(), n = !1, Me(l);
    }
  };
}
u(a8, "create_if_block_5$6");
function c8(i) {
  let e, t, s, n = (
    /*formatter*/
    i[12](
      /*pipVal*/
      i[19](
        /*i*/
        i[39]
      ),
      /*i*/
      i[39],
      /*percentOf*/
      i[15](
        /*pipVal*/
        i[19](
          /*i*/
          i[39]
        )
      )
    ) + ""
  ), l, r = (
    /*prefix*/
    i[10] && u8(i)
  ), o = (
    /*suffix*/
    i[11] && f8(i)
  );
  return {
    c() {
      e = E("span"), r && r.c(), t = $e(), s = new bn(!1), l = $e(), o && o.c(), s.a = l, b(e, "class", "pipVal");
    },
    m(a, c) {
      T(a, e, c), r && r.m(e, null), A(e, t), s.m(n, e), A(e, l), o && o.m(e, null);
    },
    p(a, c) {
      /*prefix*/
      a[10] ? r ? r.p(a, c) : (r = u8(a), r.c(), r.m(e, t)) : r && (r.d(1), r = null), c[0] & /*formatter, pipVal, percentOf*/
      561152 && n !== (n = /*formatter*/
      a[12](
        /*pipVal*/
        a[19](
          /*i*/
          a[39]
        ),
        /*i*/
        a[39],
        /*percentOf*/
        a[15](
          /*pipVal*/
          a[19](
            /*i*/
            a[39]
          )
        )
      ) + "") && s.p(n), /*suffix*/
      a[11] ? o ? o.p(a, c) : (o = f8(a), o.c(), o.m(e, null)) : o && (o.d(1), o = null);
    },
    d(a) {
      a && C(e), r && r.d(), o && o.d();
    }
  };
}
u(c8, "create_if_block_6$5");
function u8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = Q(
        /*prefix*/
        i[10]
      ), b(e, "class", "pipVal-prefix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*prefix*/
      1024 && be(
        t,
        /*prefix*/
        s[10]
      );
    },
    d(s) {
      s && C(e);
    }
  };
}
u(u8, "create_if_block_8$3");
function f8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = Q(
        /*suffix*/
        i[11]
      ), b(e, "class", "pipVal-suffix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*suffix*/
      2048 && be(
        t,
        /*suffix*/
        s[11]
      );
    },
    d(s) {
      s && C(e);
    }
  };
}
u(f8, "create_if_block_7$5");
function d8(i) {
  let e = (
    /*pipVal*/
    i[19](
      /*i*/
      i[39]
    ) !== /*min*/
    i[0] && /*pipVal*/
    i[19](
      /*i*/
      i[39]
    ) !== /*max*/
    i[1]
  ), t, s = e && a8(i);
  return {
    c() {
      s && s.c(), t = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, t, l);
    },
    p(n, l) {
      l[0] & /*pipVal, min, max*/
      524291 && (e = /*pipVal*/
      n[19](
        /*i*/
        n[39]
      ) !== /*min*/
      n[0] && /*pipVal*/
      n[19](
        /*i*/
        n[39]
      ) !== /*max*/
      n[1]), e ? s ? s.p(n, l) : (s = a8(n), s.c(), s.m(t.parentNode, t)) : s && (s.d(1), s = null);
    },
    d(n) {
      n && C(t), s && s.d(n);
    }
  };
}
u(d8, "create_each_block$p");
function p8(i) {
  let e, t, s, n, l = (
    /*all*/
    (i[6] === "label" || /*last*/
    i[8] === "label") && m8(i)
  );
  return {
    c() {
      e = E("span"), l && l.c(), b(e, "class", "pip last"), b(e, "style", t = /*orientationStart*/
      i[14] + ": 100%;"), Z(
        e,
        "selected",
        /*isSelected*/
        i[18](
          /*max*/
          i[1]
        )
      ), Z(
        e,
        "in-range",
        /*inRange*/
        i[17](
          /*max*/
          i[1]
        )
      );
    },
    m(r, o) {
      T(r, e, o), l && l.m(e, null), s || (n = [
        W(
          e,
          "pointerdown",
          /*pointerdown_handler_2*/
          i[34]
        ),
        W(
          e,
          "pointerup",
          /*pointerup_handler_2*/
          i[35]
        )
      ], s = !0);
    },
    p(r, o) {
      /*all*/
      r[6] === "label" || /*last*/
      r[8] === "label" ? l ? l.p(r, o) : (l = m8(r), l.c(), l.m(e, null)) : l && (l.d(1), l = null), o[0] & /*orientationStart*/
      16384 && t !== (t = /*orientationStart*/
      r[14] + ": 100%;") && b(e, "style", t), o[0] & /*isSelected, max*/
      262146 && Z(
        e,
        "selected",
        /*isSelected*/
        r[18](
          /*max*/
          r[1]
        )
      ), o[0] & /*inRange, max*/
      131074 && Z(
        e,
        "in-range",
        /*inRange*/
        r[17](
          /*max*/
          r[1]
        )
      );
    },
    d(r) {
      r && C(e), l && l.d(), s = !1, Me(n);
    }
  };
}
u(p8, "create_if_block$x");
function m8(i) {
  let e, t, s, n = (
    /*formatter*/
    i[12](
      /*fixFloat*/
      i[16](
        /*max*/
        i[1]
      ),
      /*pipCount*/
      i[20],
      100
    ) + ""
  ), l, r = (
    /*prefix*/
    i[10] && h8(i)
  ), o = (
    /*suffix*/
    i[11] && g8(i)
  );
  return {
    c() {
      e = E("span"), r && r.c(), t = $e(), s = new bn(!1), l = $e(), o && o.c(), s.a = l, b(e, "class", "pipVal");
    },
    m(a, c) {
      T(a, e, c), r && r.m(e, null), A(e, t), s.m(n, e), A(e, l), o && o.m(e, null);
    },
    p(a, c) {
      /*prefix*/
      a[10] ? r ? r.p(a, c) : (r = h8(a), r.c(), r.m(e, t)) : r && (r.d(1), r = null), c[0] & /*formatter, fixFloat, max, pipCount*/
      1118210 && n !== (n = /*formatter*/
      a[12](
        /*fixFloat*/
        a[16](
          /*max*/
          a[1]
        ),
        /*pipCount*/
        a[20],
        100
      ) + "") && s.p(n), /*suffix*/
      a[11] ? o ? o.p(a, c) : (o = g8(a), o.c(), o.m(e, null)) : o && (o.d(1), o = null);
    },
    d(a) {
      a && C(e), r && r.d(), o && o.d();
    }
  };
}
u(m8, "create_if_block_1$m");
function h8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = Q(
        /*prefix*/
        i[10]
      ), b(e, "class", "pipVal-prefix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*prefix*/
      1024 && be(
        t,
        /*prefix*/
        s[10]
      );
    },
    d(s) {
      s && C(e);
    }
  };
}
u(h8, "create_if_block_3$9");
function g8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = Q(
        /*suffix*/
        i[11]
      ), b(e, "class", "pipVal-suffix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*suffix*/
      2048 && be(
        t,
        /*suffix*/
        s[11]
      );
    },
    d(s) {
      s && C(e);
    }
  };
}
u(g8, "create_if_block_2$f");
function whe(i) {
  let e, t, s, n = (
    /*all*/
    (i[6] && /*first*/
    i[7] !== !1 || /*first*/
    i[7]) && n8(i)
  ), l = (
    /*all*/
    (i[6] && /*rest*/
    i[9] !== !1 || /*rest*/
    i[9]) && o8(i)
  ), r = (
    /*all*/
    (i[6] && /*last*/
    i[8] !== !1 || /*last*/
    i[8]) && p8(i)
  );
  return {
    c() {
      e = E("div"), n && n.c(), t = F(), l && l.c(), s = F(), r && r.c(), b(e, "class", "rangePips"), Z(
        e,
        "disabled",
        /*disabled*/
        i[5]
      ), Z(
        e,
        "hoverable",
        /*hoverable*/
        i[4]
      ), Z(
        e,
        "vertical",
        /*vertical*/
        i[2]
      ), Z(
        e,
        "reversed",
        /*reversed*/
        i[3]
      ), Z(
        e,
        "focus",
        /*focus*/
        i[13]
      );
    },
    m(o, a) {
      T(o, e, a), n && n.m(e, null), A(e, t), l && l.m(e, null), A(e, s), r && r.m(e, null);
    },
    p(o, a) {
      /*all*/
      o[6] && /*first*/
      o[7] !== !1 || /*first*/
      o[7] ? n ? n.p(o, a) : (n = n8(o), n.c(), n.m(e, t)) : n && (n.d(1), n = null), /*all*/
      o[6] && /*rest*/
      o[9] !== !1 || /*rest*/
      o[9] ? l ? l.p(o, a) : (l = o8(o), l.c(), l.m(e, s)) : l && (l.d(1), l = null), /*all*/
      o[6] && /*last*/
      o[8] !== !1 || /*last*/
      o[8] ? r ? r.p(o, a) : (r = p8(o), r.c(), r.m(e, null)) : r && (r.d(1), r = null), a[0] & /*disabled*/
      32 && Z(
        e,
        "disabled",
        /*disabled*/
        o[5]
      ), a[0] & /*hoverable*/
      16 && Z(
        e,
        "hoverable",
        /*hoverable*/
        o[4]
      ), a[0] & /*vertical*/
      4 && Z(
        e,
        "vertical",
        /*vertical*/
        o[2]
      ), a[0] & /*reversed*/
      8 && Z(
        e,
        "reversed",
        /*reversed*/
        o[3]
      ), a[0] & /*focus*/
      8192 && Z(
        e,
        "focus",
        /*focus*/
        o[13]
      );
    },
    i: se,
    o: se,
    d(o) {
      o && C(e), n && n.d(), l && l.d(), r && r.d();
    }
  };
}
u(whe, "create_fragment$13");
function $he(i, e, t) {
  let s, n, l, r, o, { range: a = !1 } = e, { min: c = 0 } = e, { max: f = 100 } = e, { step: d = 1 } = e, { values: p = [(f + c) / 2] } = e, { vertical: m = !1 } = e, { reversed: g = !1 } = e, { hoverable: h = !0 } = e, { disabled: _ = !1 } = e, { pipstep: y = void 0 } = e, { all: v = !0 } = e, { first: k = void 0 } = e, { last: S = void 0 } = e, { rest: D = void 0 } = e, { prefix: I = "" } = e, { suffix: M = "" } = e, { formatter: L = /* @__PURE__ */ u((me, Ce, Je) => me, "formatter") } = e, { focus: B = void 0 } = e, { orientationStart: z = void 0 } = e, { percentOf: q = void 0 } = e, { moveHandle: U = void 0 } = e, { fixFloat: H = void 0 } = e, { normalisedClient: V = void 0 } = e, Y;
  function J(me) {
    me = V(me), Y = { x: me.clientX, y: me.clientY };
  }
  u(J, "labelDown");
  function fe(me, Ce) {
    if (Ce = V(Ce), !_) {
      const Je = Math.sqrt(Math.pow(Y.x - Ce.clientX, 2) + Math.pow(Y.y - Ce.clientY, 2));
      Y && Je <= 5 && U(void 0, me);
    }
  }
  u(fe, "labelUp");
  const ke = /* @__PURE__ */ u((me) => {
    J(me);
  }, "pointerdown_handler"), ee = /* @__PURE__ */ u((me) => {
    fe(c, me);
  }, "pointerup_handler"), ne = /* @__PURE__ */ u((me) => {
    J(me);
  }, "pointerdown_handler_1"), Ee = /* @__PURE__ */ u((me, Ce) => {
    fe(l(me), Ce);
  }, "pointerup_handler_1"), Pe = /* @__PURE__ */ u((me) => {
    J(me);
  }, "pointerdown_handler_2"), ye = /* @__PURE__ */ u((me) => {
    fe(f, me);
  }, "pointerup_handler_2");
  return i.$$set = (me) => {
    "range" in me && t(23, a = me.range), "min" in me && t(0, c = me.min), "max" in me && t(1, f = me.max), "step" in me && t(24, d = me.step), "values" in me && t(25, p = me.values), "vertical" in me && t(2, m = me.vertical), "reversed" in me && t(3, g = me.reversed), "hoverable" in me && t(4, h = me.hoverable), "disabled" in me && t(5, _ = me.disabled), "pipstep" in me && t(26, y = me.pipstep), "all" in me && t(6, v = me.all), "first" in me && t(7, k = me.first), "last" in me && t(8, S = me.last), "rest" in me && t(9, D = me.rest), "prefix" in me && t(10, I = me.prefix), "suffix" in me && t(11, M = me.suffix), "formatter" in me && t(12, L = me.formatter), "focus" in me && t(13, B = me.focus), "orientationStart" in me && t(14, z = me.orientationStart), "percentOf" in me && t(15, q = me.percentOf), "moveHandle" in me && t(27, U = me.moveHandle), "fixFloat" in me && t(16, H = me.fixFloat), "normalisedClient" in me && t(28, V = me.normalisedClient);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*pipstep, max, min, step, vertical*/
    83886087 && t(29, s = y || ((f - c) / d >= (m ? 50 : 100) ? (f - c) / (m ? 10 : 20) : 1)), i.$$.dirty[0] & /*max, min, step, pipStep*/
    553648131 && t(20, n = parseInt((f - c) / (d * s), 10)), i.$$.dirty[0] & /*fixFloat, min, step, pipStep*/
    553713665 && t(19, l = /* @__PURE__ */ u(function(me) {
      return H(c + me * d * s);
    }, "pipVal")), i.$$.dirty[0] & /*values, fixFloat*/
    33619968 && t(18, r = /* @__PURE__ */ u(function(me) {
      return p.some((Ce) => H(Ce) === H(me));
    }, "isSelected")), i.$$.dirty[0] & /*range, values*/
    41943040 && t(17, o = /* @__PURE__ */ u(function(me) {
      if (a === "min")
        return p[0] > me;
      if (a === "max")
        return p[0] < me;
      if (a)
        return p[0] < me && p[1] > me;
    }, "inRange"));
  }, [
    c,
    f,
    m,
    g,
    h,
    _,
    v,
    k,
    S,
    D,
    I,
    M,
    L,
    B,
    z,
    q,
    H,
    o,
    r,
    l,
    n,
    J,
    fe,
    a,
    d,
    p,
    y,
    U,
    V,
    s,
    ke,
    ee,
    ne,
    Ee,
    Pe,
    ye
  ];
}
u($he, "instance$Z");
const YC = class YC extends re {
  constructor(e) {
    super(), oe(
      this,
      e,
      $he,
      whe,
      le,
      {
        range: 23,
        min: 0,
        max: 1,
        step: 24,
        values: 25,
        vertical: 2,
        reversed: 3,
        hoverable: 4,
        disabled: 5,
        pipstep: 26,
        all: 6,
        first: 7,
        last: 8,
        rest: 9,
        prefix: 10,
        suffix: 11,
        formatter: 12,
        focus: 13,
        orientationStart: 14,
        percentOf: 15,
        moveHandle: 27,
        fixFloat: 16,
        normalisedClient: 28
      },
      null,
      [-1, -1]
    );
  }
};
u(YC, "RangePips");
let sk = YC;
function b8(i, e, t) {
  const s = i.slice();
  return s[65] = e[t], s[67] = t, s;
}
u(b8, "get_each_context$o");
function _8(i) {
  let e, t, s, n = (
    /*handleFormatter*/
    i[21](
      /*value*/
      i[65],
      /*index*/
      i[67],
      /*percentOf*/
      i[24](
        /*value*/
        i[65]
      )
    ) + ""
  ), l, r = (
    /*prefix*/
    i[18] && y8(i)
  ), o = (
    /*suffix*/
    i[19] && v8(i)
  );
  return {
    c() {
      e = E("span"), r && r.c(), t = $e(), s = new bn(!1), l = $e(), o && o.c(), s.a = l, b(e, "class", "rangeFloat");
    },
    m(a, c) {
      T(a, e, c), r && r.m(e, null), A(e, t), s.m(n, e), A(e, l), o && o.m(e, null);
    },
    p(a, c) {
      /*prefix*/
      a[18] ? r ? r.p(a, c) : (r = y8(a), r.c(), r.m(e, t)) : r && (r.d(1), r = null), c[0] & /*handleFormatter, values, percentOf*/
      18874369 && n !== (n = /*handleFormatter*/
      a[21](
        /*value*/
        a[65],
        /*index*/
        a[67],
        /*percentOf*/
        a[24](
          /*value*/
          a[65]
        )
      ) + "") && s.p(n), /*suffix*/
      a[19] ? o ? o.p(a, c) : (o = v8(a), o.c(), o.m(e, null)) : o && (o.d(1), o = null);
    },
    d(a) {
      a && C(e), r && r.d(), o && o.d();
    }
  };
}
u(_8, "create_if_block_2$e");
function y8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = Q(
        /*prefix*/
        i[18]
      ), b(e, "class", "rangeFloat-prefix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*prefix*/
      262144 && be(
        t,
        /*prefix*/
        s[18]
      );
    },
    d(s) {
      s && C(e);
    }
  };
}
u(y8, "create_if_block_4$8");
function v8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = Q(
        /*suffix*/
        i[19]
      ), b(e, "class", "rangeFloat-suffix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*suffix*/
      524288 && be(
        t,
        /*suffix*/
        s[19]
      );
    },
    d(s) {
      s && C(e);
    }
  };
}
u(v8, "create_if_block_3$8");
function k8(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g = (
    /*float*/
    i[7] && _8(i)
  );
  return {
    c() {
      e = E("span"), t = E("span"), s = F(), g && g.c(), b(t, "class", "rangeNub"), b(e, "role", "slider"), b(e, "class", "rangeHandle"), b(
        e,
        "data-handle",
        /*index*/
        i[67]
      ), b(e, "style", n = /*orientationStart*/
      i[29] + ": " + /*$springPositions*/
      i[30][
        /*index*/
        i[67]
      ] + "%; z-index: " + /*activeHandle*/
      (i[27] === /*index*/
      i[67] ? 3 : 2) + ";"), b(e, "aria-label", l = /*ariaLabels*/
      i[22][
        /*index*/
        i[67]
      ]), b(e, "aria-valuemin", r = /*range*/
      i[2] === !0 && /*index*/
      i[67] === 1 ? (
        /*values*/
        i[0][0]
      ) : (
        /*min*/
        i[3]
      )), b(e, "aria-valuemax", o = /*range*/
      i[2] === !0 && /*index*/
      i[67] === 0 ? (
        /*values*/
        i[0][1]
      ) : (
        /*max*/
        i[4]
      )), b(e, "aria-valuenow", a = /*value*/
      i[65]), b(e, "aria-valuetext", c = "" + /*prefix*/
      (i[18] + E8(
        /*handleFormatter*/
        i[21](
          /*value*/
          i[65],
          /*index*/
          i[67],
          /*percentOf*/
          i[24](
            /*value*/
            i[65]
          )
        )
      ) + /*suffix*/
      i[19])), b(e, "aria-orientation", f = /*vertical*/
      i[6] ? "vertical" : "horizontal"), b(
        e,
        "aria-disabled",
        /*disabled*/
        i[10]
      ), b(
        e,
        "disabled",
        /*disabled*/
        i[10]
      ), b(e, "tabindex", d = /*disabled*/
      i[10] ? -1 : 0), Z(
        e,
        "active",
        /*focus*/
        i[25] && /*activeHandle*/
        i[27] === /*index*/
        i[67]
      ), Z(
        e,
        "press",
        /*handlePressed*/
        i[26] && /*activeHandle*/
        i[27] === /*index*/
        i[67]
      );
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(e, s), g && g.m(e, null), p || (m = [
        W(
          e,
          "blur",
          /*sliderBlurHandle*/
          i[35]
        ),
        W(
          e,
          "focus",
          /*sliderFocusHandle*/
          i[36]
        ),
        W(
          e,
          "keydown",
          /*sliderKeydown*/
          i[37]
        )
      ], p = !0);
    },
    p(h, _) {
      /*float*/
      h[7] ? g ? g.p(h, _) : (g = _8(h), g.c(), g.m(e, null)) : g && (g.d(1), g = null), _[0] & /*orientationStart, $springPositions, activeHandle*/
      1744830464 && n !== (n = /*orientationStart*/
      h[29] + ": " + /*$springPositions*/
      h[30][
        /*index*/
        h[67]
      ] + "%; z-index: " + /*activeHandle*/
      (h[27] === /*index*/
      h[67] ? 3 : 2) + ";") && b(e, "style", n), _[0] & /*ariaLabels*/
      4194304 && l !== (l = /*ariaLabels*/
      h[22][
        /*index*/
        h[67]
      ]) && b(e, "aria-label", l), _[0] & /*range, values, min*/
      13 && r !== (r = /*range*/
      h[2] === !0 && /*index*/
      h[67] === 1 ? (
        /*values*/
        h[0][0]
      ) : (
        /*min*/
        h[3]
      )) && b(e, "aria-valuemin", r), _[0] & /*range, values, max*/
      21 && o !== (o = /*range*/
      h[2] === !0 && /*index*/
      h[67] === 0 ? (
        /*values*/
        h[0][1]
      ) : (
        /*max*/
        h[4]
      )) && b(e, "aria-valuemax", o), _[0] & /*values*/
      1 && a !== (a = /*value*/
      h[65]) && b(e, "aria-valuenow", a), _[0] & /*prefix, handleFormatter, values, percentOf, suffix*/
      19660801 && c !== (c = "" + /*prefix*/
      (h[18] + E8(
        /*handleFormatter*/
        h[21](
          /*value*/
          h[65],
          /*index*/
          h[67],
          /*percentOf*/
          h[24](
            /*value*/
            h[65]
          )
        )
      ) + /*suffix*/
      h[19])) && b(e, "aria-valuetext", c), _[0] & /*vertical*/
      64 && f !== (f = /*vertical*/
      h[6] ? "vertical" : "horizontal") && b(e, "aria-orientation", f), _[0] & /*disabled*/
      1024 && b(
        e,
        "aria-disabled",
        /*disabled*/
        h[10]
      ), _[0] & /*disabled*/
      1024 && b(
        e,
        "disabled",
        /*disabled*/
        h[10]
      ), _[0] & /*disabled*/
      1024 && d !== (d = /*disabled*/
      h[10] ? -1 : 0) && b(e, "tabindex", d), _[0] & /*focus, activeHandle*/
      167772160 && Z(
        e,
        "active",
        /*focus*/
        h[25] && /*activeHandle*/
        h[27] === /*index*/
        h[67]
      ), _[0] & /*handlePressed, activeHandle*/
      201326592 && Z(
        e,
        "press",
        /*handlePressed*/
        h[26] && /*activeHandle*/
        h[27] === /*index*/
        h[67]
      );
    },
    d(h) {
      h && C(e), g && g.d(), p = !1, Me(m);
    }
  };
}
u(k8, "create_each_block$o");
function w8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), b(e, "class", "rangeBar"), b(e, "style", t = /*orientationStart*/
      i[29] + ": " + /*rangeStart*/
      i[33](
        /*$springPositions*/
        i[30]
      ) + "%; " + /*orientationEnd*/
      i[28] + ": " + /*rangeEnd*/
      i[34](
        /*$springPositions*/
        i[30]
      ) + "%;");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n[0] & /*orientationStart, $springPositions, orientationEnd*/
      1879048192 && t !== (t = /*orientationStart*/
      s[29] + ": " + /*rangeStart*/
      s[33](
        /*$springPositions*/
        s[30]
      ) + "%; " + /*orientationEnd*/
      s[28] + ": " + /*rangeEnd*/
      s[34](
        /*$springPositions*/
        s[30]
      ) + "%;") && b(e, "style", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(w8, "create_if_block_1$l");
function $8(i) {
  let e, t;
  return e = new sk({
    props: {
      values: (
        /*values*/
        i[0]
      ),
      min: (
        /*min*/
        i[3]
      ),
      max: (
        /*max*/
        i[4]
      ),
      step: (
        /*step*/
        i[5]
      ),
      range: (
        /*range*/
        i[2]
      ),
      vertical: (
        /*vertical*/
        i[6]
      ),
      reversed: (
        /*reversed*/
        i[8]
      ),
      orientationStart: (
        /*orientationStart*/
        i[29]
      ),
      hoverable: (
        /*hoverable*/
        i[9]
      ),
      disabled: (
        /*disabled*/
        i[10]
      ),
      all: (
        /*all*/
        i[13]
      ),
      first: (
        /*first*/
        i[14]
      ),
      last: (
        /*last*/
        i[15]
      ),
      rest: (
        /*rest*/
        i[16]
      ),
      pipstep: (
        /*pipstep*/
        i[12]
      ),
      prefix: (
        /*prefix*/
        i[18]
      ),
      suffix: (
        /*suffix*/
        i[19]
      ),
      formatter: (
        /*formatter*/
        i[20]
      ),
      focus: (
        /*focus*/
        i[25]
      ),
      percentOf: (
        /*percentOf*/
        i[24]
      ),
      moveHandle: (
        /*moveHandle*/
        i[32]
      ),
      fixFloat: (
        /*fixFloat*/
        i[31]
      ),
      normalisedClient: Ld
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*values*/
      1 && (l.values = /*values*/
      s[0]), n[0] & /*min*/
      8 && (l.min = /*min*/
      s[3]), n[0] & /*max*/
      16 && (l.max = /*max*/
      s[4]), n[0] & /*step*/
      32 && (l.step = /*step*/
      s[5]), n[0] & /*range*/
      4 && (l.range = /*range*/
      s[2]), n[0] & /*vertical*/
      64 && (l.vertical = /*vertical*/
      s[6]), n[0] & /*reversed*/
      256 && (l.reversed = /*reversed*/
      s[8]), n[0] & /*orientationStart*/
      536870912 && (l.orientationStart = /*orientationStart*/
      s[29]), n[0] & /*hoverable*/
      512 && (l.hoverable = /*hoverable*/
      s[9]), n[0] & /*disabled*/
      1024 && (l.disabled = /*disabled*/
      s[10]), n[0] & /*all*/
      8192 && (l.all = /*all*/
      s[13]), n[0] & /*first*/
      16384 && (l.first = /*first*/
      s[14]), n[0] & /*last*/
      32768 && (l.last = /*last*/
      s[15]), n[0] & /*rest*/
      65536 && (l.rest = /*rest*/
      s[16]), n[0] & /*pipstep*/
      4096 && (l.pipstep = /*pipstep*/
      s[12]), n[0] & /*prefix*/
      262144 && (l.prefix = /*prefix*/
      s[18]), n[0] & /*suffix*/
      524288 && (l.suffix = /*suffix*/
      s[19]), n[0] & /*formatter*/
      1048576 && (l.formatter = /*formatter*/
      s[20]), n[0] & /*focus*/
      33554432 && (l.focus = /*focus*/
      s[25]), n[0] & /*percentOf*/
      16777216 && (l.percentOf = /*percentOf*/
      s[24]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u($8, "create_if_block$w");
function Ahe(i) {
  let e, t, s, n, l, r, o = ue(
    /*values*/
    i[0]
  ), a = [];
  for (let d = 0; d < o.length; d += 1)
    a[d] = k8(b8(i, o, d));
  let c = (
    /*range*/
    i[2] && w8(i)
  ), f = (
    /*pips*/
    i[11] && $8(i)
  );
  return {
    c() {
      e = E("div");
      for (let d = 0; d < a.length; d += 1)
        a[d].c();
      t = F(), c && c.c(), s = F(), f && f.c(), b(
        e,
        "id",
        /*id*/
        i[17]
      ), b(e, "role", "none"), b(e, "class", "rangeSlider"), Z(
        e,
        "range",
        /*range*/
        i[2]
      ), Z(
        e,
        "disabled",
        /*disabled*/
        i[10]
      ), Z(
        e,
        "hoverable",
        /*hoverable*/
        i[9]
      ), Z(
        e,
        "vertical",
        /*vertical*/
        i[6]
      ), Z(
        e,
        "reversed",
        /*reversed*/
        i[8]
      ), Z(
        e,
        "focus",
        /*focus*/
        i[25]
      ), Z(
        e,
        "min",
        /*range*/
        i[2] === "min"
      ), Z(
        e,
        "max",
        /*range*/
        i[2] === "max"
      ), Z(
        e,
        "pips",
        /*pips*/
        i[11]
      ), Z(
        e,
        "pip-labels",
        /*all*/
        i[13] === "label" || /*first*/
        i[14] === "label" || /*last*/
        i[15] === "label" || /*rest*/
        i[16] === "label"
      );
    },
    m(d, p) {
      T(d, e, p);
      for (let m = 0; m < a.length; m += 1)
        a[m] && a[m].m(e, null);
      A(e, t), c && c.m(e, null), A(e, s), f && f.m(e, null), i[51](e), n = !0, l || (r = [
        W(
          window,
          "mousedown",
          /*bodyInteractStart*/
          i[40]
        ),
        W(
          window,
          "touchstart",
          /*bodyInteractStart*/
          i[40]
        ),
        W(
          window,
          "mousemove",
          /*bodyInteract*/
          i[41]
        ),
        W(
          window,
          "touchmove",
          /*bodyInteract*/
          i[41]
        ),
        W(
          window,
          "mouseup",
          /*bodyMouseUp*/
          i[42]
        ),
        W(
          window,
          "touchend",
          /*bodyTouchEnd*/
          i[43]
        ),
        W(
          window,
          "keydown",
          /*bodyKeyDown*/
          i[44]
        ),
        W(
          e,
          "mousedown",
          /*sliderInteractStart*/
          i[38]
        ),
        W(
          e,
          "mouseup",
          /*sliderInteractEnd*/
          i[39]
        ),
        W(e, "touchstart", st(
          /*sliderInteractStart*/
          i[38]
        )),
        W(e, "touchend", st(
          /*sliderInteractEnd*/
          i[39]
        ))
      ], l = !0);
    },
    p(d, p) {
      if (p[0] & /*orientationStart, $springPositions, activeHandle, ariaLabels, range, values, min, max, prefix, handleFormatter, percentOf, suffix, vertical, disabled, focus, handlePressed, float*/
      1869350109 | p[1] & /*sliderBlurHandle, sliderFocusHandle, sliderKeydown*/
      112) {
        o = ue(
          /*values*/
          d[0]
        );
        let m;
        for (m = 0; m < o.length; m += 1) {
          const g = b8(d, o, m);
          a[m] ? a[m].p(g, p) : (a[m] = k8(g), a[m].c(), a[m].m(e, t));
        }
        for (; m < a.length; m += 1)
          a[m].d(1);
        a.length = o.length;
      }
      /*range*/
      d[2] ? c ? c.p(d, p) : (c = w8(d), c.c(), c.m(e, s)) : c && (c.d(1), c = null), /*pips*/
      d[11] ? f ? (f.p(d, p), p[0] & /*pips*/
      2048 && w(f, 1)) : (f = $8(d), f.c(), w(f, 1), f.m(e, null)) : f && (ae(), O(f, 1, 1, () => {
        f = null;
      }), ce()), (!n || p[0] & /*id*/
      131072) && b(
        e,
        "id",
        /*id*/
        d[17]
      ), (!n || p[0] & /*range*/
      4) && Z(
        e,
        "range",
        /*range*/
        d[2]
      ), (!n || p[0] & /*disabled*/
      1024) && Z(
        e,
        "disabled",
        /*disabled*/
        d[10]
      ), (!n || p[0] & /*hoverable*/
      512) && Z(
        e,
        "hoverable",
        /*hoverable*/
        d[9]
      ), (!n || p[0] & /*vertical*/
      64) && Z(
        e,
        "vertical",
        /*vertical*/
        d[6]
      ), (!n || p[0] & /*reversed*/
      256) && Z(
        e,
        "reversed",
        /*reversed*/
        d[8]
      ), (!n || p[0] & /*focus*/
      33554432) && Z(
        e,
        "focus",
        /*focus*/
        d[25]
      ), (!n || p[0] & /*range*/
      4) && Z(
        e,
        "min",
        /*range*/
        d[2] === "min"
      ), (!n || p[0] & /*range*/
      4) && Z(
        e,
        "max",
        /*range*/
        d[2] === "max"
      ), (!n || p[0] & /*pips*/
      2048) && Z(
        e,
        "pips",
        /*pips*/
        d[11]
      ), (!n || p[0] & /*all, first, last, rest*/
      122880) && Z(
        e,
        "pip-labels",
        /*all*/
        d[13] === "label" || /*first*/
        d[14] === "label" || /*last*/
        d[15] === "label" || /*rest*/
        d[16] === "label"
      );
    },
    i(d) {
      n || (w(f), n = !0);
    },
    o(d) {
      O(f), n = !1;
    },
    d(d) {
      d && C(e), Le(a, d), c && c.d(), f && f.d(), i[51](null), l = !1, Me(r);
    }
  };
}
u(Ahe, "create_fragment$12");
function A8(i) {
  if (!i) return -1;
  for (var e = 0; i = i.previousElementSibling; )
    e++;
  return e;
}
u(A8, "index");
function Ld(i) {
  return i.type.includes("touch") ? i.touches[0] || i.changedTouches[0] : i;
}
u(Ld, "normalisedClient");
function E8(i) {
  return `${i}`.replace(/<[^>]*>/g, "");
}
u(E8, "pureText");
function Ehe(i, e, t) {
  let s, n, l, r, o, a, c = se, f = /* @__PURE__ */ u(() => (c(), c = Xt(je, (Ie) => t(30, a = Ie)), je), "$$subscribe_springPositions");
  i.$$.on_destroy.push(() => c());
  let { slider: d = void 0 } = e, { range: p = !1 } = e, { pushy: m = !1 } = e, { min: g = 0 } = e, { max: h = 100 } = e, { step: _ = 1 } = e, { values: y = [(h + g) / 2] } = e, { vertical: v = !1 } = e, { float: k = !1 } = e, { reversed: S = !1 } = e, { hoverable: D = !0 } = e, { disabled: I = !1 } = e, { pips: M = !1 } = e, { pipstep: L = void 0 } = e, { all: B = void 0 } = e, { first: z = void 0 } = e, { last: q = void 0 } = e, { rest: U = void 0 } = e, { id: H = void 0 } = e, { prefix: V = "" } = e, { suffix: Y = "" } = e, { formatter: J = /* @__PURE__ */ u((Ie, nt, Ft) => Ie, "formatter") } = e, { handleFormatter: fe = J } = e, { ariaLabels: ke = [] } = e, { precision: ee = 2 } = e, { springValues: ne = { stiffness: 0.15, damping: 0.4 } } = e;
  const Ee = ft();
  let Pe = 0, ye = !1, me = !1, Ce = !1, Je = !1, Ne = y.length - 1, Re, ge, je;
  const Be = /* @__PURE__ */ u((Ie) => parseFloat((+Ie).toFixed(ee)), "fixFloat");
  function Ze(Ie) {
    const nt = d.querySelectorAll(".handle"), Ft = Array.prototype.includes.call(nt, Ie), Qe = Array.prototype.some.call(nt, (_n) => _n.contains(Ie));
    return Ft || Qe;
  }
  u(Ze, "targetIsHandle");
  function Ge(Ie) {
    return p === "min" || p === "max" ? Ie.slice(0, 1) : p ? Ie.slice(0, 2) : Ie;
  }
  u(Ge, "trimRange");
  function Se() {
    return d.getBoundingClientRect();
  }
  u(Se, "getSliderDimensions");
  function _e(Ie) {
    const nt = Se();
    let Ft = 0, Qe = 0, _n = 0;
    v ? (Ft = Ie.clientY - nt.top, Qe = Ft / nt.height * 100, Qe = S ? Qe : 100 - Qe) : (Ft = Ie.clientX - nt.left, Qe = Ft / nt.width * 100, Qe = S ? 100 - Qe : Qe), _n = (h - g) / 100 * Qe + g;
    let Wl;
    return p === !0 && y[0] === y[1] ? _n > y[1] ? 1 : 0 : (Wl = y.indexOf(
      [...y].sort((Mr, Tc) => Math.abs(_n - Mr) - Math.abs(_n - Tc))[0]
    ), Wl);
  }
  u(_e, "getClosestHandle");
  function we(Ie) {
    const nt = Se();
    let Ft = 0, Qe = 0, _n = 0;
    v ? (Ft = Ie.clientY - nt.top, Qe = Ft / nt.height * 100, Qe = S ? Qe : 100 - Qe) : (Ft = Ie.clientX - nt.left, Qe = Ft / nt.width * 100, Qe = S ? 100 - Qe : Qe), _n = (h - g) / 100 * Qe + g, Fe(Ne, _n);
  }
  u(we, "handleInteract");
  function Fe(Ie, nt) {
    return nt = l(nt), typeof Ie > "u" && (Ie = Ne), p && (Ie === 0 && nt > y[1] ? m ? t(0, y[1] = nt, y) : nt = y[1] : Ie === 1 && nt < y[0] && (m ? t(0, y[0] = nt, y) : nt = y[0])), y[Ie] !== nt && t(0, y[Ie] = nt, y), ge !== nt && (Bi(), ge = nt), nt;
  }
  u(Fe, "moveHandle");
  function xe(Ie) {
    return p === "min" ? 0 : Ie[0];
  }
  u(xe, "rangeStart");
  function vt(Ie) {
    return p === "max" ? 0 : p === "min" ? 100 - Ie[0] : 100 - Ie[1];
  }
  u(vt, "rangeEnd");
  function ps(Ie) {
    Je && (t(25, ye = !1), me = !1, t(26, Ce = !1));
  }
  u(ps, "sliderBlurHandle");
  function As(Ie) {
    I || (t(27, Ne = A8(Ie.target)), t(25, ye = !0));
  }
  u(As, "sliderFocusHandle");
  function zs(Ie) {
    if (!I) {
      const nt = A8(Ie.target);
      let Ft = Ie.ctrlKey || Ie.metaKey || Ie.shiftKey ? _ * 10 : _, Qe = !1;
      switch (Ie.key) {
        case "PageDown":
          Ft *= 10;
        case "ArrowRight":
        case "ArrowUp":
          Fe(nt, y[nt] + Ft), Qe = !0;
          break;
        case "PageUp":
          Ft *= 10;
        case "ArrowLeft":
        case "ArrowDown":
          Fe(nt, y[nt] - Ft), Qe = !0;
          break;
        case "Home":
          Fe(nt, g), Qe = !0;
          break;
        case "End":
          Fe(nt, h), Qe = !0;
          break;
      }
      Qe && (Ie.preventDefault(), Ie.stopPropagation());
    }
  }
  u(zs, "sliderKeydown");
  function sn(Ie) {
    if (!I) {
      const nt = Ie.target, Ft = Ld(Ie);
      t(25, ye = !0), me = !0, t(26, Ce = !0), t(27, Ne = _e(Ft)), Re = ge = l(y[Ne]), Pr(), Ie.type === "touchstart" && !nt.matches(".pipVal") && we(Ft);
    }
  }
  u(sn, "sliderInteractStart");
  function St(Ie) {
    Ie.type === "touchend" && Ao(), t(26, Ce = !1);
  }
  u(St, "sliderInteractEnd");
  function ws(Ie) {
    Je = !1, ye && Ie.target !== d && !d.contains(Ie.target) && t(25, ye = !1);
  }
  u(ws, "bodyInteractStart");
  function _i(Ie) {
    I || me && we(Ld(Ie));
  }
  u(_i, "bodyInteract");
  function es(Ie) {
    if (!I) {
      const nt = Ie.target;
      me && ((nt === d || d.contains(nt)) && (t(25, ye = !0), !Ze(nt) && !nt.matches(".pipVal") && we(Ld(Ie))), Ao());
    }
    me = !1, t(26, Ce = !1);
  }
  u(es, "bodyMouseUp");
  function yi(Ie) {
    me = !1, t(26, Ce = !1);
  }
  u(yi, "bodyTouchEnd");
  function Ir(Ie) {
    I || (Ie.target === d || d.contains(Ie.target)) && (Je = !0);
  }
  u(Ir, "bodyKeyDown");
  function Pr() {
    !I && Ee("start", {
      activeHandle: Ne,
      value: Re,
      values: y.map((Ie) => l(Ie))
    });
  }
  u(Pr, "eStart");
  function Ao() {
    !I && Ee("stop", {
      activeHandle: Ne,
      startValue: Re,
      value: y[Ne],
      values: y.map((Ie) => l(Ie))
    });
  }
  u(Ao, "eStop");
  function Bi() {
    !I && Ee("change", {
      activeHandle: Ne,
      startValue: Re,
      previousValue: typeof ge > "u" ? Re : ge,
      value: y[Ne],
      values: y.map((Ie) => l(Ie))
    });
  }
  u(Bi, "eChange");
  function Eo(Ie) {
    rt[Ie ? "unshift" : "push"](() => {
      d = Ie, t(1, d);
    });
  }
  return u(Eo, "div_binding"), i.$$set = (Ie) => {
    "slider" in Ie && t(1, d = Ie.slider), "range" in Ie && t(2, p = Ie.range), "pushy" in Ie && t(45, m = Ie.pushy), "min" in Ie && t(3, g = Ie.min), "max" in Ie && t(4, h = Ie.max), "step" in Ie && t(5, _ = Ie.step), "values" in Ie && t(0, y = Ie.values), "vertical" in Ie && t(6, v = Ie.vertical), "float" in Ie && t(7, k = Ie.float), "reversed" in Ie && t(8, S = Ie.reversed), "hoverable" in Ie && t(9, D = Ie.hoverable), "disabled" in Ie && t(10, I = Ie.disabled), "pips" in Ie && t(11, M = Ie.pips), "pipstep" in Ie && t(12, L = Ie.pipstep), "all" in Ie && t(13, B = Ie.all), "first" in Ie && t(14, z = Ie.first), "last" in Ie && t(15, q = Ie.last), "rest" in Ie && t(16, U = Ie.rest), "id" in Ie && t(17, H = Ie.id), "prefix" in Ie && t(18, V = Ie.prefix), "suffix" in Ie && t(19, Y = Ie.suffix), "formatter" in Ie && t(20, J = Ie.formatter), "handleFormatter" in Ie && t(21, fe = Ie.handleFormatter), "ariaLabels" in Ie && t(22, ke = Ie.ariaLabels), "precision" in Ie && t(46, ee = Ie.precision), "springValues" in Ie && t(47, ne = Ie.springValues);
  }, i.$$.update = () => {
    if (i.$$.dirty[0] & /*min, max*/
    24 && t(50, n = /* @__PURE__ */ u(function(Ie) {
      return Ie <= g ? g : Ie >= h ? h : Ie;
    }, "clampValue")), i.$$.dirty[0] & /*min, max, step*/
    56 | i.$$.dirty[1] & /*clampValue*/
    524288 && t(49, l = /* @__PURE__ */ u(function(Ie) {
      if (Ie <= g)
        return Be(g);
      if (Ie >= h)
        return Be(h);
      Ie = Be(Ie);
      let nt = (Ie - g) % _, Ft = Ie - nt;
      return Math.abs(nt) * 2 >= _ && (Ft += nt > 0 ? _ : -_), Ft = n(Ft), Be(Ft);
    }, "alignValueToStep")), i.$$.dirty[0] & /*min, max*/
    24 && t(24, s = /* @__PURE__ */ u(function(Ie) {
      let nt = (Ie - g) / (h - g) * 100;
      return isNaN(nt) || nt <= 0 ? 0 : nt >= 100 ? 100 : Be(nt);
    }, "percentOf")), i.$$.dirty[0] & /*values, max, min, percentOf, springPositions, ariaLabels*/
    29360153 | i.$$.dirty[1] & /*alignValueToStep, valueLength, springValues*/
    458752) {
      Array.isArray(y) || (t(0, y = [(h + g) / 2]), console.error("'values' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)"));
      const Ie = Ge(y.map((nt) => l(nt)));
      (y.length !== Ie.length || !y.every((nt, Ft) => Be(nt) === Ie[Ft])) && t(0, y = Ie), Pe !== y.length ? f(t(23, je = khe(y.map((nt) => s(nt)), ne))) : je.set(y.map((nt) => s(nt))), t(48, Pe = y.length), y.length > 1 && !Array.isArray(ke) && console.warn("'ariaLabels' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)");
    }
    i.$$.dirty[0] & /*vertical, reversed*/
    320 && t(29, r = v ? S ? "top" : "bottom" : S ? "right" : "left"), i.$$.dirty[0] & /*vertical, reversed*/
    320 && t(28, o = v ? S ? "bottom" : "top" : S ? "left" : "right");
  }, [
    y,
    d,
    p,
    g,
    h,
    _,
    v,
    k,
    S,
    D,
    I,
    M,
    L,
    B,
    z,
    q,
    U,
    H,
    V,
    Y,
    J,
    fe,
    ke,
    je,
    s,
    ye,
    Ce,
    Ne,
    o,
    r,
    a,
    Be,
    Fe,
    xe,
    vt,
    ps,
    As,
    zs,
    sn,
    St,
    ws,
    _i,
    es,
    yi,
    Ir,
    m,
    ee,
    ne,
    Pe,
    l,
    n,
    Eo
  ];
}
u(Ehe, "instance$Y");
const XC = class XC extends re {
  constructor(e) {
    super(), oe(
      this,
      e,
      Ehe,
      Ahe,
      le,
      {
        slider: 1,
        range: 2,
        pushy: 45,
        min: 3,
        max: 4,
        step: 5,
        values: 0,
        vertical: 6,
        float: 7,
        reversed: 8,
        hoverable: 9,
        disabled: 10,
        pips: 11,
        pipstep: 12,
        all: 13,
        first: 14,
        last: 15,
        rest: 16,
        id: 17,
        prefix: 18,
        suffix: 19,
        formatter: 20,
        handleFormatter: 21,
        ariaLabels: 22,
        precision: 46,
        springValues: 47
      },
      null,
      [-1, -1, -1]
    );
  }
};
u(XC, "RangeSlider");
let Vp = XC;
function S8(i, e, t) {
  const s = i.slice();
  return s[12] = e[t].display, s[13] = e[t].heading, s[14] = e[t].filterKey, s[15] = e[t].options, s;
}
u(S8, "get_each_context$n");
function She(i) {
  let e, t, s;
  return e = new Vp({
    props: {
      first: "label",
      last: "label",
      min: 0,
      max: 6,
      pips: !0,
      pipstep: 1,
      range: !0,
      springValues: { stiffness: 1, damping: 1 },
      step: 1,
      values: [
        /*filterSelections*/
        i[0].exertion.min,
        /*filterSelections*/
        i[0].exertion.max
      ]
    }
  }), e.$on(
    "change",
    /*change_handler*/
    i[5]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--range-handle", "var(--a5e-color-primary)"), G(t, "--range-handle-focus", "var(--a5e-color-primary)"), G(t, "--range-handle-inactive", "var(--a5e-color-primary)"), G(t, "--range-pip", "var(--a5e-color-text-medium)"), G(t, "--range-slider", "#c8c6be");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*filterSelections*/
      1 && (r.values = [
        /*filterSelections*/
        n[0].exertion.min,
        /*filterSelections*/
        n[0].exertion.max
      ]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(She, "create_default_slot$m");
function Che(i) {
  let e, t;
  function s(...r) {
    return (
      /*updateExclusiveMode_handler*/
      i[6](
        /*filterKey*/
        i[14],
        ...r
      )
    );
  }
  u(s, "updateExclusiveMode_handler");
  function n(...r) {
    return (
      /*updateInclusiveMode_handler*/
      i[7](
        /*filterKey*/
        i[14],
        ...r
      )
    );
  }
  u(n, "updateInclusiveMode_handler");
  function l(...r) {
    return (
      /*updateSelection_handler*/
      i[8](
        /*filterKey*/
        i[14],
        ...r
      )
    );
  }
  return u(l, "updateSelection_handler"), e = new Sr({
    props: {
      filterKey: (
        /*filterKey*/
        i[14]
      ),
      filterSelections: (
        /*filterSelections*/
        i[0]
      ),
      heading: (
        /*heading*/
        i[13]
      ),
      options: (
        /*options*/
        i[15]
      )
    }
  }), e.$on("updateExclusiveMode", s), e.$on("updateInclusiveMode", n), e.$on("updateSelection", l), {
    c() {
      j(e.$$.fragment);
    },
    m(r, o) {
      R(e, r, o), t = !0;
    },
    p(r, o) {
      i = r;
      const a = {};
      o & /*filterSelections*/
      1 && (a.filterSelections = /*filterSelections*/
      i[0]), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      O(e.$$.fragment, r), t = !1;
    },
    d(r) {
      N(e, r);
    }
  };
}
u(Che, "create_if_block$v");
function C8(i) {
  let e, t, s = (
    /*display*/
    (i[12] ?? !0) && Che(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*display*/
      (n[12] ?? !0) && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(C8, "create_each_block$n");
function The(i) {
  let e, t, s, n, l;
  e = new ie({
    props: {
      heading: "Exertion Cost Range (" + /*exertionCostLabel*/
      i[1] + ")",
      $$slots: { default: [She] },
      $$scope: { ctx: i }
    }
  });
  let r = ue(
    /*formSectionMap*/
    i[4]
  ), o = [];
  for (let c = 0; c < r.length; c += 1)
    o[c] = C8(S8(i, r, c));
  const a = /* @__PURE__ */ u((c) => O(o[c], 1, 1, () => {
    o[c] = null;
  }), "out");
  return {
    c() {
      t = E("div"), j(e.$$.fragment), s = F();
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      n = $e(), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-header-width", "100%");
    },
    m(c, f) {
      T(c, t, f), R(e, t, null), T(c, s, f);
      for (let d = 0; d < o.length; d += 1)
        o[d] && o[d].m(c, f);
      T(c, n, f), l = !0;
    },
    p(c, [f]) {
      const d = {};
      if (f & /*exertionCostLabel*/
      2 && (d.heading = "Exertion Cost Range (" + /*exertionCostLabel*/
      c[1] + ")"), f & /*$$scope, filterSelections*/
      262145 && (d.$$scope = { dirty: f, ctx: c }), e.$set(d), f & /*formSectionMap, filterSelections, filterStore*/
      21) {
        r = ue(
          /*formSectionMap*/
          c[4]
        );
        let p;
        for (p = 0; p < r.length; p += 1) {
          const m = S8(c, r, p);
          o[p] ? (o[p].p(m, f), w(o[p], 1)) : (o[p] = C8(m), o[p].c(), w(o[p], 1), o[p].m(n.parentNode, n));
        }
        for (ae(), p = r.length; p < o.length; p += 1)
          a(p);
        ce();
      }
    },
    i(c) {
      if (!l) {
        w(e.$$.fragment, c);
        for (let f = 0; f < r.length; f += 1)
          w(o[f]);
        l = !0;
      }
    },
    o(c) {
      O(e.$$.fragment, c), o = o.filter(Boolean);
      for (let f = 0; f < o.length; f += 1)
        O(o[f]);
      l = !1;
    },
    d(c) {
      c && (C(s), C(n)), c && e && C(t), N(e, c), Le(o, c);
    }
  };
}
u(The, "create_fragment$11");
function Ohe({ exertion: i }) {
  const { min: e, max: t } = i;
  return e === t ? e : `${e}–${t}`;
}
u(Ohe, "getExertionCostLabel");
function Dhe(i, e, t) {
  let s;
  const n = de("filterStore"), { maneuverDegrees: l, maneuverTraditions: r } = CONFIG.A5E, o = Object.entries(CONFIG.A5E.products).reduce(
    (h, [_, y]) => (h[_] = y.title, h),
    {}
  );
  console.log(o);
  function a([h, _]) {
    n.update((y) => ({
      ...y,
      exertion: { min: h, max: _ }
    }));
  }
  u(a, "updateExertionRange");
  let c = {};
  n.subscribe((h) => {
    t(0, c = h);
  });
  const f = [
    {
      filterKey: "maneuverDegrees",
      heading: "Maneuver Degrees",
      options: l
    },
    {
      filterKey: "maneuverTraditions",
      heading: "Maneuver Traditions",
      options: r
    },
    {
      filterKey: "miscellaneous",
      heading: "Miscellaneous",
      options: {
        concentration: "Concentration",
        stance: "Stance"
      }
    },
    {
      filterKey: "source",
      heading: "Source",
      options: o
    }
  ], d = /* @__PURE__ */ u(({ detail: h }) => a(h.values), "change_handler"), p = /* @__PURE__ */ u((h, { detail: _ }) => {
    n.update((y) => ({
      ...y,
      [h]: {
        inclusive: c[h].inclusive,
        inclusiveMode: c[h].inclusiveMode,
        exclusive: c[h].exclusive,
        exclusiveMode: _
      }
    }));
  }, "updateExclusiveMode_handler"), m = /* @__PURE__ */ u((h, { detail: _ }) => {
    n.update((y) => ({
      ...y,
      [h]: {
        inclusive: c[h].inclusive,
        inclusiveMode: _,
        exclusive: c[h].exclusive,
        exclusiveMode: c[h].exclusiveMode
      }
    }));
  }, "updateInclusiveMode_handler"), g = /* @__PURE__ */ u((h, { detail: _ }) => {
    n.update((y) => ({
      ...y,
      [h]: {
        inclusive: _[0],
        inclusiveMode: c[h].inclusiveMode,
        exclusive: _[1],
        exclusiveMode: c[h].exclusiveMode
      }
    }));
  }, "updateSelection_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*filterSelections*/
    1 && t(1, s = Ohe(c));
  }, [
    c,
    s,
    n,
    a,
    f,
    d,
    p,
    m,
    g
  ];
}
u(Dhe, "instance$X");
const JC = class JC extends re {
  constructor(e) {
    super(), oe(this, e, Dhe, The, le, {});
  }
};
u(JC, "CompendiumManeuverFilters");
let nk = JC;
function T8(i, e, t) {
  const s = i.slice();
  return s[14] = e[t].heading, s[15] = e[t].filterKey, s[16] = e[t].options, s;
}
u(T8, "get_each_context$m");
function Ihe(i) {
  let e, t, s;
  return e = new Vp({
    props: {
      first: "label",
      last: "label",
      min: 0,
      max: 30,
      pips: !0,
      pipstep: 1,
      range: !0,
      springValues: { stiffness: 1, damping: 1 },
      step: 1,
      values: [
        /*filterSelections*/
        i[0].cr.min,
        /*filterSelections*/
        i[0].cr.max
      ]
    }
  }), e.$on(
    "change",
    /*change_handler*/
    i[6]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--range-handle", "var(--a5e-color-primary)"), G(t, "--range-handle-focus", "var(--a5e-color-primary)"), G(t, "--range-handle-inactive", "var(--a5e-color-primary)"), G(t, "--range-pip", "var(--a5e-color-text-medium)"), G(t, "--range-slider", "#c8c6be");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*filterSelections*/
      1 && (r.values = [
        /*filterSelections*/
        n[0].cr.min,
        /*filterSelections*/
        n[0].cr.max
      ]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Ihe, "create_default_slot$l");
function O8(i) {
  let e, t;
  function s(...r) {
    return (
      /*updateExclusiveMode_handler*/
      i[7](
        /*filterKey*/
        i[15],
        ...r
      )
    );
  }
  u(s, "updateExclusiveMode_handler");
  function n(...r) {
    return (
      /*updateInclusiveMode_handler*/
      i[8](
        /*filterKey*/
        i[15],
        ...r
      )
    );
  }
  u(n, "updateInclusiveMode_handler");
  function l(...r) {
    return (
      /*updateSelection_handler*/
      i[9](
        /*filterKey*/
        i[15],
        ...r
      )
    );
  }
  return u(l, "updateSelection_handler"), e = new Sr({
    props: {
      filterKey: (
        /*filterKey*/
        i[15]
      ),
      filterSelections: (
        /*filterSelections*/
        i[0]
      ),
      heading: (
        /*heading*/
        i[14]
      ),
      options: (
        /*options*/
        i[16]
      )
    }
  }), e.$on("updateExclusiveMode", s), e.$on("updateInclusiveMode", n), e.$on("updateSelection", l), {
    c() {
      j(e.$$.fragment);
    },
    m(r, o) {
      R(e, r, o), t = !0;
    },
    p(r, o) {
      i = r;
      const a = {};
      o & /*filterSelections*/
      1 && (a.filterSelections = /*filterSelections*/
      i[0]), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      O(e.$$.fragment, r), t = !1;
    },
    d(r) {
      N(e, r);
    }
  };
}
u(O8, "create_each_block$m");
function Phe(i) {
  let e, t, s, n, l;
  e = new ie({
    props: {
      heading: `CR Range (${/*crRangeLabel*/
      i[1]})`,
      $$slots: { default: [Ihe] },
      $$scope: { ctx: i }
    }
  });
  let r = ue(
    /*formSectionMap*/
    i[4]
  ), o = [];
  for (let c = 0; c < r.length; c += 1)
    o[c] = O8(T8(i, r, c));
  const a = /* @__PURE__ */ u((c) => O(o[c], 1, 1, () => {
    o[c] = null;
  }), "out");
  return {
    c() {
      t = E("div"), j(e.$$.fragment), s = F();
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      n = $e(), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-header-width", "100%");
    },
    m(c, f) {
      T(c, t, f), R(e, t, null), T(c, s, f);
      for (let d = 0; d < o.length; d += 1)
        o[d] && o[d].m(c, f);
      T(c, n, f), l = !0;
    },
    p(c, [f]) {
      const d = {};
      if (f & /*crRangeLabel*/
      2 && (d.heading = `CR Range (${/*crRangeLabel*/
      c[1]})`), f & /*$$scope, filterSelections*/
      524289 && (d.$$scope = { dirty: f, ctx: c }), e.$set(d), f & /*formSectionMap, filterSelections, filterStore*/
      21) {
        r = ue(
          /*formSectionMap*/
          c[4]
        );
        let p;
        for (p = 0; p < r.length; p += 1) {
          const m = T8(c, r, p);
          o[p] ? (o[p].p(m, f), w(o[p], 1)) : (o[p] = O8(m), o[p].c(), w(o[p], 1), o[p].m(n.parentNode, n));
        }
        for (ae(), p = r.length; p < o.length; p += 1)
          a(p);
        ce();
      }
    },
    i(c) {
      if (!l) {
        w(e.$$.fragment, c);
        for (let f = 0; f < r.length; f += 1)
          w(o[f]);
        l = !0;
      }
    },
    o(c) {
      O(e.$$.fragment, c), o = o.filter(Boolean);
      for (let f = 0; f < o.length; f += 1)
        O(o[f]);
      l = !1;
    },
    d(c) {
      c && (C(s), C(n)), c && e && C(t), N(e, c), Le(o, c);
    }
  };
}
u(Phe, "create_fragment$10");
function Mhe({ cr: i }) {
  const { min: e, max: t } = i;
  return e === t ? e : `${e}–${t}`;
}
u(Mhe, "getChallengeRatingRangeLabel");
function Fhe(i, e, t) {
  let s;
  const n = "monster", l = de("filterStore"), { actorSizes: r, creatureTypes: o, terrainTypes: a } = CONFIG.A5E, c = Object.entries(CONFIG.A5E.products).reduce(
    (y, [v, k]) => (y[v] = k.title, y),
    {}
  );
  function f([y, v]) {
    l.update((k) => ({
      ...k,
      cr: { min: y, max: v }
    }));
  }
  u(f, "updateChallengeRatingRange");
  const d = [
    {
      filterKey: "creatureTypes",
      heading: "Creature Types",
      options: o
    },
    {
      filterKey: "terrain",
      heading: "Terrain",
      options: a
    },
    {
      filterKey: "creatureSize",
      heading: "Creature Size",
      options: r
    },
    {
      filterKey: "miscellaneous",
      heading: "Miscellaneous",
      options: { elite: "Elite", swarm: "Swarm" }
    },
    {
      filterKey: "source",
      heading: "Source",
      options: c
    }
  ];
  let p = {};
  l.subscribe((y) => {
    t(0, p = y);
  });
  const m = /* @__PURE__ */ u(({ detail: y }) => f(y.values), "change_handler"), g = /* @__PURE__ */ u((y, { detail: v }) => {
    l.update((k) => ({
      ...k,
      [y]: {
        inclusive: p[y].inclusive,
        inclusiveMode: p[y].inclusiveMode,
        exclusive: p[y].exclusive,
        exclusiveMode: v
      }
    }));
  }, "updateExclusiveMode_handler"), h = /* @__PURE__ */ u((y, { detail: v }) => {
    l.update((k) => ({
      ...k,
      [y]: {
        inclusive: p[y].inclusive,
        inclusiveMode: v,
        exclusive: p[y].exclusive,
        exclusiveMode: p[y].exclusiveMode
      }
    }));
  }, "updateInclusiveMode_handler"), _ = /* @__PURE__ */ u((y, { detail: v }) => {
    l.update((k) => ({
      ...k,
      [y]: {
        inclusive: v[0],
        inclusiveMode: p[y].inclusiveMode,
        exclusive: v[1],
        exclusiveMode: p[y].exclusiveMode
      }
    }));
  }, "updateSelection_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*filterSelections*/
    1 && t(1, s = Mhe(p));
  }, [
    p,
    s,
    l,
    f,
    d,
    n,
    m,
    g,
    h,
    _
  ];
}
u(Fhe, "instance$W");
const ZC = class ZC extends re {
  constructor(e) {
    super(), oe(this, e, Fhe, Phe, le, { compendiumType: 5 });
  }
  get compendiumType() {
    return this.$$.ctx[5];
  }
};
u(ZC, "CompendiumMonsterFilters");
let ik = ZC;
function D8(i, e, t) {
  const s = i.slice();
  return s[10] = e[t].display, s[11] = e[t].heading, s[12] = e[t].filterKey, s[13] = e[t].options, s;
}
u(D8, "get_each_context$l");
function Rhe(i) {
  let e, t;
  function s(...r) {
    return (
      /*updateExclusiveMode_handler*/
      i[4](
        /*filterKey*/
        i[12],
        ...r
      )
    );
  }
  u(s, "updateExclusiveMode_handler");
  function n(...r) {
    return (
      /*updateInclusiveMode_handler*/
      i[5](
        /*filterKey*/
        i[12],
        ...r
      )
    );
  }
  u(n, "updateInclusiveMode_handler");
  function l(...r) {
    return (
      /*updateSelection_handler*/
      i[6](
        /*filterKey*/
        i[12],
        ...r
      )
    );
  }
  return u(l, "updateSelection_handler"), e = new Sr({
    props: {
      filterKey: (
        /*filterKey*/
        i[12]
      ),
      filterSelections: (
        /*filterSelections*/
        i[0]
      ),
      heading: (
        /*heading*/
        i[11]
      ),
      options: (
        /*options*/
        i[13]
      )
    }
  }), e.$on("updateExclusiveMode", s), e.$on("updateInclusiveMode", n), e.$on("updateSelection", l), {
    c() {
      j(e.$$.fragment);
    },
    m(r, o) {
      R(e, r, o), t = !0;
    },
    p(r, o) {
      i = r;
      const a = {};
      o & /*filterSelections*/
      1 && (a.filterSelections = /*filterSelections*/
      i[0]), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      O(e.$$.fragment, r), t = !1;
    },
    d(r) {
      N(e, r);
    }
  };
}
u(Rhe, "create_if_block$u");
function I8(i) {
  let e, t, s = (
    /*display*/
    (i[10] ?? !0) && Rhe(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*display*/
      (n[10] ?? !0) && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(I8, "create_each_block$l");
function Nhe(i) {
  let e, t, s = ue(
    /*getFormSections*/
    i[2]()
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = I8(D8(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, [o]) {
      if (o & /*getFormSections, filterSelections, filterStore*/
      7) {
        s = ue(
          /*getFormSections*/
          r[2]()
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = D8(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = I8(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(Nhe, "create_fragment$$");
function jhe(i, e, t) {
  let { compendiumType: s = "magicItem" } = e;
  const n = de("filterStore"), { itemRarity: l, objectTypes: r } = CONFIG.A5E, o = Object.entries(CONFIG.A5E.products).reduce(
    (m, [g, h]) => (m[g] = h.title, m),
    {}
  );
  function a() {
    const m = [
      {
        filterKey: "objectType",
        heading: "Object Type",
        options: r
      },
      {
        filterKey: "rarity",
        heading: "Item Rarity",
        options: l,
        display: s === "magicItem"
      },
      {
        filterKey: "miscellaneous",
        heading: "Miscellaneous",
        options: { bulky: "Bulky" }
      },
      {
        filterKey: "source",
        heading: "Source",
        options: o
      }
    ];
    if (s === "magicItem") {
      const g = m.find((h) => h.filterKey === "miscellaneous");
      g.options.requiresAttunement = "Requires Attunement";
    }
    return m;
  }
  u(a, "getFormSections");
  let c = {};
  n.subscribe((m) => {
    t(0, c = m);
  });
  const f = /* @__PURE__ */ u((m, { detail: g }) => {
    n.update((h) => ({
      ...h,
      [m]: {
        inclusive: c[m].inclusive,
        inclusiveMode: c[m].inclusiveMode,
        exclusive: c[m].exclusive,
        exclusiveMode: g
      }
    }));
  }, "updateExclusiveMode_handler"), d = /* @__PURE__ */ u((m, { detail: g }) => {
    n.update((h) => ({
      ...h,
      [m]: {
        inclusive: c[m].inclusive,
        inclusiveMode: g,
        exclusive: c[m].exclusive,
        exclusiveMode: c[m].exclusiveMode
      }
    }));
  }, "updateInclusiveMode_handler"), p = /* @__PURE__ */ u((m, { detail: g }) => {
    n.update((h) => ({
      ...h,
      [m]: {
        inclusive: g[0],
        inclusiveMode: c[m].inclusiveMode,
        exclusive: g[1],
        exclusiveMode: c[m].exclusiveMode
      }
    }));
  }, "updateSelection_handler");
  return i.$$set = (m) => {
    "compendiumType" in m && t(3, s = m.compendiumType);
  }, [
    c,
    n,
    a,
    s,
    f,
    d,
    p
  ];
}
u(jhe, "instance$V");
const QC = class QC extends re {
  constructor(e) {
    super(), oe(this, e, jhe, Nhe, le, { compendiumType: 3 });
  }
};
u(QC, "CompendiumObjectFilters");
let Wp = QC;
function P8(i, e, t) {
  const s = i.slice();
  return s[9] = e[t].display, s[10] = e[t].heading, s[11] = e[t].filterKey, s[12] = e[t].options, s;
}
u(P8, "get_each_context$k");
function Lhe(i) {
  let e, t;
  function s(...r) {
    return (
      /*updateExclusiveMode_handler*/
      i[4](
        /*filterKey*/
        i[11],
        ...r
      )
    );
  }
  u(s, "updateExclusiveMode_handler");
  function n(...r) {
    return (
      /*updateInclusiveMode_handler*/
      i[5](
        /*filterKey*/
        i[11],
        ...r
      )
    );
  }
  u(n, "updateInclusiveMode_handler");
  function l(...r) {
    return (
      /*updateSelection_handler*/
      i[6](
        /*filterKey*/
        i[11],
        ...r
      )
    );
  }
  return u(l, "updateSelection_handler"), e = new Sr({
    props: {
      filterKey: (
        /*filterKey*/
        i[11]
      ),
      filterSelections: (
        /*filterSelections*/
        i[0]
      ),
      heading: (
        /*heading*/
        i[10]
      ),
      options: (
        /*options*/
        i[12]
      )
    }
  }), e.$on("updateExclusiveMode", s), e.$on("updateInclusiveMode", n), e.$on("updateSelection", l), {
    c() {
      j(e.$$.fragment);
    },
    m(r, o) {
      R(e, r, o), t = !0;
    },
    p(r, o) {
      i = r;
      const a = {};
      o & /*filterSelections*/
      1 && (a.filterSelections = /*filterSelections*/
      i[0]), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      O(e.$$.fragment, r), t = !1;
    },
    d(r) {
      N(e, r);
    }
  };
}
u(Lhe, "create_if_block$t");
function M8(i) {
  let e, t, s = (
    /*display*/
    (i[9] ?? !0) && Lhe(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*display*/
      (n[9] ?? !0) && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(M8, "create_each_block$k");
function Bhe(i) {
  let e, t, s = ue(
    /*getFormSections*/
    i[2]()
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = M8(P8(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, [o]) {
      if (o & /*getFormSections, filterSelections, filterStore*/
      7) {
        s = ue(
          /*getFormSections*/
          r[2]()
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = P8(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = M8(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(Bhe, "create_fragment$_");
function qhe(i, e, t) {
  let { compendiumType: s = "class" } = e;
  const n = de("filterStore"), { classes: l } = CONFIG.A5E, r = Object.entries(CONFIG.A5E.products).reduce(
    (p, [m, g]) => (p[m] = g.title, p),
    {}
  );
  function o() {
    const p = [
      {
        filterKey: "source",
        heading: "Source",
        options: r
      }
    ];
    return s === "archetype" && p.unshift({
      filterKey: "class",
      heading: "Class",
      options: l
    }), p;
  }
  u(o, "getFormSections");
  let a = {};
  n.subscribe((p) => {
    t(0, a = p);
  });
  const c = /* @__PURE__ */ u((p, { detail: m }) => {
    n.update((g) => ({
      ...g,
      [p]: {
        inclusive: a[p].inclusive,
        inclusiveMode: a[p].inclusiveMode,
        exclusive: a[p].exclusive,
        exclusiveMode: m
      }
    }));
  }, "updateExclusiveMode_handler"), f = /* @__PURE__ */ u((p, { detail: m }) => {
    n.update((g) => ({
      ...g,
      [p]: {
        inclusive: a[p].inclusive,
        inclusiveMode: m,
        exclusive: a[p].exclusive,
        exclusiveMode: a[p].exclusiveMode
      }
    }));
  }, "updateInclusiveMode_handler"), d = /* @__PURE__ */ u((p, { detail: m }) => {
    n.update((g) => ({
      ...g,
      [p]: {
        inclusive: m[0],
        inclusiveMode: a[p].inclusiveMode,
        exclusive: m[1],
        exclusiveMode: a[p].exclusiveMode
      }
    }));
  }, "updateSelection_handler");
  return i.$$set = (p) => {
    "compendiumType" in p && t(3, s = p.compendiumType);
  }, [
    a,
    n,
    o,
    s,
    c,
    f,
    d
  ];
}
u(qhe, "instance$U");
const xC = class xC extends re {
  constructor(e) {
    super(), oe(this, e, qhe, Bhe, le, { compendiumType: 3 });
  }
};
u(xC, "CompendiumOriginFilters");
let lk = xC;
function F8(i, e, t) {
  const s = i.slice();
  return s[12] = e[t].display, s[13] = e[t].heading, s[14] = e[t].filterKey, s[15] = e[t].options, s;
}
u(F8, "get_each_context$j");
function Ghe(i) {
  let e, t;
  function s(...r) {
    return (
      /*updateExclusiveMode_handler*/
      i[4](
        /*filterKey*/
        i[14],
        ...r
      )
    );
  }
  u(s, "updateExclusiveMode_handler");
  function n(...r) {
    return (
      /*updateInclusiveMode_handler*/
      i[5](
        /*filterKey*/
        i[14],
        ...r
      )
    );
  }
  u(n, "updateInclusiveMode_handler");
  function l(...r) {
    return (
      /*updateSelection_handler*/
      i[6](
        /*filterKey*/
        i[14],
        ...r
      )
    );
  }
  return u(l, "updateSelection_handler"), e = new Sr({
    props: {
      filterKey: (
        /*filterKey*/
        i[14]
      ),
      filterSelections: (
        /*filterSelections*/
        i[0]
      ),
      heading: (
        /*heading*/
        i[13]
      ),
      options: (
        /*options*/
        i[15]
      )
    }
  }), e.$on("updateExclusiveMode", s), e.$on("updateInclusiveMode", n), e.$on("updateSelection", l), {
    c() {
      j(e.$$.fragment);
    },
    m(r, o) {
      R(e, r, o), t = !0;
    },
    p(r, o) {
      i = r;
      const a = {};
      o & /*filterSelections*/
      1 && (a.filterSelections = /*filterSelections*/
      i[0]), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      O(e.$$.fragment, r), t = !1;
    },
    d(r) {
      N(e, r);
    }
  };
}
u(Ghe, "create_if_block$s");
function R8(i) {
  let e, t, s = (
    /*display*/
    (i[12] ?? !0) && Ghe(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*display*/
      (n[12] ?? !0) && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(R8, "create_each_block$j");
function zhe(i) {
  let e, t, s = ue(
    /*formSectionMap*/
    i[2]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = R8(F8(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, [o]) {
      if (o & /*formSectionMap, filterSelections, filterStore*/
      7) {
        s = ue(
          /*formSectionMap*/
          r[2]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = F8(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = R8(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(zhe, "create_fragment$Z");
function Hhe(i, e, t) {
  let { compendiumType: s = "spell" } = e;
  const n = de("filterStore"), { classSpellLists: l, spellLevels: r, spellSchools: o, spellComponents: a } = CONFIG.A5E, c = Object.entries(CONFIG.A5E.products).reduce(
    (h, [_, y]) => (h[_] = y.title, h),
    {}
  );
  let f = {};
  n.subscribe((h) => {
    t(0, f = h);
  });
  const d = [
    {
      filterKey: "spellLists",
      heading: "Spell Lists",
      options: l,
      display: s === "spell"
    },
    {
      filterKey: "spellLevels",
      heading: "Spell Levels",
      options: r
    },
    {
      filterKey: "primarySpellSchools",
      heading: s === "spell" ? "Primary Spell Schools" : "Spell Schools",
      options: o.primary
    },
    {
      filterKey: "secondarySpellSchools",
      heading: "Secondary Spell Schools",
      options: o.secondary,
      display: s === "spell"
    },
    {
      filterKey: "components",
      heading: "Components",
      options: a
    },
    {
      filterKey: "miscellaneous",
      heading: "Miscellaneous",
      options: {
        concentration: "Concentration",
        rare: "Rare",
        ritual: "Ritual"
      }
    },
    {
      filterKey: "source",
      heading: "Source",
      options: c
    }
  ], p = /* @__PURE__ */ u((h, { detail: _ }) => {
    n.update((y) => ({
      ...y,
      [h]: {
        inclusive: f[h].inclusive,
        inclusiveMode: f[h].inclusiveMode,
        exclusive: f[h].exclusive,
        exclusiveMode: _
      }
    }));
  }, "updateExclusiveMode_handler"), m = /* @__PURE__ */ u((h, { detail: _ }) => {
    n.update((y) => ({
      ...y,
      [h]: {
        inclusive: f[h].inclusive,
        inclusiveMode: _,
        exclusive: f[h].exclusive,
        exclusiveMode: f[h].exclusiveMode
      }
    }));
  }, "updateInclusiveMode_handler"), g = /* @__PURE__ */ u((h, { detail: _ }) => {
    n.update((y) => ({
      ...y,
      [h]: {
        inclusive: _[0],
        inclusiveMode: f[h].inclusiveMode,
        exclusive: _[1],
        exclusiveMode: f[h].exclusiveMode
      }
    }));
  }, "updateSelection_handler");
  return i.$$set = (h) => {
    "compendiumType" in h && t(3, s = h.compendiumType);
  }, [
    f,
    n,
    d,
    s,
    p,
    m,
    g
  ];
}
u(Hhe, "instance$T");
const eT = class eT extends re {
  constructor(e) {
    super(), oe(this, e, Hhe, zhe, le, { compendiumType: 3 });
  }
};
u(eT, "CompendiumSpellFilters");
let Kp = eT;
function N8(i, e, t) {
  const s = i.slice();
  return s[9] = e[t].display, s[10] = e[t].heading, s[11] = e[t].filterKey, s[12] = e[t].options, s;
}
u(N8, "get_each_context$i");
function Uhe(i) {
  let e, t;
  function s(...r) {
    return (
      /*updateExclusiveMode_handler*/
      i[4](
        /*filterKey*/
        i[11],
        ...r
      )
    );
  }
  u(s, "updateExclusiveMode_handler");
  function n(...r) {
    return (
      /*updateInclusiveMode_handler*/
      i[5](
        /*filterKey*/
        i[11],
        ...r
      )
    );
  }
  u(n, "updateInclusiveMode_handler");
  function l(...r) {
    return (
      /*updateSelection_handler*/
      i[6](
        /*filterKey*/
        i[11],
        ...r
      )
    );
  }
  return u(l, "updateSelection_handler"), e = new Sr({
    props: {
      filterKey: (
        /*filterKey*/
        i[11]
      ),
      filterSelections: (
        /*filterSelections*/
        i[0]
      ),
      heading: (
        /*heading*/
        i[10]
      ),
      options: (
        /*options*/
        i[12]
      )
    }
  }), e.$on("updateExclusiveMode", s), e.$on("updateInclusiveMode", n), e.$on("updateSelection", l), {
    c() {
      j(e.$$.fragment);
    },
    m(r, o) {
      R(e, r, o), t = !0;
    },
    p(r, o) {
      i = r;
      const a = {};
      o & /*filterSelections*/
      1 && (a.filterSelections = /*filterSelections*/
      i[0]), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      O(e.$$.fragment, r), t = !1;
    },
    d(r) {
      N(e, r);
    }
  };
}
u(Uhe, "create_if_block$r");
function j8(i) {
  let e, t, s = (
    /*display*/
    (i[9] ?? !0) && Uhe(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*display*/
      (n[9] ?? !0) && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(j8, "create_each_block$i");
function Vhe(i) {
  let e, t, s = ue(
    /*getFormSections*/
    i[2]()
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = j8(N8(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, [o]) {
      if (o & /*getFormSections, filterSelections, filterStore*/
      7) {
        s = ue(
          /*getFormSections*/
          r[2]()
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = N8(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = j8(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(Vhe, "create_fragment$Y");
function Whe(i, e, t) {
  let { compendiumType: s = "class" } = e;
  const n = de("filterStore"), { classes: l } = CONFIG.A5E, r = Object.entries(CONFIG.A5E.products).reduce(
    (p, [m, g]) => (p[m] = g.title, p),
    {}
  );
  function o() {
    return [
      {
        filterKey: "classes",
        heading: "Class",
        options: l
      },
      {
        filterKey: "source",
        heading: "Source",
        options: r
      }
    ];
  }
  u(o, "getFormSections");
  let a = {};
  n.subscribe((p) => {
    t(0, a = p);
  });
  const c = /* @__PURE__ */ u((p, { detail: m }) => {
    n.update((g) => ({
      ...g,
      [p]: {
        inclusive: a[p].inclusive,
        inclusiveMode: a[p].inclusiveMode,
        exclusive: a[p].exclusive,
        exclusiveMode: m
      }
    }));
  }, "updateExclusiveMode_handler"), f = /* @__PURE__ */ u((p, { detail: m }) => {
    n.update((g) => ({
      ...g,
      [p]: {
        inclusive: a[p].inclusive,
        inclusiveMode: m,
        exclusive: a[p].exclusive,
        exclusiveMode: a[p].exclusiveMode
      }
    }));
  }, "updateInclusiveMode_handler"), d = /* @__PURE__ */ u((p, { detail: m }) => {
    n.update((g) => ({
      ...g,
      [p]: {
        inclusive: m[0],
        inclusiveMode: a[p].inclusiveMode,
        exclusive: m[1],
        exclusiveMode: a[p].exclusiveMode
      }
    }));
  }, "updateSelection_handler");
  return i.$$set = (p) => {
    "compendiumType" in p && t(3, s = p.compendiumType);
  }, [
    a,
    n,
    o,
    s,
    c,
    f,
    d
  ];
}
u(Whe, "instance$S");
const tT = class tT extends re {
  constructor(e) {
    super(), oe(this, e, Whe, Vhe, le, { compendiumType: 3 });
  }
};
u(tT, "CompendiumClassFeatureFilters");
let rk = tT;
function Khe(i) {
  let e, t, s, n;
  var l = (
    /*compendiumItemComponents*/
    i[1][
      /*compendiumType*/
      i[0]
    ]
  );
  function r(o, a) {
    return {
      props: {
        compendiumType: (
          /*compendiumType*/
          o[0]
        )
      }
    };
  }
  return u(r, "switch_props"), l && (t = et(l, r(i))), {
    c() {
      e = E("section"), t && j(t.$$.fragment), b(e, "class", "filter-page svelte-1rso1s1");
    },
    m(o, a) {
      T(o, e, a), t && R(t, e, null), n = !0;
    },
    p(o, [a]) {
      if (a & /*compendiumType*/
      1 && l !== (l = /*compendiumItemComponents*/
      o[1][
        /*compendiumType*/
        o[0]
      ])) {
        if (t) {
          ae();
          const c = t;
          O(c.$$.fragment, 1, 0, () => {
            N(c, 1);
          }), ce();
        }
        l ? (t = et(l, r(o)), j(t.$$.fragment), w(t.$$.fragment, 1), R(t, e, null)) : t = null;
      } else if (l) {
        const c = {};
        a & /*compendiumType*/
        1 && (c.compendiumType = /*compendiumType*/
        o[0]), t.$set(c);
      }
    },
    i(o) {
      n || (t && w(t.$$.fragment, o), o && ks(() => {
        n && (s || (s = yr(e, oc, {}, !0)), s.run(1));
      }), n = !0);
    },
    o(o) {
      t && O(t.$$.fragment, o), o && (s || (s = yr(e, oc, {}, !1)), s.run(0)), n = !1;
    },
    d(o) {
      o && C(e), t && N(t), o && s && s.end();
    }
  };
}
u(Khe, "create_fragment$X");
function Yhe(i, e, t) {
  let { compendiumType: s } = e;
  const n = {
    "5eSpell": Kp,
    classFeature: rk,
    object: Wp,
    magicItem: Wp,
    maneuver: nk,
    monster: ik,
    spell: Kp,
    archetype: lk
  };
  return i.$$set = (l) => {
    "compendiumType" in l && t(0, s = l.compendiumType);
  }, [s, n];
}
u(Yhe, "instance$R");
const sT = class sT extends re {
  constructor(e) {
    super(), oe(this, e, Yhe, Khe, le, { compendiumType: 0 });
  }
};
u(sT, "CompendiumFilters");
let Yp = sT;
function Xhe(i) {
  return i == 0.125 ? "CR ⅛" : i == 0.25 ? "CR ¼" : i == 0.5 ? "CR ½" : `CR ${i}`;
}
u(Xhe, "getCRLabel$1");
function Jhe(i) {
  return i == 0 ? "Basic Maneuvers" : (typeof i == "string" && (i = parseInt(i, 10)), i = Number.isNaN(i) ? 1 .ordinalString() : i.ordinalString(), `${i} Degree Maneuvers`);
}
u(Jhe, "getManueverDegreeLabel");
function Zhe(i) {
  return typeof i == "string" ? `${i.capitalize()} Items` : `${i.toString().capitalize()} Items`;
}
u(Zhe, "getRarityLabel");
function Qhe(i) {
  return i == 0 ? "Cantrips" : (typeof i == "string" && (i = parseInt(i, 10)), i = Number.isNaN(i) ? 1 .ordinalString() : i.ordinalString(), `${i} Level Spells`);
}
u(Qhe, "getSpellLevelLabel");
function xhe(i, e) {
  return i === "monster" ? Xhe(e) : ["5eSpell", "spell"].includes(i) ? Qhe(e) : i === "maneuver" ? Jhe(e) : ["object", "magicItem"].includes(i) ? Zhe(e) : `${e}`;
}
u(xhe, "getCategoryNames");
function ege(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-compendium-import-button fa-solid fa-download svelte-1h6veuf"), b(e, "data-tooltip", t = `Import ${/*document*/
      i[0].name}`), b(e, "data-tooltip-direction", "UP");
    },
    m(l, r) {
      T(l, e, r), s || (n = W(e, "click", Ve(
        /*click_handler*/
        i[2]
      )), s = !0);
    },
    p(l, [r]) {
      r & /*document*/
      1 && t !== (t = `Import ${/*document*/
      l[0].name}`) && b(e, "data-tooltip", t);
    },
    i: se,
    o: se,
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(ege, "create_fragment$W");
function tge(i, e, t) {
  let { document: s } = e;
  async function n() {
    const a = await l.getDocument(s._id);
    if (r) {
      r([a.toObject()]);
      return;
    }
    a.collection.importFromCompendium(a.compendium, a._id);
  }
  u(n, "importDocument");
  const l = de("collection"), r = de("customImporter"), o = /* @__PURE__ */ u(async () => n(), "click_handler");
  return i.$$set = (a) => {
    "document" in a && t(0, s = a.document);
  }, [s, n, o];
}
u(tge, "instance$Q");
const nT = class nT extends re {
  constructor(e) {
    super(), oe(this, e, tge, ege, le, { document: 0 });
  }
};
u(nT, "ImportButton");
let Cr = nT;
function sge(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-compendium-delete-button fa-solid fa-trash svelte-1a4liwt"), b(e, "data-tooltip", t = `Delete ${/*document*/
      i[0].name}`), b(e, "data-tooltip-direction", "UP");
    },
    m(l, r) {
      T(l, e, r), s || (n = W(e, "click", Ve(
        /*click_handler*/
        i[2]
      )), s = !0);
    },
    p(l, [r]) {
      r & /*document*/
      1 && t !== (t = `Delete ${/*document*/
      l[0].name}`) && b(e, "data-tooltip", t);
    },
    i: se,
    o: se,
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(sge, "create_fragment$V");
function nge(i, e, t) {
  let { document: s } = e;
  async function n() {
    const a = { name: s.name, type: "Document" }, c = new Au(a, !0);
    await c.render(!0);
    const f = await c.promise;
    if (!f || !(f != null && f.confirmDeletion)) return;
    await (await l.getDocument(s._id)).delete(), await r.render(!0);
  }
  u(n, "deleteDocument");
  const l = de("collection"), r = de("sheet"), o = /* @__PURE__ */ u(async () => n(), "click_handler");
  return i.$$set = (a) => {
    "document" in a && t(0, s = a.document);
  }, [s, n, o];
}
u(nge, "instance$P");
const iT = class iT extends re {
  constructor(e) {
    super(), oe(this, e, nge, sge, le, { document: 0 });
  }
};
u(iT, "CompendiumDeleteButton");
let Tr = iT;
function L8(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-key"), b(e, "data-tooltip", t = q8(
        /*document*/
        i[0].system.prerequisite
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--basic"), b(e, "data-tooltip-direction", "DOWN");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*document*/
      1 && t !== (t = q8(
        /*document*/
        s[0].system.prerequisite
      )) && b(e, "data-tooltip", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(L8, "create_if_block_2$d");
function B8(i) {
  var a;
  let e, t = (
    /*featureSource*/
    ((a = i[1]) == null ? void 0 : a.abbreviation) + ""
  ), s, n, l, r, o;
  return {
    c() {
      var c;
      e = E("a"), s = Q(t), b(e, "class", "a5e-item__source-tag"), b(e, "href", n = /*featureSource*/
      (c = i[1]) == null ? void 0 : c.url), b(e, "target", "_blank"), b(e, "data-tooltip", l = On(
        /*featureSource*/
        i[1]
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source");
    },
    m(c, f) {
      T(c, e, f), A(e, s), r || (o = W(e, "click", Ve(
        /*click_handler*/
        i[5]
      )), r = !0);
    },
    p(c, f) {
      var d, p;
      f & /*featureSource*/
      2 && t !== (t = /*featureSource*/
      ((d = c[1]) == null ? void 0 : d.abbreviation) + "") && be(s, t), f & /*featureSource*/
      2 && n !== (n = /*featureSource*/
      (p = c[1]) == null ? void 0 : p.url) && b(e, "href", n), f & /*featureSource*/
      2 && l !== (l = On(
        /*featureSource*/
        c[1]
      )) && b(e, "data-tooltip", l);
    },
    d(c) {
      c && C(e), r = !1, o();
    }
  };
}
u(B8, "create_if_block_1$k");
function ige(i) {
  let e, t;
  return e = new Tr({ props: { document: (
    /*document*/
    i[0]
  ) } }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*document*/
      1 && (l.document = /*document*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(ige, "create_if_block$q");
function lge(i) {
  var M;
  let e, t, s, n, l, r, o = (
    /*document*/
    i[0].name + ""
  ), a, c, f, d, p, m, g, h, _, y, v, k, S = (
    /*document*/
    i[0].system.prerequisite && L8(i)
  ), D = (
    /*featureSource*/
    ((M = i[1]) == null ? void 0 : M.abbreviation) && B8(i)
  );
  h = new Cr({ props: { document: (
    /*document*/
    i[0]
  ) } });
  let I = !/*collection*/
  i[4].locked && ige(i);
  return {
    c() {
      e = E("li"), t = E("img"), l = F(), r = E("h3"), a = Q(o), c = F(), S && S.c(), f = F(), d = E("span"), D && D.c(), p = F(), m = Q(
        /*featureDetails*/
        i[2]
      ), g = F(), j(h.$$.fragment), _ = F(), I && I.c(), b(t, "class", "a5e-item__image a5e-item__image--compendium-document"), ze(t.src, s = /*document*/
      i[0].img) || b(t, "src", s), b(t, "alt", n = /*document*/
      i[0].name), b(r, "class", "a5e-item__name a5e-item__name--compendium-document"), b(d, "class", "a5e-item__details"), b(e, "class", "a5e-item a5e-item--compendium-spell-document"), b(e, "draggable", "true");
    },
    m(L, B) {
      T(L, e, B), A(e, t), A(e, l), A(e, r), A(r, a), A(r, c), S && S.m(r, null), A(e, f), A(e, d), D && D.m(d, null), A(d, p), A(d, m), A(e, g), R(h, e, null), A(e, _), I && I.m(e, null), y = !0, v || (k = [
        W(
          e,
          "click",
          /*click_handler_1*/
          i[6]
        ),
        W(
          e,
          "dragstart",
          /*onDragStart*/
          i[3]
        )
      ], v = !0);
    },
    p(L, [B]) {
      var q;
      (!y || B & /*document*/
      1 && !ze(t.src, s = /*document*/
      L[0].img)) && b(t, "src", s), (!y || B & /*document*/
      1 && n !== (n = /*document*/
      L[0].name)) && b(t, "alt", n), (!y || B & /*document*/
      1) && o !== (o = /*document*/
      L[0].name + "") && be(a, o), /*document*/
      L[0].system.prerequisite ? S ? S.p(L, B) : (S = L8(L), S.c(), S.m(r, null)) : S && (S.d(1), S = null), /*featureSource*/
      (q = L[1]) != null && q.abbreviation ? D ? D.p(L, B) : (D = B8(L), D.c(), D.m(d, p)) : D && (D.d(1), D = null), (!y || B & /*featureDetails*/
      4) && be(
        m,
        /*featureDetails*/
        L[2]
      );
      const z = {};
      B & /*document*/
      1 && (z.document = /*document*/
      L[0]), h.$set(z), /*collection*/
      L[4].locked || I.p(L, B);
    },
    i(L) {
      y || (w(h.$$.fragment, L), w(I), y = !0);
    },
    o(L) {
      O(h.$$.fragment, L), O(I), y = !1;
    },
    d(L) {
      L && C(e), S && S.d(), D && D.d(), N(h), I && I.d(), v = !1, Me(k);
    }
  };
}
u(lge, "create_fragment$U");
function q8(i) {
  return `<b>Prerequisites:</b> ${i}`;
}
u(q8, "getPrerequisiteTooltipContent");
function rge(i, e, t) {
  let s, n, { document: l } = e;
  function r(_) {
    const y = {
      type: c.documentName,
      uuid: c.getUuid(l._id)
    };
    return _.dataTransfer.setData("text/plain", JSON.stringify(y));
  }
  u(r, "onDragStart");
  function o(_) {
    const y = _.system.classes, v = [f[y] ?? d[y]];
    return _.system.featureType === "knack" && v.push(p[y]), v.filter(Boolean).join(" | ");
  }
  u(o, "getFeatureDetailsLabel");
  function a(_) {
    return typeof _.system.source != "string" ? null : m[_.system.source] || null;
  }
  u(a, "getFeatureSource");
  const c = de("collection"), { classes: f, classes5e: d, knackTypes: p, products: m } = CONFIG.A5E;
  function g(_) {
    bt.call(this, i, _);
  }
  u(g, "click_handler");
  const h = /* @__PURE__ */ u(async () => {
    var y;
    (y = (c.get(l._id) ?? await c.getDocument(l._id)).sheet) == null || y.render(!0);
  }, "click_handler_1");
  return i.$$set = (_) => {
    "document" in _ && t(0, l = _.document);
  }, i.$$.update = () => {
    i.$$.dirty & /*document*/
    1 && t(2, s = o(l)), i.$$.dirty & /*document*/
    1 && t(1, n = a(l));
  }, [
    l,
    n,
    s,
    r,
    c,
    g,
    h
  ];
}
u(rge, "instance$O");
const lT = class lT extends re {
  constructor(e) {
    super(), oe(this, e, rge, lge, le, { document: 0 });
  }
};
u(lT, "CompendiumClassFeatureItem");
let ok = lT;
function G8(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-street-view"), b(e, "data-tooltip", "Stance"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(G8, "create_if_block_2$c");
function z8(i) {
  var a;
  let e, t = (
    /*maneuverSource*/
    ((a = i[1]) == null ? void 0 : a.abbreviation) + ""
  ), s, n, l, r, o;
  return {
    c() {
      var c;
      e = E("a"), s = Q(t), b(e, "class", "a5e-item__source-tag"), b(e, "href", n = /*maneuverSource*/
      (c = i[1]) == null ? void 0 : c.url), b(e, "target", "_blank"), b(e, "data-tooltip", l = On(
        /*maneuverSource*/
        i[1]
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source");
    },
    m(c, f) {
      T(c, e, f), A(e, s), r || (o = W(e, "click", Ve(
        /*click_handler*/
        i[5]
      )), r = !0);
    },
    p(c, f) {
      var d, p;
      f & /*maneuverSource*/
      2 && t !== (t = /*maneuverSource*/
      ((d = c[1]) == null ? void 0 : d.abbreviation) + "") && be(s, t), f & /*maneuverSource*/
      2 && n !== (n = /*maneuverSource*/
      (p = c[1]) == null ? void 0 : p.url) && b(e, "href", n), f & /*maneuverSource*/
      2 && l !== (l = On(
        /*maneuverSource*/
        c[1]
      )) && b(e, "data-tooltip", l);
    },
    d(c) {
      c && C(e), r = !1, o();
    }
  };
}
u(z8, "create_if_block_1$j");
function oge(i) {
  let e, t;
  return e = new Tr({ props: { document: (
    /*document*/
    i[0]
  ) } }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*document*/
      1 && (l.document = /*document*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(oge, "create_if_block$p");
function age(i) {
  var M;
  let e, t, s, n, l, r, o = (
    /*document*/
    i[0].name + ""
  ), a, c, f, d, p, m, g, h, _, y, v, k, S = (
    /*document*/
    i[0].system.isStance && G8()
  ), D = (
    /*maneuverSource*/
    ((M = i[1]) == null ? void 0 : M.abbreviation) && z8(i)
  );
  h = new Cr({ props: { document: (
    /*document*/
    i[0]
  ) } });
  let I = !/*collection*/
  i[4].locked && oge(i);
  return {
    c() {
      e = E("li"), t = E("img"), l = F(), r = E("h3"), a = Q(o), c = F(), S && S.c(), f = F(), d = E("span"), D && D.c(), p = F(), m = Q(
        /*maneuverDetails*/
        i[2]
      ), g = F(), j(h.$$.fragment), _ = F(), I && I.c(), b(t, "class", "a5e-item__image a5e-item__image--compendium-document"), ze(t.src, s = /*document*/
      i[0].img) || b(t, "src", s), b(t, "alt", n = /*document*/
      i[0].name), b(r, "class", "a5e-item__name a5e-item__name--compendium-document"), b(d, "class", "a5e-item__details"), b(e, "class", "a5e-item a5e-item--compendium-spell-document"), b(e, "draggable", "true");
    },
    m(L, B) {
      T(L, e, B), A(e, t), A(e, l), A(e, r), A(r, a), A(r, c), S && S.m(r, null), A(e, f), A(e, d), D && D.m(d, null), A(d, p), A(d, m), A(e, g), R(h, e, null), A(e, _), I && I.m(e, null), y = !0, v || (k = [
        W(
          e,
          "click",
          /*click_handler_1*/
          i[6]
        ),
        W(
          e,
          "dragstart",
          /*onDragStart*/
          i[3]
        )
      ], v = !0);
    },
    p(L, [B]) {
      var q;
      (!y || B & /*document*/
      1 && !ze(t.src, s = /*document*/
      L[0].img)) && b(t, "src", s), (!y || B & /*document*/
      1 && n !== (n = /*document*/
      L[0].name)) && b(t, "alt", n), (!y || B & /*document*/
      1) && o !== (o = /*document*/
      L[0].name + "") && be(a, o), /*document*/
      L[0].system.isStance ? S || (S = G8(), S.c(), S.m(r, null)) : S && (S.d(1), S = null), /*maneuverSource*/
      (q = L[1]) != null && q.abbreviation ? D ? D.p(L, B) : (D = z8(L), D.c(), D.m(d, p)) : D && (D.d(1), D = null), (!y || B & /*maneuverDetails*/
      4) && be(
        m,
        /*maneuverDetails*/
        L[2]
      );
      const z = {};
      B & /*document*/
      1 && (z.document = /*document*/
      L[0]), h.$set(z), /*collection*/
      L[4].locked || I.p(L, B);
    },
    i(L) {
      y || (w(h.$$.fragment, L), w(I), y = !0);
    },
    o(L) {
      O(h.$$.fragment, L), O(I), y = !1;
    },
    d(L) {
      L && C(e), S && S.d(), D && D.d(), N(h), I && I.d(), v = !1, Me(k);
    }
  };
}
u(age, "create_fragment$T");
function cge(i) {
  return typeof i.system.source != "string" ? null : CONFIG.A5E.products[i.system.source] || null;
}
u(cge, "getManeuverSource");
function uge(i, e, t) {
  let s, n, { document: l } = e;
  function r(m) {
    const g = {
      type: a.documentName,
      uuid: a.getUuid(l._id)
    };
    return m.dataTransfer.setData("text/plain", JSON.stringify(g));
  }
  u(r, "onDragStart");
  function o(m) {
    const g = c[parseInt(m.system.degree, 10)], h = f[m.system.tradition] ?? "", _ = m.system.isStance ? "Stance" : "", y = m.system.exertionCost ? `(${m.system.exertionCost} ${K(m.system.exertionCost > 1 ? "A5E.ExertionPointPlural" : "A5E.ExertionPoint")})` : "";
    return [g, h, _, y].filter(Boolean).join(" ");
  }
  u(o, "getManeuverDetailsLabel");
  const a = de("collection"), { maneuverDegrees: c, maneuverTraditions: f } = CONFIG.A5E;
  function d(m) {
    bt.call(this, i, m);
  }
  u(d, "click_handler");
  const p = /* @__PURE__ */ u(async () => {
    var g;
    (g = (a.get(l._id) ?? await a.getDocument(l._id)).sheet) == null || g.render(!0);
  }, "click_handler_1");
  return i.$$set = (m) => {
    "document" in m && t(0, l = m.document);
  }, i.$$.update = () => {
    i.$$.dirty & /*document*/
    1 && t(2, s = o(l)), i.$$.dirty & /*document*/
    1 && t(1, n = cge(l));
  }, [
    l,
    n,
    s,
    r,
    a,
    d,
    p
  ];
}
u(uge, "instance$N");
const rT = class rT extends re {
  constructor(e) {
    super(), oe(this, e, uge, age, le, { document: 0 });
  }
};
u(rT, "CompendiumManeuverItem");
let ak = rT;
function H8(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-skull"), b(e, "data-tooltip", "Elite Monster"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(H8, "create_if_block_4$7");
function U8(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-people-group"), b(e, "data-tooltip", "Squad"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(U8, "create_if_block_3$7");
function V8(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-locust"), b(e, "data-tooltip", "Swarm"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(V8, "create_if_block_2$b");
function W8(i) {
  var a;
  let e, t = (
    /*monsterSource*/
    ((a = i[1]) == null ? void 0 : a.abbreviation) + ""
  ), s, n, l, r, o;
  return {
    c() {
      var c;
      e = E("a"), s = Q(t), b(e, "class", "a5e-item__source-tag"), b(e, "href", n = /*monsterSource*/
      (c = i[1]) == null ? void 0 : c.url), b(e, "target", "_blank"), b(e, "data-tooltip", l = On(
        /*monsterSource*/
        i[1]
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source");
    },
    m(c, f) {
      T(c, e, f), A(e, s), r || (o = W(e, "click", Ve(
        /*click_handler*/
        i[5]
      )), r = !0);
    },
    p(c, f) {
      var d, p;
      f & /*monsterSource*/
      2 && t !== (t = /*monsterSource*/
      ((d = c[1]) == null ? void 0 : d.abbreviation) + "") && be(s, t), f & /*monsterSource*/
      2 && n !== (n = /*monsterSource*/
      (p = c[1]) == null ? void 0 : p.url) && b(e, "href", n), f & /*monsterSource*/
      2 && l !== (l = On(
        /*monsterSource*/
        c[1]
      )) && b(e, "data-tooltip", l);
    },
    d(c) {
      c && C(e), r = !1, o();
    }
  };
}
u(W8, "create_if_block_1$i");
function fge(i) {
  let e, t;
  return e = new Tr({ props: { document: (
    /*document*/
    i[0]
  ) } }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*document*/
      1 && (l.document = /*document*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(fge, "create_if_block$o");
function dge(i) {
  var q, U, H, V, Y, J, fe, ke, ee, ne, Ee;
  let e, t, s, n, l, r, o = (
    /*document*/
    ((q = i[0]) == null ? void 0 : q.name) + ""
  ), a, c, f, d, p, m, g, h, _, y, v, k, S, D, I = (
    /*document*/
    ((V = (H = (U = i[0]) == null ? void 0 : U.system) == null ? void 0 : H.details) == null ? void 0 : V.elite) && H8()
  ), M = (
    /*document*/
    ((fe = (J = (Y = i[0]) == null ? void 0 : Y.system) == null ? void 0 : J.details) == null ? void 0 : fe.isSquad) && U8()
  ), L = (
    /*document*/
    ((ne = (ee = (ke = i[0]) == null ? void 0 : ke.system) == null ? void 0 : ee.details) == null ? void 0 : ne.isSwarm) && V8()
  ), B = (
    /*monsterSource*/
    ((Ee = i[1]) == null ? void 0 : Ee.abbreviation) && W8(i)
  );
  y = new Cr({ props: { document: (
    /*document*/
    i[0]
  ) } });
  let z = !/*collection*/
  i[4].locked && fge(i);
  return {
    c() {
      var Pe, ye;
      e = E("li"), t = E("img"), l = F(), r = E("h3"), a = Q(o), c = F(), I && I.c(), f = F(), M && M.c(), d = F(), L && L.c(), p = F(), m = E("div"), B && B.c(), g = F(), h = Q(
        /*monsterDetails*/
        i[2]
      ), _ = F(), j(y.$$.fragment), v = F(), z && z.c(), b(t, "class", "a5e-item__image a5e-item__image--compendium-document"), ze(t.src, s = /*document*/
      (Pe = i[0]) == null ? void 0 : Pe.img) || b(t, "src", s), b(t, "alt", n = /*document*/
      (ye = i[0]) == null ? void 0 : ye.name), b(r, "class", "a5e-item__name a5e-item__name--compendium-document"), b(m, "class", "a5e-item__details"), b(e, "class", "a5e-item a5e-item--compendium-document"), b(e, "draggable", "true");
    },
    m(Pe, ye) {
      T(Pe, e, ye), A(e, t), A(e, l), A(e, r), A(r, a), A(r, c), I && I.m(r, null), A(r, f), M && M.m(r, null), A(r, d), L && L.m(r, null), A(e, p), A(e, m), B && B.m(m, null), A(m, g), A(m, h), A(e, _), R(y, e, null), A(e, v), z && z.m(e, null), k = !0, S || (D = [
        W(
          e,
          "click",
          /*click_handler_1*/
          i[6]
        ),
        W(
          e,
          "dragstart",
          /*onDragStart*/
          i[3]
        )
      ], S = !0);
    },
    p(Pe, [ye]) {
      var Ce, Je, Ne, Re, ge, je, Be, Ze, Ge, Se, _e, we, Fe;
      (!k || ye & /*document*/
      1 && !ze(t.src, s = /*document*/
      (Ce = Pe[0]) == null ? void 0 : Ce.img)) && b(t, "src", s), (!k || ye & /*document*/
      1 && n !== (n = /*document*/
      (Je = Pe[0]) == null ? void 0 : Je.name)) && b(t, "alt", n), (!k || ye & /*document*/
      1) && o !== (o = /*document*/
      ((Ne = Pe[0]) == null ? void 0 : Ne.name) + "") && be(a, o), /*document*/
      (je = (ge = (Re = Pe[0]) == null ? void 0 : Re.system) == null ? void 0 : ge.details) != null && je.elite ? I || (I = H8(), I.c(), I.m(r, f)) : I && (I.d(1), I = null), /*document*/
      (Ge = (Ze = (Be = Pe[0]) == null ? void 0 : Be.system) == null ? void 0 : Ze.details) != null && Ge.isSquad ? M || (M = U8(), M.c(), M.m(r, d)) : M && (M.d(1), M = null), /*document*/
      (we = (_e = (Se = Pe[0]) == null ? void 0 : Se.system) == null ? void 0 : _e.details) != null && we.isSwarm ? L || (L = V8(), L.c(), L.m(r, null)) : L && (L.d(1), L = null), /*monsterSource*/
      (Fe = Pe[1]) != null && Fe.abbreviation ? B ? B.p(Pe, ye) : (B = W8(Pe), B.c(), B.m(m, g)) : B && (B.d(1), B = null), (!k || ye & /*monsterDetails*/
      4) && be(
        h,
        /*monsterDetails*/
        Pe[2]
      );
      const me = {};
      ye & /*document*/
      1 && (me.document = /*document*/
      Pe[0]), y.$set(me), /*collection*/
      Pe[4].locked || z.p(Pe, ye);
    },
    i(Pe) {
      k || (w(y.$$.fragment, Pe), w(z), k = !0);
    },
    o(Pe) {
      O(y.$$.fragment, Pe), O(z), k = !1;
    },
    d(Pe) {
      Pe && C(e), I && I.d(), M && M.d(), L && L.d(), B && B.d(), N(y), z && z.d(), S = !1, Me(D);
    }
  };
}
u(dge, "create_fragment$S");
function pge(i) {
  var t, s;
  let e = (s = (t = i == null ? void 0 : i.system) == null ? void 0 : t.details) == null ? void 0 : s.cr;
  return e === void 0 ? "?" : e === 0.125 || e === "0.125" ? "⅛" : e === 0.25 || e === "0.25" ? "¼" : e === 0.5 || e === "0.5" ? "½" : e;
}
u(pge, "getCRLabel");
function mge(i) {
  return typeof i.system.source != "string" ? null : CONFIG.A5E.products[i.system.source] || null;
}
u(mge, "getMonsterSource");
function hge(i, e, t) {
  let s, n, { document: l } = e;
  function r(g) {
    var h, _;
    return (((_ = (h = g == null ? void 0 : g.system) == null ? void 0 : h.details) == null ? void 0 : _.creatureTypes) ?? []).map((y) => d[y] ?? y ?? "").sort((y, v) => y.localeCompare(v)).join(", ");
  }
  u(r, "getCreatureTypes");
  function o(g) {
    var D, I, M, L;
    const h = [], _ = pge(g), y = r(g), v = (I = (D = g == null ? void 0 : g.system) == null ? void 0 : D.details) == null ? void 0 : I.elite, k = f[(L = (M = g == null ? void 0 : g.system) == null ? void 0 : M.traits) == null ? void 0 : L.size] ?? "", S = FB(g);
    return _ === "?" ? h.push(k, y) : h.push(k, y, "|", v ? "Elite" : "", `CR ${_}`, `(${S} XP)`), h.filter((B) => !foundry.utils.isEmpty(B) && B !== "").join(" ");
  }
  u(o, "getMonsterDetailsLabel");
  function a(g) {
    const h = {
      type: c.documentName,
      uuid: c.getUuid(l._id)
    };
    return g.dataTransfer.setData("text/plain", JSON.stringify(h));
  }
  u(a, "onDragStart");
  const c = de("collection"), { actorSizes: f, creatureTypes: d } = CONFIG.A5E;
  function p(g) {
    bt.call(this, i, g);
  }
  u(p, "click_handler");
  const m = /* @__PURE__ */ u(async () => {
    var h;
    (h = (c.get(l._id) ?? await c.getDocument(l._id)).sheet) == null || h.render(!0);
  }, "click_handler_1");
  return i.$$set = (g) => {
    "document" in g && t(0, l = g.document);
  }, i.$$.update = () => {
    i.$$.dirty & /*document*/
    1 && t(2, s = o(l)), i.$$.dirty & /*document*/
    1 && t(1, n = mge(l));
  }, [
    l,
    n,
    s,
    a,
    c,
    p,
    m
  ];
}
u(hge, "instance$M");
const oT = class oT extends re {
  constructor(e) {
    super(), oe(this, e, hge, dge, le, { document: 0 });
  }
};
u(oT, "CompendiumMonsterItem");
let ck = oT;
function K8(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-link"), b(e, "data-tooltip", "Requires Attunement"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(K8, "create_if_block_2$a");
function Y8(i) {
  var a;
  let e, t = (
    /*objectSource*/
    ((a = i[1]) == null ? void 0 : a.abbreviation) + ""
  ), s, n, l, r, o;
  return {
    c() {
      var c;
      e = E("a"), s = Q(t), b(e, "class", "a5e-item__source-tag"), b(e, "href", n = /*objectSource*/
      (c = i[1]) == null ? void 0 : c.url), b(e, "target", "_blank"), b(e, "data-tooltip", l = On(
        /*objectSource*/
        i[1]
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source");
    },
    m(c, f) {
      T(c, e, f), A(e, s), r || (o = W(e, "click", Ve(
        /*click_handler*/
        i[5]
      )), r = !0);
    },
    p(c, f) {
      var d, p;
      f & /*objectSource*/
      2 && t !== (t = /*objectSource*/
      ((d = c[1]) == null ? void 0 : d.abbreviation) + "") && be(s, t), f & /*objectSource*/
      2 && n !== (n = /*objectSource*/
      (p = c[1]) == null ? void 0 : p.url) && b(e, "href", n), f & /*objectSource*/
      2 && l !== (l = On(
        /*objectSource*/
        c[1]
      )) && b(e, "data-tooltip", l);
    },
    d(c) {
      c && C(e), r = !1, o();
    }
  };
}
u(Y8, "create_if_block_1$h");
function gge(i) {
  let e, t;
  return e = new Tr({ props: { document: (
    /*document*/
    i[0]
  ) } }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*document*/
      1 && (l.document = /*document*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(gge, "create_if_block$n");
function bge(i) {
  var M, L;
  let e, t, s, n, l, r, o = (
    /*document*/
    i[0].name + ""
  ), a, c, f, d, p, m, g, h, _, y, v, k, S = (
    /*document*/
    ((M = i[0].system) == null ? void 0 : M.requiresAttunement) && K8()
  ), D = (
    /*objectSource*/
    ((L = i[1]) == null ? void 0 : L.abbreviation) && Y8(i)
  );
  h = new Cr({ props: { document: (
    /*document*/
    i[0]
  ) } });
  let I = !/*collection*/
  i[4].locked && gge(i);
  return {
    c() {
      e = E("li"), t = E("img"), l = F(), r = E("h3"), a = Q(o), c = F(), S && S.c(), f = F(), d = E("span"), D && D.c(), p = F(), m = Q(
        /*objectDetails*/
        i[2]
      ), g = F(), j(h.$$.fragment), _ = F(), I && I.c(), b(t, "class", "a5e-item__image a5e-item__image--compendium-document"), ze(t.src, s = /*document*/
      i[0].img) || b(t, "src", s), b(t, "alt", n = /*document*/
      i[0].name), b(r, "class", "a5e-item__name a5e-item__name--compendium-document"), b(d, "class", "a5e-item__details"), b(e, "class", "a5e-item a5e-item--compendium-document"), b(e, "draggable", "true");
    },
    m(B, z) {
      T(B, e, z), A(e, t), A(e, l), A(e, r), A(r, a), A(r, c), S && S.m(r, null), A(e, f), A(e, d), D && D.m(d, null), A(d, p), A(d, m), A(e, g), R(h, e, null), A(e, _), I && I.m(e, null), y = !0, v || (k = [
        W(
          e,
          "click",
          /*click_handler_1*/
          i[6]
        ),
        W(
          e,
          "dragstart",
          /*onDragStart*/
          i[3]
        )
      ], v = !0);
    },
    p(B, [z]) {
      var U, H;
      (!y || z & /*document*/
      1 && !ze(t.src, s = /*document*/
      B[0].img)) && b(t, "src", s), (!y || z & /*document*/
      1 && n !== (n = /*document*/
      B[0].name)) && b(t, "alt", n), (!y || z & /*document*/
      1) && o !== (o = /*document*/
      B[0].name + "") && be(a, o), /*document*/
      (U = B[0].system) != null && U.requiresAttunement ? S || (S = K8(), S.c(), S.m(r, null)) : S && (S.d(1), S = null), /*objectSource*/
      (H = B[1]) != null && H.abbreviation ? D ? D.p(B, z) : (D = Y8(B), D.c(), D.m(d, p)) : D && (D.d(1), D = null), (!y || z & /*objectDetails*/
      4) && be(
        m,
        /*objectDetails*/
        B[2]
      );
      const q = {};
      z & /*document*/
      1 && (q.document = /*document*/
      B[0]), h.$set(q), /*collection*/
      B[4].locked || I.p(B, z);
    },
    i(B) {
      y || (w(h.$$.fragment, B), w(I), y = !0);
    },
    o(B) {
      O(h.$$.fragment, B), O(I), y = !1;
    },
    d(B) {
      B && C(e), S && S.d(), D && D.d(), N(h), I && I.d(), v = !1, Me(k);
    }
  };
}
u(bge, "create_fragment$R");
function _ge(i) {
  return typeof i.system.source != "string" ? null : CONFIG.A5E.products[i.system.source] || null;
}
u(_ge, "getObjectSource");
function yge(i, e, t) {
  let s, n, { document: l } = e;
  function r(g) {
    return g.system.requiresAttunement ? K("A5E.AttunementRequiredPrompt") : null;
  }
  u(r, "getAttunementLabel");
  function o(g) {
    const h = r(g), { price: _ } = g.system, y = a(g);
    return y ? _ && h ? `${y} (${h}; Cost ${_})` : _ ? `${y} (Cost ${_})` : h ? `${y} (${h})` : y : _ && h ? `${h}; Cost ${_}` : _ ? `Cost ${_}` : h || null;
  }
  u(o, "getObjectDetailsLabel");
  function a(g) {
    const { rarity: h } = g.system;
    return !h || h === "mundane" ? null : d[h] ?? h;
  }
  u(a, "getRarityLabel");
  function c(g) {
    const h = {
      type: f.documentName,
      uuid: f.getUuid(l._id)
    };
    return g.dataTransfer.setData("text/plain", JSON.stringify(h));
  }
  u(c, "onDragStart");
  const f = de("collection"), { itemRarity: d } = CONFIG.A5E;
  function p(g) {
    bt.call(this, i, g);
  }
  u(p, "click_handler");
  const m = /* @__PURE__ */ u(async () => {
    var h;
    (h = (f.get(l._id) ?? await f.getDocument(l._id)).sheet) == null || h.render(!0);
  }, "click_handler_1");
  return i.$$set = (g) => {
    "document" in g && t(0, l = g.document);
  }, i.$$.update = () => {
    i.$$.dirty & /*document*/
    1 && t(2, s = o(l)), i.$$.dirty & /*document*/
    1 && t(1, n = _ge(l));
  }, [
    l,
    n,
    s,
    c,
    f,
    p,
    m
  ];
}
u(yge, "instance$L");
const aT = class aT extends re {
  constructor(e) {
    super(), oe(this, e, yge, bge, le, { document: 0 });
  }
};
u(aT, "CompendiumObjectItem");
let Xp = aT;
function X8(i) {
  var a;
  let e, t = (
    /*originSource*/
    ((a = i[1]) == null ? void 0 : a.abbreviation) + ""
  ), s, n, l, r, o;
  return {
    c() {
      var c;
      e = E("a"), s = Q(t), b(e, "class", "a5e-item__source-tag"), b(e, "href", n = /*originSource*/
      (c = i[1]) == null ? void 0 : c.url), b(e, "target", "_blank"), b(e, "data-tooltip", l = On(
        /*originSource*/
        i[1]
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source");
    },
    m(c, f) {
      T(c, e, f), A(e, s), r || (o = W(e, "click", Ve(
        /*click_handler*/
        i[4]
      )), r = !0);
    },
    p(c, f) {
      var d, p;
      f & /*originSource*/
      2 && t !== (t = /*originSource*/
      ((d = c[1]) == null ? void 0 : d.abbreviation) + "") && be(s, t), f & /*originSource*/
      2 && n !== (n = /*originSource*/
      (p = c[1]) == null ? void 0 : p.url) && b(e, "href", n), f & /*originSource*/
      2 && l !== (l = On(
        /*originSource*/
        c[1]
      )) && b(e, "data-tooltip", l);
    },
    d(c) {
      c && C(e), r = !1, o();
    }
  };
}
u(X8, "create_if_block_1$g");
function vge(i) {
  let e, t;
  return e = new Tr({ props: { document: (
    /*document*/
    i[0]
  ) } }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*document*/
      1 && (l.document = /*document*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(vge, "create_if_block$m");
function kge(i) {
  var k;
  let e, t, s, n, l, r, o = (
    /*document*/
    i[0].name + ""
  ), a, c, f, d, p, m, g, h, _, y = (
    /*originSource*/
    ((k = i[1]) == null ? void 0 : k.abbreviation) && X8(i)
  );
  p = new Cr({ props: { document: (
    /*document*/
    i[0]
  ) } });
  let v = !/*collection*/
  i[3].locked && vge(i);
  return {
    c() {
      e = E("li"), t = E("img"), l = F(), r = E("h3"), a = Q(o), c = F(), f = E("span"), y && y.c(), d = F(), j(p.$$.fragment), m = F(), v && v.c(), b(t, "class", "a5e-item__image a5e-item__image--compendium-document"), ze(t.src, s = /*document*/
      i[0].img) || b(t, "src", s), b(t, "alt", n = /*document*/
      i[0].name), b(r, "class", "a5e-item__name a5e-item__name--compendium-document"), b(f, "class", "a5e-item__details"), b(e, "class", "a5e-item a5e-item--compendium-spell-document"), b(e, "draggable", "true");
    },
    m(S, D) {
      T(S, e, D), A(e, t), A(e, l), A(e, r), A(r, a), A(e, c), A(e, f), y && y.m(f, null), A(e, d), R(p, e, null), A(e, m), v && v.m(e, null), g = !0, h || (_ = [
        W(
          e,
          "click",
          /*click_handler_1*/
          i[5]
        ),
        W(
          e,
          "dragstart",
          /*onDragStart*/
          i[2]
        )
      ], h = !0);
    },
    p(S, [D]) {
      var M;
      (!g || D & /*document*/
      1 && !ze(t.src, s = /*document*/
      S[0].img)) && b(t, "src", s), (!g || D & /*document*/
      1 && n !== (n = /*document*/
      S[0].name)) && b(t, "alt", n), (!g || D & /*document*/
      1) && o !== (o = /*document*/
      S[0].name + "") && be(a, o), /*originSource*/
      (M = S[1]) != null && M.abbreviation ? y ? y.p(S, D) : (y = X8(S), y.c(), y.m(f, null)) : y && (y.d(1), y = null);
      const I = {};
      D & /*document*/
      1 && (I.document = /*document*/
      S[0]), p.$set(I), /*collection*/
      S[3].locked || v.p(S, D);
    },
    i(S) {
      g || (w(p.$$.fragment, S), w(v), g = !0);
    },
    o(S) {
      O(p.$$.fragment, S), O(v), g = !1;
    },
    d(S) {
      S && C(e), y && y.d(), N(p), v && v.d(), h = !1, Me(_);
    }
  };
}
u(kge, "create_fragment$Q");
function wge(i, e, t) {
  let s, { document: n } = e;
  function l(d) {
    const p = {
      type: o.documentName,
      uuid: o.getUuid(n._id)
    };
    return d.dataTransfer.setData("text/plain", JSON.stringify(p));
  }
  u(l, "onDragStart");
  function r(d) {
    return typeof d.system.source != "string" ? null : a[d.system.source] || null;
  }
  u(r, "getOriginSource");
  const o = de("collection"), { products: a } = CONFIG.A5E;
  function c(d) {
    bt.call(this, i, d);
  }
  u(c, "click_handler");
  const f = /* @__PURE__ */ u(async () => {
    var p;
    (p = (o.get(n._id) ?? await o.getDocument(n._id)).sheet) == null || p.render(!0);
  }, "click_handler_1");
  return i.$$set = (d) => {
    "document" in d && t(0, n = d.document);
  }, i.$$.update = () => {
    i.$$.dirty & /*document*/
    1 && t(1, s = r(n));
  }, [
    n,
    s,
    l,
    o,
    c,
    f
  ];
}
u(wge, "instance$K");
const cT = class cT extends re {
  constructor(e) {
    super(), oe(this, e, wge, kge, le, { document: 0 });
  }
};
u(cT, "CompendiumOriginItem");
let uk = cT;
function J8(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-sun"), b(e, "data-tooltip", "Rare Spell Variant"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(J8, "create_if_block_7$4");
function Z8(i) {
  var a;
  let e, t = (
    /*spellSource*/
    ((a = i[1]) == null ? void 0 : a.abbreviation) + ""
  ), s, n, l, r, o;
  return {
    c() {
      var c;
      e = E("a"), s = Q(t), b(e, "class", "a5e-item__source-tag"), b(e, "href", n = /*spellSource*/
      (c = i[1]) == null ? void 0 : c.url), b(e, "target", "_blank"), b(e, "data-tooltip", l = On(
        /*spellSource*/
        i[1]
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source");
    },
    m(c, f) {
      T(c, e, f), A(e, s), r || (o = W(e, "click", Ve(
        /*click_handler*/
        i[5]
      )), r = !0);
    },
    p(c, f) {
      var d, p;
      f & /*spellSource*/
      2 && t !== (t = /*spellSource*/
      ((d = c[1]) == null ? void 0 : d.abbreviation) + "") && be(s, t), f & /*spellSource*/
      2 && n !== (n = /*spellSource*/
      (p = c[1]) == null ? void 0 : p.url) && b(e, "href", n), f & /*spellSource*/
      2 && l !== (l = On(
        /*spellSource*/
        c[1]
      )) && b(e, "data-tooltip", l);
    },
    d(c) {
      c && C(e), r = !1, o();
    }
  };
}
u(Z8, "create_if_block_6$4");
function Q8(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellComponentVocalizedAbbr")}`, b(e, "class", "component svelte-1295g6i"), b(e, "data-tooltip", "A5E.SpellComponentVocalized"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(Q8, "create_if_block_5$5");
function x8(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellComponentSeenAbbr")}`, b(e, "class", "component svelte-1295g6i"), b(e, "data-tooltip", "A5E.SpellComponentSeen"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(x8, "create_if_block_4$6");
function ej(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellComponentMaterialAbbr")}`, b(e, "class", "component svelte-1295g6i"), b(e, "data-tooltip", "A5E.SpellComponentMaterial"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(ej, "create_if_block_3$6");
function tj(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellConcentrationAbbr")}`, b(e, "class", "component svelte-1295g6i"), b(e, "data-tooltip", "A5E.SpellConcentration"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(tj, "create_if_block_2$9");
function sj(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellRitualAbbr")}`, b(e, "class", "component svelte-1295g6i"), b(e, "data-tooltip", "A5E.SpellRitual"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(sj, "create_if_block_1$f");
function $ge(i) {
  let e, t;
  return e = new Tr({ props: { document: (
    /*document*/
    i[0]
  ) } }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*document*/
      1 && (l.document = /*document*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u($ge, "create_if_block$l");
function Age(i) {
  var ke;
  let e, t, s, n, l, r, o = (
    /*document*/
    i[0].name + ""
  ), a, c, f, d, p, m, g, h, _, y, v, k, S, D, I, M, L, B, z = (
    /*document*/
    i[0].system.rare && J8()
  ), q = (
    /*spellSource*/
    ((ke = i[1]) == null ? void 0 : ke.abbreviation) && Z8(i)
  ), U = (
    /*document*/
    i[0].system.components.vocalized && Q8()
  ), H = (
    /*document*/
    i[0].system.components.seen && x8()
  ), V = (
    /*document*/
    i[0].system.components.material && ej()
  ), Y = (
    /*document*/
    i[0].system.concentration && tj()
  ), J = (
    /*document*/
    i[0].system.ritual && sj()
  );
  D = new Cr({ props: { document: (
    /*document*/
    i[0]
  ) } });
  let fe = !/*collection*/
  i[4].locked && $ge(i);
  return {
    c() {
      e = E("li"), t = E("img"), l = F(), r = E("span"), a = Q(o), c = F(), z && z.c(), f = F(), d = E("span"), q && q.c(), p = F(), m = Q(
        /*spellDetails*/
        i[2]
      ), g = F(), h = E("ul"), U && U.c(), _ = F(), H && H.c(), y = F(), V && V.c(), v = F(), Y && Y.c(), k = F(), J && J.c(), S = F(), j(D.$$.fragment), I = F(), fe && fe.c(), b(t, "class", "a5e-item__image a5e-item__image--compendium-document"), ze(t.src, s = /*document*/
      i[0].img) || b(t, "src", s), b(t, "alt", n = /*document*/
      i[0].name), b(r, "class", "a5e-item__name--compendium-document"), b(d, "class", "a5e-item__details"), b(h, "class", "component-wrapper svelte-1295g6i"), b(e, "class", "a5e-item a5e-item--compendium-spell-document"), b(e, "draggable", "true");
    },
    m(ee, ne) {
      T(ee, e, ne), A(e, t), A(e, l), A(e, r), A(r, a), A(r, c), z && z.m(r, null), A(e, f), A(e, d), q && q.m(d, null), A(d, p), A(d, m), A(e, g), A(e, h), U && U.m(h, null), A(h, _), H && H.m(h, null), A(h, y), V && V.m(h, null), A(h, v), Y && Y.m(h, null), A(h, k), J && J.m(h, null), A(e, S), R(D, e, null), A(e, I), fe && fe.m(e, null), M = !0, L || (B = [
        W(
          e,
          "click",
          /*click_handler_1*/
          i[6]
        ),
        W(
          e,
          "dragstart",
          /*onDragStart*/
          i[3]
        )
      ], L = !0);
    },
    p(ee, [ne]) {
      var Pe;
      (!M || ne & /*document*/
      1 && !ze(t.src, s = /*document*/
      ee[0].img)) && b(t, "src", s), (!M || ne & /*document*/
      1 && n !== (n = /*document*/
      ee[0].name)) && b(t, "alt", n), (!M || ne & /*document*/
      1) && o !== (o = /*document*/
      ee[0].name + "") && be(a, o), /*document*/
      ee[0].system.rare ? z || (z = J8(), z.c(), z.m(r, null)) : z && (z.d(1), z = null), /*spellSource*/
      (Pe = ee[1]) != null && Pe.abbreviation ? q ? q.p(ee, ne) : (q = Z8(ee), q.c(), q.m(d, p)) : q && (q.d(1), q = null), (!M || ne & /*spellDetails*/
      4) && be(
        m,
        /*spellDetails*/
        ee[2]
      ), /*document*/
      ee[0].system.components.vocalized ? U || (U = Q8(), U.c(), U.m(h, _)) : U && (U.d(1), U = null), /*document*/
      ee[0].system.components.seen ? H || (H = x8(), H.c(), H.m(h, y)) : H && (H.d(1), H = null), /*document*/
      ee[0].system.components.material ? V || (V = ej(), V.c(), V.m(h, v)) : V && (V.d(1), V = null), /*document*/
      ee[0].system.concentration ? Y || (Y = tj(), Y.c(), Y.m(h, k)) : Y && (Y.d(1), Y = null), /*document*/
      ee[0].system.ritual ? J || (J = sj(), J.c(), J.m(h, null)) : J && (J.d(1), J = null);
      const Ee = {};
      ne & /*document*/
      1 && (Ee.document = /*document*/
      ee[0]), D.$set(Ee), /*collection*/
      ee[4].locked || fe.p(ee, ne);
    },
    i(ee) {
      M || (w(D.$$.fragment, ee), w(fe), M = !0);
    },
    o(ee) {
      O(D.$$.fragment, ee), O(fe), M = !1;
    },
    d(ee) {
      ee && C(e), z && z.d(), q && q.d(), U && U.d(), H && H.d(), V && V.d(), Y && Y.d(), J && J.d(), N(D), fe && fe.d(), L = !1, Me(B);
    }
  };
}
u(Age, "create_fragment$P");
function Ege(i) {
  return typeof i.system.source != "string" ? null : CONFIG.A5E.products[i.system.source] || null;
}
u(Ege, "getSpellSource");
function Sge(i, e, t) {
  let s, n, { document: l } = e;
  function r(m) {
    const { level: g, schools: h } = m.system, _ = f[g] ?? "", y = c.primary[h.primary] ?? h.primary, v = h.secondary.map((S) => c.secondary[S] ?? S);
    v.sort((S, D) => S.localeCompare(D));
    const k = [y, ...v].join(", ");
    return k ? `${_} (${k})` : _;
  }
  u(r, "getSpellDetailsLabel");
  function o(m) {
    const g = {
      type: a.documentName,
      uuid: a.getUuid(l._id)
    };
    return m.dataTransfer.setData("text/plain", JSON.stringify(g));
  }
  u(o, "onDragStart");
  const a = de("collection"), { spellSchools: c, spellLevels: f } = CONFIG.A5E;
  function d(m) {
    bt.call(this, i, m);
  }
  u(d, "click_handler");
  const p = /* @__PURE__ */ u(async () => {
    var g;
    (g = (a.get(l._id) ?? await a.getDocument(l._id)).sheet) == null || g.render(!0);
  }, "click_handler_1");
  return i.$$set = (m) => {
    "document" in m && t(0, l = m.document);
  }, i.$$.update = () => {
    i.$$.dirty & /*document*/
    1 && t(2, s = r(l)), i.$$.dirty & /*document*/
    1 && t(1, n = Ege(l));
  }, [
    l,
    n,
    s,
    o,
    a,
    d,
    p
  ];
}
u(Sge, "instance$J");
const uT = class uT extends re {
  constructor(e) {
    super(), oe(this, e, Sge, Age, le, { document: 0 });
  }
};
u(uT, "CompendiumSpellItem");
let Jp = uT;
function nj(i, e, t) {
  const s = i.slice();
  return s[4] = e[t], s;
}
u(nj, "get_each_context$h");
function ij(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: (
        /*name*/
        i[1]
      ),
      $$slots: { default: [Cge] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-gap", "0");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*name*/
      2 && (r.heading = /*name*/
      n[1]), l & /*$$scope, $reducer, ItemComponent*/
      137 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(ij, "create_if_block$k");
function lj(i) {
  let e, t, s;
  var n = (
    /*ItemComponent*/
    i[0]
  );
  function l(r, o) {
    return { props: { document: (
      /*document*/
      r[4]
    ) } };
  }
  return u(l, "switch_props"), n && (e = et(n, l(i))), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(r, o) {
      e && R(e, r, o), T(r, t, o), s = !0;
    },
    p(r, o) {
      if (o & /*ItemComponent*/
      1 && n !== (n = /*ItemComponent*/
      r[0])) {
        if (e) {
          ae();
          const a = e;
          O(a.$$.fragment, 1, 0, () => {
            N(a, 1);
          }), ce();
        }
        n ? (e = et(n, l(r)), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (n) {
        const a = {};
        o & /*$reducer*/
        8 && (a.document = /*document*/
        r[4]), e.$set(a);
      }
    },
    i(r) {
      s || (e && w(e.$$.fragment, r), s = !0);
    },
    o(r) {
      e && O(e.$$.fragment, r), s = !1;
    },
    d(r) {
      r && C(t), e && N(e, r);
    }
  };
}
u(lj, "create_each_block$h");
function Cge(i) {
  let e, t, s = ue([.../*$reducer*/
  i[3]]), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = lj(nj(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "a5e-item-list a5e-item-list--compendium");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o & /*ItemComponent, $reducer*/
      9) {
        s = ue([.../*$reducer*/
        r[3]]);
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = nj(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = lj(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(Cge, "create_default_slot$k");
function Tge(i) {
  let e, t, s = (
    /*reducer*/
    i[2].length && ij(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, [l]) {
      /*reducer*/
      n[2].length ? s ? (s.p(n, l), l & /*reducer*/
      4 && w(s, 1)) : (s = ij(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(Tge, "create_fragment$O");
function Oge(i, e, t) {
  let s, n = se, l = /* @__PURE__ */ u(() => (n(), n = Xt(a, (c) => t(3, s = c)), a), "$$subscribe_reducer");
  i.$$.on_destroy.push(() => n());
  let { ItemComponent: r } = e, { name: o } = e, { reducer: a } = e;
  return l(), i.$$set = (c) => {
    "ItemComponent" in c && t(0, r = c.ItemComponent), "name" in c && t(1, o = c.name), "reducer" in c && l(t(2, a = c.reducer));
  }, [r, o, a, s];
}
u(Oge, "instance$I");
const fT = class fT extends re {
  constructor(e) {
    super(), oe(this, e, Oge, Tge, le, { ItemComponent: 0, name: 1, reducer: 2 });
  }
};
u(fT, "CompendiumSubItemList");
let fk = fT;
function rj(i, e, t) {
  const s = i.slice();
  return s[18] = e[t], s;
}
u(rj, "get_each_context_1$3");
function oj(i, e, t) {
  const s = i.slice();
  return s[14] = e[t].name, s[15] = e[t].derivedReducer, s;
}
u(oj, "get_each_context$g");
function Dge(i) {
  let e, t, s = ue(
    /*documents*/
    i[0]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = aj(rj(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o & /*compendiumItemComponents, compendiumType, documents*/
      11) {
        s = ue(
          /*documents*/
          r[0]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = rj(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = aj(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(Dge, "create_else_block$6");
function Ige(i) {
  let e, t, s = ue(
    /*derived*/
    i[2]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = uj(oj(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o & /*derived, compendiumItemComponents, compendiumType*/
      14) {
        s = ue(
          /*derived*/
          r[2]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = oj(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = uj(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(Ige, "create_if_block$j");
function aj(i) {
  let e, t, s;
  var n = (
    /*compendiumItemComponents*/
    i[3][
      /*compendiumType*/
      i[1]
    ]
  );
  function l(r, o) {
    return {
      props: { document: (
        /*document*/
        r[18]
      ) }
    };
  }
  return u(l, "switch_props"), n && (e = et(n, l(i))), {
    c() {
      e && j(e.$$.fragment), t = $e();
    },
    m(r, o) {
      e && R(e, r, o), T(r, t, o), s = !0;
    },
    p(r, o) {
      if (o & /*compendiumType*/
      2 && n !== (n = /*compendiumItemComponents*/
      r[3][
        /*compendiumType*/
        r[1]
      ])) {
        if (e) {
          ae();
          const a = e;
          O(a.$$.fragment, 1, 0, () => {
            N(a, 1);
          }), ce();
        }
        n ? (e = et(n, l(r)), j(e.$$.fragment), w(e.$$.fragment, 1), R(e, t.parentNode, t)) : e = null;
      } else if (n) {
        const a = {};
        o & /*documents*/
        1 && (a.document = /*document*/
        r[18]), e.$set(a);
      }
    },
    i(r) {
      s || (e && w(e.$$.fragment, r), s = !0);
    },
    o(r) {
      e && O(e.$$.fragment, r), s = !1;
    },
    d(r) {
      r && C(t), e && N(e, r);
    }
  };
}
u(aj, "create_each_block_1$3");
function cj(i) {
  let e, t;
  return e = new fk({
    props: {
      name: (
        /*name*/
        i[14]
      ),
      ItemComponent: (
        /*compendiumItemComponents*/
        i[3][
          /*compendiumType*/
          i[1]
        ]
      ),
      reducer: (
        /*derivedReducer*/
        i[15]
      )
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*derived*/
      4 && (l.name = /*name*/
      s[14]), n & /*compendiumType*/
      2 && (l.ItemComponent = /*compendiumItemComponents*/
      s[3][
        /*compendiumType*/
        s[1]
      ]), n & /*derived*/
      4 && (l.reducer = /*derivedReducer*/
      s[15]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(cj, "create_if_block_1$e");
function uj(i) {
  let e, t, s = [.../*derivedReducer*/
  i[15]].length !== 0 && cj(i);
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      [.../*derivedReducer*/
      n[15]].length !== 0 ? s ? (s.p(n, l), l & /*derived*/
      4 && w(s, 1)) : (s = cj(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ae(), O(s, 1, 1, () => {
        s = null;
      }), ce());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(uj, "create_each_block$g");
function Pge(i) {
  let e, t, s, n, l, r, o;
  const a = [Ige, Dge], c = [];
  function f(d, p) {
    return (
      /*derived*/
      d[2].length ? 0 : 1
    );
  }
  return u(f, "select_block_type"), t = f(i), s = c[t] = a[t](i), {
    c() {
      e = E("ul"), s.c(), b(e, "class", "a5e-item-list a5e-item-list--compendium");
    },
    m(d, p) {
      T(d, e, p), c[t].m(e, null), l = !0, r || (o = [
        W(
          e,
          "scroll",
          /*scroll_handler*/
          i[8]
        ),
        W(
          e,
          "drop",
          /*onDocumentDrop*/
          i[5]
        )
      ], r = !0);
    },
    p(d, [p]) {
      let m = t;
      t = f(d), t === m ? c[t].p(d, p) : (ae(), O(c[m], 1, 1, () => {
        c[m] = null;
      }), ce(), s = c[t], s ? s.p(d, p) : (s = c[t] = a[t](d), s.c()), w(s, 1), s.m(e, null));
    },
    i(d) {
      l || (w(s), d && ks(() => {
        l && (n || (n = yr(e, oc, {}, !0)), n.run(1));
      }), l = !0);
    },
    o(d) {
      O(s), d && (n || (n = yr(e, oc, {}, !1)), n.run(0)), l = !1;
    },
    d(d) {
      d && C(e), c[t].d(), d && n && n.end(), r = !1, Me(o);
    }
  };
}
u(Pge, "create_fragment$N");
function Mge(i, e, t) {
  let s, { documents: n = [] } = e, { compendiumType: l } = e, { enableGrouping: r = !1 } = e;
  const o = de("collection"), a = {
    "5eSpell": Jp,
    classFeature: ok,
    magicItem: Xp,
    maneuver: ak,
    monster: ck,
    object: Xp,
    spell: Jp,
    archetype: uk
  }, c = {
    "5eSpell": "level",
    magicItem: "rarity",
    maneuver: "degree",
    monster: "details.cr",
    object: "rarity",
    spell: "level"
  }, f = {
    "5eSpell": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    magicItem: [
      "mundane",
      "common",
      "uncommon",
      "rare",
      "very rare",
      "legendary",
      "artifact"
    ],
    maneuver: [0, 1, 2, 3, 4, 5],
    monster: [0, 0.125, 0.25, 0.5, ...Array.from(Array(30).keys(), (y) => y + 1)],
    object: [
      "mundane",
      "common",
      "uncommon",
      "rare",
      "very rare",
      "legendary",
      "artifact"
    ],
    spell: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  }, d = de("reducer");
  pe(i, d, (y) => t(9, s = y));
  let p = [];
  function m(y) {
    if (!y) {
      d.derived.clear(), t(2, p = []);
      return;
    }
    const v = f[l], k = `system.${c[l]}`;
    for (const S of v) {
      const D = s.derived.create(`${S}`);
      D.filters.add((M) => foundry.utils.getProperty(M, k) == S), D.index.update(!0);
      const I = xhe(l, S);
      p.push({ name: I, derivedReducer: D });
    }
    t(2, p);
  }
  u(m, "setupGrouping");
  async function g(y) {
    const v = y.dataTransfer.getData("text/plain");
    if (v)
      try {
        const k = JSON.parse(v), S = await fromUuid(k.uuid);
        return o.importDocument(S);
      } catch {
        return;
      }
  }
  u(g, "onDocumentDrop");
  const h = ft(), _ = /* @__PURE__ */ u(({ target: y }) => h("listScrolled", y.scrollTop / (y.scrollHeight - y.clientHeight) * 100), "scroll_handler");
  return i.$$set = (y) => {
    "documents" in y && t(0, n = y.documents), "compendiumType" in y && t(1, l = y.compendiumType), "enableGrouping" in y && t(7, r = y.enableGrouping);
  }, i.$$.update = () => {
    i.$$.dirty & /*enableGrouping*/
    128 && m(r);
  }, [
    n,
    l,
    p,
    a,
    d,
    g,
    h,
    r,
    _
  ];
}
u(Mge, "instance$H");
const dT = class dT extends re {
  constructor(e) {
    super(), oe(this, e, Mge, Pge, le, {
      documents: 0,
      compendiumType: 1,
      enableGrouping: 7
    });
  }
};
u(dT, "CompendiumItemList");
let Zp = dT;
function Fge(i) {
  let e, t, s;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), b(e, "placeholder", "New Rolltable");
    },
    m(n, l) {
      T(n, e, l), He(
        e,
        /*rollTableName*/
        i[0]
      ), t || (s = W(
        e,
        "input",
        /*input_input_handler*/
        i[2]
      ), t = !0);
    },
    p(n, l) {
      l & /*rollTableName*/
      1 && e.value !== /*rollTableName*/
      n[0] && He(
        e,
        /*rollTableName*/
        n[0]
      );
    },
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(Fge, "create_default_slot$j");
function Rge(i) {
  let e, t, s, n, l, r, o, a;
  return t = new ie({
    props: {
      heading: "Rolltable Name",
      $$slots: { default: [Fge] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("section"), j(t.$$.fragment), s = F(), n = E("div"), l = E("button"), l.innerHTML = `<i class="fa-solid fa-table-list"></i>
            Create Rolltable`, b(l, "class", "submit-button svelte-1umr3fn"), b(n, "class", "u-flex u-justify-center"), b(e, "class", "svelte-1umr3fn");
    },
    m(c, f) {
      T(c, e, f), R(t, e, null), A(e, s), A(e, n), A(n, l), r = !0, o || (a = W(l, "click", st(
        /*onSubmit*/
        i[1]
      )), o = !0);
    },
    p(c, [f]) {
      const d = {};
      f & /*$$scope, rollTableName*/
      17 && (d.$$scope = { dirty: f, ctx: c }), t.$set(d);
    },
    i(c) {
      r || (w(t.$$.fragment, c), r = !0);
    },
    o(c) {
      O(t.$$.fragment, c), r = !1;
    },
    d(c) {
      c && C(e), N(t), o = !1, a();
    }
  };
}
u(Rge, "create_fragment$M");
function Nge(i, e, t) {
  let { application: s } = de("#external");
  function n() {
    s.submit({
      rollTableName: l || "New RollTable"
    });
  }
  u(n, "onSubmit");
  let l = "";
  function r() {
    l = this.value, t(0, l);
  }
  return u(r, "input_input_handler"), [l, n, r];
}
u(Nge, "instance$G");
const pT = class pT extends re {
  constructor(e) {
    super(), oe(this, e, Nge, Rge, le, {});
  }
};
u(pT, "ExportToRollTableDialog");
let dk = pT;
const fj = {
  spellLists: {
    key: "system.classes",
    type: "array"
  },
  spellLevels: {
    key: "system.level",
    type: "value"
  },
  primarySpellSchools: {
    key: "system.schools.primary",
    type: "value"
  },
  secondarySpellSchools: {
    key: "system.schools.secondary",
    type: "array"
  },
  components: {
    subFilters: {
      material: {
        key: "system.components.material",
        type: "boolean"
      },
      seen: {
        key: "system.components.seen",
        type: "boolean"
      },
      vocalized: {
        key: "system.components.vocalized",
        type: "boolean"
      }
    }
  },
  miscellaneous: {
    subFilters: {
      concentration: {
        key: "system.concentration",
        type: "boolean"
      },
      ritual: {
        key: "system.ritual",
        type: "boolean"
      },
      rare: {
        key: "system.rare",
        type: "boolean"
      }
    }
  },
  source: {
    key: "system.source",
    type: "value"
  }
}, jge = {
  exertion: {
    key: "system.exertionCost",
    type: "range"
  },
  maneuverDegrees: {
    key: "system.degree",
    type: "value"
  },
  maneuverTraditions: {
    key: "system.tradition",
    type: "value"
  },
  miscellaneous: {
    subFilters: {
      concentration: {
        key: "system.concentration",
        type: "boolean"
      },
      stance: {
        key: "system.isStance",
        type: "boolean"
      }
    }
  },
  source: {
    key: "system.source",
    type: "value"
  }
}, Lge = {
  cr: {
    key: "system.details.cr",
    type: "range"
  },
  creatureSize: {
    key: "system.traits.size",
    type: "value"
  },
  creatureTypes: {
    key: "system.details.creatureTypes",
    type: "array"
  },
  miscellaneous: {
    subFilters: {
      elite: {
        key: "system.details.elite",
        type: "boolean"
      },
      swarm: {
        key: "system.details.isSwarm",
        type: "boolean"
      }
    }
  },
  terrain: {
    key: "system.details.terrain",
    type: "array"
  },
  source: {
    key: "system.source",
    type: "value"
  }
}, dj = {
  objectType: {
    key: "system.objectType",
    type: "value"
  },
  rarity: {
    key: "system.rarity",
    type: "value"
  },
  miscellaneous: {
    subFilters: {
      bulky: {
        key: "system.bulky",
        type: "boolean"
      },
      requiresAttunement: {
        key: "system.requiresAttunement",
        type: "boolean"
      }
    }
  },
  source: {
    key: "system.source",
    type: "value"
  }
}, Bge = {
  classes: {
    key: "system.classes",
    type: "value"
  },
  source: "system.source",
  type: "value"
}, qge = {
  class: {
    key: "system.class",
    type: "value"
  },
  source: {
    key: "system.source",
    type: "value"
  }
}, Gge = {
  "5eSpell": fj,
  classFeature: Bge,
  object: dj,
  magicItem: dj,
  maneuver: jge,
  monster: Lge,
  spell: fj,
  archetype: qge
};
function pj(i, e, t) {
  return t ? (s) => {
    var n;
    return (n = foundry.utils.getProperty(s, i)) == null ? void 0 : n.includes(e);
  } : (s) => {
    var n;
    return !((n = foundry.utils.getProperty(s, i)) != null && n.includes(e));
  };
}
u(pj, "arrayFilter");
function _d(i, e) {
  return e ? (t) => foundry.utils.getProperty(t, i) : (t) => !foundry.utils.getProperty(t, i);
}
u(_d, "booleanFilter");
function zge(i, { min: e, max: t }) {
  return (s) => {
    const n = foundry.utils.getProperty(s, i);
    return n >= e && n <= t;
  };
}
u(zge, "rangeFilter");
function mj(i, e, t) {
  return t ? (s) => foundry.utils.getProperty(s, i) == e : (s) => foundry.utils.getProperty(s, i) != e;
}
u(mj, "valueFilter");
function Hge(i, e, t) {
  const s = [...i.filters].filter((r) => r.id !== "searchFilter");
  i.filters.remove(...s);
  const n = Gge[t], l = { and: 0, or: 0 };
  for (const [r, o] of Object.entries(e)) {
    const a = [], c = [], { key: f, type: d, subFilters: p } = (n == null ? void 0 : n[r]) ?? {};
    if (!((!f || !d) && !p)) {
      if (d === "range") {
        const { min: m, max: g } = o, h = zge(f, { min: m, max: g });
        a.push({ filter: h }), l.and += 1;
      } else {
        const { inclusive: m, inclusiveMode: g, exclusive: h, exclusiveMode: _ } = o;
        m.forEach((y) => {
          var k;
          let v;
          if (d === "array") v = pj(f, y, !0);
          else if (((k = p == null ? void 0 : p[y]) == null ? void 0 : k.type) === "boolean")
            v = _d(p[y].key, !0);
          else if (d === "boolean") v = _d(f, !0);
          else if (d === "value") v = mj(f, y, !0);
          else return;
          g ? a.push({ filter: v }) : c.push(v);
        }), h.forEach((y) => {
          var k;
          let v;
          if (d === "array") v = pj(f, y, !1);
          else if (((k = p == null ? void 0 : p[y]) == null ? void 0 : k.type) === "boolean")
            v = _d(p[y].key, !1);
          else if (d === "boolean") v = _d(f, !1);
          else if (d === "value") v = mj(f, y, !1);
          else return;
          _ ? a.push({ filter: v }) : c.push(v);
        });
      }
      a.length && (i.filters.add(...a), l.and += a.length), c.length && (i.filters.add({
        filter: /* @__PURE__ */ u((m) => c.some((g) => g(m)), "filter")
      }), l.or += 1);
    }
  }
  return l;
}
u(Hge, "constructReducerFilters");
function hj(i) {
  let e, t = (
    /*showGroupingToggle*/
    i[11]()
  ), s, n = (
    /*showRollTableToggle*/
    i[12]()
  ), l, r = Uge(i), o = t && Vge(i), a = n && Wge(i);
  return {
    c() {
      r && r.c(), e = F(), o && o.c(), s = F(), a && a.c(), l = $e();
    },
    m(c, f) {
      r && r.m(c, f), T(c, e, f), o && o.m(c, f), T(c, s, f), a && a.m(c, f), T(c, l, f);
    },
    p(c, f) {
      r.p(c, f), t && o.p(c, f), n && a.p(c, f);
    },
    d(c) {
      c && (C(e), C(s), C(l)), r && r.d(c), o && o.d(c), a && a.d(c);
    }
  };
}
u(hj, "create_if_block_2$8");
function Uge(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("button"), t = E("i"), b(t, "class", "a5efc-filter-button__icon fa-solid fa-book"), b(e, "class", "a5efc-filter-button"), b(e, "data-tooltip", s = /*includeDescriptions*/
      i[4] ? "Exclude item descriptions in search" : "Include item descriptions in search"), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "a5efc-filter-button--active",
        /*includeDescriptions*/
        i[4]
      );
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = W(
        e,
        "click",
        /*click_handler*/
        i[20]
      ), n = !0);
    },
    p(r, o) {
      o & /*includeDescriptions*/
      16 && s !== (s = /*includeDescriptions*/
      r[4] ? "Exclude item descriptions in search" : "Include item descriptions in search") && b(e, "data-tooltip", s), o & /*includeDescriptions*/
      16 && Z(
        e,
        "a5efc-filter-button--active",
        /*includeDescriptions*/
        r[4]
      );
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Uge, "create_if_block_7$3");
function Vge(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("button"), t = E("i"), b(t, "class", "a5efc-filter-button__icon fa-solid fa-bars-staggered"), b(e, "class", "a5efc-filter-button"), b(e, "data-tooltip", s = /*enableGrouping*/
      i[7] ? "Disable grouping of documents" : "Enable grouping of documents"), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "a5efc-filter-button--active",
        /*enableGrouping*/
        i[7]
      );
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = W(
        e,
        "click",
        /*click_handler_1*/
        i[21]
      ), n = !0);
    },
    p(r, o) {
      o & /*enableGrouping*/
      128 && s !== (s = /*enableGrouping*/
      r[7] ? "Disable grouping of documents" : "Enable grouping of documents") && b(e, "data-tooltip", s), o & /*enableGrouping*/
      128 && Z(
        e,
        "a5efc-filter-button--active",
        /*enableGrouping*/
        r[7]
      );
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Vge, "create_if_block_6$3");
function Wge(i) {
  let e;
  function t(l, r) {
    if (!/*customImporter*/
    l[2]) return Yge;
    if (
      /*compendiumType*/
      l[1] === "spell" || /*compendiumType*/
      l[1] === "maneuver"
    ) return Kge;
  }
  u(t, "select_block_type");
  let s = t(i), n = s && s(i);
  return {
    c() {
      n && n.c(), e = $e();
    },
    m(l, r) {
      n && n.m(l, r), T(l, e, r);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n && n.d(1), n = s && s(l), n && (n.c(), n.m(e.parentNode, e)));
    },
    d(l) {
      l && C(e), n && n.d(l);
    }
  };
}
u(Wge, "create_if_block_3$5");
function Kge(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("button"), t = E("i"), b(t, "class", "a5efc-filter-button__icon fa-solid fa-download"), b(e, "class", "a5efc-filter-button"), b(e, "data-tooltip", s = "Export " + [.../*$reducer*/
      i[10]].length + " Documents to Actor"), b(e, "data-tooltip-direction", "UP");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = W(
        e,
        "click",
        /*click_handler_3*/
        i[23]
      ), n = !0);
    },
    p(r, o) {
      o & /*$reducer*/
      1024 && s !== (s = "Export " + [.../*$reducer*/
      r[10]].length + " Documents to Actor") && b(e, "data-tooltip", s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Kge, "create_if_block_5$4");
function Yge(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("button"), t = E("i"), b(t, "class", "a5efc-filter-button__icon fa-solid fa-table-list"), b(e, "class", "a5efc-filter-button"), b(e, "data-tooltip", s = "Export " + [.../*$reducer*/
      i[10]].length + " Documents to Rolltable"), b(e, "data-tooltip-direction", "UP");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = W(
        e,
        "click",
        /*click_handler_2*/
        i[22]
      ), n = !0);
    },
    p(r, o) {
      o & /*$reducer*/
      1024 && s !== (s = "Export " + [.../*$reducer*/
      r[10]].length + " Documents to Rolltable") && b(e, "data-tooltip", s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Yge, "create_if_block_4$5");
function Xge(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("button"), t = E("i"), b(t, "class", "a5efc-filter-button__icon fa-solid fa-filter"), b(e, "class", "a5efc-filter-button"), b(e, "data-tooltip", s = /*tab*/
      i[5] === "items" ? "Open Filter Page" : "Close Filter Page"), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "a5efc-filter-button--active",
        /*tab*/
        i[5] === "filters" || /*filterCount*/
        i[8].and || /*filterCount*/
        i[8].or
      );
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = W(
        e,
        "click",
        /*click_handler_4*/
        i[24]
      ), n = !0);
    },
    p(r, o) {
      o & /*tab*/
      32 && s !== (s = /*tab*/
      r[5] === "items" ? "Open Filter Page" : "Close Filter Page") && b(e, "data-tooltip", s), o & /*tab, filterCount*/
      288 && Z(
        e,
        "a5efc-filter-button--active",
        /*tab*/
        r[5] === "filters" || /*filterCount*/
        r[8].and || /*filterCount*/
        r[8].or
      );
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Xge, "create_if_block_1$d");
function gj(i) {
  let e, t, s = [.../*$reducer*/
  i[10]].length + "", n, l, r = [.../*document*/
  i[3].index].length + "", o, a;
  return {
    c() {
      e = E("footer"), t = Q("Showing "), n = Q(s), l = Q(" of "), o = Q(r), a = Q(" items"), b(e, "class", "a5efc-footer");
    },
    m(c, f) {
      T(c, e, f), A(e, t), A(e, n), A(e, l), A(e, o), A(e, a);
    },
    p(c, f) {
      f & /*$reducer*/
      1024 && s !== (s = [.../*$reducer*/
      c[10]].length + "") && be(n, s), f & /*document*/
      8 && r !== (r = [.../*document*/
      c[3].index].length + "") && be(o, r);
    },
    d(c) {
      c && C(e);
    }
  };
}
u(gj, "create_if_block$i");
function Jge(i) {
  let e, t, s, n, l, r, o, a, c, f;
  s = new Cp({ props: { input: (
    /*searchInput*/
    i[9]
  ) } });
  let d = (
    /*tab*/
    i[5] === "items" && hj(i)
  ), p = Xge(i);
  var m = (
    /*tab*/
    i[5] === "items" ? Zp : Yp
  );
  function g(_, y) {
    return {
      props: {
        documents: [.../*$reducer*/
        _[10]].slice(
          0,
          /*visibleDocumentCount*/
          _[6]
        ),
        compendiumType: (
          /*compendiumType*/
          _[1]
        ),
        enableGrouping: (
          /*enableGrouping*/
          _[7]
        )
      }
    };
  }
  u(g, "switch_props"), m && (a = et(m, g(i)), a.$on(
    "listScrolled",
    /*listScrolled_handler*/
    i[25]
  ));
  let h = (
    /*tab*/
    i[5] === "items" && gj(i)
  );
  return {
    c() {
      e = E("main"), t = E("div"), n = E("div"), j(s.$$.fragment), l = F(), d && d.c(), r = F(), p && p.c(), o = F(), a && j(a.$$.fragment), c = F(), h && h.c(), G(n, "display", "contents"), G(n, "--tjs-input-placeholder-color", "#555"), G(n, "--tjs-input-text-margin", "0"), G(n, "--tjs-input-text-width", "100%"), b(t, "class", "a5efc-search-field"), b(e, "class", "a5efc-main-wrapper");
    },
    m(_, y) {
      T(_, e, y), A(e, t), A(t, n), R(s, n, null), A(t, l), d && d.m(t, null), A(t, r), p && p.m(t, null), A(e, o), a && R(a, e, null), A(e, c), h && h.m(e, null), f = !0;
    },
    p(_, y) {
      const v = {};
      if (y & /*searchInput*/
      512 && (v.input = /*searchInput*/
      _[9]), s.$set(v), /*tab*/
      _[5] === "items" ? d ? d.p(_, y) : (d = hj(_), d.c(), d.m(t, r)) : d && (d.d(1), d = null), p.p(_, y), y & /*tab*/
      32 && m !== (m = /*tab*/
      _[5] === "items" ? Zp : Yp)) {
        if (a) {
          ae();
          const k = a;
          O(k.$$.fragment, 1, 0, () => {
            N(k, 1);
          }), ce();
        }
        m ? (a = et(m, g(_)), a.$on(
          "listScrolled",
          /*listScrolled_handler*/
          _[25]
        ), j(a.$$.fragment), w(a.$$.fragment, 1), R(a, e, c)) : a = null;
      } else if (m) {
        const k = {};
        y & /*$reducer, visibleDocumentCount*/
        1088 && (k.documents = [.../*$reducer*/
        _[10]].slice(
          0,
          /*visibleDocumentCount*/
          _[6]
        )), y & /*compendiumType*/
        2 && (k.compendiumType = /*compendiumType*/
        _[1]), y & /*enableGrouping*/
        128 && (k.enableGrouping = /*enableGrouping*/
        _[7]), a.$set(k);
      }
      /*tab*/
      _[5] === "items" ? h ? h.p(_, y) : (h = gj(_), h.c(), h.m(e, null)) : h && (h.d(1), h = null);
    },
    i(_) {
      f || (w(s.$$.fragment, _), a && w(a.$$.fragment, _), f = !0);
    },
    o(_) {
      O(s.$$.fragment, _), a && O(a.$$.fragment, _), f = !1;
    },
    d(_) {
      _ && C(e), N(s), d && d.d(), p && p.d(), a && N(a), h && h.d();
    }
  };
}
u(Jge, "create_default_slot$i");
function Zge(i) {
  let e, t, s;
  function n(r) {
    i[26](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Jge] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, document, $reducer, tab, visibleDocumentCount, compendiumType, enableGrouping, filterCount, customImporter, includeDescriptions, searchInput*/
        536872958 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(Zge, "create_fragment$L");
function Qge(i) {
  i.sort((t, s) => t.name.localeCompare(s.name));
  const e = /* @__PURE__ */ new Map();
  return i.forEach((t) => e.set(t._id, t)), e;
}
u(Qge, "getDocuments");
function xge(i, e, t) {
  let s, n, l, r, { compendiumType: o, customImporter: a, document: c, filterStore: f, sheet: d } = de("#external").application, { compendiumType: p = o, customImporter: m = a, document: g = c, filterStore: h = f, sheet: _ = d } = e, { elementRoot: y } = e;
  function v() {
    return !["classFeature", "archetype"].includes(p);
  }
  u(v, "showGroupingToggle");
  function k() {
    return !["classFeature", "archetype"].includes(p);
  }
  u(k, "showRollTableToggle");
  async function S() {
    const Ee = g, Pe = (await Promise.all([...r].map(async (ye) => Ee.getDocument(ye._id)))).map((ye) => ye.toObject());
    m(Pe);
  }
  u(S, "exportToActor");
  async function D() {
    let Ee = new ac("Export to RollTable", dk);
    Ee.render(!0);
    const { rollTableName: Pe } = await Ee.promise ?? {};
    if (!Pe) return;
    const ye = {
      name: `${Pe}`,
      formula: `1d${[...r].length}`,
      replacement: !0,
      results: [...r].map((me, Ce) => ({
        documentCollection: g.metadata.id,
        documentId: me._id,
        img: me.img,
        text: me.name,
        range: [Ce + 1, Ce + 1],
        type: 2,
        weight: 1
      }))
    };
    RollTable.create(ye);
  }
  u(D, "exportToRollTable");
  function I(Ee) {
    Ee > 80 && t(6, z += 50);
  }
  u(I, "handleScroll");
  let M = "items", L = !1, B = new Sn();
  pe(i, B, (Ee) => t(10, r = Ee));
  let z = 100;
  B.setData(Qge([...g.index]), !0), lt("collection", g), lt("customImporter", m), lt("filterStore", h), lt("reducer", B), lt("sheet", _);
  const q = B.subscribe(() => t(6, z = 100));
  let U = {};
  const H = h.subscribe((Ee) => {
    t(19, U = Ee);
  });
  Qt(() => {
    oB(B), q(), H();
  });
  const V = /* @__PURE__ */ u(() => t(4, L = !L), "click_handler"), Y = /* @__PURE__ */ u(() => t(7, l = !l), "click_handler_1"), J = /* @__PURE__ */ u(() => D(), "click_handler_2"), fe = /* @__PURE__ */ u(() => S(), "click_handler_3"), ke = /* @__PURE__ */ u(() => {
    t(5, M = M === "items" ? "filters" : "items");
  }, "click_handler_4"), ee = /* @__PURE__ */ u(({ detail: Ee }) => I(Ee), "listScrolled_handler");
  function ne(Ee) {
    y = Ee, t(0, y);
  }
  return u(ne, "applicationshell_elementRoot_binding"), i.$$set = (Ee) => {
    "compendiumType" in Ee && t(1, p = Ee.compendiumType), "customImporter" in Ee && t(2, m = Ee.customImporter), "document" in Ee && t(3, g = Ee.document), "filterStore" in Ee && t(17, h = Ee.filterStore), "sheet" in Ee && t(18, _ = Ee.sheet), "elementRoot" in Ee && t(0, y = Ee.elementRoot);
  }, i.$$.update = () => {
    i.$$.dirty & /*includeDescriptions*/
    16 && t(9, s = rB(B)), i.$$.dirty & /*filterSelections, compendiumType*/
    524290 && t(8, n = Hge(B, U, p));
  }, t(7, l = !1), [
    y,
    p,
    m,
    g,
    L,
    M,
    z,
    l,
    n,
    s,
    r,
    v,
    k,
    S,
    D,
    I,
    B,
    h,
    _,
    U,
    V,
    Y,
    J,
    fe,
    ke,
    ee,
    ne
  ];
}
u(xge, "instance$F");
const mT = class mT extends re {
  constructor(e) {
    super(), oe(this, e, xge, Zge, le, {
      compendiumType: 1,
      customImporter: 2,
      document: 3,
      filterStore: 17,
      sheet: 18,
      elementRoot: 0
    });
  }
  get compendiumType() {
    return this.$$.ctx[1];
  }
  set compendiumType(e) {
    this.$$set({ compendiumType: e }), Xe();
  }
  get customImporter() {
    return this.$$.ctx[2];
  }
  set customImporter(e) {
    this.$$set({ customImporter: e }), Xe();
  }
  get document() {
    return this.$$.ctx[3];
  }
  set document(e) {
    this.$$set({ document: e }), Xe();
  }
  get filterStore() {
    return this.$$.ctx[17];
  }
  set filterStore(e) {
    this.$$set({ filterStore: e }), Xe();
  }
  get sheet() {
    return this.$$.ctx[18];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Xe();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
};
u(mT, "CompendiumSheet");
let Ul = mT;
const e1e = Mt({
  spellLevels: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  miscellaneous: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  primarySpellSchools: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  source: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  }
}), hT = class hT extends Gs {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(
      foundry.utils.mergeObject(t, {
        id: "collection.metadata.package",
        title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
        width: 560,
        height: "auto",
        resizable: !0,
        svelte: {
          class: Ul,
          props: {
            compendiumType: "5eSpell",
            customImporter: t.importer ?? null,
            document: null,
            filterStore: e1e
          }
        }
      })
    ), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
u(hT, "DND5ESpellCompendiumSheet");
let Qp = hT;
const t1e = Mt({
  objectType: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  rarity: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  miscellaneous: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  source: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  }
}), gT = class gT extends Gs {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(
      foundry.utils.mergeObject(t, {
        id: "collection.metadata.package",
        title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
        width: 560,
        height: "auto",
        resizable: !0,
        svelte: {
          class: Ul,
          props: {
            compendiumType: "magicItem",
            customImporter: t.importer ?? null,
            document: null,
            filterStore: t1e
          }
        }
      })
    ), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
u(gT, "ItemCompendiumSheet");
let Tu = gT;
const s1e = Mt({
  exertion: {
    min: 0,
    max: 6
  },
  maneuverDegrees: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  maneuverTraditions: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  miscellaneous: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  source: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  }
}), bT = class bT extends Gs {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(
      foundry.utils.mergeObject(t, {
        id: "collection.metadata.package",
        title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
        width: 560,
        height: "auto",
        resizable: !0,
        svelte: {
          class: Ul,
          props: {
            compendiumType: "maneuver",
            customImporter: t.importer ?? null,
            document: null,
            filterStore: s1e
          }
        }
      })
    ), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
u(bT, "ManeuverCompendiumSheet");
let Ou = bT;
const n1e = Mt({
  cr: {
    min: 0,
    max: 30
  },
  creatureSize: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  creatureTypes: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  miscellaneous: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  terrain: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  source: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  }
}), _T = class _T extends Gs {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(
      foundry.utils.mergeObject(t, {
        id: "collection.metadata.package",
        title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
        width: 560,
        height: "auto",
        resizable: !0,
        svelte: {
          class: Ul,
          props: {
            compendiumType: "monster",
            customImporter: t.importer ?? null,
            document: null,
            filterStore: n1e
          }
        }
      })
    ), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
u(_T, "MonsterCompendiumSheet");
let Du = _T;
const i1e = Mt({
  spellLists: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 1
  },
  spellLevels: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  components: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 1
  },
  miscellaneous: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  primarySpellSchools: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  secondarySpellSchools: {
    inclusive: [],
    inclusiveMode: 1,
    exclusive: [],
    exclusiveMode: 1
  },
  source: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  }
}), yT = class yT extends Gs {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(
      foundry.utils.mergeObject(t, {
        id: "collection.metadata.package",
        title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
        width: 560,
        height: "auto",
        resizable: !0,
        svelte: {
          class: Ul,
          props: {
            compendiumType: "spell",
            customImporter: t.importer ?? null,
            document: null,
            filterStore: i1e
          }
        }
      })
    ), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
u(yT, "SpellCompendiumSheet");
let Iu = yT;
const vT = class vT extends foundry.data.fields.SchemaField {
  // @ts-ignore
  _cast(e) {
    return e;
  }
  // @ts-ignore
  _cleanType(e, t) {
    return typeof e != "object" ? e : super._cleanType(e, t);
  }
};
u(vT, "UnchasteSchemaField");
let pk = vT;
function l1e() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(U9("bonus")),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
u(l1e, "getAbilitiesBonusData");
function r1e() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(V9("bonus")),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
u(r1e, "getAttackBonusData");
function o1e() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(W9("bonus")),
    damageType: new i.StringField({ required: !0, initial: "" }),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
u(o1e, "getDamageBonusData");
function a1e() {
  const { fields: i } = foundry.data;
  return {
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
u(a1e, "getExertionBonusData");
function c1e() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(K9("bonus")),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    healingType: new i.StringField({ required: !0, initial: "healing" }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
u(c1e, "getHealingBonusData");
function u1e() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(Y9()),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
u(u1e, "getHitPointBonusData");
function f1e() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(X9("bonus")),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
u(f1e, "getInitiativeBonusData");
function d1e() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(J9("bonus")),
    unit: new i.StringField({ required: !0, initial: "feet" }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
u(d1e, "getMovementBonusData");
function p1e() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(Z9("bonus")),
    unit: new i.StringField({ required: !0, initial: "feet" }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
u(p1e, "getSensesBonusData");
function m1e() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(Q9("bonus")),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
u(m1e, "getSkillBonusData");
const { fields: Oe } = foundry.data, sq = /* @__PURE__ */ u(() => ({
  abilities: new Oe.SchemaField(
    Object.keys(CONFIG.A5E.abilities ?? {}).reduce((i, e) => (i[e] = new Oe.SchemaField({
      value: new Oe.NumberField({ required: !0, initial: 10, integer: !0 }),
      check: new Oe.SchemaField({
        expertiseDice: new Oe.NumberField({
          required: !0,
          initial: 0,
          integer: !0
        }),
        bonus: new Oe.StringField({ required: !0, initial: "" })
      }),
      save: new Oe.SchemaField({
        proficient: new Oe.BooleanField({ required: !0, initial: !1 }),
        expertiseDice: new Oe.NumberField({
          required: !0,
          initial: 0,
          integer: !0
        }),
        bonus: new Oe.StringField({ required: !0, initial: "" }),
        ...e === "con" ? { concentrationBonus: new Oe.StringField({ required: !0, initial: "" }) } : {}
      })
    }), i), {})
  )
}), "abilities"), nq = /* @__PURE__ */ u(() => ({
  ac: new Oe.SchemaField({
    baseFormula: new Oe.StringField({ required: !0, initial: "10 + @dex.mod" }),
    value: new Oe.NumberField({ required: !0, initial: 0, integer: !0 })
  }),
  death: new Oe.SchemaField({
    success: new Oe.NumberField({
      required: !0,
      nullable: !1,
      initial: 0,
      integer: !0
    }),
    failure: new Oe.NumberField({
      required: !0,
      nullable: !1,
      initial: 0,
      integer: !0
    })
  }),
  hp: new Oe.SchemaField({
    value: new Oe.NumberField({
      required: !0,
      initial: 10,
      nullable: !1,
      integer: !0
    }),
    baseMax: new Oe.NumberField({
      required: !0,
      nullable: !1,
      initial: 10,
      integer: !0
    }),
    temp: new Oe.NumberField({
      required: !0,
      nullable: !1,
      initial: 0,
      integer: !0
    }),
    bonus: new Oe.NumberField({
      required: !0,
      nullable: !1,
      initial: 0,
      integer: !0
    })
  }),
  initiative: new Oe.SchemaField({
    ability: new Oe.StringField({ required: !0, initial: "dex" }),
    // TODO: Migration Upgrade - Remove this at a later date when migration is guaranteed
    bonus: new Oe.StringField({ required: !0, initial: "" }),
    expertiseDice: new Oe.NumberField({ required: !0, initial: 0, integer: !0 })
  }),
  movement: new Oe.SchemaField({
    burrow: new Oe.SchemaField({
      distance: new Oe.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0,
        min: 0
      }),
      unit: new Oe.StringField({ required: !0, initial: "feet" })
    }),
    climb: new Oe.SchemaField({
      distance: new Oe.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0,
        min: 0
      }),
      unit: new Oe.StringField({ required: !0, initial: "feet" })
    }),
    fly: new Oe.SchemaField({
      distance: new Oe.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0,
        min: 0
      }),
      unit: new Oe.StringField({ required: !0, initial: "feet" })
    }),
    swim: new Oe.SchemaField({
      distance: new Oe.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0,
        min: 0
      }),
      unit: new Oe.StringField({ required: !0, initial: "feet" })
    }),
    walk: new Oe.SchemaField({
      distance: new Oe.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0,
        min: 0
      }),
      unit: new Oe.StringField({ required: !0, initial: "feet" })
    }),
    traits: new Oe.SchemaField({
      hover: new Oe.BooleanField({ required: !0, initial: !1 })
    })
  }),
  senses: new Oe.SchemaField({
    blindsight: new Oe.SchemaField({
      distance: new Oe.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0,
        min: 0
      }),
      unit: new Oe.StringField({ required: !0, initial: "feet" }),
      otherwiseBlind: new Oe.BooleanField({ required: !0, initial: !1 })
    }),
    darkvision: new Oe.SchemaField({
      distance: new Oe.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0,
        min: 0
      }),
      unit: new Oe.StringField({ required: !0, initial: "feet" })
    }),
    tremorsense: new Oe.SchemaField({
      distance: new Oe.NumberField({
        required: !0,
        initial: 0,
        nullable: !1,
        integer: !0,
        min: 0
      }),
      unit: new Oe.StringField({ required: !0, initial: "feet" })
    }),
    truesight: new Oe.SchemaField({
      distance: new Oe.NumberField({
        required: !0,
        initial: 0,
        nullable: !1,
        integer: !0,
        min: 0
      }),
      unit: new Oe.StringField({ required: !0, initial: "feet" })
    })
  }),
  inspiration: new Oe.BooleanField({ required: !0, initial: !1 }),
  corruption: new Oe.NumberField({
    required: !0,
    nullable: !1,
    initial: 0,
    integer: !0
  }),
  fatigue: new Oe.NumberField({
    required: !0,
    nullable: !1,
    initial: 0,
    integer: !0
  }),
  inebriated: new Oe.NumberField({
    required: !0,
    nullable: !1,
    initial: 0,
    integer: !0
  }),
  strife: new Oe.NumberField({
    required: !0,
    nullable: !1,
    initial: 0,
    integer: !0
  }),
  spellcasting: new Oe.StringField({ required: !0, initial: "int" })
}), "attributes"), h1e = /* @__PURE__ */ u(() => new Oe.SchemaField({
  current: new Oe.NumberField({
    required: !0,
    initial: 0,
    integer: !0,
    min: 0
  }),
  total: new Oe.NumberField({
    required: !0,
    initial: 0,
    integer: !0,
    min: 0
  })
}), "hitDice"), iq = /* @__PURE__ */ u(() => ({
  bonuses: new Oe.SchemaField({
    abilities: new Vs(
      new Oe.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
      // @ts-expect-error
      new pk(l1e())
    ),
    attacks: new Vs(
      new Oe.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
      new Oe.SchemaField(r1e())
    ),
    damage: new Vs(
      new Oe.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
      new Oe.SchemaField(o1e())
    ),
    exertion: new Vs(
      new Oe.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
      new Oe.SchemaField(a1e())
    ),
    healing: new Vs(
      new Oe.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
      new Oe.SchemaField(c1e())
    ),
    hitPoint: new Vs(
      new Oe.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
      new Oe.SchemaField(u1e())
    ),
    initiative: new Vs(
      new Oe.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
      new Oe.SchemaField(f1e())
    ),
    movement: new Vs(
      new Oe.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
      new Oe.SchemaField(d1e())
    ),
    senses: new Vs(
      new Oe.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
      new Oe.SchemaField(p1e())
    ),
    skills: new Vs(
      new Oe.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
      new Oe.SchemaField(m1e())
    ),
    maneuverDC: new Oe.StringField({ initial: "" }),
    spellDC: new Oe.StringField({ initial: "" }),
    // TODO: Migration Upgrade - Remove these at a later date when migration is guaranteed
    meleeSpellAttack: new Oe.StringField({ initial: "" }),
    meleeWeaponAttack: new Oe.StringField({ initial: "" }),
    rangedSpellAttack: new Oe.StringField({ initial: "" }),
    rangedWeaponAttack: new Oe.StringField({ initial: "" })
  })
}), "bonuses"), lq = /* @__PURE__ */ u(() => ({
  currency: new Oe.SchemaField({
    cp: new Oe.NumberField({ required: !0, initial: 0, integer: !0 }),
    sp: new Oe.NumberField({ required: !0, initial: 0, integer: !0 }),
    ep: new Oe.NumberField({ required: !0, initial: 0, integer: !0 }),
    gp: new Oe.NumberField({ required: !0, initial: 0, integer: !0 }),
    pp: new Oe.NumberField({ required: !0, initial: 0, integer: !0 }),
    cr: new Oe.NumberField({ required: !0, initial: 0, integer: !0 })
  })
}), "currency"), rq = /* @__PURE__ */ u(() => ({
  bio: new Oe.StringField({ required: !0, initial: "" }),
  creatureTypes: new Oe.ArrayField(new Oe.StringField({ required: !0, initial: "" }), {
    required: !0,
    initial: []
  })
}), "details"), oq = /* @__PURE__ */ u(() => ({
  grants: new Vs(
    new Oe.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
    new Oe.ObjectField()
  )
}), "grants"), aq = /* @__PURE__ */ u(() => ({
  proficiencies: new Oe.SchemaField({
    armor: new Oe.ArrayField(new Oe.StringField({ required: !0, initial: "" }), {
      required: !0,
      initial: []
    }),
    languages: new Oe.ArrayField(new Oe.StringField({ required: !0, initial: "" }), {
      required: !0,
      initial: []
    }),
    tools: new Oe.ArrayField(new Oe.StringField({ required: !0, initial: "" }), {
      required: !0,
      initial: []
    }),
    traditions: new Oe.ArrayField(
      new Oe.StringField({ required: !0, nullable: !1, initial: "" }),
      { required: !0, nullable: !1 }
    ),
    weapons: new Oe.ArrayField(new Oe.StringField({ required: !0, initial: "" }), {
      required: !0,
      initial: []
    })
  })
}), "proficiencies"), cq = /* @__PURE__ */ u(() => ({
  ...["primary", "secondary", "tertiary", "quaternary"].reduce((i, e) => (i[e] = new Oe.SchemaField({
    label: new Oe.StringField({ required: !0, initial: "" }),
    value: new Oe.NumberField({ required: !0, initial: 0, integer: !0 }),
    max: new Oe.StringField({ required: !0, initial: "" }),
    per: new Oe.StringField({ required: !0, initial: "" }),
    hideMax: new Oe.BooleanField({ required: !0, initial: !1 }),
    recharge: new Oe.SchemaField({
      formula: new Oe.StringField({ required: !0, initial: "1d6" }),
      threshold: new Oe.NumberField({ required: !0, initial: 6, integer: !0 })
    })
  }), i), {})
}), "resources"), uq = /* @__PURE__ */ u(() => ({
  skills: new Oe.SchemaField(
    Object.keys(CONFIG.A5E.skills ?? {}).reduce((i, e) => (i[e] = new Oe.SchemaField({
      ability: new Oe.StringField({
        required: !0,
        initial: CONFIG.A5E.skillDefaultAbilities[e] ?? "int"
      }),
      proficient: new Oe.NumberField({
        required: !0,
        initial: 0,
        integer: !0,
        min: 0,
        max: 2
      }),
      specialties: new Oe.ArrayField(
        new Oe.StringField({ required: !0, initial: "" }),
        { required: !0, initial: [] }
      ),
      expertiseDice: new Oe.NumberField({ required: !0, initial: 0, integer: !0 }),
      minRoll: new Oe.NumberField({
        required: !0,
        initial: 1,
        integer: !0,
        min: 1,
        max: 20
      }),
      bonuses: new Oe.SchemaField({
        check: new Oe.StringField({ required: !0, initial: "" }),
        passive: new Oe.NumberField({ required: !0, initial: 0, integer: !0 })
      })
    }), i), {})
  )
}), "skills"), fq = /* @__PURE__ */ u(() => ({
  spellBooks: new Vs(
    new Oe.DocumentIdField({ required: !0, initial: /* @__PURE__ */ u(() => foundry.utils.randomID(), "initial") }),
    new Oe.ObjectField(),
    {
      required: !0,
      initial: /* @__PURE__ */ u(() => ({ [foundry.utils.randomID()]: {} }), "initial")
    }
  )
}), "spellBooks"), dq = /* @__PURE__ */ u(() => ({
  traits: new Oe.SchemaField({
    size: new Oe.StringField({ required: !0, initial: "med" }),
    alignment: new Oe.ArrayField(new Oe.StringField({ required: !0, initial: "" }), {
      required: !0,
      initial: []
    }),
    conditionImmunities: new Oe.ArrayField(
      new Oe.StringField({ required: !0, initial: "" }),
      { required: !0, initial: [] }
    ),
    damageImmunities: new Oe.ArrayField(
      new Oe.StringField({ required: !0, initial: "" }),
      { required: !0, initial: [] }
    ),
    damageResistances: new Oe.ArrayField(
      new Oe.StringField({ required: !0, initial: "" }),
      { required: !0, initial: [] }
    ),
    damageVulnerabilities: new Oe.ArrayField(
      new Oe.StringField({ required: !0, initial: "" }),
      { required: !0, initial: [] }
    )
  })
}), "traits"), { fields: at } = foundry.data, g1e = /* @__PURE__ */ u(() => ({
  attributes: new at.SchemaField({
    attunement: new at.SchemaField({
      current: new at.NumberField({ required: !0, initial: 0, integer: !0 }),
      max: new at.NumberField({ required: !0, initial: 3, integer: !0 })
    }),
    exertion: new at.SchemaField({
      current: new at.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      }),
      max: new at.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      }),
      recoverOnRest: new at.BooleanField({ required: !0, initial: !0 })
    }),
    favorPoints: new at.SchemaField({
      current: new at.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      }),
      max: new at.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      })
    }),
    hitDice: new at.SchemaField({
      ...["d6", "d8", "d10", "d12"].reduce((i, e) => (i[e] = h1e(), i), {})
    }),
    ...nq()
  }),
  details: new at.SchemaField({
    age: new at.StringField({ required: !0, initial: "" }),
    appearance: new at.StringField({ required: !0, initial: "" }),
    archetype: new at.StringField({ required: !0, initial: "" }),
    background: new at.StringField({ required: !0, initial: "" }),
    classes: new at.StringField({ required: !0, initial: "" }),
    culture: new at.StringField({ required: !0, initial: "" }),
    destiny: new at.StringField({ required: !0, initial: "" }),
    eyeColor: new at.StringField({ required: !0, initial: "" }),
    gender: new at.StringField({ required: !0, initial: "" }),
    hairColor: new at.StringField({ required: !0, initial: "" }),
    heritage: new at.StringField({ required: !0, initial: "" }),
    height: new at.StringField({ required: !0, initial: "" }),
    level: new at.NumberField({
      required: !0,
      nullable: !1,
      initial: 1,
      integer: !0
    }),
    bonds: new at.HTMLField({ required: !0, nullable: !1, initial: "" }),
    flaws: new at.HTMLField({ required: !0, nullable: !1, initial: "" }),
    ideals: new at.HTMLField({ required: !0, nullable: !1, initial: "" }),
    goals: new at.HTMLField({ required: !0, nullable: !1, initial: "" }),
    notes: new at.HTMLField({ required: !0, nullable: !1, initial: "" }),
    prestige: new at.NumberField({ required: !0, initial: 1, integer: !0 }),
    skinColor: new at.StringField({ required: !0, initial: "" }),
    weight: new at.StringField({ required: !0, initial: "" }),
    xp: new at.NumberField({ required: !0, initial: 0, integer: !0 }),
    ...rq()
  }),
  classes: new at.SchemaField({
    startingClass: new at.StringField({ required: !0, initial: "" })
  }),
  resources: new at.SchemaField(
    {
      classResources: new at.ObjectField({ required: !0, nullable: !1 }),
      ...cq()
    },
    { required: !0, nullable: !1 }
  ),
  spellResources: new at.SchemaField({
    artifactCharges: new at.SchemaField({
      current: new at.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      }),
      override: new at.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      })
    }),
    inventions: new at.SchemaField({
      current: new at.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      }),
      override: new at.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      })
    }),
    points: new at.SchemaField({
      current: new at.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      }),
      max: new at.NumberField({
        required: !0,
        nullable: !0,
        initial: 0,
        min: 0
      }),
      override: new at.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      })
    }),
    slots: new at.SchemaField(
      Array.from({ length: 9 }, (i, e) => e + 1).reduce((i, e) => (i[e] = new at.SchemaField({
        current: new at.NumberField({
          required: !0,
          nullable: !1,
          initial: 0,
          min: 0
        }),
        max: new at.NumberField({
          required: !0,
          nullable: !0,
          initial: 0,
          min: 0
        }),
        override: new at.NumberField({
          required: !0,
          nullable: !1,
          initial: 0,
          min: 0
        })
      }), i), {})
    )
  }),
  supply: new at.NumberField({
    required: !0,
    initial: 0,
    integer: !0,
    nullable: !1
  })
}), "characterSchema"), kT = class kT extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    return {
      ...sq(),
      ...iq(),
      ...lq(),
      ...oq(),
      ...aq(),
      ...uq(),
      ...fq(),
      ...dq(),
      ...g1e(),
      ...sB(),
      ...mg()
    };
  }
};
u(kT, "A5ECharacterData");
let mk = kT;
const { fields: Wt } = foundry.data, b1e = /* @__PURE__ */ u(() => ({
  attributes: new Wt.SchemaField({
    casterLevel: new Wt.NumberField({ required: !0, initial: 0, integer: !0 }),
    hitDice: new Wt.SchemaField({
      ...["d4", "d6", "d8", "d10", "d12", "d20"].reduce((i, e) => (i[e] = new Wt.SchemaField({
        current: new Wt.NumberField({
          required: !0,
          initial: 0,
          integer: !0,
          min: 0
        }),
        total: new Wt.NumberField({
          required: !0,
          initial: 0,
          integer: !0,
          min: 0
        })
      }), i), {})
    }),
    ...nq()
  }),
  details: new Wt.SchemaField({
    cr: new Wt.NumberField({ required: !0, nullable: !1, initial: 0 }),
    // @ts-expect-error
    elite: new Wt.BooleanField({ required: !0, initial: !1 }),
    // @ts-expect-error
    isSquad: new Wt.BooleanField({ required: !0, initial: !1 }),
    // @ts-expect-error
    isSwarm: new Wt.BooleanField({ required: !0, initial: !1 }),
    notes: new Wt.HTMLField({ required: !0, initial: "" }),
    privateNotes: new Wt.HTMLField({ required: !0, initial: "" }),
    terrain: new Wt.ArrayField(new Wt.StringField({ required: !0, initial: "" }), {
      required: !0,
      initial: []
    }),
    ...rq()
  }),
  resources: new Wt.SchemaField(
    {
      ...cq()
    },
    { required: !0, nullable: !1 }
  ),
  spellResources: new Wt.SchemaField({
    artifactCharges: new Wt.SchemaField({
      current: new Wt.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      }),
      max: new Wt.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      })
    }),
    inventions: new Wt.SchemaField({
      current: new Wt.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      }),
      max: new Wt.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      })
    }),
    points: new Wt.SchemaField({
      current: new Wt.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      }),
      max: new Wt.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        integer: !0
      })
    }),
    slots: new Wt.SchemaField(
      Array.from({ length: 9 }, (i, e) => e + 1).reduce((i, e) => (i[e] = new Wt.SchemaField({
        current: new Wt.NumberField({
          required: !0,
          nullable: !1,
          initial: 0,
          min: 0
        }),
        max: new Wt.NumberField({
          required: !0,
          nullable: !1,
          initial: 0,
          min: 0
        })
      }), i), {})
    )
  })
}), "npcSchema"), wT = class wT extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    return {
      ...sq(),
      ...iq(),
      ...lq(),
      ...oq(),
      ...aq(),
      ...uq(),
      ...fq(),
      ...dq(),
      ...sB(),
      ...mg(),
      ...b1e()
    };
  }
};
u(wT, "A5ENPCData");
let hk = wT;
const _1e = {
  character: mk,
  npc: hk
}, { fields: Hg } = foundry.data, y1e = /* @__PURE__ */ u(() => ({
  applyToSelf: new Hg.BooleanField({ required: !0, nullable: !1, initial: !1 }),
  effectType: new Hg.StringField({ required: !0, nullable: !1, initial: "passive" }),
  default: new Hg.BooleanField({ required: !0, nullable: !1, initial: !0 })
}), "baseSchema"), $T = class $T extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    return {
      ...y1e(),
      ...mg()
    };
  }
};
u($T, "A5EBaseActiveEffectData");
let gk = $T;
const v1e = {
  base: gk
}, { fields: Ug } = foundry.data, pq = /* @__PURE__ */ u(() => ({
  actorId: new Ug.StringField({ required: !0, nullable: !1, initial: "" }),
  actorName: new Ug.StringField({ required: !0, nullable: !1, initial: "" }),
  img: new Ug.FilePathField({ categories: ["IMAGE"] })
}), "metadata"), { fields: vn } = foundry.data, k1e = /* @__PURE__ */ u(() => ({
  actionName: new vn.StringField({ required: !0, nullable: !1, initial: "" }),
  actionId: new vn.StringField({ required: !1, nullable: !0 }),
  actionDescription: new vn.HTMLField({ required: !0, nullable: !1, initial: "" }),
  castingLevel: new vn.NumberField({ required: !0, nullable: !0 }),
  effects: new vn.ArrayField(
    new vn.StringField({ required: !0, nullable: !1, initial: "" }),
    { required: !0, nullable: !1 }
  ),
  itemDescription: new vn.HTMLField({ required: !0, nullable: !1, initial: "" }),
  itemId: new vn.StringField({ required: !0, nullable: !1, initial: "" }),
  prompts: new vn.ArrayField(new vn.ObjectField({ required: !0, nullable: !1 })),
  rollData: new vn.ArrayField(new vn.ObjectField({ required: !0, nullable: !1 })),
  summaryData: new vn.ObjectField({ required: !0, nullable: !1 }),
  unidentifiedDescription: new vn.HTMLField({ required: !0, nullable: !1, initial: "" })
}), "itemCardSchema"), AT = class AT extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    return {
      ...k1e(),
      ...pq()
    };
  }
};
u(AT, "A5eItemCardData");
let bk = AT;
const { fields: Vg } = foundry.data, w1e = /* @__PURE__ */ u(() => ({
  rollData: new Vg.ArrayField(new Vg.ObjectField({ required: !0, nullable: !1 })),
  rollType: new Vg.StringField({
    required: !0,
    nullable: !1,
    initial: "abilityCheck",
    choices: ["abilityCheck", "hitDice", "initiative", "savingThrow", "skillCheck"]
  })
}), "rollCardSchema"), ET = class ET extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    return {
      ...w1e(),
      ...pq()
    };
  }
};
u(ET, "A5eRollCardData");
let _k = ET;
const $1e = {
  item: bk,
  roll: _k
}, { fields: A1e } = foundry.data, E1e = {
  grants: new A1e.ObjectField({
    nullable: !1,
    initial: /* @__PURE__ */ u(() => ({
      // Default ASI
      [foundry.utils.randomID()]: {
        grantType: "ability",
        abilities: { options: Object.keys(CONFIG.A5E.abilities), total: 1 },
        context: { types: ["base"] },
        bonus: "1",
        label: "Default ASI"
      },
      // Skill Proficiency
      [foundry.utils.randomID()]: {
        grantType: "proficiency",
        keys: { total: 1 },
        proficiencyType: "skill",
        label: "Skill Proficiencies"
      },
      // Feature
      [foundry.utils.randomID()]: {
        grantType: "feature",
        label: "Background Feature"
      },
      // Suggested Equipment
      [foundry.utils.randomID()]: {
        grantType: "item",
        label: "Suggested Equipment",
        optional: !0
      },
      // Trait Proficiency
      [foundry.utils.randomID()]: {
        grantType: "proficiency",
        proficiencyType: "tool",
        label: "Tool Proficiencies"
      }
    }), "initial")
  })
}, ST = class ST extends bi {
  /** @inheritDoc */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      ...E1e
    };
  }
};
u(ST, "A5EBackgroundData");
let yk = ST;
const { fields: ts } = foundry.data, S1e = {
  slug: new ts.StringField({ nullable: !1, initial: "" }),
  archetypeLevel: new ts.NumberField({
    required: !0,
    nullable: !1,
    initial: 3,
    min: 0,
    max: 20
  }),
  classLevels: new ts.NumberField({
    required: !0,
    nullable: !1,
    initial: 0,
    min: 0,
    max: 20
  }),
  maxLevel: new ts.NumberField({
    required: !0,
    nullable: !1,
    initial: 20,
    min: 0,
    max: 20
  }),
  hp: new ts.SchemaField({
    hitDiceSize: new ts.NumberField({
      required: !0,
      nullable: !1,
      initial: 6,
      min: 4,
      max: 20
    }),
    hitDiceUsed: new ts.NumberField({
      required: !0,
      nullable: !1,
      initial: 0,
      min: 0
    }),
    levels: new ts.SchemaField(
      Array.from({ length: 20 }, (i, e) => e + 1).reduce((i, e) => (i[e] = new ts.NumberField({
        required: !0,
        nullable: !1,
        initial: 0,
        min: 0
      }), i), {})
    )
  }),
  grants: new ts.ObjectField({
    nullable: !1,
    initial: /* @__PURE__ */ u(() => ({
      [foundry.utils.randomID()]: {
        grantType: "proficiency",
        keys: {
          base: [],
          options: [],
          total: 0
        },
        proficiencyType: "armor",
        label: "Armor Proficiencies",
        levelType: "class"
      },
      [foundry.utils.randomID()]: {
        grantType: "proficiency",
        keys: {
          base: [],
          options: [],
          total: 0
        },
        proficiencyType: "weapon",
        label: "Weapon Proficiencies",
        levelType: "class"
      },
      [foundry.utils.randomID()]: {
        grantType: "proficiency",
        keys: {
          base: [],
          options: [],
          total: 0
        },
        proficiencyType: "tool",
        label: "Tool Proficiencies",
        levelType: "character"
      },
      [foundry.utils.randomID()]: {
        grantType: "proficiency",
        keys: {
          base: [],
          options: [],
          total: 0
        },
        proficiencyType: "savingThrow",
        isExpertise: !1,
        label: "Saving Throw Proficiencies",
        levelType: "character"
      },
      [foundry.utils.randomID()]: {
        grantType: "proficiency",
        keys: {
          base: [],
          options: [],
          total: 0
        },
        proficiencyType: "skill",
        isExpertise: !1,
        label: "Skill Proficiencies",
        levelType: "character"
      },
      [foundry.utils.randomID()]: {
        grantType: "feature",
        features: {
          base: [],
          options: [],
          total: 0
        },
        label: "1st Level Class Features",
        levelType: "class"
      },
      [foundry.utils.randomID()]: {
        grantType: "item",
        items: {
          base: [],
          options: [],
          total: 0
        },
        label: "Starting Equipment",
        levelType: "character",
        optional: !0
      }
    }), "initial")
  }),
  resources: new ts.ArrayField(
    new ts.SchemaField({
      name: new ts.StringField({ nullable: !1, required: !0, initial: "New Resource" }),
      consumable: new ts.BooleanField({ nullable: !1, required: !0, initial: !1 }),
      displayOnCore: new ts.BooleanField({ nullable: !1, required: !0, initial: !0 }),
      reference: new ts.SchemaField(
        Array.from({ length: 20 }, (i, e) => e + 1).reduce((i, e) => (i[e] = new ts.StringField({ required: !0, initial: "" }), i), {})
      ),
      recovery: new ts.StringField({ nullable: !1, required: !0, initial: "longRest" }),
      slug: new ts.StringField({ nullable: !1, required: !0, initial: "" })
    }),
    { nullable: !1, required: !0, initial: [] }
  ),
  spellcasting: new ts.SchemaField({
    ability: new ts.SchemaField({
      base: new ts.StringField({ nullable: !1, initial: "none" }),
      options: new ts.ArrayField(new ts.StringField({ nullable: !1, initial: "none" }), {
        nullable: !1,
        initial: []
      }),
      value: new ts.StringField({ nullable: !1, initial: "none" })
    }),
    casterType: new ts.StringField({ nullable: !1, initial: "none" })
  }),
  wealth: new ts.StringField({ nullable: !1, initial: "" })
}, CT = class CT extends bi {
  /** @inheritDoc */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      ...S1e
    };
  }
};
u(CT, "A5EClassData");
let vk = CT;
const { fields: C1e } = foundry.data, T1e = {
  grants: new C1e.ObjectField({
    nullable: !1,
    initial: /* @__PURE__ */ u(() => ({
      // Feature Grant
      [foundry.utils.randomID()]: {
        grantType: "feature",
        label: "Culture Features"
      },
      // Languages
      [foundry.utils.randomID()]: {
        grantType: "trait",
        traits: { traitType: "languages" },
        label: "Languages"
      }
    }), "initial")
  })
}, TT = class TT extends bi {
  /** @inheritDoc */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      ...T1e
    };
  }
};
u(TT, "A5ECultureData");
let kk = TT;
const { fields: Wg } = foundry.data, O1e = {
  sourceOfInspiration: new Wg.StringField({ required: !0, nullable: !1, initial: "" }),
  inspirationFeature: new Wg.StringField({ required: !0, nullable: !1, initial: "" }),
  fulfillmentFeature: new Wg.StringField({ required: !0, nullable: !1, initial: "" })
}, OT = class OT extends bi {
  /** @inheritDoc */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      ...O1e
    };
  }
};
u(OT, "A5EDestinyData");
let wk = OT;
const { fields: D1e } = foundry.data, I1e = {
  grants: new D1e.ObjectField({
    nullable: !1,
    initial: /* @__PURE__ */ u(() => ({
      [foundry.utils.randomID()]: {
        grantType: "movement",
        movementTypes: { base: ["walk"] },
        bonus: "30",
        unit: "feet",
        label: "Base Movement"
      }
    }), "initial")
  })
}, DT = class DT extends bi {
  /** @inheritDoc */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      ...I1e
    };
  }
};
u(DT, "A5EHeritageData");
let $k = DT;
const { fields: Fr } = foundry.data, P1e = {
  class: new Fr.StringField({ required: !0, initial: "" }),
  classes: new Fr.StringField({ required: !0, initial: "" }),
  concentration: new Fr.BooleanField({ required: !0, initial: !1 }),
  featureType: new Fr.StringField({ required: !0, initial: "" }),
  grants: new Fr.ObjectField({ required: !0, initial: {} }),
  prerequisite: new Fr.StringField({ required: !0, initial: "" }),
  requiresBloodied: new Fr.BooleanField({ required: !0, initial: !1 })
}, IT = class IT extends bi {
  /** @inheritDoc */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      ...dg(),
      ...tB(),
      ...pg(),
      ...P1e
    };
  }
};
u(IT, "A5EFeatureData");
let Ak = IT;
const { fields: Oo } = foundry.data, M1e = {
  concentration: new Oo.BooleanField({ required: !0, initial: !1 }),
  degree: new Oo.NumberField({
    required: !0,
    nullable: !1,
    initial: 0,
    integer: !0,
    min: 0
  }),
  exertionCost: new Oo.NumberField({
    required: !0,
    initial: 0,
    integer: !0,
    min: 0
  }),
  isStance: new Oo.BooleanField({ required: !0, initial: !1 }),
  prerequisite: new Oo.StringField({ required: !0, initial: "" }),
  tradition: new Oo.StringField({ required: !0, initial: "" })
}, PT = class PT extends bi {
  /** @inheritDoc */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      ...dg(),
      ...pg(),
      ...M1e
    };
  }
};
u(PT, "A5EManeuverData");
let Ek = PT;
const { fields: ut } = foundry.data, F1e = {
  ammunitionProperties: new ut.ArrayField(
    new ut.StringField({ required: !0, initial: "" }),
    { required: !0, initial: [] }
  ),
  armorCategory: new ut.StringField({ required: !0, initial: "" }),
  armorMods: new ut.ArrayField(new ut.StringField({ required: !0, initial: "" }), {
    required: !0,
    initial: []
  }),
  armorProperties: new ut.ArrayField(new ut.StringField({ required: !0, initial: "" }), {
    required: !0,
    initial: []
  }),
  attuned: new ut.BooleanField({ required: !0, initial: !1 }),
  bulky: new ut.BooleanField({ required: !0, initial: !1 }),
  breakerProperties: new ut.ArrayField(
    new ut.StringField({ required: !0, initial: "" }),
    { required: !0, initial: [] }
  ),
  capacity: new ut.SchemaField({
    type: new ut.StringField({ required: !0, initial: "weight" }),
    value: new ut.NumberField({ nullable: !1, initial: 0, min: 0 }),
    weightlessContents: new ut.BooleanField({ required: !0, initial: !1 })
  }),
  containerId: new ut.StringField({ required: !0, initial: "" }),
  craftingComponents: new ut.StringField({ required: !0, initial: "" }),
  damagedState: new ut.NumberField({
    required: !0,
    initial: 0,
    integer: !0,
    min: 0,
    max: 2
  }),
  defensiveProperties: new ut.StringField({ required: !0, initial: "" }),
  energyProperties: new ut.StringField({ required: !0, initial: "" }),
  equippedState: new ut.NumberField({
    required: !0,
    initial: 0,
    integer: !0,
    min: 0,
    max: 2
  }),
  flaws: new ut.ArrayField(new ut.StringField({ required: !0, initial: "" }), {
    required: !0,
    initial: []
  }),
  items: new ut.ObjectField({ required: !0, initial: {} }),
  implant: new ut.BooleanField({ required: !0, initial: !1 }),
  materialProperties: new ut.ArrayField(
    new ut.StringField({ required: !0, initial: "" }),
    { required: !0, initial: [] }
  ),
  modPorts: new ut.StringField({ required: !0, initial: "" }),
  mounted: new ut.ArrayField(new ut.StringField({ required: !0, initial: "" }), {
    required: !0,
    initial: []
  }),
  objectType: new ut.StringField({ required: !0, initial: "" }),
  plotItem: new ut.BooleanField({ required: !0, initial: !1 }),
  price: new ut.StringField({ required: !0, initial: "" }),
  proficient: new ut.BooleanField({ required: !0, initial: !1 }),
  quantity: new ut.NumberField({
    required: !0,
    nullable: !1,
    initial: 1,
    integer: !0,
    min: 0
  }),
  rarity: new ut.StringField({ required: !0, initial: "mundane" }),
  repairabilityDC: new ut.NumberField({
    required: !0,
    initial: 0,
    min: 0,
    nullable: !1
  }),
  repairTools: new ut.ArrayField(new ut.StringField({ required: !0, initial: "" }), {
    required: !0,
    initial: []
  }),
  requiresAttunement: new ut.BooleanField({ required: !0, initial: !1 }),
  shieldCategory: new ut.StringField({ required: !0, initial: "" }),
  shieldProperties: new ut.ArrayField(new ut.StringField({ required: !0, initial: "" }), {
    required: !0,
    initial: []
  }),
  supply: new ut.BooleanField({ required: !0, initial: !1 }),
  techLevel: new ut.StringField({ required: !0, initial: "archaic" }),
  unidentified: new ut.BooleanField({ required: !0, initial: !1 }),
  unidentifiedDescription: new ut.HTMLField({ required: !0, initial: "" }),
  unidentifiedName: new ut.StringField({ required: !0, initial: "" }),
  versatile: new ut.StringField({ required: !0, initial: "" }),
  weaponAugments: new ut.ArrayField(new ut.StringField({ required: !0, initial: "" }), {
    required: !0,
    initial: []
  }),
  weaponProperties: new ut.ArrayField(new ut.StringField({ required: !0, initial: "" }), {
    required: !0,
    initial: []
  }),
  weight: new ut.NumberField({
    required: !0,
    initial: 0,
    min: 0,
    nullable: !1
  })
}, MT = class MT extends bi {
  /** @inheritDoc */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      ...dg(),
      ...tB(),
      ...pg(),
      ...F1e
    };
  }
};
u(MT, "A5EObjectData");
let Sk = MT;
const { fields: Es } = foundry.data, R1e = {
  classes: new Es.ArrayField(new Es.StringField({ required: !0, initial: "" }), {
    required: !0,
    initial: []
  }),
  components: new Es.SchemaField({
    vocalized: new Es.BooleanField({ required: !0, initial: !1 }),
    seen: new Es.BooleanField({ required: !0, initial: !1 }),
    material: new Es.BooleanField({ required: !0, initial: !1 })
  }),
  concentration: new Es.BooleanField({ required: !0, initial: !1 }),
  discipline: new Es.StringField({ required: !0, initial: "" }),
  level: new Es.NumberField({
    required: !0,
    nullable: !1,
    initial: 0,
    integer: !0,
    min: 0
  }),
  materials: new Es.StringField({ required: !0, initial: "" }),
  materialsConsumed: new Es.BooleanField({ required: !0, initial: !1 }),
  prepared: new Es.NumberField({ required: !0, initial: 0 }),
  prerequisite: new Es.StringField({ required: !0, initial: "" }),
  rare: new Es.BooleanField({ required: !0, initial: !1 }),
  ritual: new Es.BooleanField({ required: !0, initial: !1 }),
  schools: new Es.SchemaField({
    primary: new Es.StringField({ required: !0, initial: "" }),
    secondary: new Es.ArrayField(new Es.StringField({ required: !0, initial: "" }), {
      required: !0,
      initial: []
    })
  }),
  spellBook: new Es.StringField({ required: !0, initial: "", nullable: !1 })
}, FT = class FT extends bi {
  /** @inheritDoc */
  static defineSchema() {
    return {
      ...super.defineSchema(),
      ...dg(),
      ...pg(),
      ...R1e
    };
  }
};
u(FT, "A5ESpellData");
let Ck = FT;
const N1e = {
  archetype: vp,
  background: yk,
  class: vk,
  culture: kk,
  destiny: wk,
  heritage: $k,
  feature: Ak,
  maneuver: Ek,
  object: Sk,
  spell: Ck
}, H5 = Il.ACTIVE_EFFECT_MODES, j1e = Object.keys(H5).filter((i) => i !== "CUSTOM").sort((i, e) => i.localeCompare(e)), L1e = Object.keys(H5).filter((i) => !["CUSTOM", "UPGRADE", "DOWNGRADE", "CONDITIONAL"].includes(i)).sort((i, e) => i.localeCompare(e)), B1e = ["ADD", "OVERRIDE"], q1e = ["OVERRIDE"], G1e = ["CUSTOM"], z1e = ["CONDITIONAL"], H1e = ["OVERRIDE", "CONDITIONAL"], We = {
  MODES: H5,
  DEFAULT_MODES: j1e,
  DEFAULT_STRING_MODES: L1e,
  ADD_AND_OVERRIDE: B1e,
  OVERRIDE_ONLY: q1e,
  CUSTOM_ONLY: G1e,
  CONDITIONAL_ONLY: z1e,
  CONDITIONAL_AND_OVERRIDE: H1e
}, RT = class RT {
  constructor(e, t, s = {
    modes: [],
    options: [],
    phase: "afterDerived",
    type: ""
  }) {
    qe(this, "effectKey");
    qe(this, "label");
    qe(this, "modes");
    qe(this, "options");
    qe(this, "phase");
    qe(this, "sampleValue");
    qe(this, "type");
    var n;
    this.effectKey = e, this.label = ((n = CONFIG.A5E.effectsKeyLocalizations) == null ? void 0 : n[e]) ?? e, this.sampleValue = t, this.modes = s.modes ?? [], this.options = s.options ?? [], this.phase = s.phase ?? "afterDerived", this.type = s.type ?? "DEFAULT";
  }
};
u(RT, "EffectOption");
let Zo = RT;
function U1e(i) {
  i["system.attributes.inspiration"] = [
    !1,
    We.OVERRIDE_ONLY,
    [
      [!0, "Has Inspiration"],
      [!1, "Doesn't have Inspiration"]
    ],
    "RADIO"
  ], i["system.attributes.exertion.recoverOnRest"] = [
    !1,
    We.OVERRIDE_ONLY,
    [
      [!0, "Can Recover"],
      [!1, "Cannot recover"]
    ],
    "RADIO"
  ], i["system.attributes.movement.traits.hover"] = [
    !1,
    We.OVERRIDE_ONLY,
    [
      [!0, "Can Hover"],
      [!1, "Cannot Hover"]
    ],
    "RADIO"
  ], i["system.attributes.senses.blindsight.otherwiseBlind"] = [
    !1,
    We.OVERRIDE_ONLY,
    [
      [!0, "Blind Beyond Vision"],
      [!1, "Normal Vision"]
    ],
    "RADIO"
  ], i["system.details.elite"] = [
    !1,
    We.OVERRIDE_ONLY,
    [
      [!0, "Elite Monster"],
      [!1, "Normal Monster"]
    ],
    "RADIO"
  ], i["system.details.isSwarm"] = [
    !1,
    We.OVERRIDE_ONLY,
    [
      [!0, "Is Swarm"],
      [!1, "Not a Swarm"]
    ],
    "RADIO"
  ], Object.keys(CONFIG.A5E.abilities).forEach((e) => {
    i[`system.abilities.${e}.save.proficient`] = [
      !1,
      We.OVERRIDE_ONLY,
      [
        [!0, "Proficient"],
        [!1, "Not Proficient"]
      ],
      "RADIO"
    ];
  }), Object.keys(CONFIG.A5E.skills).forEach((e) => {
    i[`system.skills.${e}.proficient`] = [
      0,
      We.OVERRIDE_ONLY,
      [
        [0, "Not Proficient"],
        [1, "Proficient"],
        [2, "Expertise"]
      ],
      "RADIO"
    ], i[`system.skills.${e}.ability`] = [
      "",
      We.OVERRIDE_ONLY,
      [...Object.entries(CONFIG.A5E.abilities), ["@attributes.spellcasting", "Spellcasting"]],
      "RADIO"
    ];
  }), i["system.attributes.initiative.ability"] = [
    "",
    We.OVERRIDE_ONLY,
    Object.entries(CONFIG.A5E.abilities),
    "RADIO"
  ], i["system.details.creatureTypes"] = [
    "",
    We.DEFAULT_MODES,
    Object.entries(CONFIG.A5E.creatureTypes),
    "TAG_GROUP"
  ], i["system.traits.conditionImmunities"] = [
    "",
    We.DEFAULT_STRING_MODES,
    Object.entries(CONFIG.A5E.conditions),
    "TAG_GROUP"
  ], i["system.traits.damageImmunities"] = [
    "",
    We.DEFAULT_STRING_MODES,
    Object.entries(CONFIG.A5E.damageTypes),
    "TAG_GROUP"
  ], i["system.traits.damageResistances"] = [
    "",
    We.DEFAULT_STRING_MODES,
    Object.entries(CONFIG.A5E.damageTypes),
    "TAG_GROUP"
  ], i["system.traits.damageVulnerabilities"] = [
    "",
    We.DEFAULT_STRING_MODES,
    Object.entries(CONFIG.A5E.damageTypes),
    "TAG_GROUP"
  ], i["system.traits.size"] = [
    "",
    We.OVERRIDE_ONLY,
    Object.entries(CONFIG.A5E.actorSizes),
    "RADIO"
  ], i["system.proficiencies.armor"] = [
    "",
    We.DEFAULT_STRING_MODES,
    Object.entries(CONFIG.A5E.armor),
    "TAG_GROUP"
  ], i["system.proficiencies.languages"] = [
    "",
    We.DEFAULT_STRING_MODES,
    Object.entries(CONFIG.A5E.languages),
    "TAG_GROUP"
  ], i["system.proficiencies.tools"] = [
    "",
    We.DEFAULT_STRING_MODES,
    Object.values(CONFIG.A5E.tools).flatMap((e) => Object.entries(e)),
    "TAG_GROUP"
  ], i["system.proficiencies.weapons"] = [
    "",
    We.DEFAULT_STRING_MODES,
    Object.values(CONFIG.A5E.weapons).flatMap((e) => Object.entries(e)),
    "TAG_GROUP"
  ], i["system.attributes.prof"] = [0, We.DEFAULT_MODES], i["system.attributes.spellcasting"] = [
    "",
    We.OVERRIDE_ONLY,
    Object.entries(CONFIG.A5E.abilities),
    "RADIO"
  ], i["flags.a5e.effects.bonuses.abilities"] = [{}, We.CUSTOM_ONLY, null, "ABILITY_BONUS"], i["flags.a5e.effects.bonuses.attacks"] = [{}, We.CUSTOM_ONLY, null, "ATTACK_BONUS"], i["flags.a5e.effects.bonuses.damage"] = [{}, We.CUSTOM_ONLY, null, "DAMAGE_BONUS"], i["flags.a5e.effects.bonuses.healing"] = [{}, We.CUSTOM_ONLY, null, "HEALING_BONUS"], i["flags.a5e.effects.bonuses.initiative"] = [
    {},
    We.CUSTOM_ONLY,
    null,
    "INITIATIVE_BONUS"
  ], i["flags.a5e.effects.bonuses.skills"] = [{}, We.CUSTOM_ONLY, null, "SKILL_BONUS"], delete i["system.bonuses.meleeWeaponAttack"], delete i["system.bonuses.rangedWeaponAttack"], delete i["system.bonuses.meleeSpellAttack"], delete i["system.bonuses.rangedSpellAttack"], delete i["system.attributes.initiative.bonus"], Object.keys(CONFIG.A5E.abilities).forEach((e) => {
    delete i[`system.abilities.${e}.check.mod`], delete i[`system.abilities.${e}.check.bonus`], delete i[`system.abilities.${e}.save.mod`], delete i[`system.abilities.${e}.save.bonus`];
  }), Object.keys(CONFIG.A5E.skills).forEach((e) => {
    delete i[`system.skills.${e}.mod`], delete i[`system.skills.${e}.bonus`];
  }), delete i["system.attributes.initiative.bonus"], delete i["system.attributes.ac.baseFormula"], delete i["system.attributes.ac.value"], delete i["system.spellBooks"], delete i["system.grants"], Object.keys(CONFIG.A5E.abilities).forEach((e) => {
    delete i[`system.abilities.${e}.check.bonus`], delete i[`system.abilities.${e}.save.bonus`];
  }), Object.keys(CONFIG.A5E.skills).forEach((e) => {
    delete i[`system.skills.${e}.bonuses.check`], delete i[`system.skills.${e}.bonuses.passive`];
  }), delete i["system.details.age"], delete i["system.details.appearance"], delete i["system.details.background"], delete i["system.details.bio"], delete i["system.details.classes"], delete i["system.details.culture"], delete i["system.details.destiny"], delete i["system.details.eyeColor"], delete i["system.details.gender"], delete i["system.details.hairColor"], delete i["system.details.height"], delete i["system.details.heritage"], delete i["system.details.level"], delete i["system.details.notes"], delete i["system.details.prestige"], delete i["system.details.skinColor"], delete i["system.details.weight"], delete i["system.details.notes"], delete i["system.details.xp"], delete i["system.details.privateNotes"], delete i["system.source.link"], delete i["system.source.name"], delete i["system.source.publisher"], delete i["system.resources.primary.hideMax"], delete i["system.resources.secondary.hideMax"], delete i["system.resources.tertiary.hideMax"], delete i["system.resources.quaternary.hideMax"], Object.keys(CONFIG.A5E.movement).forEach((e) => {
    delete i[`system.attributes.movement.${e}.distance`];
  }), Object.keys(CONFIG.A5E.senses).forEach((e) => {
    delete i[`system.attributes.senses.${e}.distance`];
  }), delete i["system.bonuses.abilities"], delete i["system.bonuses.attacks"], delete i["system.bonuses.damage"], delete i["system.bonuses.healing"], delete i["system.bonuses.initiative"], delete i["system.bonuses.movement"], delete i["system.bonuses.senses"], delete i["system.bonuses.skills"], delete i["system.schemaVersion.version"], delete i["system.schemaVersion.lastMigration"];
}
u(U1e, "modifyBaseOptions");
function V1e(i) {
  i["system.attributes.ac.baseFormula"] = ["", We.OVERRIDE_ONLY], i["system.attributes.ac.changes.bonuses.value"] = [0, We.DEFAULT_MODES], i["system.attributes.ac.value"] = [0, We.CONDITIONAL_AND_OVERRIDE], i["system.attributes.hp.max"] = [0, We.DEFAULT_MODES], i["system.attributes.maneuverDC"] = [0, We.DEFAULT_MODES], i["system.attributes.spellDC"] = [0, We.DEFAULT_MODES], Object.keys(CONFIG.A5E.movement).forEach((e) => {
    i[`system.attributes.movement.${e}.distance`] = [0, We.DEFAULT_MODES], i[`system.attributes.movement.${e}.unit`] = [
      "",
      We.OVERRIDE_ONLY,
      Object.entries(CONFIG.A5E.distanceUnits),
      "RADIO"
    ], i["flags.a5e.effects.movement.allDistances"] = [0, We.DEFAULT_MODES], i["flags.a5e.effects.movement.allUnits"] = [
      "",
      We.OVERRIDE_ONLY,
      Object.entries(CONFIG.A5E.distanceUnits),
      "RADIO"
    ];
  }), Object.keys(CONFIG.A5E.senses).forEach((e) => {
    i[`system.attributes.senses.${e}.distance`] = [0, We.DEFAULT_MODES], i[`system.attributes.senses.${e}.unit`] = [
      "",
      We.OVERRIDE_ONLY,
      Object.entries(CONFIG.A5E.visionUnits),
      "RADIO"
    ], i["flags.a5e.effects.senses.allDistances"] = [0, We.DEFAULT_MODES], i["flags.a5e.effects.senses.allUnits"] = [
      "",
      We.OVERRIDE_ONLY,
      Object.entries(CONFIG.A5E.visionUnits),
      "RADIO"
    ];
  }), i["flags.a5e.deathSaveThreshold"] = [0, We.DEFAULT_MODES];
}
u(V1e, "modifyDerivedOptions");
function W1e(i) {
  const e = Object.entries(CONFIG.A5E.ROLL_MODE).map(([s, n]) => [
    n,
    s.toLowerCase().capitalize()
  ]);
  i["flags.a5e.effects.rollMode.attack.all"] = [0, We.OVERRIDE_ONLY, e, "RADIO"], Object.keys(CONFIG.A5E.attackTypes).forEach((s) => {
    i[`flags.a5e.effects.rollMode.attack.${s}`] = [
      0,
      We.OVERRIDE_ONLY,
      e,
      "RADIO"
    ];
  }), i["flags.a5e.effects.rollMode.abilityCheck.all"] = [
    0,
    We.OVERRIDE_ONLY,
    e,
    "RADIO"
  ], i["flags.a5e.effects.rollMode.abilitySave.all"] = [
    0,
    We.OVERRIDE_ONLY,
    e,
    "RADIO"
  ], i["flags.a5e.effects.rollMode.skillCheck.all"] = [
    0,
    We.OVERRIDE_ONLY,
    e,
    "RADIO"
  ], i["flags.a5e.effects.rollMode.concentration"] = [
    0,
    We.OVERRIDE_ONLY,
    e,
    "RADIO"
  ], i["flags.a5e.effects.rollMode.deathSave"] = [0, We.OVERRIDE_ONLY, e, "RADIO"], i["flags.a5e.effects.rollMode.initiative"] = [0, We.OVERRIDE_ONLY, e, "RADIO"], Object.keys(CONFIG.A5E.abilities).forEach((s) => {
    i[`flags.a5e.effects.rollMode.abilityCheck.${s}`] = [
      0,
      We.OVERRIDE_ONLY,
      e,
      "RADIO"
    ], i[`flags.a5e.effects.rollMode.abilitySave.${s}`] = [
      0,
      We.OVERRIDE_ONLY,
      e,
      "RADIO"
    ];
  }), Object.keys(CONFIG.A5E.skills).forEach((s) => {
    i[`flags.a5e.effects.rollMode.skillCheck.${s}`] = [
      0,
      We.OVERRIDE_ONLY,
      e,
      "RADIO"
    ];
  }), i["flags.a5e.effects.damageImmunities.all"] = [[], We.CUSTOM_ONLY, null, "NONE"], i["flags.a5e.effects.damageResistances.all"] = [[], We.CUSTOM_ONLY, null, "NONE"], i["flags.a5e.effects.damageVulnerabilities.all"] = [[], We.CUSTOM_ONLY, null, "NONE"], i["flags.a5e.effects.conditionImmunities.all"] = [[], We.CUSTOM_ONLY, null, "NONE"];
  const t = Object.entries(CONFIG.A5E.conditions);
  i["flags.a5e.effects.statusConditions"] = [
    [],
    We.CUSTOM_ONLY,
    t,
    "CHECKBOX"
  ], i["@token.width"] = [1, We.OVERRIDE_ONLY], i["@token.height"] = [1, We.OVERRIDE_ONLY], i["@token.texture.src"] = ["", We.OVERRIDE_ONLY], i["@token.texture.scaleX"] = [1, We.OVERRIDE_ONLY], i["@token.texture.scaleY"] = [1, We.OVERRIDE_ONLY], i["@token.light.alpha"] = [0.5, We.OVERRIDE_ONLY], i["@token.light.angle"] = [360, We.OVERRIDE_ONLY], i["@token.light.animation.intensity"] = [5, We.OVERRIDE_ONLY], i["@token.light.animation.reverse"] = [!1, We.OVERRIDE_ONLY], i["@token.light.animation.speed"] = [5, We.OVERRIDE_ONLY], i["@token.light.animation.type"] = [null, We.OVERRIDE_ONLY], i["@token.light.attenuation"] = [0.5, We.OVERRIDE_ONLY], i["@token.light.bright"] = [0, We.OVERRIDE_ONLY], i["@token.light.color"] = [null, We.OVERRIDE_ONLY], i["@token.light.coloration"] = [1, We.OVERRIDE_ONLY], i["@token.light.contrast"] = [0, We.OVERRIDE_ONLY], i["@token.light.darkness.min"] = [0, We.OVERRIDE_ONLY], i["@token.light.darkness.max"] = [1, We.OVERRIDE_ONLY], i["@token.light.dim"] = [0, We.OVERRIDE_ONLY], i["@token.light.luminosity"] = [0.5, We.OVERRIDE_ONLY], i["@token.light.negative"] = [
    !1,
    We.OVERRIDE_ONLY,
    [
      [!0, "Yes"],
      [!1, "No"]
    ],
    "RADIO"
  ], i["@token.light.saturation"] = [0, We.OVERRIDE_ONLY], i["@token.light.shadows"] = [0, We.OVERRIDE_ONLY];
}
u(W1e, "modifySpecialOptions");
function K1e() {
  const i = {};
  Object.entries(CONFIG.Actor.dataModels ?? {}).forEach(([t, s]) => {
    var a;
    i[t] = {
      allOptions: {},
      baseOptions: {},
      derivedOptions: {}
    };
    const n = {
      system: foundry.utils.duplicate(s.schema.initial())
    }, l = foundry.utils.flattenObject(n);
    Object.keys(l).forEach((c) => {
      l[c] = [
        l[c],
        typeof l[c] == "string" ? We.DEFAULT_STRING_MODES : We.DEFAULT_MODES
      ];
    }), U1e(l), Object.keys(l).forEach((c) => {
      const [f, d, p, m, g] = l[c];
      i[t].baseOptions[c] = new Zo(c, f, {
        modes: d ?? We.DEFAULT_MODES,
        options: p ?? [],
        type: m ?? "DEFAULT",
        phase: g ?? "applyAEs"
      });
    });
    const r = {};
    V1e(r), Object.keys(r).forEach((c) => {
      const [f, d, p, m, g] = r[c];
      i[t].derivedOptions[c] = new Zo(c, f, {
        modes: d ?? We.DEFAULT_MODES,
        options: p ?? [],
        type: m ?? "DEFAULT",
        phase: g ?? "afterDerived"
      });
    });
    const o = {};
    W1e(o), Object.keys(o).forEach((c) => {
      const [f, d, p, m, g] = o[c];
      i[t].derivedOptions[c] = new Zo(c, f, {
        modes: d ?? We.DEFAULT_MODES,
        options: p ?? [],
        type: m ?? "DEFAULT",
        phase: g ?? "afterDerived"
      });
    }), i[t].allOptions = {
      ...i[t].baseOptions,
      ...i[t].derivedOptions
    }, i[t].allOptions = Object.fromEntries(
      Object.entries(((a = i[t]) == null ? void 0 : a.allOptions) ?? {}).sort(
        ([, c], [, f]) => c.label.localeCompare(f.label)
      )
    );
  });
  const e = {};
  return Object.keys(game.model.Actor).forEach((t) => {
    var s;
    t !== "base" && Object.entries(((s = i[t]) == null ? void 0 : s.allOptions) ?? {}).forEach(([n, l]) => {
      e[n] = l;
    });
  }), i.all = { allOptions: e }, i;
}
u(K1e, "constructEffectOptions");
function bj(i, e, t) {
  const s = i.slice();
  s[5] = e[t][0], s[6] = e[t][1];
  const n = (
    /*attribute*/
    s[6].save.proficient
  );
  s[7] = n;
  const l = (
    /*abilities*/
    s[2][
      /*key*/
      s[5]
    ]
  );
  return s[8] = l, s;
}
u(bj, "get_each_context$f");
function _j(i) {
  var h, _, y, v;
  let e, t, s, n = nl(
    /*attribute*/
    (_ = (h = i[6]) == null ? void 0 : h.check) == null ? void 0 : _.deterministicBonus
  ) + "", l, r, o, a, c, f = nl(
    /*attribute*/
    (v = (y = i[6]) == null ? void 0 : y.save) == null ? void 0 : v.deterministicBonus
  ) + "", d, p, m, g;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("span"), l = Q(n), o = F(), a = E("div"), c = E("span"), d = Q(f), m = F(), b(s, "class", "svelte-1xux4w8"), b(t, "class", "attribute-wrapper__check svelte-1xux4w8"), b(t, "data-tooltip", r = /*abilityLabel*/
      i[8] + " Check Modifier"), b(t, "data-tooltip-direction", "UP"), b(c, "class", "svelte-1xux4w8"), b(a, "class", "attribute-wrapper__save svelte-1xux4w8"), b(a, "data-tooltip", p = /*proficient*/
      i[7] ? `${/*abilityLabel*/
      i[8]} Saving Throw Modifier (Proficient)` : `${/*abilityLabel*/
      i[8]} Saving Throw Modifier`), b(a, "data-tooltip-direction", "UP"), Z(
        a,
        "attribute-wrapper__save--proficient",
        /*proficient*/
        i[7]
      ), b(e, "class", g = "attribute-wrapper attribute-wrapper--" + /*key*/
      i[5] + " svelte-1xux4w8");
    },
    m(k, S) {
      T(k, e, S), A(e, t), A(t, s), A(s, l), A(e, o), A(e, a), A(a, c), A(c, d), A(e, m);
    },
    p(k, S) {
      var D, I, M, L;
      S & /*actorData*/
      2 && n !== (n = nl(
        /*attribute*/
        (I = (D = k[6]) == null ? void 0 : D.check) == null ? void 0 : I.deterministicBonus
      ) + "") && be(l, n), S & /*actorData*/
      2 && r !== (r = /*abilityLabel*/
      k[8] + " Check Modifier") && b(t, "data-tooltip", r), S & /*actorData*/
      2 && f !== (f = nl(
        /*attribute*/
        (L = (M = k[6]) == null ? void 0 : M.save) == null ? void 0 : L.deterministicBonus
      ) + "") && be(d, f), S & /*actorData*/
      2 && p !== (p = /*proficient*/
      k[7] ? `${/*abilityLabel*/
      k[8]} Saving Throw Modifier (Proficient)` : `${/*abilityLabel*/
      k[8]} Saving Throw Modifier`) && b(a, "data-tooltip", p), S & /*Object, actorData*/
      2 && Z(
        a,
        "attribute-wrapper__save--proficient",
        /*proficient*/
        k[7]
      ), S & /*actorData*/
      2 && g !== (g = "attribute-wrapper attribute-wrapper--" + /*key*/
      k[5] + " svelte-1xux4w8") && b(e, "class", g);
    },
    d(k) {
      k && C(e);
    }
  };
}
u(_j, "create_each_block$f");
function Y1e(i) {
  let e, t = ue(Object.entries(
    /*actorData*/
    i[1].abilities ?? {}
  )), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = _j(bj(i, t, n));
  return {
    c() {
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      e = $e();
    },
    m(n, l) {
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(n, l);
      T(n, e, l);
    },
    p(n, [l]) {
      if (l & /*Object, actorData, abilities*/
      6) {
        t = ue(Object.entries(
          /*actorData*/
          n[1].abilities ?? {}
        ));
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = bj(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = _j(o), s[r].c(), s[r].m(e.parentNode, e));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    i: se,
    o: se,
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(Y1e, "create_fragment$K");
function X1e(i, e, t) {
  let s, n, l = se, r = /* @__PURE__ */ u(() => (l(), l = Xt(o, (f) => t(4, n = f)), o), "$$subscribe_actor");
  i.$$.on_destroy.push(() => l());
  let { actor: o } = e;
  r();
  const a = {}, c = CONFIG.A5E.abilities;
  return i.$$set = (f) => {
    "actor" in f && r(t(0, o = f.actor));
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    16 && t(1, s = n == null ? void 0 : n.system);
  }, [o, s, c, a, n];
}
u(X1e, "instance$E");
const NT = class NT extends re {
  constructor(e) {
    super(), oe(this, e, X1e, Y1e, le, { actor: 0, propData: 3 });
  }
  get propData() {
    return this.$$.ctx[3];
  }
};
u(NT, "PartyViewerAttributesSummary");
let Tk = NT;
function J1e(i) {
  var fe, ke, ee, ne, Ee, Pe, ye, me, Ce, Je, Ne;
  let e, t, s = (
    /*actorData*/
    ((fe = i[6]) == null ? void 0 : fe.attributes.hp.value) + ""
  ), n, l, r = (
    /*actorData*/
    ((ke = i[6]) == null ? void 0 : ke.attributes.hp.max) + ""
  ), o, a, c, f, d = (
    /*actorData*/
    ((ee = i[6]) == null ? void 0 : ee.attributes.ac.value) + ""
  ), p, m, g, h = (
    /*actorData*/
    ((ne = i[6]) == null ? void 0 : ne.attributes.maneuverDC) + ""
  ), _, y, v, k = (
    /*actorData*/
    ((Ee = i[6]) == null ? void 0 : Ee.attributes.spellDC) + ""
  ), S, D, I, M = (
    /*actorData*/
    ((ye = (Pe = i[6]) == null ? void 0 : Pe.skills) == null ? void 0 : ye.prc.passive) + ""
  ), L, B, z, q = (
    /*actorData*/
    ((Ce = (me = i[6]) == null ? void 0 : me.skills) == null ? void 0 : Ce.ins.passive) + ""
  ), U, H, V, Y = (
    /*actorData*/
    ((Ne = (Je = i[6]) == null ? void 0 : Je.skills) == null ? void 0 : Ne.inv.passive) + ""
  ), J;
  return {
    c() {
      var Re, ge, je, Be, Ze, Ge;
      e = E("span"), t = E("span"), n = Q(s), l = Q(" / "), o = Q(r), c = F(), f = E("span"), p = Q(d), m = F(), g = E("span"), _ = Q(h), y = F(), v = E("span"), S = Q(k), D = F(), I = E("span"), L = Q(M), B = F(), z = E("span"), U = Q(q), H = F(), V = E("span"), J = Q(Y), b(t, "class", "color-blend"), b(e, "class", "field field--hp field--highlight-hp svelte-1pddho2"), G(
        e,
        "--color-primary-hp-bar",
        /*primaryHPColor*/
        i[3]
      ), G(
        e,
        "--total-hp-percentage",
        /*totalHPPercentage*/
        i[4]
      ), b(e, "data-tooltip", a = /*isBloodied*/
      i[5] ? `${/*$actor*/
      i[2].name} is Bloodied` : null), b(e, "data-tooltip-direction", "UP"), b(f, "class", "field field--ac svelte-1pddho2"), b(g, "class", "field field--maneuver-dc svelte-1pddho2"), b(v, "class", "field field--spell-dc svelte-1pddho2"), b(I, "class", "field field--perception svelte-1pddho2"), Z(
        I,
        "field--highlight",
        /*actorData*/
        ((ge = (Re = i[6]) == null ? void 0 : Re.skills) == null ? void 0 : ge.prc.passive) === /*propData*/
        i[1].highestPassiveScores.prc
      ), b(z, "class", "field field--insight svelte-1pddho2"), Z(
        z,
        "field--highlight",
        /*actorData*/
        ((Be = (je = i[6]) == null ? void 0 : je.skills) == null ? void 0 : Be.ins.passive) === /*propData*/
        i[1].highestPassiveScores.ins
      ), b(V, "class", "field field--investigation svelte-1pddho2"), Z(
        V,
        "field--highlight",
        /*actorData*/
        ((Ge = (Ze = i[6]) == null ? void 0 : Ze.skills) == null ? void 0 : Ge.inv.passive) === /*propData*/
        i[1].highestPassiveScores.inv
      );
    },
    m(Re, ge) {
      T(Re, e, ge), A(e, t), A(t, n), A(t, l), A(t, o), T(Re, c, ge), T(Re, f, ge), A(f, p), T(Re, m, ge), T(Re, g, ge), A(g, _), T(Re, y, ge), T(Re, v, ge), A(v, S), T(Re, D, ge), T(Re, I, ge), A(I, L), T(Re, B, ge), T(Re, z, ge), A(z, U), T(Re, H, ge), T(Re, V, ge), A(V, J);
    },
    p(Re, [ge]) {
      var je, Be, Ze, Ge, Se, _e, we, Fe, xe, vt, ps, As, zs, sn, St, ws, _i;
      ge & /*actorData*/
      64 && s !== (s = /*actorData*/
      ((je = Re[6]) == null ? void 0 : je.attributes.hp.value) + "") && be(n, s), ge & /*actorData*/
      64 && r !== (r = /*actorData*/
      ((Be = Re[6]) == null ? void 0 : Be.attributes.hp.max) + "") && be(o, r), ge & /*primaryHPColor*/
      8 && G(
        e,
        "--color-primary-hp-bar",
        /*primaryHPColor*/
        Re[3]
      ), ge & /*totalHPPercentage*/
      16 && G(
        e,
        "--total-hp-percentage",
        /*totalHPPercentage*/
        Re[4]
      ), ge & /*isBloodied, $actor*/
      36 && a !== (a = /*isBloodied*/
      Re[5] ? `${/*$actor*/
      Re[2].name} is Bloodied` : null) && b(e, "data-tooltip", a), ge & /*actorData*/
      64 && d !== (d = /*actorData*/
      ((Ze = Re[6]) == null ? void 0 : Ze.attributes.ac.value) + "") && be(p, d), ge & /*actorData*/
      64 && h !== (h = /*actorData*/
      ((Ge = Re[6]) == null ? void 0 : Ge.attributes.maneuverDC) + "") && be(_, h), ge & /*actorData*/
      64 && k !== (k = /*actorData*/
      ((Se = Re[6]) == null ? void 0 : Se.attributes.spellDC) + "") && be(S, k), ge & /*actorData*/
      64 && M !== (M = /*actorData*/
      ((we = (_e = Re[6]) == null ? void 0 : _e.skills) == null ? void 0 : we.prc.passive) + "") && be(L, M), ge & /*actorData, propData*/
      66 && Z(
        I,
        "field--highlight",
        /*actorData*/
        ((xe = (Fe = Re[6]) == null ? void 0 : Fe.skills) == null ? void 0 : xe.prc.passive) === /*propData*/
        Re[1].highestPassiveScores.prc
      ), ge & /*actorData*/
      64 && q !== (q = /*actorData*/
      ((ps = (vt = Re[6]) == null ? void 0 : vt.skills) == null ? void 0 : ps.ins.passive) + "") && be(U, q), ge & /*actorData, propData*/
      66 && Z(
        z,
        "field--highlight",
        /*actorData*/
        ((zs = (As = Re[6]) == null ? void 0 : As.skills) == null ? void 0 : zs.ins.passive) === /*propData*/
        Re[1].highestPassiveScores.ins
      ), ge & /*actorData*/
      64 && Y !== (Y = /*actorData*/
      ((St = (sn = Re[6]) == null ? void 0 : sn.skills) == null ? void 0 : St.inv.passive) + "") && be(J, Y), ge & /*actorData, propData*/
      66 && Z(
        V,
        "field--highlight",
        /*actorData*/
        ((_i = (ws = Re[6]) == null ? void 0 : ws.skills) == null ? void 0 : _i.inv.passive) === /*propData*/
        Re[1].highestPassiveScores.inv
      );
    },
    i: se,
    o: se,
    d(Re) {
      Re && (C(e), C(c), C(f), C(m), C(g), C(y), C(v), C(D), C(I), C(B), C(z), C(H), C(V));
    }
  };
}
u(J1e, "create_fragment$J");
function Z1e(i) {
  return `${i}%`;
}
u(Z1e, "convertToPercentage");
function Q1e(i, e, t) {
  let s, n, l, r, o, a, c = se, f = /* @__PURE__ */ u(() => (c(), c = Xt(d, (h) => t(2, a = h)), d), "$$subscribe_actor");
  i.$$.on_destroy.push(() => c());
  let { actor: d } = e;
  f();
  let { propData: p = {} } = e;
  function m(h) {
    const _ = Math.min(h.value / h.max * 100, 100);
    return `hsl(${Math.round(_)}, 50%, 35%)`;
  }
  u(m, "calculatePrimaryHPColor");
  function g(h) {
    const _ = h.temp || 0;
    return Math.min((h.value + (h.temp || 0)) / (h.max + _) * 100, 100);
  }
  return u(g, "calculateTotalHPPercentage"), i.$$set = (h) => {
    "actor" in h && f(t(0, d = h.actor)), "propData" in h && t(1, p = h.propData);
  }, i.$$.update = () => {
    var h, _, y;
    i.$$.dirty & /*$actor*/
    4 && t(6, s = a == null ? void 0 : a.system), i.$$.dirty & /*$actor*/
    4 && t(5, n = ((h = a == null ? void 0 : a.system) == null ? void 0 : h.attributes.hp.max) / 2 >= ((_ = a == null ? void 0 : a.system) == null ? void 0 : _.attributes.hp.value)), i.$$.dirty & /*$actor*/
    4 && t(7, l = (y = a == null ? void 0 : a.system) == null ? void 0 : y.attributes.hp), i.$$.dirty & /*hp*/
    128 && t(4, r = Z1e(g(l))), i.$$.dirty & /*hp*/
    128 && t(3, o = m(l));
  }, [
    d,
    p,
    a,
    o,
    r,
    n,
    s,
    l
  ];
}
u(Q1e, "instance$D");
const jT = class jT extends re {
  constructor(e) {
    super(), oe(this, e, Q1e, J1e, le, { actor: 0, propData: 1 });
  }
};
u(jT, "PartyViewerCoreSummary");
let xp = jT;
function x1e(i) {
  let e = K("A5E.None") + "", t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p: se,
    d(s) {
      s && C(t);
    }
  };
}
u(x1e, "create_else_block$5");
function ebe(i) {
  let e;
  return {
    c() {
      e = Q(
        /*knownLanguages*/
        i[1]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*knownLanguages*/
      2 && be(
        e,
        /*knownLanguages*/
        t[1]
      );
    },
    d(t) {
      t && C(e);
    }
  };
}
u(ebe, "create_if_block$h");
function tbe(i) {
  let e;
  function t(l, r) {
    return (
      /*knownLanguages*/
      l[1] ? ebe : x1e
    );
  }
  u(t, "select_block_type");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("span"), n.c(), b(e, "class", "field field--languages svelte-1dp0j00");
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, [r]) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    i: se,
    o: se,
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(tbe, "create_fragment$I");
function sbe(i, e, t) {
  let s, n, l, r = se, o = /* @__PURE__ */ u(() => (r(), r = Xt(a, (d) => t(4, l = d)), a), "$$subscribe_actor");
  i.$$.on_destroy.push(() => r());
  let { actor: a } = e;
  o();
  const c = {}, { languages: f } = CONFIG.A5E;
  return i.$$set = (d) => {
    "actor" in d && o(t(0, a = d.actor));
  }, i.$$.update = () => {
    var d;
    i.$$.dirty & /*$actor*/
    16 && t(3, s = (l == null ? void 0 : l.system) ?? {}), i.$$.dirty & /*actorData*/
    8 && t(1, n = (((d = s == null ? void 0 : s.proficiencies) == null ? void 0 : d.languages) ?? []).map((p) => f[p] ?? p).sort((p, m) => p.localeCompare(m)).join(", "));
  }, [a, n, c, s, l];
}
u(sbe, "instance$C");
const LT = class LT extends re {
  constructor(e) {
    super(), oe(this, e, sbe, tbe, le, { actor: 0, propData: 2 });
  }
  get propData() {
    return this.$$.ctx[2];
  }
};
u(LT, "PartyViewerLanguagesSummary");
let Ok = LT;
function yj(i, e, t) {
  const s = i.slice();
  return s[9] = e[t][0], s[10] = e[t][1].current, s[11] = e[t][1].max, s;
}
u(yj, "get_each_context$e");
function nbe(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = "No resources to display", b(e, "class", "field field--no-resources svelte-1pav9z3");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    d(t) {
      t && C(e);
    }
  };
}
u(nbe, "create_else_block_5");
function ibe(i) {
  let e, t, s, n, l, r = (
    /*propData*/
    i[1].partyHasInspiration && vj(i)
  ), o = (
    /*propData*/
    i[1].partyHasExertionPool && kj(i)
  ), a = (
    /*propData*/
    i[1].partyHasArtifactCharges && wj(i)
  ), c = (
    /*propData*/
    i[1].partyHasSpellPointPool && $j(i)
  ), f = (
    /*propData*/
    i[1].highestSpellSlotLevel && Aj(i)
  );
  return {
    c() {
      r && r.c(), e = F(), o && o.c(), t = F(), a && a.c(), s = F(), c && c.c(), n = F(), f && f.c(), l = $e();
    },
    m(d, p) {
      r && r.m(d, p), T(d, e, p), o && o.m(d, p), T(d, t, p), a && a.m(d, p), T(d, s, p), c && c.m(d, p), T(d, n, p), f && f.m(d, p), T(d, l, p);
    },
    p(d, p) {
      /*propData*/
      d[1].partyHasInspiration ? r ? r.p(d, p) : (r = vj(d), r.c(), r.m(e.parentNode, e)) : r && (r.d(1), r = null), /*propData*/
      d[1].partyHasExertionPool ? o ? o.p(d, p) : (o = kj(d), o.c(), o.m(t.parentNode, t)) : o && (o.d(1), o = null), /*propData*/
      d[1].partyHasArtifactCharges ? a ? a.p(d, p) : (a = wj(d), a.c(), a.m(s.parentNode, s)) : a && (a.d(1), a = null), /*propData*/
      d[1].partyHasSpellPointPool ? c ? c.p(d, p) : (c = $j(d), c.c(), c.m(n.parentNode, n)) : c && (c.d(1), c = null), /*propData*/
      d[1].highestSpellSlotLevel ? f ? f.p(d, p) : (f = Aj(d), f.c(), f.m(l.parentNode, l)) : f && (f.d(1), f = null);
    },
    d(d) {
      d && (C(e), C(t), C(s), C(n), C(l)), r && r.d(d), o && o.d(d), a && a.d(d), c && c.d(d), f && f.d(d);
    }
  };
}
u(ibe, "create_if_block$g");
function vj(i) {
  let e;
  function t(l, r) {
    var o;
    return (
      /*actorData*/
      (o = l[7]) != null && o.attributes.inspiration ? rbe : lbe
    );
  }
  u(t, "select_block_type_1");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("span"), n.c(), b(e, "class", "field field--inspiration svelte-1pav9z3");
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(vj, "create_if_block_10$1");
function lbe(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "cross fa-solid fa-xmark svelte-1pav9z3"), b(e, "data-tooltip", t = /*$actor*/
      i[2].name + " does not have inspiration."), b(e, "data-tooltip-direction", "UP");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*$actor*/
      4 && t !== (t = /*$actor*/
      s[2].name + " does not have inspiration.") && b(e, "data-tooltip", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(lbe, "create_else_block_4");
function rbe(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "check fa-solid fa-circle-check svelte-1pav9z3"), b(e, "data-tooltip", t = /*$actor*/
      i[2].name + " has inspiration."), b(e, "data-tooltip-direction", "UP");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*$actor*/
      4 && t !== (t = /*$actor*/
      s[2].name + " has inspiration.") && b(e, "data-tooltip", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(rbe, "create_if_block_11");
function kj(i) {
  let e;
  function t(l, r) {
    return (
      /*showExertion*/
      l[5] ? abe : obe
    );
  }
  u(t, "select_block_type_2");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("span"), n.c(), b(e, "class", "field field--exertion svelte-1pav9z3");
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(kj, "create_if_block_8$2");
function obe(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "cross fa-solid fa-xmark svelte-1pav9z3"), b(e, "data-tooltip", t = /*$actor*/
      i[2].name + " does not have an exertion pool."), b(e, "data-tooltip-direction", "UP");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*$actor*/
      4 && t !== (t = /*$actor*/
      s[2].name + " does not have an exertion pool.") && b(e, "data-tooltip", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(obe, "create_else_block_3");
function abe(i) {
  var r, o, a, c;
  let e = (
    /*actorData*/
    ((o = (r = i[7]) == null ? void 0 : r.attributes.exertion) == null ? void 0 : o.current) + ""
  ), t, s, n = (
    /*actorData*/
    ((c = (a = i[7]) == null ? void 0 : a.attributes.exertion) == null ? void 0 : c.max) + ""
  ), l;
  return {
    c() {
      t = Q(e), s = Q(" / "), l = Q(n);
    },
    m(f, d) {
      T(f, t, d), T(f, s, d), T(f, l, d);
    },
    p(f, d) {
      var p, m, g, h;
      d & /*actorData*/
      128 && e !== (e = /*actorData*/
      ((m = (p = f[7]) == null ? void 0 : p.attributes.exertion) == null ? void 0 : m.current) + "") && be(t, e), d & /*actorData*/
      128 && n !== (n = /*actorData*/
      ((h = (g = f[7]) == null ? void 0 : g.attributes.exertion) == null ? void 0 : h.max) + "") && be(l, n);
    },
    d(f) {
      f && (C(t), C(s), C(l));
    }
  };
}
u(abe, "create_if_block_9$2");
function wj(i) {
  let e;
  function t(l, r) {
    return (
      /*showArtifactCharges*/
      l[6] ? ube : cbe
    );
  }
  u(t, "select_block_type_3");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("span"), n.c(), b(e, "class", "field field--artifact-charges svelte-1pav9z3");
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && C(e), n.d();
    }
  };
}
u(wj, "create_if_block_6$2");
function cbe(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "cross fa-solid fa-xmark svelte-1pav9z3"), b(e, "data-tooltip", t = /*$actor*/
      i[2].name + " does not have artifact charges."), b(e, "data-tooltip-direction", "UP");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*$actor*/
      4 && t !== (t = /*$actor*/
      s[2].name + " does not have artifact charges.") && b(e, "data-tooltip", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(cbe, "create_else_block_2");
function ube(i) {
  var r, o;
  let e = (
    /*actorData*/
    ((r = i[7]) == null ? void 0 : r.spellResources.artifactCharges.current) + ""
  ), t, s, n = (
    /*actorData*/
    ((o = i[7]) == null ? void 0 : o.spellResources.artifactCharges.max) + ""
  ), l;
  return {
    c() {
      t = Q(e), s = Q(" / "), l = Q(n);
    },
    m(a, c) {
      T(a, t, c), T(a, s, c), T(a, l, c);
    },
    p(a, c) {
      var f, d;
      c & /*actorData*/
      128 && e !== (e = /*actorData*/
      ((f = a[7]) == null ? void 0 : f.spellResources.artifactCharges.current) + "") && be(t, e), c & /*actorData*/
      128 && n !== (n = /*actorData*/
      ((d = a[7]) == null ? void 0 : d.spellResources.artifactCharges.max) + "") && be(l, n);
    },
    d(a) {
      a && (C(t), C(s), C(l));
    }
  };
}
u(ube, "create_if_block_7$2");
function $j(i) {
  let e;
  function t(l, r) {
    return (
      /*showSpellPoints*/
      l[4] ? dbe : fbe
    );
  }
  u(t, "select_block_type_4");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("span"), n.c(), b(e, "class", "field field--spell-points svelte-1pav9z3");
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && C(e), n.d();
    }
  };
}
u($j, "create_if_block_4$4");
function fbe(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "cross fa-solid fa-xmark svelte-1pav9z3"), b(e, "data-tooltip", t = /*$actor*/
      i[2].name + " does not have a spell point pool."), b(e, "data-tooltip-direction", "UP");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*$actor*/
      4 && t !== (t = /*$actor*/
      s[2].name + " does not have a spell point pool.") && b(e, "data-tooltip", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(fbe, "create_else_block_1$1");
function dbe(i) {
  var r, o;
  let e = (
    /*actorData*/
    ((r = i[7]) == null ? void 0 : r.spellResources.points.current) + ""
  ), t, s, n = (
    /*actorData*/
    ((o = i[7]) == null ? void 0 : o.spellResources.points.max) + ""
  ), l;
  return {
    c() {
      t = Q(e), s = Q(" / "), l = Q(n);
    },
    m(a, c) {
      T(a, t, c), T(a, s, c), T(a, l, c);
    },
    p(a, c) {
      var f, d;
      c & /*actorData*/
      128 && e !== (e = /*actorData*/
      ((f = a[7]) == null ? void 0 : f.spellResources.points.current) + "") && be(t, e), c & /*actorData*/
      128 && n !== (n = /*actorData*/
      ((d = a[7]) == null ? void 0 : d.spellResources.points.max) + "") && be(l, n);
    },
    d(a) {
      a && (C(t), C(s), C(l));
    }
  };
}
u(dbe, "create_if_block_5$3");
function Aj(i) {
  var n;
  let e, t = ue(Object.entries(
    /*actorData*/
    ((n = i[7]) == null ? void 0 : n.spellResources.slots) ?? {}
  )), s = [];
  for (let l = 0; l < t.length; l += 1)
    s[l] = Sj(yj(i, t, l));
  return {
    c() {
      e = E("ol");
      for (let l = 0; l < s.length; l += 1)
        s[l].c();
      b(e, "class", "spell-slots svelte-1pav9z3");
    },
    m(l, r) {
      T(l, e, r);
      for (let o = 0; o < s.length; o += 1)
        s[o] && s[o].m(e, null);
    },
    p(l, r) {
      var o;
      if (r & /*propData, Object, actorData, $actor, spellLevels*/
      390) {
        t = ue(Object.entries(
          /*actorData*/
          ((o = l[7]) == null ? void 0 : o.spellResources.slots) ?? {}
        ));
        let a;
        for (a = 0; a < t.length; a += 1) {
          const c = yj(l, t, a);
          s[a] ? s[a].p(c, r) : (s[a] = Sj(c), s[a].c(), s[a].m(e, null));
        }
        for (; a < s.length; a += 1)
          s[a].d(1);
        s.length = t.length;
      }
    },
    d(l) {
      l && C(e), Le(s, l);
    }
  };
}
u(Aj, "create_if_block_1$c");
function Ej(i) {
  let e, t;
  function s(r, o) {
    return (
      /*max*/
      r[11] && /*max*/
      r[11] > 0 ? mbe : pbe
    );
  }
  u(s, "select_block_type_5");
  let n = s(i), l = n(i);
  return {
    c() {
      e = E("li"), l.c(), t = F(), b(e, "class", "field field--spell-slot svelte-1pav9z3"), Z(
        e,
        "field--narrow-spell-slot",
        /*propData*/
        i[1].highestSpellSlotLevel >= 8
      );
    },
    m(r, o) {
      T(r, e, o), l.m(e, null), A(e, t);
    },
    p(r, o) {
      n === (n = s(r)) && l ? l.p(r, o) : (l.d(1), l = n(r), l && (l.c(), l.m(e, t))), o & /*propData*/
      2 && Z(
        e,
        "field--narrow-spell-slot",
        /*propData*/
        r[1].highestSpellSlotLevel >= 8
      );
    },
    d(r) {
      r && C(e), l.d();
    }
  };
}
u(Ej, "create_if_block_2$7");
function pbe(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "cross fa-solid fa-xmark svelte-1pav9z3"), b(e, "data-tooltip", t = /*$actor*/
      i[2].name + " has no spell slots of " + K(
        /*spellLevels*/
        i[8][
          /*level*/
          i[9]
        ]
      ).toLowerCase() + "."), b(e, "data-tooltip-direction", "UP");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*$actor, actorData*/
      132 && t !== (t = /*$actor*/
      s[2].name + " has no spell slots of " + K(
        /*spellLevels*/
        s[8][
          /*level*/
          s[9]
        ]
      ).toLowerCase() + ".") && b(e, "data-tooltip", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(pbe, "create_else_block$4");
function mbe(i) {
  let e = (
    /*current*/
    i[10] + ""
  ), t;
  return {
    c() {
      t = Q(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*actorData*/
      128 && e !== (e = /*current*/
      s[10] + "") && be(t, e);
    },
    d(s) {
      s && C(t);
    }
  };
}
u(mbe, "create_if_block_3$4");
function Sj(i) {
  let e, t = (
    /*level*/
    i[9] && /*level*/
    i[9] !== "0" && /*level*/
    i[9] <= /*propData*/
    i[1].highestSpellSlotLevel && Ej(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*level*/
      s[9] && /*level*/
      s[9] !== "0" && /*level*/
      s[9] <= /*propData*/
      s[1].highestSpellSlotLevel ? t ? t.p(s, n) : (t = Ej(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && C(e), t && t.d(s);
    }
  };
}
u(Sj, "create_each_block$e");
function hbe(i) {
  let e;
  function t(l, r) {
    return (
      /*showResources*/
      l[3] ? ibe : nbe
    );
  }
  u(t, "select_block_type");
  let s = t(i), n = s(i);
  return {
    c() {
      n.c(), e = $e();
    },
    m(l, r) {
      n.m(l, r), T(l, e, r);
    },
    p(l, [r]) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e.parentNode, e)));
    },
    i: se,
    o: se,
    d(l) {
      l && C(e), n.d(l);
    }
  };
}
u(hbe, "create_fragment$H");
function gbe(i) {
  var e, t, s;
  return (s = (t = (e = i == null ? void 0 : i.system) == null ? void 0 : e.spellResources) == null ? void 0 : t.artifactCharges) == null ? void 0 : s.max;
}
u(gbe, "hasArtifactCharges");
function bbe(i) {
  var e, t;
  return (t = (e = i == null ? void 0 : i.system) == null ? void 0 : e.attributes.exertion) == null ? void 0 : t.max;
}
u(bbe, "hasExertionPool");
function _be(i) {
  var e, t, s;
  return (s = (t = (e = i == null ? void 0 : i.system) == null ? void 0 : e.spellResources) == null ? void 0 : t.points) == null ? void 0 : s.max;
}
u(_be, "hasSpellPoints");
function ybe(i, e, t) {
  let s, n, l, r, o, a, c = se, f = /* @__PURE__ */ u(() => (c(), c = Xt(d, (g) => t(2, a = g)), d), "$$subscribe_actor");
  i.$$.on_destroy.push(() => c());
  let { actor: d } = e;
  f();
  let { propData: p = {} } = e;
  const { spellLevels: m } = CONFIG.A5E;
  return i.$$set = (g) => {
    "actor" in g && f(t(0, d = g.actor)), "propData" in g && t(1, p = g.propData);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    4 && t(7, s = a == null ? void 0 : a.system), i.$$.dirty & /*$actor*/
    4 && t(6, n = gbe(a)), i.$$.dirty & /*$actor*/
    4 && t(5, l = bbe(a)), i.$$.dirty & /*$actor*/
    4 && t(4, r = _be(a)), i.$$.dirty & /*propData*/
    2 && t(3, o = p.partyHasArtifactCharges || p.partyHasExertionPool || p.partyHasInspiration || p.partyHasSpellPointPool || p.highestSpellSlotLevel);
  }, [
    d,
    p,
    a,
    o,
    r,
    l,
    n,
    s,
    m
  ];
}
u(ybe, "instance$B");
const BT = class BT extends re {
  constructor(e) {
    super(), oe(this, e, ybe, hbe, le, { actor: 0, propData: 1 });
  }
};
u(BT, "PartyViewerResourceSummary");
let Dk = BT;
function Cj(i, e, t) {
  const s = i.slice();
  return s[4] = e[t], s;
}
u(Cj, "get_each_context$d");
function Tj(i) {
  var l, r;
  let e, t = (
    /*actorData*/
    ((l = i[1]) != null && l.currency ? (
      /*actorData*/
      (r = i[1]) == null ? void 0 : r.currency[
        /*denomination*/
        i[4]
      ]
    ) : 0) + ""
  ), s, n;
  return {
    c() {
      e = E("span"), s = Q(t), n = F(), b(e, "class", "field field--" + /*denomination*/
      i[4] + " svelte-1fazaa5");
    },
    m(o, a) {
      T(o, e, a), A(e, s), A(e, n);
    },
    p(o, a) {
      var c, f;
      a & /*actorData*/
      2 && t !== (t = /*actorData*/
      ((c = o[1]) != null && c.currency ? (
        /*actorData*/
        (f = o[1]) == null ? void 0 : f.currency[
          /*denomination*/
          o[4]
        ]
      ) : 0) + "") && be(s, t);
    },
    d(o) {
      o && C(e);
    }
  };
}
u(Tj, "create_each_block$d");
function vbe(i) {
  let e, t = ue(["pp", "gp", "ep", "sp", "cp"]), s = [];
  for (let n = 0; n < 5; n += 1)
    s[n] = Tj(Cj(i, t, n));
  return {
    c() {
      for (let n = 0; n < 5; n += 1)
        s[n].c();
      e = $e();
    },
    m(n, l) {
      for (let r = 0; r < 5; r += 1)
        s[r] && s[r].m(n, l);
      T(n, e, l);
    },
    p(n, [l]) {
      if (l & /*actorData*/
      2) {
        t = ue(["pp", "gp", "ep", "sp", "cp"]);
        let r;
        for (r = 0; r < 5; r += 1) {
          const o = Cj(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = Tj(o), s[r].c(), s[r].m(e.parentNode, e));
        }
        for (; r < 5; r += 1)
          s[r].d(1);
      }
    },
    i: se,
    o: se,
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(vbe, "create_fragment$G");
function kbe(i, e, t) {
  let s, n, l = se, r = /* @__PURE__ */ u(() => (l(), l = Xt(o, (c) => t(3, n = c)), o), "$$subscribe_actor");
  i.$$.on_destroy.push(() => l());
  let { actor: o } = e;
  r();
  const a = {};
  return i.$$set = (c) => {
    "actor" in c && r(t(0, o = c.actor));
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    8 && t(1, s = (n == null ? void 0 : n.system) ?? {});
  }, [o, s, a, n];
}
u(kbe, "instance$A");
const qT = class qT extends re {
  constructor(e) {
    super(), oe(this, e, kbe, vbe, le, { actor: 0, propData: 2 });
  }
  get propData() {
    return this.$$.ctx[2];
  }
};
u(qT, "PartyViewerWealthSummary");
let Ik = qT;
function Oj(i) {
  let e, t, s;
  return {
    c() {
      var n, l;
      e = E("img"), b(e, "class", "actor-image svelte-mtsv9e"), ze(e.src, t = /*$actor*/
      (n = i[10]) == null ? void 0 : n.img) || b(e, "src", t), b(e, "alt", s = /*$actor*/
      (l = i[10]) == null ? void 0 : l.name);
    },
    m(n, l) {
      T(n, e, l);
    },
    p(n, l) {
      var r, o;
      l & /*$actor*/
      1024 && !ze(e.src, t = /*$actor*/
      (r = n[10]) == null ? void 0 : r.img) && b(e, "src", t), l & /*$actor*/
      1024 && s !== (s = /*$actor*/
      (o = n[10]) == null ? void 0 : o.name) && b(e, "alt", s);
    },
    d(n) {
      n && C(e);
    }
  };
}
u(Oj, "create_if_block_1$b");
function Dj(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("span"), t = E("button"), b(t, "class", "a5e-button a5e-button--delete delete-button fas fa-trash svelte-mtsv9e"), b(t, "data-tooltip", "Remove Actor from the Party"), b(t, "data-tooltip-direction", "UP"), b(e, "class", "delete-wrapper svelte-mtsv9e");
    },
    m(l, r) {
      T(l, e, r), A(e, t), s || (n = W(
        t,
        "click",
        /*click_handler*/
        i[15]
      ), s = !0);
    },
    p: se,
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Dj, "create_if_block$f");
function wbe(i) {
  var _;
  let e, t, s, n = (
    /*$actor*/
    ((_ = i[10]) == null ? void 0 : _.name) + ""
  ), l, r, o, a, c, f, d, p = (
    /*$showActorImagesInPartyViewer*/
    i[11] && Oj(i)
  );
  var m = (
    /*viewComponent*/
    i[9]
  );
  function g(y, v) {
    return {
      props: {
        actor: (
          /*actor*/
          y[0]
        ),
        propData: {
          highestPassiveScores: (
            /*highestPassiveScores*/
            y[1]
          ),
          highestSpellSlotLevel: (
            /*highestSpellSlotLevel*/
            y[2]
          ),
          partyHasArtifactCharges: (
            /*partyHasArtifactCharges*/
            y[3]
          ),
          partyHasExertionPool: (
            /*partyHasExertionPool*/
            y[4]
          ),
          partyHasInspiration: (
            /*partyHasInspiration*/
            y[5]
          ),
          partyHasSpellPointPool: (
            /*partyHasSpellPointPool*/
            y[6]
          )
        }
      }
    };
  }
  u(g, "switch_props"), m && (o = et(m, g(i)));
  let h = (
    /*isGM*/
    i[13] && !/*partyIsLocked*/
    i[7] && Dj(i)
  );
  return {
    c() {
      e = E("li"), p && p.c(), t = F(), s = E("span"), l = Q(n), r = F(), o && j(o.$$.fragment), a = F(), h && h.c(), b(s, "class", "actor-name svelte-mtsv9e"), b(e, "class", "a5e-item a5e-item--party-member");
    },
    m(y, v) {
      T(y, e, v), p && p.m(e, null), A(e, t), A(e, s), A(s, l), A(e, r), o && R(o, e, null), A(e, a), h && h.m(e, null), c = !0, f || (d = W(
        e,
        "dblclick",
        /*dblclick_handler*/
        i[16]
      ), f = !0);
    },
    p(y, [v]) {
      var k;
      if (/*$showActorImagesInPartyViewer*/
      y[11] ? p ? p.p(y, v) : (p = Oj(y), p.c(), p.m(e, t)) : p && (p.d(1), p = null), (!c || v & /*$actor*/
      1024) && n !== (n = /*$actor*/
      ((k = y[10]) == null ? void 0 : k.name) + "") && be(l, n), v & /*viewComponent*/
      512 && m !== (m = /*viewComponent*/
      y[9])) {
        if (o) {
          ae();
          const S = o;
          O(S.$$.fragment, 1, 0, () => {
            N(S, 1);
          }), ce();
        }
        m ? (o = et(m, g(y)), j(o.$$.fragment), w(o.$$.fragment, 1), R(o, e, a)) : o = null;
      } else if (m) {
        const S = {};
        v & /*actor*/
        1 && (S.actor = /*actor*/
        y[0]), v & /*highestPassiveScores, highestSpellSlotLevel, partyHasArtifactCharges, partyHasExertionPool, partyHasInspiration, partyHasSpellPointPool*/
        126 && (S.propData = {
          highestPassiveScores: (
            /*highestPassiveScores*/
            y[1]
          ),
          highestSpellSlotLevel: (
            /*highestSpellSlotLevel*/
            y[2]
          ),
          partyHasArtifactCharges: (
            /*partyHasArtifactCharges*/
            y[3]
          ),
          partyHasExertionPool: (
            /*partyHasExertionPool*/
            y[4]
          ),
          partyHasInspiration: (
            /*partyHasInspiration*/
            y[5]
          ),
          partyHasSpellPointPool: (
            /*partyHasSpellPointPool*/
            y[6]
          )
        }), o.$set(S);
      }
      /*isGM*/
      y[13] && !/*partyIsLocked*/
      y[7] ? h ? h.p(y, v) : (h = Dj(y), h.c(), h.m(e, null)) : h && (h.d(1), h = null);
    },
    i(y) {
      c || (o && w(o.$$.fragment, y), c = !0);
    },
    o(y) {
      o && O(o.$$.fragment, y), c = !1;
    },
    d(y) {
      y && C(e), p && p.d(), o && N(o), h && h.d(), f = !1, d();
    }
  };
}
u(wbe, "create_fragment$F");
function $be(i, e, t) {
  let s, n, l = se, r = /* @__PURE__ */ u(() => (l(), l = Xt(f, (q) => t(10, n = q)), f), "$$subscribe_actor"), o, a = se, c = /* @__PURE__ */ u(() => (a(), a = Xt(k, (q) => t(11, o = q)), k), "$$subscribe_showActorImagesInPartyViewer");
  i.$$.on_destroy.push(() => l()), i.$$.on_destroy.push(() => a());
  let { actor: f } = e;
  r();
  let { currentViewMode: d = "core" } = e, { highestPassiveScores: p = {} } = e, { highestSpellSlotLevel: m = 0 } = e, { partyHasArtifactCharges: g = !0 } = e, { partyHasExertionPool: h = !0 } = e, { partyHasInspiration: _ = !1 } = e, { partyHasSpellPointPool: y = !0 } = e, { partyIsLocked: v = !1 } = e, { showActorImagesInPartyViewer: k = !0 } = e;
  c();
  function S(q) {
    switch (q) {
      case "attributes":
        return Tk;
      case "core":
        return xp;
      case "languages":
        return Ok;
      case "resources":
        return Dk;
      case "wealth":
        return Ik;
      default:
        return xp;
    }
  }
  u(S, "getViewModeComponent");
  const D = n.uuid, I = ft(), { isGM: M } = game.user, L = f.subscribe((q) => I("actor-updated", D));
  Qt(() => {
    L();
  });
  const B = /* @__PURE__ */ u(() => I("remove-actor", n.uuid), "click_handler"), z = /* @__PURE__ */ u(() => n == null ? void 0 : n.sheet.render(!0), "dblclick_handler");
  return i.$$set = (q) => {
    "actor" in q && r(t(0, f = q.actor)), "currentViewMode" in q && t(14, d = q.currentViewMode), "highestPassiveScores" in q && t(1, p = q.highestPassiveScores), "highestSpellSlotLevel" in q && t(2, m = q.highestSpellSlotLevel), "partyHasArtifactCharges" in q && t(3, g = q.partyHasArtifactCharges), "partyHasExertionPool" in q && t(4, h = q.partyHasExertionPool), "partyHasInspiration" in q && t(5, _ = q.partyHasInspiration), "partyHasSpellPointPool" in q && t(6, y = q.partyHasSpellPointPool), "partyIsLocked" in q && t(7, v = q.partyIsLocked), "showActorImagesInPartyViewer" in q && c(t(8, k = q.showActorImagesInPartyViewer));
  }, i.$$.update = () => {
    i.$$.dirty & /*currentViewMode*/
    16384 && t(9, s = S(d));
  }, [
    f,
    p,
    m,
    g,
    h,
    _,
    y,
    v,
    k,
    s,
    n,
    o,
    I,
    M,
    d,
    B,
    z
  ];
}
u($be, "instance$z");
const GT = class GT extends re {
  constructor(e) {
    super(), oe(this, e, $be, wbe, le, {
      actor: 0,
      currentViewMode: 14,
      highestPassiveScores: 1,
      highestSpellSlotLevel: 2,
      partyHasArtifactCharges: 3,
      partyHasExertionPool: 4,
      partyHasInspiration: 5,
      partyHasSpellPointPool: 6,
      partyIsLocked: 7,
      showActorImagesInPartyViewer: 8
    });
  }
};
u(GT, "PartyViewerActorSummary");
let Pk = GT;
function Abe(i, e, t) {
  const s = i.slice();
  return s[0] = e[t], s;
}
u(Abe, "get_each_context$c");
function Ebe(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${/*attribute*/
      i[0]}`, b(e, "class", "attribute attribute--" + /*attribute*/
      i[0] + " svelte-r6wrb3");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    d(t) {
      t && C(e);
    }
  };
}
u(Ebe, "create_each_block$c");
function Sbe(i) {
  let e, t = ue(["str", "dex", "con", "int", "wis", "cha"]), s = [];
  for (let n = 0; n < 6; n += 1)
    s[n] = Ebe(Abe(i, t, n));
  return {
    c() {
      e = E("header");
      for (let n = 0; n < 6; n += 1)
        s[n].c();
      b(e, "class", "a5e-section-header a5e-section-header--party-viewer");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < 6; r += 1)
        s[r] && s[r].m(e, null);
    },
    p: se,
    i: se,
    o: se,
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(Sbe, "create_fragment$E");
const zT = class zT extends re {
  constructor(e) {
    super(), oe(this, e, null, Sbe, le, {});
  }
};
u(zT, "PartyViewerAttributesHeader");
let Mk = zT;
function Cbe(i) {
  let e;
  return {
    c() {
      e = E("header"), e.innerHTML = '<i class="heading heading--hp fa-solid fa-heart svelte-v8mh4j" data-tooltip="Hit Points" data-tooltip-direction="UP"></i> <i class="heading heading--ac fa-solid fa-shield svelte-v8mh4j" data-tooltip="Armor Class" data-tooltip-direction="UP"></i> <i class="heading heading--maneuver-dc fa-solid fa-hand-fist svelte-v8mh4j" data-tooltip="Maneuver DC" data-tooltip-direction="UP"></i> <i class="heading heading--spell-dc fa-solid fa-wand-sparkles svelte-v8mh4j" data-tooltip="Spell DC" data-tooltip-direction="UP"></i> <i class="heading heading--perception fa-solid fa-eye svelte-v8mh4j" data-tooltip="Passive Perception" data-tooltip-direction="UP"></i> <i class="heading heading--insight fa-solid fa-brain svelte-v8mh4j" data-tooltip="Passive Insight" data-tooltip-direction="UP"></i> <i class="heading heading--investigation fa-solid fa-magnifying-glass svelte-v8mh4j" data-tooltip="Passive Investigation" data-tooltip-direction="UP"></i>', b(e, "class", "a5e-section-header a5e-section-header--party-viewer");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    i: se,
    o: se,
    d(t) {
      t && C(e);
    }
  };
}
u(Cbe, "create_fragment$D");
const HT = class HT extends re {
  constructor(e) {
    super(), oe(this, e, null, Cbe, le, {});
  }
};
u(HT, "PartyViewerCoreHeader");
let em = HT;
function Tbe(i) {
  let e;
  return {
    c() {
      e = E("header"), e.innerHTML = '<h3 class="heading heading--languages svelte-436ftr" data-tooltip="Known Languages" data-tooltip-direction="UP">Languages</h3>', b(e, "class", "a5e-section-header a5e-section-header--party-viewer");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    i: se,
    o: se,
    d(t) {
      t && C(e);
    }
  };
}
u(Tbe, "create_fragment$C");
const UT = class UT extends re {
  constructor(e) {
    super(), oe(this, e, null, Tbe, le, {});
  }
};
u(UT, "PartyViewerLanguagesHeader");
let Fk = UT;
function Ij(i, e, t) {
  const s = i.slice();
  return s[1] = e[t][0], s[2] = e[t][1], s;
}
u(Ij, "get_each_context$b");
function Pj(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "heading heading--inspiration fa-solid fa-dice-d20 svelte-1i2z96d"), b(e, "data-tooltip", "Inspiration"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(Pj, "create_if_block_4$3");
function Mj(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "heading heading--exertion fa-solid fa-dumbbell svelte-1i2z96d"), b(e, "data-tooltip", "Exertion"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(Mj, "create_if_block_3$3");
function Fj(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "heading heading--artifact-charges fa-solid fa-wand-sparkles svelte-1i2z96d"), b(e, "data-tooltip", "Artifact Charges"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(Fj, "create_if_block_2$6");
function Rj(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "heading heading--spell-points fa-solid fa-hand-sparkles svelte-1i2z96d"), b(e, "data-tooltip", "Spell Points"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(Rj, "create_if_block_1$a");
function Nj(i) {
  let e, t = ue(Lj(
    /*propData*/
    i[0]
  )), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = jj(Ij(i, t, n));
  return {
    c() {
      e = E("ol");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "spell-levels svelte-1i2z96d");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*getSpellLevels, propData*/
      1) {
        t = ue(Lj(
          /*propData*/
          n[0]
        ));
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = Ij(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = jj(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(Nj, "create_if_block$e");
function jj(i) {
  let e, t, s = (
    /*spellLevel*/
    i[1] + ""
  ), n, l, r;
  return {
    c() {
      e = E("li"), t = E("span"), n = Q(s), l = F(), G(t, "position", "relative"), G(t, "z-index", "1"), b(e, "class", "spell-level svelte-1i2z96d"), b(e, "data-tooltip", r = `${/*tooltip*/
      i[2]} Spell Slots`), b(e, "data-tooltip-direction", "UP"), Z(
        e,
        "spell-level--narrow",
        /*propData*/
        i[0].highestSpellSlotLevel >= 8
      );
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(t, n), A(e, l);
    },
    p(o, a) {
      a & /*propData*/
      1 && s !== (s = /*spellLevel*/
      o[1] + "") && be(n, s), a & /*propData*/
      1 && r !== (r = `${/*tooltip*/
      o[2]} Spell Slots`) && b(e, "data-tooltip", r), a & /*propData*/
      1 && Z(
        e,
        "spell-level--narrow",
        /*propData*/
        o[0].highestSpellSlotLevel >= 8
      );
    },
    d(o) {
      o && C(e);
    }
  };
}
u(jj, "create_each_block$b");
function Obe(i) {
  let e, t, s, n, l, r = (
    /*propData*/
    i[0].partyHasInspiration && Pj()
  ), o = (
    /*propData*/
    i[0].partyHasExertionPool && Mj()
  ), a = (
    /*propData*/
    i[0].partyHasArtifactCharges && Fj()
  ), c = (
    /*propData*/
    i[0].partyHasSpellPointPool && Rj()
  ), f = (
    /*propData*/
    i[0].highestSpellSlotLevel && Nj(i)
  );
  return {
    c() {
      e = E("header"), r && r.c(), t = F(), o && o.c(), s = F(), a && a.c(), n = F(), c && c.c(), l = F(), f && f.c(), b(e, "class", "a5e-section-header a5e-section-header--party-viewer");
    },
    m(d, p) {
      T(d, e, p), r && r.m(e, null), A(e, t), o && o.m(e, null), A(e, s), a && a.m(e, null), A(e, n), c && c.m(e, null), A(e, l), f && f.m(e, null);
    },
    p(d, [p]) {
      /*propData*/
      d[0].partyHasInspiration ? r || (r = Pj(), r.c(), r.m(e, t)) : r && (r.d(1), r = null), /*propData*/
      d[0].partyHasExertionPool ? o || (o = Mj(), o.c(), o.m(e, s)) : o && (o.d(1), o = null), /*propData*/
      d[0].partyHasArtifactCharges ? a || (a = Fj(), a.c(), a.m(e, n)) : a && (a.d(1), a = null), /*propData*/
      d[0].partyHasSpellPointPool ? c || (c = Rj(), c.c(), c.m(e, l)) : c && (c.d(1), c = null), /*propData*/
      d[0].highestSpellSlotLevel ? f ? f.p(d, p) : (f = Nj(d), f.c(), f.m(e, null)) : f && (f.d(1), f = null);
    },
    i: se,
    o: se,
    d(d) {
      d && C(e), r && r.d(), o && o.d(), a && a.d(), c && c.d(), f && f.d();
    }
  };
}
u(Obe, "create_fragment$B");
function Lj({ highestSpellSlotLevel: i }) {
  return Object.entries(CONFIG.A5E.spellLevels).filter(([e]) => e && e !== "0" && e <= i);
}
u(Lj, "getSpellLevels");
function Dbe(i, e, t) {
  let { propData: s = {} } = e;
  return i.$$set = (n) => {
    "propData" in n && t(0, s = n.propData);
  }, [s];
}
u(Dbe, "instance$y");
const VT = class VT extends re {
  constructor(e) {
    super(), oe(this, e, Dbe, Obe, le, { propData: 0 });
  }
};
u(VT, "PartyViewerResourceHeader");
let Rk = VT;
function Ibe(i, e, t) {
  const s = i.slice();
  return s[0] = e[t], s;
}
u(Ibe, "get_each_context$a");
function Pbe(i) {
  let e;
  return {
    c() {
      e = E("h3"), e.textContent = `${/*denomination*/
      i[0]} `, b(e, "class", "heading heading--" + /*denomination*/
      i[0] + " svelte-1hl4xyk"), b(e, "data-tooltip", "A5E.effects.keys.currency." + /*denomination*/
      i[0]), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    d(t) {
      t && C(e);
    }
  };
}
u(Pbe, "create_each_block$a");
function Mbe(i) {
  let e, t = ue(["pp", "gp", "ep", "sp", "cp"]), s = [];
  for (let n = 0; n < 5; n += 1)
    s[n] = Pbe(Ibe(i, t, n));
  return {
    c() {
      e = E("header");
      for (let n = 0; n < 5; n += 1)
        s[n].c();
      b(e, "class", "a5e-section-header a5e-section-header--party-viewer");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < 5; r += 1)
        s[r] && s[r].m(e, null);
    },
    p: se,
    i: se,
    o: se,
    d(n) {
      n && C(e), Le(s, n);
    }
  };
}
u(Mbe, "create_fragment$A");
const WT = class WT extends re {
  constructor(e) {
    super(), oe(this, e, null, Mbe, le, {});
  }
};
u(WT, "PartyViewerWealthHeader");
let Nk = WT;
function Bj(i, e, t) {
  const s = i.slice();
  return s[3] = e[t], s;
}
u(Bj, "get_each_context$9");
function qj(i) {
  let e, t = (
    /*totalPartyWealth*/
    (i[0][
      /*denomination*/
      i[3]
    ] ?? 0) + ""
  ), s, n;
  return {
    c() {
      e = E("span"), s = Q(t), n = F(), b(e, "class", "total total--" + /*denomination*/
      i[3] + " svelte-i3sbac");
    },
    m(l, r) {
      T(l, e, r), A(e, s), A(e, n);
    },
    p(l, r) {
      r & /*totalPartyWealth*/
      1 && t !== (t = /*totalPartyWealth*/
      (l[0][
        /*denomination*/
        l[3]
      ] ?? 0) + "") && be(s, t);
    },
    d(l) {
      l && C(e);
    }
  };
}
u(qj, "create_each_block$9");
function Fbe(i) {
  let e, t, s, n = ue(["pp", "gp", "ep", "sp", "cp"]), l = [];
  for (let r = 0; r < 5; r += 1)
    l[r] = qj(Bj(i, n, r));
  return {
    c() {
      e = E("footer"), t = E("h3"), t.textContent = "Party Total", s = F();
      for (let r = 0; r < 5; r += 1)
        l[r].c();
      b(t, "class", "heading svelte-i3sbac"), Z(t, "heading--no-actor-image", !/*$showActorImagesInPartyViewer*/
      i[2]), b(e, "class", "wealth-footer svelte-i3sbac");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(e, s);
      for (let a = 0; a < 5; a += 1)
        l[a] && l[a].m(e, null);
    },
    p(r, [o]) {
      if (o & /*$showActorImagesInPartyViewer*/
      4 && Z(t, "heading--no-actor-image", !/*$showActorImagesInPartyViewer*/
      r[2]), o & /*totalPartyWealth*/
      1) {
        n = ue(["pp", "gp", "ep", "sp", "cp"]);
        let a;
        for (a = 0; a < 5; a += 1) {
          const c = Bj(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = qj(c), l[a].c(), l[a].m(e, null));
        }
        for (; a < 5; a += 1)
          l[a].d(1);
      }
    },
    i: se,
    o: se,
    d(r) {
      r && C(e), Le(l, r);
    }
  };
}
u(Fbe, "create_fragment$z");
function Rbe(i, e, t) {
  let s, n = se, l = /* @__PURE__ */ u(() => (n(), n = Xt(o, (a) => t(2, s = a)), o), "$$subscribe_showActorImagesInPartyViewer");
  i.$$.on_destroy.push(() => n());
  let { totalPartyWealth: r = {} } = e, { showActorImagesInPartyViewer: o = !0 } = e;
  return l(), i.$$set = (a) => {
    "totalPartyWealth" in a && t(0, r = a.totalPartyWealth), "showActorImagesInPartyViewer" in a && l(t(1, o = a.showActorImagesInPartyViewer));
  }, [r, o, s];
}
u(Rbe, "instance$x");
const KT = class KT extends re {
  constructor(e) {
    super(), oe(this, e, Rbe, Fbe, le, {
      totalPartyWealth: 0,
      showActorImagesInPartyViewer: 1
    });
  }
};
u(KT, "PartyViewerWealthFooter");
let jk = KT;
function Gj(i, e, t) {
  const s = i.slice();
  return s[45] = e[t], s;
}
u(Gj, "get_each_context$8");
function Nbe(i) {
  let e;
  return {
    c() {
      e = E("div"), e.textContent = "Drop actors into this window to populate the party.", b(e, "class", "instructions svelte-7f2g8t");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    i: se,
    o: se,
    d(t) {
      t && C(e);
    }
  };
}
u(Nbe, "create_else_block$3");
function jbe(i) {
  let e, t, s, n, l, r, o, a, c, f;
  e = new ie({
    props: {
      $$slots: { default: [Bbe] },
      $$scope: { ctx: i }
    }
  });
  var d = (
    /*getViewModeComponent*/
    i[12](
      /*currentViewMode*/
      i[1]
    )
  );
  function p(y, v) {
    return {
      props: {
        propData: {
          highestSpellSlotLevel: (
            /*highestSpellSlotLevel*/
            y[4]
          ),
          partyHasArtifactCharges: (
            /*partyHasArtifactCharges*/
            y[5]
          ),
          partyHasExertionPool: (
            /*partyHasExertionPool*/
            y[6]
          ),
          partyHasInspiration: (
            /*partyHasInspiration*/
            y[7]
          ),
          partyHasSpellPointPool: (
            /*partyHasSpellPointPool*/
            y[8]
          ),
          partyIsLocked: (
            /*partyIsLocked*/
            y[0]
          ),
          showActorImagesInPartyViewer: (
            /*showActorImagesInPartyViewer*/
            y[21]
          )
        }
      }
    };
  }
  u(p, "switch_props"), d && (n = et(d, p(i)));
  let m = ue(
    /*$partyMembers*/
    i[2] ?? []
  ), g = [];
  for (let y = 0; y < m.length; y += 1)
    g[y] = zj(Gj(i, m, y));
  const h = /* @__PURE__ */ u((y) => O(g[y], 1, 1, () => {
    g[y] = null;
  }), "out");
  let _ = (
    /*currentViewMode*/
    i[1] === "wealth" && Hj(i)
  );
  return {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), n && j(n.$$.fragment), r = F(), o = E("ul");
      for (let y = 0; y < g.length; y += 1)
        g[y].c();
      a = F(), _ && _.c(), c = $e(), G(t, "display", "contents"), G(t, "--a5e-field-wrapper-direction", "row"), G(t, "--a5e-field-wrapper-item-alignment", "center"), G(t, "--a5e-field-wrapper-gap", "0.75rem"), G(t, "--a5e-field-wrapper-margin", "0.375rem 0 0.375rem"), G(t, "--a5e-field-wrapper-padding", "0"), G(t, "--a5e-field-wrapper-wrap", "no-wrap"), G(l, "display", "contents"), G(
        l,
        "--a5e-section-heading-template-areas",
        /*gridAreaDefinition*/
        i[11]
      ), G(
        l,
        "--a5e-section-heading-template-columns",
        /*gridSizeDefinition*/
        i[10]
      ), b(o, "class", "a5e-item-list a5e-item-list--party");
    },
    m(y, v) {
      T(y, t, v), R(e, t, null), T(y, s, v), T(y, l, v), n && R(n, l, null), T(y, r, v), T(y, o, v);
      for (let k = 0; k < g.length; k += 1)
        g[k] && g[k].m(o, null);
      T(y, a, v), _ && _.m(y, v), T(y, c, v), f = !0;
    },
    p(y, v) {
      const k = {};
      if (v[0] & /*partyIsLocked, currentViewMode*/
      3 | v[1] & /*$$scope*/
      131072 && (k.$$scope = { dirty: v, ctx: y }), e.$set(k), v[0] & /*gridAreaDefinition*/
      2048 && G(
        l,
        "--a5e-section-heading-template-areas",
        /*gridAreaDefinition*/
        y[11]
      ), v[0] & /*gridSizeDefinition*/
      1024 && G(
        l,
        "--a5e-section-heading-template-columns",
        /*gridSizeDefinition*/
        y[10]
      ), v[0] & /*currentViewMode*/
      2 && d !== (d = /*getViewModeComponent*/
      y[12](
        /*currentViewMode*/
        y[1]
      ))) {
        if (n) {
          ae();
          const S = n;
          O(S.$$.fragment, 1, 0, () => {
            N(S, 1), C(l);
          }), ce();
        }
        d ? (T(r.parentNode, l, r), n = et(d, p(y)), j(n.$$.fragment), w(n.$$.fragment, 1), R(n, l, null)) : n = null;
      } else if (d) {
        const S = {};
        v[0] & /*highestSpellSlotLevel, partyHasArtifactCharges, partyHasExertionPool, partyHasInspiration, partyHasSpellPointPool, partyIsLocked*/
        497 && (S.propData = {
          highestSpellSlotLevel: (
            /*highestSpellSlotLevel*/
            y[4]
          ),
          partyHasArtifactCharges: (
            /*partyHasArtifactCharges*/
            y[5]
          ),
          partyHasExertionPool: (
            /*partyHasExertionPool*/
            y[6]
          ),
          partyHasInspiration: (
            /*partyHasInspiration*/
            y[7]
          ),
          partyHasSpellPointPool: (
            /*partyHasSpellPointPool*/
            y[8]
          ),
          partyIsLocked: (
            /*partyIsLocked*/
            y[0]
          ),
          showActorImagesInPartyViewer: (
            /*showActorImagesInPartyViewer*/
            y[21]
          )
        }), n.$set(S);
      }
      if (v[0] & /*$partyMembers, currentViewMode, highestPassiveScores, highestSpellSlotLevel, partyHasArtifactCharges, partyHasExertionPool, partyHasInspiration, partyHasSpellPointPool, partyIsLocked, showActorImagesInPartyViewer, updatePartyData, removeActorFromParty, gridAreaDefinition, gridSizeDefinition*/
      2182655) {
        m = ue(
          /*$partyMembers*/
          y[2] ?? []
        );
        let S;
        for (S = 0; S < m.length; S += 1) {
          const D = Gj(y, m, S);
          g[S] ? (g[S].p(D, v), w(g[S], 1)) : (g[S] = zj(D), g[S].c(), w(g[S], 1), g[S].m(o, null));
        }
        for (ae(), S = m.length; S < g.length; S += 1)
          h(S);
        ce();
      }
      /*currentViewMode*/
      y[1] === "wealth" ? _ ? (_.p(y, v), v[0] & /*currentViewMode*/
      2 && w(_, 1)) : (_ = Hj(y), _.c(), w(_, 1), _.m(c.parentNode, c)) : _ && (ae(), O(_, 1, 1, () => {
        _ = null;
      }), ce());
    },
    i(y) {
      if (!f) {
        w(e.$$.fragment, y), n && w(n.$$.fragment, y);
        for (let v = 0; v < m.length; v += 1)
          w(g[v]);
        w(_), f = !0;
      }
    },
    o(y) {
      O(e.$$.fragment, y), n && O(n.$$.fragment, y), g = g.filter(Boolean);
      for (let v = 0; v < g.length; v += 1)
        O(g[v]);
      O(_), f = !1;
    },
    d(y) {
      y && (C(s), C(r), C(o), C(a), C(c)), y && e && C(t), N(e, y), y && n && C(l), n && N(n, y), Le(g, y), _ && _.d(y);
    }
  };
}
u(jbe, "create_if_block$d");
function Lbe(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("button"), b(e, "class", t = "sheet-lock fas " + /*partyIsLocked*/
      (i[0] ? "sheet-lock--locked fa-lock" : "fa-unlock") + " svelte-7f2g8t"), b(e, "data-tooltip", s = /*partyIsLocked*/
      i[0] ? "Unlock this party" : "Lock this party"), b(e, "data-tooltip-direction", "UP");
    },
    m(r, o) {
      T(r, e, o), n || (l = W(
        e,
        "click",
        /*togglePartyLock*/
        i[15]
      ), n = !0);
    },
    p(r, o) {
      o[0] & /*partyIsLocked*/
      1 && t !== (t = "sheet-lock fas " + /*partyIsLocked*/
      (r[0] ? "sheet-lock--locked fa-lock" : "fa-unlock") + " svelte-7f2g8t") && b(e, "class", t), o[0] & /*partyIsLocked*/
      1 && s !== (s = /*partyIsLocked*/
      r[0] ? "Unlock this party" : "Lock this party") && b(e, "data-tooltip", s);
    },
    d(r) {
      r && C(e), n = !1, l();
    }
  };
}
u(Lbe, "create_if_block_2$5");
function Bbe(i) {
  let e, t, s, n, l;
  e = new Ke({
    props: {
      allowDeselect: !1,
      options: (
        /*viewModes*/
        i[17]
      ),
      selected: (
        /*currentViewMode*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[26]
  );
  let r = (
    /*isGM*/
    i[22] && Lbe(i)
  );
  return {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), r && r.c(), n = $e(), G(t, "display", "contents"), G(t, "--radio-group-width", "fit-content");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a[0] & /*currentViewMode*/
      2 && (c.selected = /*currentViewMode*/
      o[1]), e.$set(c), /*isGM*/
      o[22] && r.p(o, a);
    },
    i(o) {
      l || (w(e.$$.fragment, o), l = !0);
    },
    o(o) {
      O(e.$$.fragment, o), l = !1;
    },
    d(o) {
      o && (C(s), C(n)), o && e && C(t), N(e, o), r && r.d(o);
    }
  };
}
u(Bbe, "create_default_slot$h");
function zj(i) {
  let e, t, s;
  return e = new Pk({
    props: {
      actor: (
        /*actor*/
        i[45]
      ),
      currentViewMode: (
        /*currentViewMode*/
        i[1]
      ),
      highestPassiveScores: (
        /*highestPassiveScores*/
        i[3]
      ),
      highestSpellSlotLevel: (
        /*highestSpellSlotLevel*/
        i[4]
      ),
      partyHasArtifactCharges: (
        /*partyHasArtifactCharges*/
        i[5]
      ),
      partyHasExertionPool: (
        /*partyHasExertionPool*/
        i[6]
      ),
      partyHasInspiration: (
        /*partyHasInspiration*/
        i[7]
      ),
      partyHasSpellPointPool: (
        /*partyHasSpellPointPool*/
        i[8]
      ),
      partyIsLocked: (
        /*partyIsLocked*/
        i[0]
      ),
      showActorImagesInPartyViewer: (
        /*showActorImagesInPartyViewer*/
        i[21]
      )
    }
  }), e.$on(
    "actor-updated",
    /*actor_updated_handler*/
    i[27]
  ), e.$on(
    "remove-actor",
    /*remove_actor_handler*/
    i[28]
  ), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(
        t,
        "--grid-areas",
        /*gridAreaDefinition*/
        i[11]
      ), G(
        t,
        "--grid-template",
        /*gridSizeDefinition*/
        i[10]
      );
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      l[0] & /*gridAreaDefinition*/
      2048 && G(
        t,
        "--grid-areas",
        /*gridAreaDefinition*/
        n[11]
      ), l[0] & /*gridSizeDefinition*/
      1024 && G(
        t,
        "--grid-template",
        /*gridSizeDefinition*/
        n[10]
      );
      const r = {};
      l[0] & /*$partyMembers*/
      4 && (r.actor = /*actor*/
      n[45]), l[0] & /*currentViewMode*/
      2 && (r.currentViewMode = /*currentViewMode*/
      n[1]), l[0] & /*highestPassiveScores*/
      8 && (r.highestPassiveScores = /*highestPassiveScores*/
      n[3]), l[0] & /*highestSpellSlotLevel*/
      16 && (r.highestSpellSlotLevel = /*highestSpellSlotLevel*/
      n[4]), l[0] & /*partyHasArtifactCharges*/
      32 && (r.partyHasArtifactCharges = /*partyHasArtifactCharges*/
      n[5]), l[0] & /*partyHasExertionPool*/
      64 && (r.partyHasExertionPool = /*partyHasExertionPool*/
      n[6]), l[0] & /*partyHasInspiration*/
      128 && (r.partyHasInspiration = /*partyHasInspiration*/
      n[7]), l[0] & /*partyHasSpellPointPool*/
      256 && (r.partyHasSpellPointPool = /*partyHasSpellPointPool*/
      n[8]), l[0] & /*partyIsLocked*/
      1 && (r.partyIsLocked = /*partyIsLocked*/
      n[0]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(zj, "create_each_block$8");
function Hj(i) {
  let e, t, s, n;
  return t = new jk({
    props: {
      partyIsLocked: (
        /*partyIsLocked*/
        i[0]
      ),
      totalPartyWealth: (
        /*totalPartyWealth*/
        i[9]
      ),
      showActorImagesInPartyViewer: (
        /*showActorImagesInPartyViewer*/
        i[21]
      )
    }
  }), {
    c() {
      e = E("footer"), s = E("div"), j(t.$$.fragment), G(s, "display", "contents"), G(
        s,
        "--grid-areas",
        /*gridAreaDefinition*/
        i[11]
      ), G(
        s,
        "--grid-template",
        /*gridSizeDefinition*/
        i[10]
      );
    },
    m(l, r) {
      T(l, e, r), A(e, s), R(t, s, null), n = !0;
    },
    p(l, r) {
      r[0] & /*gridAreaDefinition*/
      2048 && G(
        s,
        "--grid-areas",
        /*gridAreaDefinition*/
        l[11]
      ), r[0] & /*gridSizeDefinition*/
      1024 && G(
        s,
        "--grid-template",
        /*gridSizeDefinition*/
        l[10]
      );
      const o = {};
      r[0] & /*partyIsLocked*/
      1 && (o.partyIsLocked = /*partyIsLocked*/
      l[0]), r[0] & /*totalPartyWealth*/
      512 && (o.totalPartyWealth = /*totalPartyWealth*/
      l[9]), t.$set(o);
    },
    i(l) {
      n || (w(t.$$.fragment, l), n = !0);
    },
    o(l) {
      O(t.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(e), N(t);
    }
  };
}
u(Hj, "create_if_block_1$9");
function qbe(i) {
  let e, t, s, n, l, r;
  const o = [jbe, Nbe], a = [];
  function c(f, d) {
    return (
      /*$partyMembers*/
      f[2].length ? 0 : 1
    );
  }
  return u(c, "select_block_type"), t = c(i), s = a[t] = o[t](i), {
    c() {
      e = E("article"), s.c(), b(e, "class", "svelte-7f2g8t");
    },
    m(f, d) {
      T(f, e, d), a[t].m(e, null), n = !0, l || (r = W(
        e,
        "drop",
        /*drop_handler*/
        i[29]
      ), l = !0);
    },
    p(f, d) {
      let p = t;
      t = c(f), t === p ? a[t].p(f, d) : (ae(), O(a[p], 1, 1, () => {
        a[p] = null;
      }), ce(), s = a[t], s ? s.p(f, d) : (s = a[t] = o[t](f), s.c()), w(s, 1), s.m(e, null));
    },
    i(f) {
      n || (w(s), n = !0);
    },
    o(f) {
      O(s), n = !1;
    },
    d(f) {
      f && C(e), a[t].d(), l = !1, r();
    }
  };
}
u(qbe, "create_fragment$y");
function Gbe(i, e) {
  return i.length ? e.isLocked ?? !1 : !1;
}
u(Gbe, "getIsLocked");
function zbe(i, e, t) {
  let s, n, l, r, o, a, c, f, { settings: d, sheet: p } = de("#external").application, { settings: m = d, sheet: g = p } = e;
  function h() {
    return (a ?? []).some((Se) => {
      var we, Fe, xe;
      const _e = Bn(Se);
      return (xe = (Fe = (we = _e == null ? void 0 : _e.system) == null ? void 0 : we.spellResources) == null ? void 0 : Fe.artifactCharges) == null ? void 0 : xe.max;
    });
  }
  u(h, "getAnyMemberHasArtifactCharges");
  function _() {
    return (a ?? []).some((Se) => {
      var we, Fe, xe;
      const _e = Bn(Se);
      return (xe = (Fe = (we = _e == null ? void 0 : _e.system) == null ? void 0 : we.attributes) == null ? void 0 : Fe.exertion) == null ? void 0 : xe.max;
    });
  }
  u(_, "getAnyMemberHasExertionPool");
  function y() {
    return (a ?? []).some((Se) => {
      var we, Fe;
      const _e = Bn(Se);
      return (Fe = (we = _e == null ? void 0 : _e.system) == null ? void 0 : we.attributes) == null ? void 0 : Fe.inspiration;
    });
  }
  u(y, "getAnyMemberHasInspiration");
  function v() {
    return (a ?? []).some((Se) => {
      var we, Fe, xe;
      const _e = Bn(Se);
      return (xe = (Fe = (we = _e == null ? void 0 : _e.system) == null ? void 0 : we.spellResources) == null ? void 0 : Fe.points) == null ? void 0 : xe.max;
    });
  }
  u(v, "getAnyMemberHasSpellPointPool");
  function k(Se) {
    let _e;
    f ? _e = "img name" : _e = "name";
    const we = game.user.isGM && !n ? "delete" : "";
    switch (Se) {
      case "attributes":
        return `"${_e} str dex con int wis cha ${we}"`;
      case "core":
        return `"${_e} hp ac maneuverDC spellDC perception insight investigation ${we}"`;
      case "languages":
        return `"${_e} languages ${we}"`;
      case "resources":
        return S();
      case "wealth":
        return `"${_e} pp gp ep sp cp ${we}"`;
      default:
        return `"${_e} hp ac maneuverDC spellDC perception insight investigation ${we}"`;
    }
  }
  u(k, "getGridAreaDefinition");
  function S() {
    const Se = [];
    return f ? Se.push("img", "name") : Se.push("name"), me && Se.push("inspiration"), ye && Se.push("exertion"), Pe && Se.push("artifactCharges"), Ce && Se.push("spellPoints"), Ee && Se.push("spellSlots"), !Pe && !ye && !Ce && !Ee && Se.push("noResources"), game.user.isGM && !n && Se.push("delete"), `"${Se.join(" ")}"`;
  }
  u(S, "getResourcePanelGridAreaDefinition");
  function D(Se) {
    let _e;
    f ? _e = "1.75rem 1fr" : _e = "1fr";
    const we = game.user.isGM && !n ? "2rem" : "";
    switch (Se) {
      case "attributes":
        return `${_e} repeat(6, 0.5fr) ${we}`;
      case "core":
        return `${_e} 4rem repeat(6, 3rem) ${we}`;
      case "languages":
        return `${_e} 2.5fr ${we}`;
      case "resources":
        return I();
      case "wealth":
        return `${_e} repeat(5, 3.5rem) ${we}`;
      default:
        return `${_e} 4rem repeat(6, 3rem) ${we}`;
    }
  }
  u(D, "getGridSizeDefinition");
  function I() {
    const Se = [];
    f ? Se.push("1.75rem", "1fr") : Se.push("1fr");
    let _e = "1.75rem", we = "3.5rem";
    return Ee >= 8 && (_e = "1.5rem", we = "3.25rem"), me && Se.push(_e), ye && Se.push(we), Pe && Se.push(we), Ce && Se.push(we), Ee && Se.push("min-content"), !Pe && !ye && !Ce && !Ee && Se.push("1fr"), game.user.isGM && !n && Se.push("2rem"), Se.join(" ");
  }
  u(I, "getResourcePanelGridSizeDefinition");
  function M(Se) {
    switch (Se) {
      case "attributes":
        return Mk;
      case "core":
        return em;
      case "languages":
        return Fk;
      case "resources":
        return Rk;
      case "wealth":
        return Nk;
      default:
        return em;
    }
  }
  u(M, "getViewModeComponent");
  function L() {
    return (a ?? []).reduce(
      (Se, _e) => {
        var Fe;
        const we = Bn(_e);
        return Object.entries(((Fe = we == null ? void 0 : we.system) == null ? void 0 : Fe.skills) ?? {}).forEach(([xe, { passive: vt }]) => {
          Se[xe] ?? (Se[xe] = 0), vt > Se[xe] && (Se[xe] = vt);
        }), Se;
      },
      {}
    );
  }
  u(L, "getHighestPassiveScoresForParty");
  function B() {
    return (a ?? []).reduce(
      (Se, _e) => {
        var Fe, xe;
        const we = Bn(_e);
        return Object.entries(((xe = (Fe = we == null ? void 0 : we.system) == null ? void 0 : Fe.spellResources) == null ? void 0 : xe.slots) ?? {}).forEach(([vt, { max: ps }]) => {
          vt > Se && ps && ps > 0 && (Se = vt);
        }), Se;
      },
      0
    );
  }
  u(B, "getHighestSpellSlotLevel");
  function z() {
    return (a ?? []).reduce(
      (Se, _e) => {
        var xe;
        const we = Bn(_e), Fe = (xe = we == null ? void 0 : we.system) == null ? void 0 : xe.currency;
        return Se.cp += (Fe == null ? void 0 : Fe.cp) ?? 0, Se.sp += (Fe == null ? void 0 : Fe.sp) ?? 0, Se.ep += (Fe == null ? void 0 : Fe.ep) ?? 0, Se.gp += (Fe == null ? void 0 : Fe.gp) ?? 0, Se.pp += (Fe == null ? void 0 : Fe.pp) ?? 0, Se;
      },
      { cp: 0, sp: 0, ep: 0, gp: 0, pp: 0 }
    );
  }
  u(z, "getTotalPartyWealth");
  async function q(Se) {
    if (!game.user.isGM) {
      ui.notifications.warn("You do not have permission to edit this party.");
      return;
    }
    try {
      const { uuid: _e } = JSON.parse(Se.dataTransfer.getData("text/plain")), we = await fromUuid(_e);
      (we == null ? void 0 : we.documentName) === "Actor" && U(_e);
    } catch (_e) {
      console.error(_e);
    }
  }
  u(q, "onDropDocument");
  async function U(Se) {
    var _e, we, Fe;
    if (n) {
      ui.notifications.warn("This party is locked.");
      return;
    }
    if ((_e = o == null ? void 0 : o.actors) != null && _e.length) {
      if ((we = o.actors) != null && we.includes(Se)) return;
      (Fe = o.actors) == null || Fe.push(Se), await game.settings.set("a5e", "parties", c);
    } else
      await game.settings.set("a5e", "parties", {
        [foundry.utils.randomID()]: {
          name: "New Party",
          actors: [Se],
          isLocked: !1
        }
      });
  }
  u(U, "onDropActor");
  async function H(Se) {
    const { actors: _e } = o, we = _e.indexOf(Se);
    we !== -1 && (_e.splice(we, 1), await game.settings.set("a5e", "parties", c));
  }
  u(H, "removeActorFromParty");
  async function V() {
    var _e;
    const Se = Object.entries(c ?? {}).map(([we, Fe]) => ({
      id: we,
      label: Fe.name || "New Party",
      actors: Fe.actors ?? [],
      isLocked: Fe.isLocked ?? !1
    }));
    if (Se.length) {
      const we = c[(_e = Se[0]) == null ? void 0 : _e.id];
      we.isLocked = !(we != null && we.isLocked), await game.settings.set("a5e", "parties", c);
    }
  }
  u(V, "togglePartyLock");
  function Y(Se) {
    fromUuidSync(Se) || H(Se), t(3, ne = L()), t(4, Ee = B()), t(5, Pe = h()), t(6, ye = _()), t(7, me = y()), t(8, Ce = v()), t(9, Je = z()), t(11, l = k(s)), t(10, r = D(s));
  }
  u(Y, "updatePartyData");
  const J = [
    ["core", "Core"],
    ["attributes", "Attributes"],
    ["resources", "Resources"],
    ["languages", "Languages"],
    ["wealth", "Wealth"]
  ];
  let fe = m.getStore("parties");
  pe(i, fe, (Se) => t(30, c = Se));
  let ke = Vo(fe, (Se) => {
    var we;
    const _e = Object.entries(Se ?? {}).map(([Fe, xe]) => ({
      id: Fe,
      label: xe.name || "New Party",
      actors: xe.actors ?? [],
      isLocked: xe.isLocked ?? !1
    }));
    return _e.length ? Se[(we = _e[0]) == null ? void 0 : we.id] : {};
  });
  pe(i, ke, (Se) => t(25, o = Se));
  let ee = Vo(ke, (Se) => ((Se == null ? void 0 : Se.actors) ?? []).reduce(
    (_e, we) => {
      const Fe = fromUuidSync(we);
      if (Fe) {
        const xe = new Zt(Fe);
        _e.push(xe);
      }
      return _e;
    },
    []
  ));
  pe(i, ee, (Se) => t(2, a = Se));
  let ne = L(), Ee = B(), Pe = h(), ye = _(), me = y(), Ce = v(), Je = z();
  const Ne = m.getStore("showActorImagesInPartyViewer");
  pe(i, Ne, (Se) => t(31, f = Se));
  const Re = ee.subscribe((Se) => {
    t(3, ne = L()), t(4, Ee = B()), t(5, Pe = h()), t(6, ye = _()), t(7, me = y()), t(8, Ce = v()), t(9, Je = z()), t(11, l = k(s)), t(10, r = D(s));
  }), { isGM: ge } = game.user;
  Qt(() => {
    Re();
  });
  const je = /* @__PURE__ */ u((Se) => t(1, s = Se.detail), "updateSelection_handler"), Be = /* @__PURE__ */ u(({ detail: Se }) => Y(Se), "actor_updated_handler"), Ze = /* @__PURE__ */ u(({ detail: Se }) => H(Se), "remove_actor_handler"), Ge = /* @__PURE__ */ u((Se) => q(Se), "drop_handler");
  return i.$$set = (Se) => {
    "settings" in Se && t(23, m = Se.settings), "sheet" in Se && t(24, g = Se.sheet);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*$partyMembers, $currentParty*/
    33554436 && t(0, n = Gbe(a, o)), i.$$.dirty[0] & /*currentViewMode, partyIsLocked*/
    3 && t(11, l = k(s)), i.$$.dirty[0] & /*currentViewMode, partyIsLocked*/
    3 && t(10, r = D(s));
  }, t(1, s = J[0][0]), [
    n,
    s,
    a,
    ne,
    Ee,
    Pe,
    ye,
    me,
    Ce,
    Je,
    r,
    l,
    M,
    q,
    H,
    V,
    Y,
    J,
    fe,
    ke,
    ee,
    Ne,
    ge,
    m,
    g,
    o,
    je,
    Be,
    Ze,
    Ge
  ];
}
u(zbe, "instance$w");
var Za;
let Hbe = (Za = class extends re {
  constructor(e) {
    super(), oe(this, e, zbe, qbe, le, { settings: 23, sheet: 24 }, null, [-1, -1]);
  }
}, u(Za, "PartyViewer"), Za);
const YT = class YT extends Un {
  constructor() {
    super(
      {
        title: K("Party Viewer"),
        content: {
          class: Hbe,
          props: {
            // @ts-expect-error
            settings: _c
          }
        },
        resizable: !0,
        zIndex: null
      },
      {
        classes: ["a5e-sheet", "a5e-sheet--party-viewer"],
        width: 672
      }
    ), this.data.content.props.sheet = this;
  }
  close() {
    game.a5e.dialogs.partyViewer = null, super.close();
  }
};
u(YT, "PartyViewer");
let Lk = YT;
function mq(i = !1) {
  var e, t, s, n;
  if (i && ((e = game.a5e.dialogs.partyViewer) != null && e.rendered)) {
    (s = (t = game.a5e.dialogs) == null ? void 0 : t.partyViewer) == null || s.close();
    return;
  }
  (n = game.a5e.dialogs).partyViewer ?? (n.partyViewer = new Lk()), game.a5e.dialogs.partyViewer.render(!0);
}
u(mq, "renderPartyViewer");
function Ube(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.5eStyleDeathSaves",
      checked: (
        /*updates*/
        i[12].get("5eStyleDeathSaves") ?? /*$deathSaves*/
        i[1] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[24]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$deathSaves*/
      2 && (l.checked = /*updates*/
      s[12].get("5eStyleDeathSaves") ?? /*$deathSaves*/
      s[1] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Ube, "create_default_slot_12$2");
function Vbe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.5eStyleExpertise",
      checked: (
        /*updates*/
        i[12].get("5eStyleExpertise") ?? /*$expertise*/
        i[2] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[25]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$expertise*/
      4 && (l.checked = /*updates*/
      s[12].get("5eStyleExpertise") ?? /*$expertise*/
      s[2] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Vbe, "create_default_slot_11$2");
function Wbe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.5eStyleJackOfAllTrades",
      checked: (
        /*updates*/
        i[12].get("5eStyleJackOfAllTrades") ?? /*$jackOfAllTrades*/
        i[3] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[26]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$jackOfAllTrades*/
      8 && (l.checked = /*updates*/
      s[12].get("5eStyleJackOfAllTrades") ?? /*$jackOfAllTrades*/
      s[3] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Wbe, "create_default_slot_10$2");
function Kbe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.hideA5eSkills",
      checked: (
        /*updates*/
        i[12].get("hideA5eSkills") ?? /*$hideA5eSkills*/
        i[4] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[27]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideA5eSkills*/
      16 && (l.checked = /*updates*/
      s[12].get("hideA5eSkills") ?? /*$hideA5eSkills*/
      s[4] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Kbe, "create_default_slot_9$2");
function Ybe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.hideExpertiseDice",
      checked: (
        /*updates*/
        i[12].get("hideExpertiseDice") ?? /*$hideExpertiseDice*/
        i[5] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[28]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideExpertiseDice*/
      32 && (l.checked = /*updates*/
      s[12].get("hideExpertiseDice") ?? /*$hideExpertiseDice*/
      s[5] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Ybe, "create_default_slot_8$2");
function Xbe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.hideSkillCriticalPrompt",
      checked: (
        /*updates*/
        i[12].get("hideSkillCriticalPrompt") ?? /*$hideSkillCriticalPrompt*/
        i[6] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[29]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideSkillCriticalPrompt*/
      64 && (l.checked = /*updates*/
      s[12].get("hideSkillCriticalPrompt") ?? /*$hideSkillCriticalPrompt*/
      s[6] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Xbe, "create_default_slot_7$4");
function Jbe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.hideSkillSpecialties",
      checked: (
        /*updates*/
        i[12].get("hideSkillSpecialties") ?? /*$hideSkillSpecialties*/
        i[7] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[30]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideSkillSpecialties*/
      128 && (l.checked = /*updates*/
      s[12].get("hideSkillSpecialties") ?? /*$hideSkillSpecialties*/
      s[7] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Jbe, "create_default_slot_6$4");
function Zbe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.replaceFatigueAndStrife",
      checked: (
        /*updates*/
        i[12].get("replaceFatigueAndStrife") ?? /*$exhaustion*/
        i[8] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[31]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$exhaustion*/
      256 && (l.checked = /*updates*/
      s[12].get("replaceFatigueAndStrife") ?? /*$exhaustion*/
      s[8] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Zbe, "create_default_slot_5$5");
function Qbe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.simpleInitiative",
      checked: (
        /*updates*/
        i[12].get("simpleInitiative") ?? /*$simpleInitiative*/
        i[9] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_8*/
    i[32]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$simpleInitiative*/
      512 && (l.checked = /*updates*/
      s[12].get("simpleInitiative") ?? /*$simpleInitiative*/
      s[9] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Qbe, "create_default_slot_4$6");
function xbe(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.simpleRests",
      checked: (
        /*updates*/
        i[12].get("simpleRests") ?? /*$simpleRests*/
        i[10] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_9*/
    i[33]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$simpleRests*/
      1024 && (l.checked = /*updates*/
      s[12].get("simpleRests") ?? /*$simpleRests*/
      s[10] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(xbe, "create_default_slot_3$7");
function e_e(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.5eStyleDeathSaves",
      $$slots: { default: [Ube] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      hint: "A5E.settings.hints.5eStyleExpertise",
      $$slots: { default: [Vbe] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      hint: "A5E.settings.hints.5eStyleJackOfAllTrades",
      $$slots: { default: [Wbe] },
      $$scope: { ctx: i }
    }
  }), o = new ie({
    props: {
      hint: "A5E.settings.hints.hideA5eSkills",
      $$slots: { default: [Kbe] },
      $$scope: { ctx: i }
    }
  }), c = new ie({
    props: {
      hint: "A5E.settings.hints.hideExpertiseDice",
      $$slots: { default: [Ybe] },
      $$scope: { ctx: i }
    }
  }), d = new ie({
    props: {
      hint: "A5E.settings.hints.hideSkillCriticalPrompt",
      $$slots: { default: [Xbe] },
      $$scope: { ctx: i }
    }
  }), m = new ie({
    props: {
      hint: "A5E.settings.hints.hideSkillSpecialties",
      $$slots: { default: [Jbe] },
      $$scope: { ctx: i }
    }
  }), h = new ie({
    props: {
      hint: "A5E.settings.hints.replaceFatigueAndStrife",
      $$slots: { default: [Zbe] },
      $$scope: { ctx: i }
    }
  }), y = new ie({
    props: {
      hint: "A5E.settings.hints.simpleInitiative",
      $$slots: { default: [Qbe] },
      $$scope: { ctx: i }
    }
  }), k = new ie({
    props: {
      hint: "A5E.settings.hints.simpleRests",
      $$slots: { default: [xbe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment), f = F(), j(d.$$.fragment), p = F(), j(m.$$.fragment), g = F(), j(h.$$.fragment), _ = F(), j(y.$$.fragment), v = F(), j(k.$$.fragment);
    },
    m(D, I) {
      R(e, D, I), T(D, t, I), R(s, D, I), T(D, n, I), R(l, D, I), T(D, r, I), R(o, D, I), T(D, a, I), R(c, D, I), T(D, f, I), R(d, D, I), T(D, p, I), R(m, D, I), T(D, g, I), R(h, D, I), T(D, _, I), R(y, D, I), T(D, v, I), R(k, D, I), S = !0;
    },
    p(D, I) {
      const M = {};
      I[0] & /*$deathSaves*/
      2 | I[1] & /*$$scope*/
      32 && (M.$$scope = { dirty: I, ctx: D }), e.$set(M);
      const L = {};
      I[0] & /*$expertise, reload*/
      5 | I[1] & /*$$scope*/
      32 && (L.$$scope = { dirty: I, ctx: D }), s.$set(L);
      const B = {};
      I[0] & /*$jackOfAllTrades, reload*/
      9 | I[1] & /*$$scope*/
      32 && (B.$$scope = { dirty: I, ctx: D }), l.$set(B);
      const z = {};
      I[0] & /*$hideA5eSkills, reload*/
      17 | I[1] & /*$$scope*/
      32 && (z.$$scope = { dirty: I, ctx: D }), o.$set(z);
      const q = {};
      I[0] & /*$hideExpertiseDice, reload*/
      33 | I[1] & /*$$scope*/
      32 && (q.$$scope = { dirty: I, ctx: D }), c.$set(q);
      const U = {};
      I[0] & /*$hideSkillCriticalPrompt, reload*/
      65 | I[1] & /*$$scope*/
      32 && (U.$$scope = { dirty: I, ctx: D }), d.$set(U);
      const H = {};
      I[0] & /*$hideSkillSpecialties, reload*/
      129 | I[1] & /*$$scope*/
      32 && (H.$$scope = { dirty: I, ctx: D }), m.$set(H);
      const V = {};
      I[0] & /*$exhaustion, reload*/
      257 | I[1] & /*$$scope*/
      32 && (V.$$scope = { dirty: I, ctx: D }), h.$set(V);
      const Y = {};
      I[0] & /*$simpleInitiative, reload*/
      513 | I[1] & /*$$scope*/
      32 && (Y.$$scope = { dirty: I, ctx: D }), y.$set(Y);
      const J = {};
      I[0] & /*$simpleRests, reload*/
      1025 | I[1] & /*$$scope*/
      32 && (J.$$scope = { dirty: I, ctx: D }), k.$set(J);
    },
    i(D) {
      S || (w(e.$$.fragment, D), w(s.$$.fragment, D), w(l.$$.fragment, D), w(o.$$.fragment, D), w(c.$$.fragment, D), w(d.$$.fragment, D), w(m.$$.fragment, D), w(h.$$.fragment, D), w(y.$$.fragment, D), w(k.$$.fragment, D), S = !0);
    },
    o(D) {
      O(e.$$.fragment, D), O(s.$$.fragment, D), O(l.$$.fragment, D), O(o.$$.fragment, D), O(c.$$.fragment, D), O(d.$$.fragment, D), O(m.$$.fragment, D), O(h.$$.fragment, D), O(y.$$.fragment, D), O(k.$$.fragment, D), S = !1;
    },
    d(D) {
      D && (C(t), C(n), C(r), C(a), C(f), C(p), C(g), C(_), C(v)), N(e, D), N(s, D), N(l, D), N(o, D), N(c, D), N(d, D), N(m, D), N(h, D), N(y, D), N(k, D);
    }
  };
}
u(e_e, "create_default_slot_2$7");
function t_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.hideBrokenAndDamaged",
      checked: (
        /*updates*/
        i[12].get("hideBrokenAndDamaged") ?? /*$hideBrokenAndDamaged*/
        i[11] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_10*/
    i[34]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideBrokenAndDamaged*/
      2048 && (l.checked = /*updates*/
      s[12].get("hideBrokenAndDamaged") ?? /*$hideBrokenAndDamaged*/
      s[11] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(t_e, "create_default_slot_1$8");
function s_e(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.hideBrokenAndDamaged",
      $$slots: { default: [t_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideBrokenAndDamaged*/
      2048 | n[1] & /*$$scope*/
      32 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(s_e, "create_default_slot$g");
function n_e(i) {
  let e, t, s, n, l, r;
  return e = new De({
    props: {
      heading: "A5E.settings.sectionHeader.actorBehavior",
      $$slots: { default: [e_e] },
      $$scope: { ctx: i }
    }
  }), n = new De({
    props: {
      heading: "A5E.settings.sectionHeader.sheetSettings",
      $$slots: { default: [s_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem"), G(l, "display", "contents"), G(l, "--a5e-section-body-gap", "0.5rem");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), T(o, l, a), R(n, l, null), r = !0;
    },
    p(o, a) {
      const c = {};
      a[0] & /*$simpleRests, reload, $simpleInitiative, $exhaustion, $hideSkillSpecialties, $hideSkillCriticalPrompt, $hideExpertiseDice, $hideA5eSkills, $jackOfAllTrades, $expertise, $deathSaves*/
      2047 | a[1] & /*$$scope*/
      32 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const f = {};
      a[0] & /*$hideBrokenAndDamaged*/
      2048 | a[1] & /*$$scope*/
      32 && (f.$$scope = { dirty: a, ctx: o }), n.$set(f);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && C(s), o && e && C(t), N(e, o), o && n && C(l), N(n, o);
    }
  };
}
u(n_e, "create_fragment$x");
function i_e(i, e, t) {
  let s, n, l, r, o, a, c, f, d, p, m, { reload: g } = e;
  const h = de("settings"), _ = de("updates");
  let y = h.getStore("5eStyleDeathSaves");
  pe(i, y, (ye) => t(1, s = ye));
  let v = h.getStore("replaceFatigueAndStrife");
  pe(i, v, (ye) => t(8, f = ye));
  let k = h.getStore("5eStyleExpertise");
  pe(i, k, (ye) => t(2, n = ye));
  let S = h.getStore("5eStyleJackOfAllTrades");
  pe(i, S, (ye) => t(3, l = ye));
  let D = h.getStore("hideA5eSkills");
  pe(i, D, (ye) => t(4, r = ye));
  let I = h.getStore("hideBrokenAndDamaged");
  pe(i, I, (ye) => t(11, m = ye));
  let M = h.getStore("hideExpertiseDice");
  pe(i, M, (ye) => t(5, o = ye));
  let L = h.getStore("hideSkillCriticalPrompt");
  pe(i, L, (ye) => t(6, a = ye));
  let B = h.getStore("hideSkillSpecialties");
  pe(i, B, (ye) => t(7, c = ye));
  let z = h.getStore("simpleInitiative");
  pe(i, z, (ye) => t(9, d = ye));
  let q = h.getStore("simpleRests");
  pe(i, q, (ye) => t(10, p = ye));
  const U = /* @__PURE__ */ u(({ detail: ye }) => {
    _.set("5eStyleDeathSaves", ye);
  }, "updateSelection_handler"), H = /* @__PURE__ */ u(({ detail: ye }) => {
    _.set("5eStyleExpertise", ye), t(0, g = !0);
  }, "updateSelection_handler_1"), V = /* @__PURE__ */ u(({ detail: ye }) => {
    _.set("5eStyleJackOfAllTrades", ye), t(0, g = !0);
  }, "updateSelection_handler_2"), Y = /* @__PURE__ */ u(({ detail: ye }) => {
    _.set("hideA5eSkills", ye), t(0, g = !0);
  }, "updateSelection_handler_3"), J = /* @__PURE__ */ u(({ detail: ye }) => {
    _.set("hideExpertiseDice", ye), t(0, g = !0);
  }, "updateSelection_handler_4"), fe = /* @__PURE__ */ u(({ detail: ye }) => {
    _.set("hideSkillCriticalPrompt", ye), t(0, g = !0);
  }, "updateSelection_handler_5"), ke = /* @__PURE__ */ u(({ detail: ye }) => {
    _.set("hideSkillSpecialties", ye), t(0, g = !0);
  }, "updateSelection_handler_6"), ee = /* @__PURE__ */ u(({ detail: ye }) => {
    _.set("replaceFatigueAndStrife", ye), t(0, g = !0);
  }, "updateSelection_handler_7"), ne = /* @__PURE__ */ u(({ detail: ye }) => {
    _.set("simpleInitiative", ye), t(0, g = !0);
  }, "updateSelection_handler_8"), Ee = /* @__PURE__ */ u(({ detail: ye }) => {
    _.set("simpleRests", ye), t(0, g = !0);
  }, "updateSelection_handler_9"), Pe = /* @__PURE__ */ u(({ detail: ye }) => {
    _.set("hideBrokenAndDamaged", ye);
  }, "updateSelection_handler_10");
  return i.$$set = (ye) => {
    "reload" in ye && t(0, g = ye.reload);
  }, [
    g,
    s,
    n,
    l,
    r,
    o,
    a,
    c,
    f,
    d,
    p,
    m,
    _,
    y,
    v,
    k,
    S,
    D,
    I,
    M,
    L,
    B,
    z,
    q,
    U,
    H,
    V,
    Y,
    J,
    fe,
    ke,
    ee,
    ne,
    Ee,
    Pe
  ];
}
u(i_e, "instance$v");
const XT = class XT extends re {
  constructor(e) {
    super(), oe(this, e, i_e, n_e, le, { reload: 0 }, null, [-1, -1]);
  }
};
u(XT, "Settings5eTab");
let Bk = XT;
function l_e(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.settings.sectionHeader.actorBehavior",
      $$slots: { default: [g_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l[0] & /*$useNPCPassive, reload, $randomHP, $trackCurrency, $blindDeathSaves, $automateTokenSize*/
      125 | l[1] & /*$$scope*/
      2048 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(l_e, "create_if_block$c");
function r_e(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.automatePrototypeTokenSize",
      $$slots: { default: [o_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$automateTokenSize*/
      4 | n[1] & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(r_e, "create_if_block_5$2");
function o_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.automatePrototypeTokenSize",
      checked: (
        /*updates*/
        i[13].get("automatePrototypeTokenSize") ?? /*$automateTokenSize*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[28]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$automateTokenSize*/
      4 && (l.checked = /*updates*/
      s[13].get("automatePrototypeTokenSize") ?? /*$automateTokenSize*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(o_e, "create_default_slot_12$1");
function a_e(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.blindDeathSaves",
      $$slots: { default: [c_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$blindDeathSaves, reload*/
      9 | n[1] & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(a_e, "create_if_block_4$2");
function c_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.blindDeathSaves",
      checked: (
        /*updates*/
        i[13].get("blindDeathSaves") ?? /*$blindDeathSaves*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[29]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$blindDeathSaves*/
      8 && (l.checked = /*updates*/
      s[13].get("blindDeathSaves") ?? /*$blindDeathSaves*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(c_e, "create_default_slot_11$1");
function u_e(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.trackCurrencyWeight",
      $$slots: { default: [f_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$trackCurrency*/
      16 | n[1] & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(u_e, "create_if_block_3$2");
function f_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.trackCurrencyWeight",
      checked: (
        /*updates*/
        i[13].get("currencyWeight") ?? /*$trackCurrency*/
        i[4] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[30]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$trackCurrency*/
      16 && (l.checked = /*updates*/
      s[13].get("currencyWeight") ?? /*$trackCurrency*/
      s[4] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(f_e, "create_default_slot_10$1");
function d_e(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.randomizeNPCHitPoints",
      $$slots: { default: [p_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$randomHP*/
      32 | n[1] & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(d_e, "create_if_block_2$4");
function p_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.randomizeNPCHitPoints",
      checked: (
        /*updates*/
        i[13].get("randomizeNPCHitPoints") ?? /*$randomHP*/
        i[5] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[31]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$randomHP*/
      32 && (l.checked = /*updates*/
      s[13].get("randomizeNPCHitPoints") ?? /*$randomHP*/
      s[5] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(p_e, "create_default_slot_9$1");
function m_e(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.useNPCExpertisePassiveRulesForCharacters",
      $$slots: { default: [h_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$useNPCPassive, reload*/
      65 | n[1] & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(m_e, "create_if_block_1$8");
function h_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.useNPCExpertisePassiveRulesForCharacters",
      checked: (
        /*updates*/
        i[13].get("useNPCExpertisePassiveRulesForCharacters") ?? /*$useNPCPassive*/
        i[6] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[32]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$useNPCPassive*/
      64 && (l.checked = /*updates*/
      s[13].get("useNPCExpertisePassiveRulesForCharacters") ?? /*$useNPCPassive*/
      s[6] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(h_e, "create_default_slot_8$1");
function g_e(i) {
  let e, t, s, n, l, r, o = (
    /*isGM*/
    i[14] && r_e(i)
  ), a = (
    /*isGM*/
    i[14] && a_e(i)
  ), c = (
    /*isGM*/
    i[14] && u_e(i)
  ), f = (
    /*isGM*/
    i[14] && d_e(i)
  ), d = (
    /*isGM*/
    i[14] && m_e(i)
  );
  return {
    c() {
      o && o.c(), e = F(), a && a.c(), t = F(), c && c.c(), s = F(), f && f.c(), n = F(), d && d.c(), l = $e();
    },
    m(p, m) {
      o && o.m(p, m), T(p, e, m), a && a.m(p, m), T(p, t, m), c && c.m(p, m), T(p, s, m), f && f.m(p, m), T(p, n, m), d && d.m(p, m), T(p, l, m), r = !0;
    },
    p(p, m) {
      /*isGM*/
      p[14] && o.p(p, m), /*isGM*/
      p[14] && a.p(p, m), /*isGM*/
      p[14] && c.p(p, m), /*isGM*/
      p[14] && f.p(p, m), /*isGM*/
      p[14] && d.p(p, m);
    },
    i(p) {
      r || (w(o), w(a), w(c), w(f), w(d), r = !0);
    },
    o(p) {
      O(o), O(a), O(c), O(f), O(d), r = !1;
    },
    d(p) {
      p && (C(e), C(t), C(s), C(n), C(l)), o && o.d(p), a && a.d(p), c && c.d(p), f && f.d(p), d && d.d(p);
    }
  };
}
u(g_e, "create_default_slot_7$3");
function b_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.collapseActionList",
      checked: (
        /*updates*/
        i[13].get("collapseActionList") ?? /*$hideActionList*/
        i[7] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[33]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideActionList*/
      128 && (l.checked = /*updates*/
      s[13].get("collapseActionList") ?? /*$hideActionList*/
      s[7] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(b_e, "create_default_slot_6$3");
function __e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.hideDeletionConfirmationDialog",
      checked: (
        /*updates*/
        i[13].get("hideDeleteConfirmation") ?? /*$hideDeleteDialog*/
        i[8] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[34]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideDeleteDialog*/
      256 && (l.checked = /*updates*/
      s[13].get("hideDeleteConfirmation") ?? /*$hideDeleteDialog*/
      s[8] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(__e, "create_default_slot_5$4");
function y_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.hideActorCompendiumSelectionDialog",
      checked: (
        /*updates*/
        i[13].get("hideActorCompendiumSelectionDialog") ?? /*$hideCompendiumSelection*/
        i[9] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[35]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideCompendiumSelection*/
      512 && (l.checked = /*updates*/
      s[13].get("hideActorCompendiumSelectionDialog") ?? /*$hideCompendiumSelection*/
      s[9] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(y_e, "create_default_slot_4$5");
function v_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.itemRightClickConfigure",
      checked: (
        /*updates*/
        i[13].get("itemRightClickConfigure") ?? /*$rightClickConfig*/
        i[10] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_8*/
    i[36]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$rightClickConfig*/
      1024 && (l.checked = /*updates*/
      s[13].get("itemRightClickConfigure") ?? /*$rightClickConfig*/
      s[10] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(v_e, "create_default_slot_3$6");
function k_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.reverseAltBehavior",
      checked: (
        /*updates*/
        i[13].get("reverseAltBehavior") ?? /*$reverseAlt*/
        i[11] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_9*/
    i[37]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$reverseAlt*/
      2048 && (l.checked = /*updates*/
      s[13].get("reverseAltBehavior") ?? /*$reverseAlt*/
      s[11] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(k_e, "create_default_slot_2$6");
function w_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.reverseInitiativeAltBehavior",
      checked: (
        /*updates*/
        i[13].get("reverseInitiativeAltBehavior") ?? /*$reverseInitAlt*/
        i[12] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_10*/
    i[38]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$reverseInitAlt*/
      4096 && (l.checked = /*updates*/
      s[13].get("reverseInitiativeAltBehavior") ?? /*$reverseInitAlt*/
      s[12] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(w_e, "create_default_slot_1$7");
function $_e(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.collapseActionList",
      $$slots: { default: [b_e] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      hint: "A5E.settings.hints.hideDeletionConfirmationDialog",
      $$slots: { default: [__e] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      hint: "A5E.settings.hints.hideActorCompendiumSelectionDialog",
      $$slots: { default: [y_e] },
      $$scope: { ctx: i }
    }
  }), o = new ie({
    props: {
      hint: "A5E.settings.hints.itemRightClickConfigure",
      $$slots: { default: [v_e] },
      $$scope: { ctx: i }
    }
  }), c = new ie({
    props: {
      hint: "A5E.settings.hints.reverseAltBehavior",
      $$slots: { default: [k_e] },
      $$scope: { ctx: i }
    }
  }), d = new ie({
    props: {
      hint: "A5E.settings.hints.reverseInitiativeAltBehavior",
      $$slots: { default: [w_e] },
      $$scope: { ctx: i }
    }
  }), m = new Ke({
    props: {
      heading: "A5E.settings.skillListFlowDirection",
      hint: "A5E.settings.hints.skillListFlowDirection",
      options: Object.entries(
        /*skillListFlowDirectionChoices*/
        i[15]
      ),
      selected: (
        /*selectedSkillListFlowDirection*/
        i[1]
      )
    }
  }), m.$on(
    "updateSelection",
    /*updateSelection_handler_11*/
    i[39]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment), f = F(), j(d.$$.fragment), p = F(), j(m.$$.fragment);
    },
    m(h, _) {
      R(e, h, _), T(h, t, _), R(s, h, _), T(h, n, _), R(l, h, _), T(h, r, _), R(o, h, _), T(h, a, _), R(c, h, _), T(h, f, _), R(d, h, _), T(h, p, _), R(m, h, _), g = !0;
    },
    p(h, _) {
      const y = {};
      _[0] & /*$hideActionList*/
      128 | _[1] & /*$$scope*/
      2048 && (y.$$scope = { dirty: _, ctx: h }), e.$set(y);
      const v = {};
      _[0] & /*$hideDeleteDialog*/
      256 | _[1] & /*$$scope*/
      2048 && (v.$$scope = { dirty: _, ctx: h }), s.$set(v);
      const k = {};
      _[0] & /*$hideCompendiumSelection*/
      512 | _[1] & /*$$scope*/
      2048 && (k.$$scope = { dirty: _, ctx: h }), l.$set(k);
      const S = {};
      _[0] & /*$rightClickConfig*/
      1024 | _[1] & /*$$scope*/
      2048 && (S.$$scope = { dirty: _, ctx: h }), o.$set(S);
      const D = {};
      _[0] & /*$reverseAlt*/
      2048 | _[1] & /*$$scope*/
      2048 && (D.$$scope = { dirty: _, ctx: h }), c.$set(D);
      const I = {};
      _[0] & /*$reverseInitAlt*/
      4096 | _[1] & /*$$scope*/
      2048 && (I.$$scope = { dirty: _, ctx: h }), d.$set(I);
      const M = {};
      _[0] & /*selectedSkillListFlowDirection*/
      2 && (M.selected = /*selectedSkillListFlowDirection*/
      h[1]), m.$set(M);
    },
    i(h) {
      g || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(l.$$.fragment, h), w(o.$$.fragment, h), w(c.$$.fragment, h), w(d.$$.fragment, h), w(m.$$.fragment, h), g = !0);
    },
    o(h) {
      O(e.$$.fragment, h), O(s.$$.fragment, h), O(l.$$.fragment, h), O(o.$$.fragment, h), O(c.$$.fragment, h), O(d.$$.fragment, h), O(m.$$.fragment, h), g = !1;
    },
    d(h) {
      h && (C(t), C(n), C(r), C(a), C(f), C(p)), N(e, h), N(s, h), N(l, h), N(o, h), N(c, h), N(d, h), N(m, h);
    }
  };
}
u($_e, "create_default_slot$f");
function A_e(i) {
  let e, t, s, n, l = (
    /*isGM*/
    i[14] && l_e(i)
  );
  return t = new De({
    props: {
      heading: "A5E.settings.sectionHeader.sheetSettings",
      $$slots: { default: [$_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      l && l.c(), e = F(), s = E("div"), j(t.$$.fragment), G(s, "display", "contents"), G(s, "--a5e-section-body-gap", "0.5rem");
    },
    m(r, o) {
      l && l.m(r, o), T(r, e, o), T(r, s, o), R(t, s, null), n = !0;
    },
    p(r, o) {
      /*isGM*/
      r[14] && l.p(r, o);
      const a = {};
      o[0] & /*selectedSkillListFlowDirection, reload, $reverseInitAlt, $reverseAlt, $rightClickConfig, $hideCompendiumSelection, $hideDeleteDialog, $hideActionList*/
      8067 | o[1] & /*$$scope*/
      2048 && (a.$$scope = { dirty: o, ctx: r }), t.$set(a);
    },
    i(r) {
      n || (w(l), w(t.$$.fragment, r), n = !0);
    },
    o(r) {
      O(l), O(t.$$.fragment, r), n = !1;
    },
    d(r) {
      r && C(e), l && l.d(r), r && t && C(s), N(t, r);
    }
  };
}
u(A_e, "create_fragment$w");
function E_e(i, e, t) {
  let s, n, l, r, o, a, c, f, d, p, m, g, { reload: h } = e;
  const _ = de("settings"), y = de("updates"), v = game.user.isGM, k = game.settings.settings.get("a5e.skillListFlowDirection").choices;
  let S = _.getStore("currencyWeight");
  pe(i, S, (ge) => t(4, r = ge));
  let D = _.getStore("randomizeNPCHitPoints");
  pe(i, D, (ge) => t(5, o = ge));
  let I = _.getStore("automatePrototypeTokenSize");
  pe(i, I, (ge) => t(2, n = ge));
  let M = _.getStore("blindDeathSaves");
  pe(i, M, (ge) => t(3, l = ge));
  let L = _.getStore("collapseActionList");
  pe(i, L, (ge) => t(7, c = ge));
  let B = _.getStore("hideDeleteConfirmation");
  pe(i, B, (ge) => t(8, f = ge));
  let z = _.getStore("hideActorCompendiumSelectionDialog");
  pe(i, z, (ge) => t(9, d = ge));
  let q = _.getStore("itemRightClickConfigure");
  pe(i, q, (ge) => t(10, p = ge));
  let U = _.getStore("reverseAltBehavior");
  pe(i, U, (ge) => t(11, m = ge));
  let H = _.getStore("reverseInitiativeAltBehavior");
  pe(i, H, (ge) => t(12, g = ge));
  let V = _.getStore("skillListFlowDirection");
  pe(i, V, (ge) => t(40, s = ge));
  let Y = _.getStore("useNPCExpertisePassiveRulesForCharacters");
  pe(i, Y, (ge) => t(6, a = ge));
  let J = y.get("skillListFlowDirection") ?? s;
  const fe = /* @__PURE__ */ u(({ detail: ge }) => {
    y.set("automatePrototypeTokenSize", ge);
  }, "updateSelection_handler"), ke = /* @__PURE__ */ u(({ detail: ge }) => {
    y.set("blindDeathSaves", ge), t(0, h = !0);
  }, "updateSelection_handler_1"), ee = /* @__PURE__ */ u(({ detail: ge }) => {
    y.set("currencyWeight", ge);
  }, "updateSelection_handler_2"), ne = /* @__PURE__ */ u(({ detail: ge }) => {
    y.set("randomizeNPCHitPoints", ge);
  }, "updateSelection_handler_3"), Ee = /* @__PURE__ */ u(({ detail: ge }) => {
    y.set("useNPCExpertisePassiveRulesForCharacters", ge), t(0, h = !0);
  }, "updateSelection_handler_4"), Pe = /* @__PURE__ */ u(({ detail: ge }) => y.set("collapseActionList", ge), "updateSelection_handler_5"), ye = /* @__PURE__ */ u(({ detail: ge }) => y.set("hideDeleteConfirmation", ge), "updateSelection_handler_6"), me = /* @__PURE__ */ u(({ detail: ge }) => y.set("hideActorCompendiumSelectionDialog", ge), "updateSelection_handler_7"), Ce = /* @__PURE__ */ u(({ detail: ge }) => y.set("itemRightClickConfigure", ge), "updateSelection_handler_8"), Je = /* @__PURE__ */ u(({ detail: ge }) => y.set("reverseAltBehavior", ge), "updateSelection_handler_9"), Ne = /* @__PURE__ */ u(({ detail: ge }) => y.set("reverseInitiativeAltBehavior", ge), "updateSelection_handler_10"), Re = /* @__PURE__ */ u(({ detail: ge }) => {
    y.set("skillListFlowDirection", ge), t(1, J = ge), t(0, h = !0);
  }, "updateSelection_handler_11");
  return i.$$set = (ge) => {
    "reload" in ge && t(0, h = ge.reload);
  }, [
    h,
    J,
    n,
    l,
    r,
    o,
    a,
    c,
    f,
    d,
    p,
    m,
    g,
    y,
    v,
    k,
    S,
    D,
    I,
    M,
    L,
    B,
    z,
    q,
    U,
    H,
    V,
    Y,
    fe,
    ke,
    ee,
    ne,
    Ee,
    Pe,
    ye,
    me,
    Ce,
    Je,
    Ne,
    Re
  ];
}
u(E_e, "instance$u");
const JT = class JT extends re {
  constructor(e) {
    super(), oe(this, e, E_e, A_e, le, { reload: 0 }, null, [-1, -1]);
  }
};
u(JT, "SettingsActorTab");
let qk = JT;
function S_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.automateVisionRules",
      checked: (
        /*updates*/
        i[4].get("automateVisionRules") ?? /*$visionRules*/
        i[1] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$visionRules*/
      2 && (l.checked = /*updates*/
      s[4].get("automateVisionRules") ?? /*$visionRules*/
      s[1] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(S_e, "create_default_slot_4$4");
function Uj(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.visionRulesApplyToCharactersOnly",
      $$slots: { default: [C_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $charOnlyVisionRules, reload*/
      4101 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Uj, "create_if_block$b");
function C_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.visionRulesApplyToCharactersOnly",
      checked: (
        /*updates*/
        i[4].get("visionRulesApplyToCharactersOnly") ?? /*$charOnlyVisionRules*/
        i[2] ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[9]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$charOnlyVisionRules*/
      4 && (l.checked = /*updates*/
      s[4].get("visionRulesApplyToCharactersOnly") ?? /*$charOnlyVisionRules*/
      s[2] ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(C_e, "create_default_slot_3$5");
function T_e(i) {
  let e, t, s, n;
  e = new ie({
    props: {
      hint: "A5E.settings.hints.automateVisionRules",
      $$slots: { default: [S_e] },
      $$scope: { ctx: i }
    }
  });
  let l = (
    /*$visionRules*/
    i[1] && Uj(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), l && l.c(), s = $e();
    },
    m(r, o) {
      R(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$$scope, $visionRules, reload*/
      4099 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a), /*$visionRules*/
      r[1] ? l ? (l.p(r, o), o & /*$visionRules*/
      2 && w(l, 1)) : (l = Uj(r), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ae(), O(l, 1, 1, () => {
        l = null;
      }), ce());
    },
    i(r) {
      n || (w(e.$$.fragment, r), w(l), n = !0);
    },
    o(r) {
      O(e.$$.fragment, r), O(l), n = !1;
    },
    d(r) {
      r && (C(t), C(s)), N(e, r), l && l.d(r);
    }
  };
}
u(T_e, "create_default_slot_2$5");
function O_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.placeItemTemplateDefault",
      checked: (
        /*updates*/
        i[4].get("placeItemTemplateDefault") ?? /*$placeTemplate*/
        i[3] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[10]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$placeTemplate*/
      8 && (l.checked = /*updates*/
      s[4].get("placeItemTemplateDefault") ?? /*$placeTemplate*/
      s[3] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(O_e, "create_default_slot_1$6");
function D_e(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.placeItemTemplateDefault",
      $$slots: { default: [O_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $placeTemplate*/
      4104 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(D_e, "create_default_slot$e");
function I_e(i) {
  let e, t, s, n, l, r;
  return e = new De({
    props: {
      heading: "VIsion Settings",
      $$slots: { default: [T_e] },
      $$scope: { ctx: i }
    }
  }), n = new De({
    props: {
      heading: "Template Settings",
      $$slots: { default: [D_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem"), G(l, "display", "contents"), G(l, "--a5e-section-body-gap", "0.5rem");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), T(o, l, a), R(n, l, null), r = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*$$scope, $charOnlyVisionRules, reload, $visionRules*/
      4103 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const f = {};
      a & /*$$scope, $placeTemplate*/
      4104 && (f.$$scope = { dirty: a, ctx: o }), n.$set(f);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && C(s), o && e && C(t), N(e, o), o && n && C(l), N(n, o);
    }
  };
}
u(I_e, "create_fragment$v");
function P_e(i, e, t) {
  let s, n, l, { reload: r } = e;
  const o = de("settings"), a = de("updates");
  let c = o.getStore("automateVisionRules");
  pe(i, c, (h) => t(1, s = h));
  let f = o.getStore("visionRulesApplyToCharactersOnly");
  pe(i, f, (h) => t(2, n = h));
  let d = o.getStore("placeItemTemplateDefault");
  pe(i, d, (h) => t(3, l = h));
  const p = /* @__PURE__ */ u(({ detail: h }) => {
    a.set("automateVisionRules", h), c.set(h), t(0, r = !0);
  }, "updateSelection_handler"), m = /* @__PURE__ */ u(({ detail: h }) => {
    a.set("visionRulesApplyToCharactersOnly", h), t(0, r = !0);
  }, "updateSelection_handler_1"), g = /* @__PURE__ */ u(({ detail: h }) => {
    a.set("placeItemTemplateDefault", h);
  }, "updateSelection_handler_2");
  return i.$$set = (h) => {
    "reload" in h && t(0, r = h.reload);
  }, [
    r,
    s,
    n,
    l,
    a,
    c,
    f,
    d,
    p,
    m,
    g
  ];
}
u(P_e, "instance$t");
const ZT = class ZT extends re {
  constructor(e) {
    super(), oe(this, e, P_e, I_e, le, { reload: 0 });
  }
};
u(ZT, "SettingsCanvasTab");
let Gk = ZT;
function M_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.enableDamageRollColors",
      checked: (
        /*updates*/
        i[6].get("enableDamageRollColors") ?? /*$enableDamageRollColors*/
        i[1] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[13]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$enableDamageRollColors*/
      2 && (l.checked = /*updates*/
      s[6].get("enableDamageRollColors") ?? /*$enableDamageRollColors*/
      s[1] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(M_e, "create_default_slot_5$3");
function F_e(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.protectRolls",
      $$slots: { default: [R_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $protectRolls, reload*/
      524293 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(F_e, "create_if_block_1$7");
function R_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.protectRolls",
      checked: (
        /*updates*/
        i[6].get("protectRolls") ?? /*$protectRolls*/
        i[2] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[14]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$protectRolls*/
      4 && (l.checked = /*updates*/
      s[6].get("protectRolls") ?? /*$protectRolls*/
      s[2] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(R_e, "create_default_slot_4$3");
function N_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.hideChatDescriptionsByDefault",
      checked: (
        /*updates*/
        i[6].get("hideChatDescriptionsByDefault") ?? /*$hideDescription*/
        i[3] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[15]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$hideDescription*/
      8 && (l.checked = /*updates*/
      s[6].get("hideChatDescriptionsByDefault") ?? /*$hideDescription*/
      s[3] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(N_e, "create_default_slot_3$4");
function j_e(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.hideRandomizedHPRolls",
      $$slots: { default: [L_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $hideHpRolls*/
      524304 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(j_e, "create_if_block$a");
function L_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.hideRandomizedHPRolls",
      checked: (
        /*updates*/
        i[6].get("hideRandomizedHPRolls") ?? /*$hideHpRolls*/
        i[4] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$hideHpRolls*/
      16 && (l.checked = /*updates*/
      s[6].get("hideRandomizedHPRolls") ?? /*$hideHpRolls*/
      s[4] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(L_e, "create_default_slot_2$4");
function B_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.terseRollFormulae",
      checked: (
        /*updates*/
        i[6].get("terseRollFormulae") ?? /*$terseRolls*/
        i[5] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$terseRolls*/
      32 && (l.checked = /*updates*/
      s[6].get("terseRollFormulae") ?? /*$terseRolls*/
      s[5] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(B_e, "create_default_slot_1$5");
function q_e(i) {
  let e, t, s, n, l, r, o, a;
  e = new ie({
    props: {
      hint: "A5E.settings.hints.enableDamageRollColors",
      $$slots: { default: [M_e] },
      $$scope: { ctx: i }
    }
  });
  let c = (
    /*isGM*/
    i[7] && F_e(i)
  );
  n = new ie({
    props: {
      hint: "A5E.settings.hints.hideChatDescriptionsByDefault",
      $$slots: { default: [N_e] },
      $$scope: { ctx: i }
    }
  });
  let f = (
    /*isGM*/
    i[7] && j_e(i)
  );
  return o = new ie({
    props: {
      hint: "A5E.settings.hints.terseRollFormulae",
      $$slots: { default: [B_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), c && c.c(), s = F(), j(n.$$.fragment), l = F(), f && f.c(), r = F(), j(o.$$.fragment);
    },
    m(d, p) {
      R(e, d, p), T(d, t, p), c && c.m(d, p), T(d, s, p), R(n, d, p), T(d, l, p), f && f.m(d, p), T(d, r, p), R(o, d, p), a = !0;
    },
    p(d, p) {
      const m = {};
      p & /*$$scope, $enableDamageRollColors, reload*/
      524291 && (m.$$scope = { dirty: p, ctx: d }), e.$set(m), /*isGM*/
      d[7] && c.p(d, p);
      const g = {};
      p & /*$$scope, $hideDescription, reload*/
      524297 && (g.$$scope = { dirty: p, ctx: d }), n.$set(g), /*isGM*/
      d[7] && f.p(d, p);
      const h = {};
      p & /*$$scope, $terseRolls, reload*/
      524321 && (h.$$scope = { dirty: p, ctx: d }), o.$set(h);
    },
    i(d) {
      a || (w(e.$$.fragment, d), w(c), w(n.$$.fragment, d), w(f), w(o.$$.fragment, d), a = !0);
    },
    o(d) {
      O(e.$$.fragment, d), O(c), O(n.$$.fragment, d), O(f), O(o.$$.fragment, d), a = !1;
    },
    d(d) {
      d && (C(t), C(s), C(l), C(r)), N(e, d), c && c.d(d), N(n, d), f && f.d(d), N(o, d);
    }
  };
}
u(q_e, "create_default_slot$d");
function G_e(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Chat Card Display Settings",
      $$slots: { default: [q_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, $terseRolls, reload, $hideHpRolls, $hideDescription, $protectRolls, $enableDamageRollColors*/
      524351 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(G_e, "create_fragment$u");
function z_e(i, e, t) {
  let s, n, l, r, o, { reload: a } = e;
  const c = de("settings"), f = de("updates"), d = game.user.isGM;
  let p = c.getStore("enableDamageRollColors");
  pe(i, p, (I) => t(1, s = I));
  let m = c.getStore("hideChatDescriptionsByDefault");
  pe(i, m, (I) => t(3, l = I));
  let g = c.getStore("hideRandomizedHPRolls");
  pe(i, g, (I) => t(4, r = I));
  let h = c.getStore("protectRolls");
  pe(i, h, (I) => t(2, n = I));
  let _ = c.getStore("terseRollFormulae");
  pe(i, _, (I) => t(5, o = I));
  const y = /* @__PURE__ */ u(({ detail: I }) => {
    f.set("enableDamageRollColors", I), t(0, a = !0);
  }, "updateSelection_handler"), v = /* @__PURE__ */ u(({ detail: I }) => {
    f.set("protectRolls", I), t(0, a = !0);
  }, "updateSelection_handler_1"), k = /* @__PURE__ */ u(({ detail: I }) => {
    f.set("hideChatDescriptionsByDefault", I), t(0, a = !0);
  }, "updateSelection_handler_2"), S = /* @__PURE__ */ u(({ detail: I }) => {
    f.set("hideRandomizedHPRolls", I);
  }, "updateSelection_handler_3"), D = /* @__PURE__ */ u(({ detail: I }) => {
    f.set("terseRollFormulae", I), t(0, a = !0);
  }, "updateSelection_handler_4");
  return i.$$set = (I) => {
    "reload" in I && t(0, a = I.reload);
  }, [
    a,
    s,
    n,
    l,
    r,
    o,
    f,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    v,
    k,
    S,
    D
  ];
}
u(z_e, "instance$s");
const QT = class QT extends re {
  constructor(e) {
    super(), oe(this, e, z_e, G_e, le, { reload: 0 });
  }
};
u(QT, "SettingsChatCardTab");
let zk = QT;
function H_e(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("li"), t = E("img"), n = F(), l = Q(
        /*conditionName*/
        i[6]
      ), b(t, "class", "condition-icon svelte-1jy5jhx"), ze(t.src, s = /*icon*/
      i[1] || /*$iconStore*/
      i[2][
        /*conditionKey*/
        i[0]
      ] || /*conditionIconsDefault*/
      i[4][
        /*conditionKey*/
        i[0]
      ]) || b(t, "src", s), b(
        t,
        "alt",
        /*getConditionName*/
        i[3]()
      ), b(e, "class", "condition-grid__item svelte-1jy5jhx");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, n), A(e, l), r || (o = W(
        e,
        "click",
        /*click_handler*/
        i[8]
      ), r = !0);
    },
    p(a, [c]) {
      c & /*icon, $iconStore, conditionKey*/
      7 && !ze(t.src, s = /*icon*/
      a[1] || /*$iconStore*/
      a[2][
        /*conditionKey*/
        a[0]
      ] || /*conditionIconsDefault*/
      a[4][
        /*conditionKey*/
        a[0]
      ]) && b(t, "src", s);
    },
    i: se,
    o: se,
    d(a) {
      a && C(e), r = !1, o();
    }
  };
}
u(H_e, "create_fragment$t");
function U_e(i, e, t) {
  let s, { conditionKey: n } = e, { icon: l } = e;
  function r() {
    return n === "dead" ? K("A5E.ConditionDead") : n === "concentration" ? K("A5E.ConditionConcentration") : o[n] ?? n;
  }
  u(r, "getConditionName");
  const { conditions: o, conditionIconsDefault: a } = CONFIG.A5E, c = ft(), f = de("settings"), d = r(), p = f.getStore("customConditionIcons");
  pe(i, p, (g) => t(2, s = g));
  const m = /* @__PURE__ */ u(() => c("updateConditionIcon", [
    n,
    l || s[n] || a[n]
  ]), "click_handler");
  return i.$$set = (g) => {
    "conditionKey" in g && t(0, n = g.conditionKey), "icon" in g && t(1, l = g.icon);
  }, [
    n,
    l,
    s,
    r,
    a,
    c,
    d,
    p,
    m
  ];
}
u(U_e, "instance$r");
const xT = class xT extends re {
  constructor(e) {
    super(), oe(this, e, U_e, H_e, le, { conditionKey: 0, icon: 1 });
  }
};
u(xT, "SettingsCustomIcon");
let Hk = xT;
function V_e(i) {
  let e, t, s, n, l, r, o, a, c;
  return {
    c() {
      e = E("form"), t = E("p"), t.textContent = `Are you sure you want to reset the system's condition icons to their
        defaults? This cannot be undone.`, s = F(), n = E("div"), l = E("button"), l.textContent = "Reset Icons", r = F(), o = E("button"), o.textContent = "Cancel", b(n, "class", "button-container svelte-1osm0n1"), b(e, "class", "svelte-1osm0n1");
    },
    m(f, d) {
      T(f, e, d), A(e, t), A(e, s), A(e, n), A(n, l), A(n, r), A(n, o), a || (c = [
        W(l, "click", st(
          /*click_handler*/
          i[3]
        )),
        W(o, "click", st(
          /*click_handler_1*/
          i[4]
        ))
      ], a = !0);
    },
    p: se,
    i: se,
    o: se,
    d(f) {
      f && C(e), a = !1, Me(c);
    }
  };
}
u(V_e, "create_fragment$s");
function W_e(i, e, t) {
  let { dialog: s } = de("#external").application, { dialog: n = s } = e;
  function l() {
    n.submit({ confirmReset: !0 });
  }
  u(l, "onSubmit");
  function r() {
    n.submit({ confirmReset: !1 });
  }
  u(r, "onCancelReset");
  const o = /* @__PURE__ */ u(() => l(), "click_handler"), a = /* @__PURE__ */ u(() => r(), "click_handler_1");
  return i.$$set = (c) => {
    "dialog" in c && t(2, n = c.dialog);
  }, [l, r, n, o, a];
}
u(W_e, "instance$q");
var Qa;
let K_e = (Qa = class extends re {
  constructor(e) {
    super(), oe(this, e, W_e, V_e, le, { dialog: 2 });
  }
}, u(Qa, "ConditionIconResetConfirmationDialog"), Qa);
var Qf, Vk;
const e3 = class e3 extends Un {
  constructor() {
    super(
      {
        title: "Condition Icons Reset Confirmation",
        content: {
          class: K_e,
          props: {}
        }
      },
      {
        classes: ["a5e-sheet"],
        width: 420
      }
    );
    x(this, Qf);
    this.data.content.props.dialog = this, this.promise = new Promise((t) => {
      this.resolve = t;
    });
  }
  /** @inheritdoc */
  close(t) {
    return X(this, Qf, Vk).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return X(this, Qf, Vk).call(this, t), super.close();
  }
};
Qf = new WeakSet(), Vk = /* @__PURE__ */ u(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), u(e3, "ConditionIconResetConfirmationDialog");
let Uk = e3;
function Vj(i, e, t) {
  const s = i.slice();
  return s[49] = e[t][0], s[50] = e[t][1], s;
}
u(Vj, "get_each_context$7");
function Y_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.automateBloodiedApplication",
      checked: (
        /*updates*/
        i[13].get("automateBloodiedApplication") ?? /*$automateBloodied*/
        i[6] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[28]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$automateBloodied*/
      64 && (l.checked = /*updates*/
      s[13].get("automateBloodiedApplication") ?? /*$automateBloodied*/
      s[6] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Y_e, "create_default_slot_12");
function X_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.automateUnconsciousApplication",
      checked: (
        /*updates*/
        i[13].get("automateUnconsciousApplication") ?? /*$automateUnconscious*/
        i[7] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[29]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$automateUnconscious*/
      128 && (l.checked = /*updates*/
      s[13].get("automateUnconsciousApplication") ?? /*$automateUnconscious*/
      s[7] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(X_e, "create_default_slot_11");
function J_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.enableRadialEffects",
      checked: (
        /*updates*/
        i[13].get("enableRadialEffects") ?? /*$radialEffects*/
        i[8]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[30]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$radialEffects*/
      256 && (l.checked = /*updates*/
      s[13].get("enableRadialEffects") ?? /*$radialEffects*/
      s[8]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(J_e, "create_default_slot_10");
function Z_e(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.removeActiveEffectsOnLongRest",
      checked: (
        /*updates*/
        i[13].get("removeActiveEffectsOnLongRest") ?? /*$removeEffects*/
        i[9] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[31]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$removeEffects*/
      512 && (l.checked = /*updates*/
      s[13].get("removeActiveEffectsOnLongRest") ?? /*$removeEffects*/
      s[9] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Z_e, "create_default_slot_9");
function Q_e(i) {
  let e, t, s, n, l, r, o, a, c, f;
  return e = new tt({
    props: {
      hint: "A5E.settings.hints.automateConditions",
      options: (
        /*automatableConditions*/
        i[14]
      ),
      selected: (
        /*selectedConditions*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[27]
  ), s = new ie({
    props: {
      hint: "A5E.settings.hints.automateBloodiedApplication",
      $$slots: { default: [Y_e] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      hint: "A5E.settings.hints.automateUnconsciousApplication",
      $$slots: { default: [X_e] },
      $$scope: { ctx: i }
    }
  }), o = new ie({
    props: {
      hint: "A5E.settings.hints.enableRadialEffects",
      $$slots: { default: [J_e] },
      $$scope: { ctx: i }
    }
  }), c = new ie({
    props: {
      hint: "A5E.settings.hints.removeActiveEffectsOnLongRest",
      $$slots: { default: [Z_e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment);
    },
    m(d, p) {
      R(e, d, p), T(d, t, p), R(s, d, p), T(d, n, p), R(l, d, p), T(d, r, p), R(o, d, p), T(d, a, p), R(c, d, p), f = !0;
    },
    p(d, p) {
      const m = {};
      p[0] & /*selectedConditions*/
      4 && (m.selected = /*selectedConditions*/
      d[2]), e.$set(m);
      const g = {};
      p[0] & /*$automateBloodied, reload*/
      65 | p[1] & /*$$scope*/
      4194304 && (g.$$scope = { dirty: p, ctx: d }), s.$set(g);
      const h = {};
      p[0] & /*$automateUnconscious, reload*/
      129 | p[1] & /*$$scope*/
      4194304 && (h.$$scope = { dirty: p, ctx: d }), l.$set(h);
      const _ = {};
      p[0] & /*$radialEffects, reload*/
      257 | p[1] & /*$$scope*/
      4194304 && (_.$$scope = { dirty: p, ctx: d }), o.$set(_);
      const y = {};
      p[0] & /*$removeEffects*/
      512 | p[1] & /*$$scope*/
      4194304 && (y.$$scope = { dirty: p, ctx: d }), c.$set(y);
    },
    i(d) {
      f || (w(e.$$.fragment, d), w(s.$$.fragment, d), w(l.$$.fragment, d), w(o.$$.fragment, d), w(c.$$.fragment, d), f = !0);
    },
    o(d) {
      O(e.$$.fragment, d), O(s.$$.fragment, d), O(l.$$.fragment, d), O(o.$$.fragment, d), O(c.$$.fragment, d), f = !1;
    },
    d(d) {
      d && (C(t), C(n), C(r), C(a)), N(e, d), N(s, d), N(l, d), N(o, d), N(c, d);
    }
  };
}
u(Q_e, "create_default_slot_8");
function x_e(i) {
  let e, t;
  return e = new Ke({
    props: {
      heading: "A5E.settings.conditionFlowDirection",
      hint: "A5E.settings.hints.conditionFlowDirection",
      options: Object.entries(
        /*conditionFlowDirectionChoices*/
        i[17]
      ),
      selected: (
        /*selectedConditionFlowDirection*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[32]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*selectedConditionFlowDirection*/
      2 && (l.selected = /*selectedConditionFlowDirection*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(x_e, "create_default_slot_7$2");
function Wj(i) {
  let e, t, s;
  function n(r) {
    i[33](r);
  }
  u(n, "settingscustomicon_reload_binding");
  let l = {
    conditionKey: (
      /*conditionKey*/
      i[49]
    ),
    icon: (
      /*icon*/
      i[50]
    )
  };
  return (
    /*reload*/
    i[0] !== void 0 && (l.reload = /*reload*/
    i[0]), e = new Hk({ props: l }), rt.push(() => Ot(e, "reload", n)), e.$on(
      "updateConditionIcon",
      /*updateConditionIcon_handler*/
      i[34]
    ), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        o[0] & /*customIcons*/
        8 && (a.conditionKey = /*conditionKey*/
        r[49]), o[0] & /*customIcons*/
        8 && (a.icon = /*icon*/
        r[50]), !t && o[0] & /*reload*/
        1 && (t = !0, a.reload = /*reload*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(Wj, "create_each_block$7");
function eye(i) {
  let e, t, s = ue(Object.entries(
    /*customIcons*/
    i[3]
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = Wj(Vj(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "condition-grid svelte-1tvn8jx");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o[0] & /*customIcons, reload, updateConditionIcon*/
      4105) {
        s = ue(Object.entries(
          /*customIcons*/
          r[3]
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = Vj(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = Wj(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(eye, "create_default_slot_6$2");
function tye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showEffectsPanel",
      checked: (
        /*updates*/
        i[13].get("showEffectsPanel") ?? /*$showEffectsPanel*/
        i[10] ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[35]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$showEffectsPanel*/
      1024 && (l.checked = /*updates*/
      s[13].get("showEffectsPanel") ?? /*$showEffectsPanel*/
      s[10] ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(tye, "create_default_slot_5$2");
function sye(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      e = E("label"), e.textContent = "Top Offset", t = F(), s = E("input"), b(e, "for", "top-offset"), b(s, "id", "top-offset"), b(s, "class", "a5e-input a5e-input--slim"), b(s, "type", "number"), s.value = n = /*selectedOffset*/
      i[5].top;
    },
    m(o, a) {
      T(o, e, a), T(o, t, a), T(o, s, a), l || (r = W(
        s,
        "change",
        /*change_handler*/
        i[37]
      ), l = !0);
    },
    p(o, a) {
      a[0] & /*selectedOffset*/
      32 && n !== (n = /*selectedOffset*/
      o[5].top) && s.value !== n && (s.value = n);
    },
    d(o) {
      o && (C(e), C(t), C(s)), l = !1, r();
    }
  };
}
u(sye, "create_default_slot_4$2");
function nye(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      e = E("label"), e.textContent = "Bottom Offset", t = F(), s = E("input"), b(e, "for", "bottom-offset"), b(s, "class", "a5e-input a5e-input--slim"), b(s, "type", "number"), s.value = n = /*selectedOffset*/
      i[5].bottom;
    },
    m(o, a) {
      T(o, e, a), T(o, t, a), T(o, s, a), l || (r = W(
        s,
        "change",
        /*change_handler_1*/
        i[38]
      ), l = !0);
    },
    p(o, a) {
      a[0] & /*selectedOffset*/
      32 && n !== (n = /*selectedOffset*/
      o[5].bottom) && s.value !== n && (s.value = n);
    },
    d(o) {
      o && (C(e), C(t), C(s)), l = !1, r();
    }
  };
}
u(nye, "create_default_slot_3$3");
function iye(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      e = E("label"), e.textContent = "Right Offset", t = F(), s = E("input"), b(e, "for", "right-offset"), b(s, "class", "a5e-input a5e-input--slim"), b(s, "type", "number"), s.value = n = /*selectedOffset*/
      i[5].right;
    },
    m(o, a) {
      T(o, e, a), T(o, t, a), T(o, s, a), l || (r = W(
        s,
        "change",
        /*change_handler_2*/
        i[39]
      ), l = !0);
    },
    p(o, a) {
      a[0] & /*selectedOffset*/
      32 && n !== (n = /*selectedOffset*/
      o[5].right) && s.value !== n && (s.value = n);
    },
    d(o) {
      o && (C(e), C(t), C(s)), l = !1, r();
    }
  };
}
u(iye, "create_default_slot_2$3");
function lye(i) {
  let e, t, s, n, l, r, o;
  return t = new ie({
    props: {
      $$slots: { default: [sye] },
      $$scope: { ctx: i }
    }
  }), n = new ie({
    props: {
      $$slots: { default: [nye] },
      $$scope: { ctx: i }
    }
  }), r = new ie({
    props: {
      $$slots: { default: [iye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("div"), j(t.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), b(e, "class", "u-flex u-gap-md");
    },
    m(a, c) {
      T(a, e, c), R(t, e, null), A(e, s), R(n, e, null), A(e, l), R(r, e, null), o = !0;
    },
    p(a, c) {
      const f = {};
      c[0] & /*selectedOffset*/
      32 | c[1] & /*$$scope*/
      4194304 && (f.$$scope = { dirty: c, ctx: a }), t.$set(f);
      const d = {};
      c[0] & /*selectedOffset*/
      32 | c[1] & /*$$scope*/
      4194304 && (d.$$scope = { dirty: c, ctx: a }), n.$set(d);
      const p = {};
      c[0] & /*selectedOffset*/
      32 | c[1] & /*$$scope*/
      4194304 && (p.$$scope = { dirty: c, ctx: a }), r.$set(p);
    },
    i(a) {
      o || (w(t.$$.fragment, a), w(n.$$.fragment, a), w(r.$$.fragment, a), o = !0);
    },
    o(a) {
      O(t.$$.fragment, a), O(n.$$.fragment, a), O(r.$$.fragment, a), o = !1;
    },
    d(a) {
      a && C(e), N(t), N(n), N(r);
    }
  };
}
u(lye, "create_default_slot_1$4");
function rye(i) {
  let e, t, s, n, l, r;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.showEffectsPanel",
      $$slots: { default: [tye] },
      $$scope: { ctx: i }
    }
  }), s = new Ke({
    props: {
      heading: "A5E.settings.effectsPanelIconSize",
      hint: "A5E.settings.hints.effectsPanelIconSize",
      options: Object.entries(
        /*iconSizeChoices*/
        i[18]
      ),
      selected: (
        /*selectedIconSize*/
        i[4]
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[36]
  ), l = new ie({
    props: {
      heading: "A5E.settings.effectsPanelPosition",
      hint: "A5E.settings.hints.effectsPanelPosition",
      $$slots: { default: [lye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), R(s, o, a), T(o, n, a), R(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a[0] & /*$showEffectsPanel, reload*/
      1025 | a[1] & /*$$scope*/
      4194304 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const f = {};
      a[0] & /*selectedIconSize*/
      16 && (f.selected = /*selectedIconSize*/
      o[4]), s.$set(f);
      const d = {};
      a[0] & /*selectedOffset*/
      32 | a[1] & /*$$scope*/
      4194304 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(s.$$.fragment, o), O(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (C(t), C(n)), N(e, o), N(s, o), N(l, o);
    }
  };
}
u(rye, "create_default_slot$c");
function oye(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p;
  return e = new De({
    props: {
      heading: "A5E.settings.automateConditions",
      $$slots: { default: [Q_e] },
      $$scope: { ctx: i }
    }
  }), n = new De({
    props: {
      heading: "Condition Interface Layout",
      $$slots: { default: [x_e] },
      $$scope: { ctx: i }
    }
  }), o = new De({
    props: {
      heading: "Custom Effect Icons",
      headerButtons: [
        {
          classes: "reset-button",
          label: "Reset Icons to Defaults",
          handler: (
            /*resetIcons*/
            i[11]
          )
        }
      ],
      $$slots: { default: [eye] },
      $$scope: { ctx: i }
    }
  }), f = new De({
    props: {
      heading: "Effects Panel",
      $$slots: { default: [rye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), l = E("div"), j(n.$$.fragment), r = F(), a = E("div"), j(o.$$.fragment), c = F(), d = E("div"), j(f.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem"), G(l, "display", "contents"), G(l, "--a5e-section-body-gap", "0.5rem"), G(a, "display", "contents"), G(a, "--a5e-section-body-gap", "0.5rem"), G(d, "display", "contents"), G(d, "--a5e-section-body-gap", "0.5rem");
    },
    m(m, g) {
      T(m, t, g), R(e, t, null), T(m, s, g), T(m, l, g), R(n, l, null), T(m, r, g), T(m, a, g), R(o, a, null), T(m, c, g), T(m, d, g), R(f, d, null), p = !0;
    },
    p(m, g) {
      const h = {};
      g[0] & /*$removeEffects, $radialEffects, reload, $automateUnconscious, $automateBloodied, selectedConditions*/
      965 | g[1] & /*$$scope*/
      4194304 && (h.$$scope = { dirty: g, ctx: m }), e.$set(h);
      const _ = {};
      g[0] & /*selectedConditionFlowDirection, reload*/
      3 | g[1] & /*$$scope*/
      4194304 && (_.$$scope = { dirty: g, ctx: m }), n.$set(_);
      const y = {};
      g[0] & /*customIcons, reload*/
      9 | g[1] & /*$$scope*/
      4194304 && (y.$$scope = { dirty: g, ctx: m }), o.$set(y);
      const v = {};
      g[0] & /*selectedOffset, selectedIconSize, $showEffectsPanel, reload*/
      1073 | g[1] & /*$$scope*/
      4194304 && (v.$$scope = { dirty: g, ctx: m }), f.$set(v);
    },
    i(m) {
      p || (w(e.$$.fragment, m), w(n.$$.fragment, m), w(o.$$.fragment, m), w(f.$$.fragment, m), p = !0);
    },
    o(m) {
      O(e.$$.fragment, m), O(n.$$.fragment, m), O(o.$$.fragment, m), O(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && (C(s), C(r), C(c)), m && e && C(t), N(e, m), m && n && C(l), N(n, m), m && o && C(a), N(o, m), m && f && C(d), N(f, m);
    }
  };
}
u(oye, "create_fragment$r");
function aye(i, e, t) {
  let s, n, l, r, o, a, c, f, d, p, { reload: m } = e;
  function g() {
    return Object.entries(S).reduce(
      (we, [Fe, xe]) => {
        var vt;
        return we[Fe] = ((vt = v.get("customConditionIcons")) == null ? void 0 : vt[Fe]) ?? (o == null ? void 0 : o[Fe]) ?? xe ?? "", we;
      },
      {}
    );
  }
  u(g, "getCustomIcons");
  async function h() {
    const we = new Uk();
    await we.render(!0);
    let Fe = await we.promise;
    !Fe || !Fe.confirmReset || (Object.keys(S).forEach((xe) => {
      const vt = S[xe];
      t(3, ne[xe] = vt, ne);
    }), v.set("customConditionIcons", ne), t(0, m = !0), t(3, ne = g()));
  }
  u(h, "resetIcons");
  function _(we, Fe) {
    new FilePicker({
      type: "image",
      current: Fe,
      callback: /* @__PURE__ */ u((vt) => {
        t(3, ne[we] = vt, ne), v.set("customConditionIcons", ne), t(3, ne = g()), t(0, m = !0);
      }, "callback")
    }).browse();
  }
  u(_, "updateConditionIcon");
  const y = de("settings"), v = de("updates");
  let { conditions: k, conditionIconsDefault: S } = CONFIG.A5E;
  const D = Object.entries(k).reduce(
    (we, Fe) => (["frightened"].includes(Fe) || we.push(Fe), we),
    []
  ), I = y.getStore("automateUnconsciousApplication");
  pe(i, I, (we) => t(7, c = we));
  const M = y.getStore("automatedConditions");
  pe(i, M, (we) => t(42, l = we));
  const L = game.settings.settings.get("a5e.conditionFlowDirection").choices, B = game.settings.settings.get("a5e.effectsPanelIconSize").choices;
  let z = y.getStore("automateBloodiedApplication");
  pe(i, z, (we) => t(6, a = we));
  let q = y.getStore("conditionFlowDirection");
  pe(i, q, (we) => t(43, r = we));
  let U = y.getStore("showEffectsPanel");
  pe(i, U, (we) => t(10, p = we));
  let H = y.getStore("effectsPanelIconSize");
  pe(i, H, (we) => t(41, n = we));
  let V = y.getStore("effectsPanelOffset");
  pe(i, V, (we) => t(40, s = we));
  let Y = y.getStore("enableRadialEffects");
  pe(i, Y, (we) => t(8, f = we));
  let J = y.getStore("removeActiveEffectsOnLongRest");
  pe(i, J, (we) => t(9, d = we));
  let fe = y.getStore("customConditionIcons");
  pe(i, fe, (we) => t(44, o = we));
  let ke = v.get("conditionFlowDirection") ?? r, ee = v.get("automatedConditions") ?? l, ne = g(), Ee = v.get("effectsPanelIconSize") ?? n ?? "medium", Pe = v.get("effectsPanelOffset") ?? s;
  const ye = /* @__PURE__ */ u(({ detail: we }) => {
    v.set("automatedConditions", we), t(2, ee = we), t(0, m = !0);
  }, "updateSelection_handler"), me = /* @__PURE__ */ u(({ detail: we }) => {
    v.set("automateBloodiedApplication", we), t(0, m = !0);
  }, "updateSelection_handler_1"), Ce = /* @__PURE__ */ u(({ detail: we }) => {
    v.set("automateUnconsciousApplication", we), t(0, m = !0);
  }, "updateSelection_handler_2"), Je = /* @__PURE__ */ u(({ detail: we }) => {
    v.set("enableRadialEffects", we), t(0, m = !0);
  }, "updateSelection_handler_3"), Ne = /* @__PURE__ */ u(({ detail: we }) => {
    v.set("removeActiveEffectsOnLongRest", we);
  }, "updateSelection_handler_4"), Re = /* @__PURE__ */ u(({ detail: we }) => {
    v.set("conditionFlowDirection", we), t(1, ke = we), t(0, m = !0);
  }, "updateSelection_handler_5");
  function ge(we) {
    m = we, t(0, m);
  }
  u(ge, "settingscustomicon_reload_binding");
  const je = /* @__PURE__ */ u(({ detail: we }) => _(...we), "updateConditionIcon_handler"), Be = /* @__PURE__ */ u(({ detail: we }) => {
    v.set("showEffectsPanel", we), t(0, m = !0);
  }, "updateSelection_handler_6"), Ze = /* @__PURE__ */ u(({ detail: we }) => {
    v.set("effectsPanelIconSize", we), t(4, Ee = we);
  }, "updateSelection_handler_7"), Ge = /* @__PURE__ */ u(({ target: we }) => {
    const { value: Fe } = we;
    t(5, Pe.top = Number(Fe), Pe), v.set("effectsPanelOffset", Pe);
  }, "change_handler"), Se = /* @__PURE__ */ u(({ target: we }) => {
    const { value: Fe } = we;
    t(5, Pe.bottom = Number(Fe), Pe), v.set("effectsPanelOffset", Pe);
  }, "change_handler_1"), _e = /* @__PURE__ */ u(({ target: we }) => {
    const { value: Fe } = we;
    t(5, Pe.right = Number(Fe), Pe), v.set("effectsPanelOffset", Pe);
  }, "change_handler_2");
  return i.$$set = (we) => {
    "reload" in we && t(0, m = we.reload);
  }, [
    m,
    ke,
    ee,
    ne,
    Ee,
    Pe,
    a,
    c,
    f,
    d,
    p,
    h,
    _,
    v,
    D,
    I,
    M,
    L,
    B,
    z,
    q,
    U,
    H,
    V,
    Y,
    J,
    fe,
    ye,
    me,
    Ce,
    Je,
    Ne,
    Re,
    ge,
    je,
    Be,
    Ze,
    Ge,
    Se,
    _e
  ];
}
u(aye, "instance$p");
const t3 = class t3 extends re {
  constructor(e) {
    super(), oe(this, e, aye, oye, le, { reload: 0 }, null, [-1, -1]);
  }
};
u(t3, "SettingsEffectsTab");
let Wk = t3;
function cye(i) {
  let e, t, s, n, l, r, o;
  return e = new De({
    props: {
      heading: "Sheet Settings",
      $$slots: { default: [dye] },
      $$scope: { ctx: i }
    }
  }), n = new De({
    props: {
      heading: "Cascading Damage Settings",
      $$slots: { default: [hye] },
      $$scope: { ctx: i }
    }
  }), r = new De({
    props: {
      heading: "Other Settings",
      $$slots: { default: [bye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(a, c) {
      T(a, t, c), R(e, t, null), T(a, s, c), R(n, a, c), T(a, l, c), R(r, a, c), o = !0;
    },
    p(a, c) {
      const f = {};
      c & /*$$scope, $fancySheetsAutoApply, reload, selectedNamingMode, $showLimitedDesc*/
      67108893 && (f.$$scope = { dirty: c, ctx: a }), e.$set(f);
      const d = {};
      c & /*$$scope, newCascadingDamageAndHealingDelay, $enableCascadingDamageAndHealing, reload*/
      67108899 && (d.$$scope = { dirty: c, ctx: a }), n.$set(d);
      const p = {};
      c & /*$$scope, reload*/
      67108865 && (p.$$scope = { dirty: c, ctx: a }), r.$set(p);
    },
    i(a) {
      o || (w(e.$$.fragment, a), w(n.$$.fragment, a), w(r.$$.fragment, a), o = !0);
    },
    o(a) {
      O(e.$$.fragment, a), O(n.$$.fragment, a), O(r.$$.fragment, a), o = !1;
    },
    d(a) {
      a && (C(s), C(l)), a && e && C(t), N(e, a), N(n, a), N(r, a);
    }
  };
}
u(cye, "create_if_block$9");
function uye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showDescriptionOnLimitedPerms",
      checked: (
        /*updates*/
        i[6].get("showDescriptionOnLimitedPerms") ?? /*$showLimitedDesc*/
        i[3] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$showLimitedDesc*/
      8 && (l.checked = /*updates*/
      s[6].get("showDescriptionOnLimitedPerms") ?? /*$showLimitedDesc*/
      s[3] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(uye, "create_default_slot_7$1");
function fye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.autoApplyFancySheets",
      checked: (
        /*updates*/
        i[6].get("autoApplyFancySheets") ?? /*$fancySheetsAutoApply*/
        i[4] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[18]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$fancySheetsAutoApply*/
      16 && (l.checked = /*updates*/
      s[6].get("autoApplyFancySheets") ?? /*$fancySheetsAutoApply*/
      s[4] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(fye, "create_default_slot_6$1");
function dye(i) {
  let e, t, s, n, l, r;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.showDescriptionOnLimitedPerms",
      $$slots: { default: [uye] },
      $$scope: { ctx: i }
    }
  }), s = new Ke({
    props: {
      hint: "A5E.settings.hints.newActionNameType",
      options: (
        /*actionTypeOptions*/
        i[8]
      ),
      selected: (
        /*selectedNamingMode*/
        i[2]
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), l = new ie({
    props: {
      hint: "A5E.settings.hints.autoApplyFancySheets",
      $$slots: { default: [fye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment);
    },
    m(o, a) {
      R(e, o, a), T(o, t, a), R(s, o, a), T(o, n, a), R(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, $showLimitedDesc, reload*/
      67108873 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const f = {};
      a & /*selectedNamingMode*/
      4 && (f.selected = /*selectedNamingMode*/
      o[2]), s.$set(f);
      const d = {};
      a & /*$$scope, $fancySheetsAutoApply, reload*/
      67108881 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(s.$$.fragment, o), O(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (C(t), C(n)), N(e, o), N(s, o), N(l, o);
    }
  };
}
u(dye, "create_default_slot_5$1");
function pye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.enableCascadingDamageAndHealing",
      checked: (
        /*updates*/
        i[6].get("enableCascadingDamageAndHealing") ?? /*$enableCascadingDamageAndHealing*/
        i[5] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[19]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$enableCascadingDamageAndHealing*/
      32 && (l.checked = /*updates*/
      s[6].get("enableCascadingDamageAndHealing") ?? /*$enableCascadingDamageAndHealing*/
      s[5] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(pye, "create_default_slot_4$1");
function mye(i) {
  let e, t, s;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), e.value = /*newCascadingDamageAndHealingDelay*/
      i[1];
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "change",
        /*change_handler*/
        i[20]
      ), t = !0);
    },
    p(n, l) {
      l & /*newCascadingDamageAndHealingDelay*/
      2 && e.value !== /*newCascadingDamageAndHealingDelay*/
      n[1] && (e.value = /*newCascadingDamageAndHealingDelay*/
      n[1]);
    },
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(mye, "create_default_slot_3$2");
function hye(i) {
  let e, t, s, n;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.enableCascadingDamageAndHealing",
      $$slots: { default: [pye] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      heading: "A5E.settings.cascadingDamageAndHealingDelay",
      hint: "A5E.settings.hints.cascadingDamageAndHealingDelay",
      $$slots: { default: [mye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, $enableCascadingDamageAndHealing, reload*/
      67108897 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, newCascadingDamageAndHealingDelay*/
      67108866 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(hye, "create_default_slot_2$2");
function gye(i) {
  let e, t, s;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = /*selectedGamemasterTitle*/
      i[15];
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "change",
        /*change_handler_1*/
        i[21]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(gye, "create_default_slot_1$3");
function bye(i) {
  let e, t;
  return e = new ie({
    props: {
      heading: "Gamemaster Title",
      $$slots: { default: [gye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, reload*/
      67108865 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(bye, "create_default_slot$b");
function _ye(i) {
  let e, t, s = (
    /*isGM*/
    i[7] && cye(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, [l]) {
      /*isGM*/
      n[7] && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      O(s), t = !1;
    },
    d(n) {
      n && C(e), s && s.d(n);
    }
  };
}
u(_ye, "create_fragment$q");
function yye(i, e, t) {
  let s, n, l, r, o, a, { reload: c } = e;
  const f = de("settings"), d = de("updates"), p = game.user.isGM, m = [["system", "System Defined"], ["action", "New Action"], ["item", "Item Name"]];
  let g = f.getStore("newActionNameType");
  pe(i, g, (H) => t(23, n = H));
  let h = f.getStore("autoApplyFancySheets");
  pe(i, h, (H) => t(4, o = H));
  let _ = f.getStore("gamemasterTitle");
  pe(i, _, (H) => t(22, s = H));
  let y = f.getStore("showDescriptionOnLimitedPerms");
  pe(i, y, (H) => t(3, r = H));
  let v = f.getStore("cascadingDamageAndHealingDelay");
  pe(i, v, (H) => t(24, l = H));
  let k = f.getStore("enableCascadingDamageAndHealing");
  pe(i, k, (H) => t(5, a = H));
  let S = d.get("cascadingDamageAndHealingDelay") ?? l, D = d.get("newActionNameType") ?? n ?? "system", I = d.get("gamemasterTitle") ?? s;
  const M = /* @__PURE__ */ u(({ detail: H }) => {
    d.set("showDescriptionOnLimitedPerms", H), t(0, c = !0);
  }, "updateSelection_handler"), L = /* @__PURE__ */ u(({ detail: H }) => {
    d.set("newActionNameType", H), t(2, D = H);
  }, "updateSelection_handler_1"), B = /* @__PURE__ */ u(({ detail: H }) => {
    d.set("autoApplyFancySheets", H), t(0, c = !0);
  }, "updateSelection_handler_2"), z = /* @__PURE__ */ u(({ detail: H }) => {
    d.set("enableCascadingDamageAndHealing", H), t(0, c = !0);
  }, "updateSelection_handler_3"), q = /* @__PURE__ */ u(({ target: H }) => {
    const { value: V } = H;
    t(1, S = Number(V)), d.set("cascadingDamageAndHealingDelay", Number(V));
  }, "change_handler"), U = /* @__PURE__ */ u(({ target: H }) => {
    var V, Y;
    d.set("gamemasterTitle", ((Y = (V = H.value) == null ? void 0 : V.trim) == null ? void 0 : Y.call(V)) ?? ""), t(0, c = !0);
  }, "change_handler_1");
  return i.$$set = (H) => {
    "reload" in H && t(0, c = H.reload);
  }, [
    c,
    S,
    D,
    r,
    o,
    a,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    v,
    k,
    I,
    M,
    L,
    B,
    z,
    q,
    U
  ];
}
u(yye, "instance$o");
const s3 = class s3 extends re {
  constructor(e) {
    super(), oe(this, e, yye, _ye, le, { reload: 0 });
  }
};
u(s3, "SettingsMiscTab");
let Kk = s3;
function vye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Show character images in the party viewer",
      checked: (
        /*updates*/
        i[3].get("showActorImagesInPartyViewer") ?? /*$showActorImages*/
        i[1] ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$showActorImages*/
      2 && (l.checked = /*updates*/
      s[3].get("showActorImagesInPartyViewer") ?? /*$showActorImages*/
      s[1] ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(vye, "create_default_slot_3$1");
function kye(i) {
  let e, t;
  return e = new ie({
    props: {
      $$slots: { default: [vye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $showActorImages, reload*/
      1027 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(kye, "create_default_slot_2$1");
function wye(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Player Access",
      $$slots: { default: [Aye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, $playersCanAccess, reload*/
      1029 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(wye, "create_if_block$8");
function $ye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "Players can access the Party Viewer",
      checked: (
        /*updates*/
        i[3].get("playersCanAccessPartyViewer") ?? /*$playersCanAccess*/
        i[2] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$playersCanAccess*/
      4 && (l.checked = /*updates*/
      s[3].get("playersCanAccessPartyViewer") ?? /*$playersCanAccess*/
      s[2] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u($ye, "create_default_slot_1$2");
function Aye(i) {
  let e, t;
  return e = new ie({
    props: {
      hint: "Players will be able to view but not edit the summary information in the Party Viewer window.",
      $$slots: { default: [$ye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $playersCanAccess, reload*/
      1029 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Aye, "create_default_slot$a");
function Eye(i) {
  let e, t, s, n, l;
  e = new De({
    props: {
      heading: "Appearance",
      $$slots: { default: [kye] },
      $$scope: { ctx: i }
    }
  });
  let r = (
    /*isGM*/
    i[4] && wye(i)
  );
  return {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), r && r.c(), n = $e(), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(o, a) {
      T(o, t, a), R(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*$$scope, $showActorImages, reload*/
      1027 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c), /*isGM*/
      o[4] && r.p(o, a);
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      O(e.$$.fragment, o), O(r), l = !1;
    },
    d(o) {
      o && (C(s), C(n)), o && e && C(t), N(e, o), r && r.d(o);
    }
  };
}
u(Eye, "create_fragment$p");
function Sye(i, e, t) {
  let s, n, { reload: l } = e;
  const r = de("settings"), o = de("updates"), a = game.user.isGM;
  let c = r.getStore("playersCanAccessPartyViewer");
  pe(i, c, (m) => t(2, n = m));
  let f = r.getStore("showActorImagesInPartyViewer");
  pe(i, f, (m) => t(1, s = m));
  const d = /* @__PURE__ */ u(({ detail: m }) => {
    o.set("showActorImagesInPartyViewer", m), t(0, l = !0);
  }, "updateSelection_handler"), p = /* @__PURE__ */ u(({ detail: m }) => {
    o.set("playersCanAccessPartyViewer", m), t(0, l = !0);
  }, "updateSelection_handler_1");
  return i.$$set = (m) => {
    "reload" in m && t(0, l = m.reload);
  }, [
    l,
    s,
    n,
    o,
    a,
    c,
    f,
    d,
    p
  ];
}
u(Sye, "instance$n");
const n3 = class n3 extends re {
  constructor(e) {
    super(), oe(this, e, Sye, Eye, le, { reload: 0 });
  }
};
u(n3, "SettingsPartyViewerTab");
let Yk = n3;
function Cye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.preventActionRollOnWarning",
      checked: (
        /*updates*/
        i[2].get("preventActionRollOnWarning") ?? /*$preventActivationRoll*/
        i[1] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[7]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$preventActivationRoll*/
      2 && (l.checked = /*updates*/
      s[2].get("preventActionRollOnWarning") ?? /*$preventActivationRoll*/
      s[1] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Cye, "create_default_slot_1$1");
function Tye(i) {
  let e, t, s, n;
  return e = new Ke({
    props: {
      hint: "A5E.settings.hints.critCalculationMode",
      options: Object.entries(
        /*critCalculationModeOptions*/
        i[5]
      ),
      selected: (
        /*selectedCritMode*/
        i[0]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  ), s = new ie({
    props: {
      hint: "A5E.settings.hints.preventActionRollOnWarning",
      $$slots: { default: [Cye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*selectedCritMode*/
      1 && (o.selected = /*selectedCritMode*/
      l[0]), e.$set(o);
      const a = {};
      r & /*$$scope, $preventActivationRoll*/
      1026 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(Tye, "create_default_slot$9");
function Oye(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "Generic Roll Settings",
      $$slots: { default: [Tye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, $preventActivationRoll, selectedCritMode*/
      1027 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Oye, "create_fragment$o");
function Dye(i, e, t) {
  let s, n;
  const l = de("settings"), r = de("updates");
  let o = l.getStore("critCalculationMode");
  pe(i, o, (m) => t(8, s = m));
  let a = l.getStore("preventActionRollOnWarning");
  pe(i, a, (m) => t(1, n = m));
  let c = r.get("critCalculationMode") ?? s;
  const f = game.settings.settings.get("a5e.critCalculationMode").choices;
  return [
    c,
    n,
    r,
    o,
    a,
    f,
    /* @__PURE__ */ u(({ detail: m }) => {
      r.set("critCalculationMode", m), t(0, c = m);
    }, "updateSelection_handler"),
    /* @__PURE__ */ u(({ detail: m }) => {
      r.set("preventActionRollOnWarning", m);
    }, "updateSelection_handler_1")
  ];
}
u(Dye, "instance$m");
const i3 = class i3 extends re {
  constructor(e) {
    super(), oe(this, e, Dye, Oye, le, {});
  }
};
u(i3, "SettingsRollTab");
let Xk = i3;
function Iye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showVRCImplants",
      checked: (
        /*updates*/
        i[8].get("showVRCImplants") ?? /*$showVRCImplants*/
        i[1] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$showVRCImplants*/
      2 && (l.checked = /*updates*/
      s[8].get("showVRCImplants") ?? /*$showVRCImplants*/
      s[1] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Iye, "create_default_slot_7");
function Pye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showVRCProficiencies",
      checked: (
        /*updates*/
        i[8].get("showVRCProficiencies") ?? /*$showVRCProficiencies*/
        i[2] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$showVRCProficiencies*/
      4 && (l.checked = /*updates*/
      s[8].get("showVRCProficiencies") ?? /*$showVRCProficiencies*/
      s[2] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Pye, "create_default_slot_6");
function Mye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showVRCPsionicDisciplines",
      checked: (
        /*updates*/
        i[8].get("showVRCPsionicDisciplines") ?? /*$showVRCPsionicDisciplines*/
        i[3] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[18]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$showVRCPsionicDisciplines*/
      8 && (l.checked = /*updates*/
      s[8].get("showVRCPsionicDisciplines") ?? /*$showVRCPsionicDisciplines*/
      s[3] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Mye, "create_default_slot_5");
function Fye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showVRCSkills",
      checked: (
        /*updates*/
        i[8].get("showVRCSkills") ?? /*$showVRCSkills*/
        i[4] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[19]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$showVRCSkills*/
      16 && (l.checked = /*updates*/
      s[8].get("showVRCSkills") ?? /*$showVRCSkills*/
      s[4] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Fye, "create_default_slot_4");
function Rye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showVRCSpecialties",
      checked: (
        /*updates*/
        i[8].get("showVRCSpecialties") ?? /*$showVRCSpecialties*/
        i[5] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[20]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$showVRCSpecialties*/
      32 && (l.checked = /*updates*/
      s[8].get("showVRCSpecialties") ?? /*$showVRCSpecialties*/
      s[5] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Rye, "create_default_slot_3");
function Nye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.showVRCTechLevel",
      checked: (
        /*updates*/
        i[8].get("showVRCTechLevel") ?? /*$showVRCTechLevel*/
        i[6] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[21]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$showVRCTechLevel*/
      64 && (l.checked = /*updates*/
      s[8].get("showVRCTechLevel") ?? /*$showVRCTechLevel*/
      s[6] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Nye, "create_default_slot_2");
function jye(i) {
  let e, t;
  return e = new Te({
    props: {
      label: "A5E.settings.useCredits",
      checked: (
        /*updates*/
        i[8].get("useCredits") ?? /*$useCredits*/
        i[7] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[22]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$useCredits*/
      128 && (l.checked = /*updates*/
      s[8].get("useCredits") ?? /*$useCredits*/
      s[7] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(jye, "create_default_slot_1");
function Lye(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g;
  return e = new ie({
    props: {
      hint: "A5E.settings.hints.showVRCImplants",
      $$slots: { default: [Iye] },
      $$scope: { ctx: i }
    }
  }), s = new ie({
    props: {
      hint: "A5E.settings.hints.showVRCProficiencies",
      $$slots: { default: [Pye] },
      $$scope: { ctx: i }
    }
  }), l = new ie({
    props: {
      hint: "A5E.settings.hints.showVRCPsionicDisciplines",
      $$slots: { default: [Mye] },
      $$scope: { ctx: i }
    }
  }), o = new ie({
    props: {
      hint: "A5E.settings.hints.showVRCSkills",
      $$slots: { default: [Fye] },
      $$scope: { ctx: i }
    }
  }), c = new ie({
    props: {
      hint: "A5E.settings.hints.showVRCSpecialties",
      $$slots: { default: [Rye] },
      $$scope: { ctx: i }
    }
  }), d = new ie({
    props: {
      hint: "A5E.settings.hints.showVRCTechLevel",
      $$slots: { default: [Nye] },
      $$scope: { ctx: i }
    }
  }), m = new ie({
    props: {
      hint: "A5E.settings.hints.useCredits",
      $$slots: { default: [jye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment), n = F(), j(l.$$.fragment), r = F(), j(o.$$.fragment), a = F(), j(c.$$.fragment), f = F(), j(d.$$.fragment), p = F(), j(m.$$.fragment);
    },
    m(h, _) {
      R(e, h, _), T(h, t, _), R(s, h, _), T(h, n, _), R(l, h, _), T(h, r, _), R(o, h, _), T(h, a, _), R(c, h, _), T(h, f, _), R(d, h, _), T(h, p, _), R(m, h, _), g = !0;
    },
    p(h, _) {
      const y = {};
      _ & /*$$scope, $showVRCImplants, reload*/
      16777219 && (y.$$scope = { dirty: _, ctx: h }), e.$set(y);
      const v = {};
      _ & /*$$scope, $showVRCProficiencies, reload*/
      16777221 && (v.$$scope = { dirty: _, ctx: h }), s.$set(v);
      const k = {};
      _ & /*$$scope, $showVRCPsionicDisciplines, reload*/
      16777225 && (k.$$scope = { dirty: _, ctx: h }), l.$set(k);
      const S = {};
      _ & /*$$scope, $showVRCSkills, reload*/
      16777233 && (S.$$scope = { dirty: _, ctx: h }), o.$set(S);
      const D = {};
      _ & /*$$scope, $showVRCSpecialties, reload*/
      16777249 && (D.$$scope = { dirty: _, ctx: h }), c.$set(D);
      const I = {};
      _ & /*$$scope, $showVRCTechLevel, reload*/
      16777281 && (I.$$scope = { dirty: _, ctx: h }), d.$set(I);
      const M = {};
      _ & /*$$scope, $useCredits, reload*/
      16777345 && (M.$$scope = { dirty: _, ctx: h }), m.$set(M);
    },
    i(h) {
      g || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(l.$$.fragment, h), w(o.$$.fragment, h), w(c.$$.fragment, h), w(d.$$.fragment, h), w(m.$$.fragment, h), g = !0);
    },
    o(h) {
      O(e.$$.fragment, h), O(s.$$.fragment, h), O(l.$$.fragment, h), O(o.$$.fragment, h), O(c.$$.fragment, h), O(d.$$.fragment, h), O(m.$$.fragment, h), g = !1;
    },
    d(h) {
      h && (C(t), C(n), C(r), C(a), C(f), C(p)), N(e, h), N(s, h), N(l, h), N(o, h), N(c, h), N(d, h), N(m, h);
    }
  };
}
u(Lye, "create_default_slot$8");
function Bye(i) {
  let e, t, s;
  return e = new De({
    props: {
      heading: "A5E.settings.sectionHeader.vrc",
      $$slots: { default: [Lye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, $useCredits, reload, $showVRCTechLevel, $showVRCSpecialties, $showVRCSkills, $showVRCPsionicDisciplines, $showVRCProficiencies, $showVRCImplants*/
      16777471 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(Bye, "create_fragment$n");
function qye(i, e, t) {
  let s, n, l, r, o, a, c, { reload: f } = e;
  const d = de("settings"), p = de("updates");
  let m = d.getStore("showVRCImplants");
  pe(i, m, (q) => t(1, s = q));
  let g = d.getStore("showVRCProficiencies");
  pe(i, g, (q) => t(2, n = q));
  let h = d.getStore("showVRCPsionicDisciplines");
  pe(i, h, (q) => t(3, l = q));
  let _ = d.getStore("showVRCSkills");
  pe(i, _, (q) => t(4, r = q));
  let y = d.getStore("showVRCSpecialties");
  pe(i, y, (q) => t(5, o = q));
  let v = d.getStore("showVRCTechLevel");
  pe(i, v, (q) => t(6, a = q));
  let k = d.getStore("useCredits");
  pe(i, k, (q) => t(7, c = q));
  const S = /* @__PURE__ */ u(({ detail: q }) => {
    p.set("showVRCImplants", q), t(0, f = !0);
  }, "updateSelection_handler"), D = /* @__PURE__ */ u(({ detail: q }) => {
    p.set("showVRCProficiencies", q), t(0, f = !0);
  }, "updateSelection_handler_1"), I = /* @__PURE__ */ u(({ detail: q }) => {
    p.set("showVRCPsionicDisciplines", q), t(0, f = !0);
  }, "updateSelection_handler_2"), M = /* @__PURE__ */ u(({ detail: q }) => {
    p.set("showVRCSkills", q), t(0, f = !0);
  }, "updateSelection_handler_3"), L = /* @__PURE__ */ u(({ detail: q }) => {
    p.set("showVRCSpecialties", q), t(0, f = !0);
  }, "updateSelection_handler_4"), B = /* @__PURE__ */ u(({ detail: q }) => {
    p.set("showVRCTechLevel", q), t(0, f = !0);
  }, "updateSelection_handler_5"), z = /* @__PURE__ */ u(({ detail: q }) => {
    p.set("useCredits", q), t(0, f = !0);
  }, "updateSelection_handler_6");
  return i.$$set = (q) => {
    "reload" in q && t(0, f = q.reload);
  }, [
    f,
    s,
    n,
    l,
    r,
    o,
    a,
    c,
    p,
    m,
    g,
    h,
    _,
    y,
    v,
    k,
    S,
    D,
    I,
    M,
    L,
    B,
    z
  ];
}
u(qye, "instance$l");
const l3 = class l3 extends re {
  constructor(e) {
    super(), oe(this, e, qye, Bye, le, { reload: 0 });
  }
};
u(l3, "SettingsExtraTab");
let Jk = l3;
function Gye(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fas fa-save");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(Gye, "create_else_block$2");
function zye(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fa-solid fa-circle-exclamation"), G(e, "color", "var(--a5e-color-warning)"), b(e, "data-tooltip", K("A5E.settings.reload")), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(zye, "create_if_block$7");
function Hye(i) {
  let e, t, s, n, l, r, o, a, c, f = K("A5E.SaveSubmit") + "", d, p, m, g;
  t = new Wn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[5]
      )
    }
  }), t.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[4]
  );
  function h(D) {
    i[10](D);
  }
  u(h, "switch_instance_reload_binding");
  var _ = (
    /*currentTab*/
    i[1].component
  );
  function y(D, I) {
    let M = {};
    return (
      /*reload*/
      D[2] !== void 0 && (M.reload = /*reload*/
      D[2]), { props: M }
    );
  }
  u(y, "switch_props"), _ && (l = et(_, y(i)), rt.push(() => Ot(l, "reload", h)));
  function v(D, I) {
    return (
      /*reload*/
      D[2] ? zye : Gye
    );
  }
  u(v, "select_block_type");
  let k = v(i), S = k(i);
  return {
    c() {
      e = E("main"), j(t.$$.fragment), s = F(), n = E("section"), l && j(l.$$.fragment), o = F(), a = E("button"), S.c(), c = F(), d = Q(f), b(n, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(a, "class", "submit svelte-i844f6"), b(e, "class", "svelte-i844f6");
    },
    m(D, I) {
      T(D, e, I), R(t, e, null), A(e, s), A(e, n), l && R(l, n, null), A(e, o), A(e, a), S.m(a, null), A(a, c), A(a, d), p = !0, m || (g = W(a, "click", st(
        /*click_handler*/
        i[11]
      )), m = !0);
    },
    p(D, I) {
      const M = {};
      if (I & /*currentTab*/
      2 && (M.currentTab = /*currentTab*/
      D[1]), t.$set(M), I & /*currentTab*/
      2 && _ !== (_ = /*currentTab*/
      D[1].component)) {
        if (l) {
          ae();
          const L = l;
          O(L.$$.fragment, 1, 0, () => {
            N(L, 1);
          }), ce();
        }
        _ ? (l = et(_, y(D)), rt.push(() => Ot(l, "reload", h)), j(l.$$.fragment), w(l.$$.fragment, 1), R(l, n, null)) : l = null;
      } else if (_) {
        const L = {};
        !r && I & /*reload*/
        4 && (r = !0, L.reload = /*reload*/
        D[2], It(() => r = !1)), l.$set(L);
      }
      k !== (k = v(D)) && (S.d(1), S = k(D), S && (S.c(), S.m(a, c)));
    },
    i(D) {
      p || (w(t.$$.fragment, D), l && w(l.$$.fragment, D), p = !0);
    },
    o(D) {
      O(t.$$.fragment, D), l && O(l.$$.fragment, D), p = !1;
    },
    d(D) {
      D && C(e), N(t), l && N(l), S.d(), m = !1, g();
    }
  };
}
u(Hye, "create_default_slot$7");
function Uye(i) {
  let e, t, s;
  function n(r) {
    i[12](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Hye] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, reload, currentTab*/
        131078 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(Uye, "create_fragment$m");
function Vye(i, e, t) {
  let s, { elementRoot: n } = e, { appId: l, settings: r, dialog: o } = de("#external").application, { appId: a = l, settings: c = r, dialog: f = o } = e;
  function d() {
    for (const [M, L] of h)
      c.getStore(M).set(L);
    f.submit({ reload: _ });
  }
  u(d, "onSubmit");
  function p(M) {
    t(1, g = m[M.detail]);
  }
  u(p, "updateCurrentTab");
  const m = [
    {
      name: "actor",
      label: "A5E.settings.navigation.actor",
      component: qk
    },
    {
      name: "canvas",
      label: "A5E.settings.navigation.canvas",
      component: Gk,
      display: game.user.isGM
    },
    {
      name: "chat",
      label: "A5E.settings.navigation.chat",
      component: zk
    },
    {
      name: "effects",
      label: "A5E.settings.navigation.activeEffects",
      component: Wk,
      display: game.user.isGM
    },
    {
      name: "partyViewer",
      label: "Party Viewer",
      component: Yk,
      display: s
    },
    {
      name: "rolls",
      label: "A5E.settings.navigation.rolls",
      component: Xk,
      display: game.user.isGM
    },
    {
      name: "5eSettings",
      label: "A5E.settings.navigation.5eSettings",
      component: Bk,
      display: game.user.isGM
    },
    {
      name: "extraSettings",
      label: "A5E.settings.navigation.extraSettings",
      component: Jk,
      display: game.user.isGM
    },
    {
      name: "misc",
      label: "A5E.settings.navigation.misc",
      component: Kk,
      display: game.user.isGM
    }
  ];
  let g = m[0], h = /* @__PURE__ */ new Map(), _ = !1, { settingsData: y } = c, v = y.reduce(
    (M, L) => {
      var B;
      return ((B = L == null ? void 0 : L.options) == null ? void 0 : B.scope) === "world" && M.add(L.key), M;
    },
    /* @__PURE__ */ new Set()
  );
  const k = c.getStore("playersCanAccessPartyViewer");
  pe(i, k, (M) => t(13, s = M)), lt("appId", a), lt("gmSettings", v), lt("settings", c), lt("updates", h);
  function S(M) {
    _ = M, t(2, _);
  }
  u(S, "switch_instance_reload_binding");
  const D = /* @__PURE__ */ u(() => d(), "click_handler");
  function I(M) {
    n = M, t(0, n);
  }
  return u(I, "applicationshell_elementRoot_binding"), i.$$set = (M) => {
    "elementRoot" in M && t(0, n = M.elementRoot), "appId" in M && t(7, a = M.appId), "settings" in M && t(8, c = M.settings), "dialog" in M && t(9, f = M.dialog);
  }, [
    n,
    g,
    _,
    d,
    p,
    m,
    k,
    a,
    c,
    f,
    S,
    D,
    I
  ];
}
u(Vye, "instance$k");
var xa;
let Wye = (xa = class extends re {
  constructor(e) {
    super(), oe(this, e, Vye, Uye, le, {
      elementRoot: 0,
      appId: 7,
      settings: 8,
      dialog: 9
    });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
  get appId() {
    return this.$$.ctx[7];
  }
  set appId(e) {
    this.$$set({ appId: e }), Xe();
  }
  get settings() {
    return this.$$.ctx[8];
  }
  set settings(e) {
    this.$$set({ settings: e }), Xe();
  }
  get dialog() {
    return this.$$.ctx[9];
  }
  set dialog(e) {
    this.$$set({ dialog: e }), Xe();
  }
}, u(xa, "SystemSettings"), xa);
var lg, hq;
const r3 = class r3 extends Gs {
  constructor(t = {}, s = {}) {
    super(
      {
        id: "a5e-system-settings",
        title: K("A5E.settings.title"),
        svelte: {
          class: Wye,
          target: document.body,
          props: {
            settings: _c
          }
        },
        width: 600,
        height: "auto",
        ...t
        // @ts-expect-error
      },
      { dialogData: s }
    );
    x(this, lg);
    qe(this, "promise", null);
    qe(this, "resolve", null);
    this.options.svelte.props.dialog = this, this.promise = new Promise((n) => {
      this.resolve = n;
    });
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5e-sheet", "a5e-settings-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      },
      token: null
    });
  }
  static getActiveApp() {
    return Object.values(ui.windows).find((t) => t.id === "a5e-system-settings");
  }
  static async show(t = {}, s = {}) {
    const n = this.getActiveApp();
    return n ? n.render(!1, { focus: !0 }) : new Promise((l) => {
      t.resolve = l, new this(t, s).render(!0, { focus: !0 });
    });
  }
  submit(t) {
    return X(this, lg, hq).call(this, t), t.reload && foundry.utils.debounce(() => window.location.reload(), 250)(), super.close();
  }
};
lg = new WeakSet(), hq = /* @__PURE__ */ u(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), u(r3, "SystemSettings");
let tm = r3;
function Kye() {
  game.keybindings.register("a5e", "party-sheet-open-close", {
    name: "Open/Close Party Sheet",
    editable: [{ key: "KeyP" }],
    onDown: /* @__PURE__ */ u(() => {
      !game.user.isGM && !game.settings.get("a5e", "playersCanAccessPartyViewer") || mq(!0);
    }, "onDown")
  }), game.keybindings.register("a5e", "system-settings-open-close", {
    name: "Open/Close System Settings",
    editable: [{ key: "KeyS", modifiers: ["Alt"] }],
    onDown: /* @__PURE__ */ u(() => {
      tm.show();
    }, "onDown")
  });
}
u(Kye, "registerKeybindings");
async function Yye(i) {
  i.preventDefault();
  const e = this.viewed, t = i.currentTarget;
  if (t.getAttribute("disabled")) return;
  t.setAttribute("disabled", !0);
  const s = e[t.dataset.control];
  let n = i.shiftKey ? CONFIG.A5E.ROLL_MODE.ADVANTAGE : CONFIG.A5E.ROLL_MODE.NORMAL;
  const l = game.settings.get("a5e", "reverseInitiativeAltBehavior");
  let o = game.settings.get("a5e", "reverseAltBehavior") ? !i.altKey : i.altKey;
  o = l ? !o : o, n = i.metaKey || i.ctrlKey ? CONFIG.A5E.ROLL_MODE.DISADVANTAGE : n, s && await s.bind(e)({
    rollOptions: {
      rollMode: n,
      skipRollDialog: o
    }
  }), t.removeAttribute("disabled");
}
u(Yye, "_onCombatControl");
async function Xye(i) {
  i.preventDefault(), i.stopPropagation();
  const e = i.currentTarget, t = e.closest(".combatant"), s = this.viewed, n = s.combatants.get(t.dataset.combatantId);
  let l = i.shiftKey ? CONFIG.A5E.ROLL_MODE.ADVANTAGE : CONFIG.A5E.ROLL_MODE.NORMAL;
  l = i.metaKey || i.ctrlKey ? CONFIG.A5E.ROLL_MODE.DISADVANTAGE : l;
  const r = game.settings.get("a5e", "reverseInitiativeAltBehavior");
  let a = game.settings.get("a5e", "reverseAltBehavior") ? !i.altKey : i.altKey;
  switch (a = r ? !a : a, e.dataset.control) {
    case "toggleHidden":
      return n.update({ hidden: !n.hidden });
    case "toggleDefeated":
      return this._onToggleDefeatedStatus(n);
    case "rollInitiative":
      return s.rollInitiative([n.id], {
        rollOptions: {
          rollMode: l,
          skipRollDialog: a
        }
      });
    case "pingCombatant":
      return this._onPingCombatant(n);
    case "panToCombatant":
      return this._onPanToCombatant(n);
  }
}
u(Xye, "_onCombatantControl");
function Jye(i, e = {}) {
  const { skillKey: t } = e, { initiative: s } = i.system.attributes, n = e.abilityKey ?? "dex", l = (e == null ? void 0 : e.rollMode) ?? CONFIG.A5E.ROLL_MODE.NORMAL, r = i.RollOverrideManager.getRollOverride("initiative", l, {
    ability: n
  }), o = new yu(i, {
    ability: n,
    expertiseDie: e.expertiseDice ?? s.expertiseDice,
    type: "initiative",
    situationalMods: e.situationalMods,
    skill: t
  });
  return F5({
    actor: i,
    rollMode: r,
    modifiers: o.getModifiers()
  }).rollFormula;
}
u(Jye, "getDefaultInitiativeFormula");
function Kj(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Ability Bonuses",
      options: (
        /*abilityBonuses*/
        i[12].map(Jj)
      ),
      selected: (
        /*selectedAbilityBonuses*/
        i[5]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[27]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*abilityBonuses*/
      4096 && (l.options = /*abilityBonuses*/
      s[12].map(Jj)), n[0] & /*selectedAbilityBonuses*/
      32 && (l.selected = /*selectedAbilityBonuses*/
      s[5]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Kj, "create_if_block_2$3");
function Yj(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Skill Bonuses",
      options: (
        /*skillBonuses*/
        i[11].map(Zj)
      ),
      selected: (
        /*selectedSkillBonuses*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[28]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*skillBonuses*/
      2048 && (l.options = /*skillBonuses*/
      s[11].map(Zj)), n[0] & /*selectedSkillBonuses*/
      16 && (l.selected = /*selectedSkillBonuses*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Yj, "create_if_block_1$6");
function Xj(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Initiative Bonuses",
      options: (
        /*initiativeBonuses*/
        i[10].map(Qj)
      ),
      selected: (
        /*selectedInitiativeBonuses*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[29]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*initiativeBonuses*/
      1024 && (l.options = /*initiativeBonuses*/
      s[10].map(Qj)), n[0] & /*selectedInitiativeBonuses*/
      8 && (l.selected = /*selectedInitiativeBonuses*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(Xj, "create_if_block$6");
function Zye(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "id", t = /*$actor*/
      i[8].id + "-" + /*appId*/
      i[16] + "-situational-mods");
    },
    m(l, r) {
      T(l, e, r), He(
        e,
        /*situationalMods*/
        i[2]
      ), s || (n = W(
        e,
        "input",
        /*input_input_handler*/
        i[30]
      ), s = !0);
    },
    p(l, r) {
      r[0] & /*$actor*/
      256 && t !== (t = /*$actor*/
      l[8].id + "-" + /*appId*/
      l[16] + "-situational-mods") && b(e, "id", t), r[0] & /*situationalMods*/
      4 && e.value !== /*situationalMods*/
      l[2] && He(
        e,
        /*situationalMods*/
        l[2]
      );
    },
    d(l) {
      l && C(e), s = !1, n();
    }
  };
}
u(Zye, "create_default_slot$6");
function Qye(i) {
  let e, t, s, n, l, r, o, a, c, f = Object.values(
    /*abilityBonuses*/
    i[12]
  ).flat().length, d, p = Object.values(
    /*skillBonuses*/
    i[11]
  ).flat().length, m, g = Object.values(
    /*initiativeBonuses*/
    i[10]
  ).flat().length, h, _, y, v, k, S, D, I, M, L, B;
  t = new vr({
    props: {
      selected: (
        /*rollMode*/
        i[6]
      ),
      source: (
        /*rollModeString*/
        i[13]
      )
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[23]
  ), n = new Ke({
    props: {
      heading: "A5E.AbilityScore",
      options: Object.entries(
        /*abilities*/
        i[17]
      ),
      selected: (
        /*abilityKey*/
        i[0]
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[24]
  ), r = new Ke({
    props: {
      heading: "A5E.Skill",
      options: Object.entries(
        /*skills*/
        i[18]
      ),
      selected: (
        /*skillKey*/
        i[1]
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[25]
  ), a = new hi({
    props: {
      source: (
        /*expertiseDieSource*/
        i[14]
      ),
      selected: (
        /*expertiseDie*/
        i[7]
      ),
      type: (
        /*$actor*/
        i[8].type
      )
    }
  }), a.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[26]
  );
  let z = f && Kj(i), q = p && Yj(i), U = g && Xj(i);
  return _ = new ie({
    props: {
      heading: "A5E.SituationalMods",
      $$slots: { default: [Zye] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), j(t.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), o = F(), j(a.$$.fragment), c = F(), z && z.c(), d = F(), q && q.c(), m = F(), U && U.c(), h = F(), j(_.$$.fragment), y = F(), v = E("section"), k = Q(
        /*rollFormula*/
        i[9]
      ), S = F(), D = E("section"), I = E("button"), I.textContent = "Roll Initiative", b(v, "class", "roll-formula-preview svelte-8gi69h"), b(e, "class", "svelte-8gi69h");
    },
    m(H, V) {
      T(H, e, V), R(t, e, null), A(e, s), R(n, e, null), A(e, l), R(r, e, null), A(e, o), R(a, e, null), A(e, c), z && z.m(e, null), A(e, d), q && q.m(e, null), A(e, m), U && U.m(e, null), A(e, h), R(_, e, null), A(e, y), A(e, v), A(v, k), A(e, S), A(e, D), A(D, I), M = !0, L || (B = W(I, "click", st(
        /*onSubmit*/
        i[19]
      )), L = !0);
    },
    p(H, V) {
      const Y = {};
      V[0] & /*rollMode*/
      64 && (Y.selected = /*rollMode*/
      H[6]), V[0] & /*rollModeString*/
      8192 && (Y.source = /*rollModeString*/
      H[13]), t.$set(Y);
      const J = {};
      V[0] & /*abilityKey*/
      1 && (J.selected = /*abilityKey*/
      H[0]), n.$set(J);
      const fe = {};
      V[0] & /*skillKey*/
      2 && (fe.selected = /*skillKey*/
      H[1]), r.$set(fe);
      const ke = {};
      V[0] & /*expertiseDieSource*/
      16384 && (ke.source = /*expertiseDieSource*/
      H[14]), V[0] & /*expertiseDie*/
      128 && (ke.selected = /*expertiseDie*/
      H[7]), V[0] & /*$actor*/
      256 && (ke.type = /*$actor*/
      H[8].type), a.$set(ke), V[0] & /*abilityBonuses*/
      4096 && (f = Object.values(
        /*abilityBonuses*/
        H[12]
      ).flat().length), f ? z ? (z.p(H, V), V[0] & /*abilityBonuses*/
      4096 && w(z, 1)) : (z = Kj(H), z.c(), w(z, 1), z.m(e, d)) : z && (ae(), O(z, 1, 1, () => {
        z = null;
      }), ce()), V[0] & /*skillBonuses*/
      2048 && (p = Object.values(
        /*skillBonuses*/
        H[11]
      ).flat().length), p ? q ? (q.p(H, V), V[0] & /*skillBonuses*/
      2048 && w(q, 1)) : (q = Yj(H), q.c(), w(q, 1), q.m(e, m)) : q && (ae(), O(q, 1, 1, () => {
        q = null;
      }), ce()), V[0] & /*initiativeBonuses*/
      1024 && (g = Object.values(
        /*initiativeBonuses*/
        H[10]
      ).flat().length), g ? U ? (U.p(H, V), V[0] & /*initiativeBonuses*/
      1024 && w(U, 1)) : (U = Xj(H), U.c(), w(U, 1), U.m(e, h)) : U && (ae(), O(U, 1, 1, () => {
        U = null;
      }), ce());
      const ee = {};
      V[0] & /*$actor, situationalMods*/
      260 | V[1] & /*$$scope*/
      8 && (ee.$$scope = { dirty: V, ctx: H }), _.$set(ee), (!M || V[0] & /*rollFormula*/
      512) && be(
        k,
        /*rollFormula*/
        H[9]
      );
    },
    i(H) {
      M || (w(t.$$.fragment, H), w(n.$$.fragment, H), w(r.$$.fragment, H), w(a.$$.fragment, H), w(z), w(q), w(U), w(_.$$.fragment, H), M = !0);
    },
    o(H) {
      O(t.$$.fragment, H), O(n.$$.fragment, H), O(r.$$.fragment, H), O(a.$$.fragment, H), O(z), O(q), O(U), O(_.$$.fragment, H), M = !1;
    },
    d(H) {
      H && C(e), N(t), N(n), N(r), N(a), z && z.d(), q && q.d(), U && U.d(), N(_), L = !1, B();
    }
  };
}
u(Qye, "create_fragment$l");
const Jj = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel], "func$1"), Zj = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel], "func_1$1"), Qj = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel], "func_2");
function xye(i, e, t) {
  let s, n, l, r, o, a, c, f, d, p, m, { document: g, dialog: h, options: _ } = de("#external").application, { document: y = g, dialog: v = h, options: k = _ } = e;
  function S() {
    return L ? 0 : m.RollOverrideManager.getExpertiseDice("initiative", k.expertiseDice ?? 0, { ability: q, skill: H });
  }
  u(S, "getInitialExpertiseDieSelection");
  const D = new Zt(y.actor);
  pe(i, D, (me) => t(8, m = me));
  const I = v.id, M = CONFIG.A5E.abilities, L = game.settings.get("a5e", "hideExpertiseDice"), B = { none: "None", ...CONFIG.A5E.skills };
  game.settings.get("a5e", "hideA5eSkills") && (delete B.cul, delete B.eng);
  function z() {
    v.submit({ rollFormula: V });
  }
  u(z, "onSubmit");
  let q = k.abilityKey ?? m.system.attributes.initiative.ability ?? "dex", U = k.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL, H = k.skillKey ?? "none", V, Y = k.situationalMods ?? "";
  const J = /* @__PURE__ */ u(({ detail: me }) => t(6, l = me), "updateSelection_handler"), fe = /* @__PURE__ */ u(({ detail: me }) => t(0, q = me), "updateSelection_handler_1"), ke = /* @__PURE__ */ u(({ detail: me }) => t(1, H = me), "updateSelection_handler_2"), ee = /* @__PURE__ */ u((me) => {
    t(7, s = me.detail);
  }, "updateSelection_handler_3"), ne = /* @__PURE__ */ u(({ detail: me }) => t(5, f = me), "updateSelection_handler_4"), Ee = /* @__PURE__ */ u(({ detail: me }) => t(4, d = me), "updateSelection_handler_5"), Pe = /* @__PURE__ */ u(({ detail: me }) => t(3, p = me), "updateSelection_handler_6");
  function ye() {
    Y = this.value, t(2, Y);
  }
  return u(ye, "input_input_handler"), i.$$set = (me) => {
    "document" in me && t(20, y = me.document), "dialog" in me && t(21, v = me.dialog), "options" in me && t(22, k = me.options);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*$actor, options, abilityKey, skillKey*/
    4194563 && t(14, n = m.RollOverrideManager.getExpertiseDiceSource("initiative", k.expertiseDie ?? 0, { ability: q, skill: H })), i.$$.dirty[0] & /*$actor, abilityKey, skillKey*/
    259 && t(6, l = m.RollOverrideManager.getRollOverride("initiative", U, { ability: q, skill: H })), i.$$.dirty[0] & /*$actor, abilityKey, skillKey*/
    259 && t(13, r = m.RollOverrideManager.getRollOverridesSource("initiative", U, { ability: q, skill: H })), i.$$.dirty[0] & /*$actor, abilityKey*/
    257 && t(12, o = m.BonusesManager.prepareAbilityBonuses(q, "check")), i.$$.dirty[0] & /*$actor, skillKey, abilityKey*/
    259 && t(11, a = m.BonusesManager.prepareSkillBonuses(H, q)), i.$$.dirty[0] & /*$actor, abilityKey, skillKey*/
    259 && t(10, c = m.BonusesManager.prepareInitiativeBonuses({ abilityKey: q, skillKey: H })), i.$$.dirty[0] & /*$actor, abilityKey*/
    257 && t(5, f = m.BonusesManager.getDefaultSelections("abilities", { abilityKey: q, abilityType: "check" })), i.$$.dirty[0] & /*$actor, skillKey, abilityKey*/
    259 && t(4, d = m.BonusesManager.getDefaultSelections("skills", { skillKey: H, abilityKey: q })), i.$$.dirty[0] & /*$actor, abilityKey, skillKey*/
    259 && t(3, p = m.BonusesManager.getDefaultSelections("initiative", { abilityKey: q, skillKey: H })), i.$$.dirty[0] & /*$actor, abilityKey, expertiseDie, rollMode, situationalMods, skillKey, selectedAbilityBonuses, selectedSkillBonuses, selectedInitiativeBonuses*/
    511 && t(9, V = ll(m, {
      ability: q,
      expertiseDie: s,
      rollMode: l,
      situationalMods: Y,
      skill: H,
      selectedAbilityBonuses: f,
      selectedSkillBonuses: d,
      selectedInitiativeBonuses: p,
      type: "initiative"
    }));
  }, t(7, s = S()), [
    q,
    H,
    Y,
    p,
    d,
    f,
    l,
    s,
    m,
    V,
    c,
    a,
    o,
    r,
    n,
    D,
    I,
    M,
    B,
    z,
    y,
    v,
    k,
    J,
    fe,
    ke,
    ee,
    ne,
    Ee,
    Pe,
    ye
  ];
}
u(xye, "instance$j");
const o3 = class o3 extends re {
  constructor(e) {
    super(), oe(this, e, xye, Qye, le, { document: 20, dialog: 21, options: 22 }, null, [-1, -1]);
  }
};
u(o3, "InitiativeRollDialog");
let Zk = o3;
function xj(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Ability Bonuses",
      options: (
        /*abilityBonuses*/
        i[9].map(t7)
      ),
      selected: (
        /*selectedAbilityBonuses*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[20]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*abilityBonuses*/
      512 && (l.options = /*abilityBonuses*/
      s[9].map(t7)), n & /*selectedAbilityBonuses*/
      16 && (l.selected = /*selectedAbilityBonuses*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(xj, "create_if_block_1$5");
function e7(i) {
  let e, t;
  return e = new tt({
    props: {
      heading: "Initiative Bonuses",
      options: (
        /*initiativeBonuses*/
        i[8].map(s7)
      ),
      selected: (
        /*selectedInitiativeBonuses*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[21]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*initiativeBonuses*/
      256 && (l.options = /*initiativeBonuses*/
      s[8].map(s7)), n & /*selectedInitiativeBonuses*/
      8 && (l.selected = /*selectedInitiativeBonuses*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(e7, "create_if_block$5");
function e0e(i) {
  let e, t, s;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text");
    },
    m(n, l) {
      T(n, e, l), He(
        e,
        /*situationalMods*/
        i[2]
      ), t || (s = W(
        e,
        "input",
        /*input_input_handler*/
        i[22]
      ), t = !0);
    },
    p(n, l) {
      l & /*situationalMods*/
      4 && e.value !== /*situationalMods*/
      n[2] && He(
        e,
        /*situationalMods*/
        n[2]
      );
    },
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(e0e, "create_default_slot$5");
function t0e(i) {
  let e, t, s, n, l, r, o, a = Object.values(
    /*abilityBonuses*/
    i[9]
  ).flat().length, c, f = Object.values(
    /*initiativeBonuses*/
    i[8]
  ).flat().length, d, p, m, g, h, _, y, v, k, S, D;
  t = new vr({
    props: {
      selected: (
        /*selectedRollMode*/
        i[7]
      ),
      source: (
        /*rollModeString*/
        i[13]
      )
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[17]
  ), n = new Ke({
    props: {
      heading: "A5E.AbilityScore",
      options: Object.entries(
        /*abilities*/
        i[11]
      ),
      selected: (
        /*abilityKey*/
        i[0]
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[18]
  ), r = new hi({
    props: {
      selected: (
        /*expertiseDie*/
        i[1]
      ),
      type: (
        /*$actor*/
        i[5].type
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[19]
  );
  let I = a && xj(i), M = f && e7(i);
  return p = new ie({
    props: {
      heading: "A5E.SituationalMods",
      $$slots: { default: [e0e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), j(t.$$.fragment), s = F(), j(n.$$.fragment), l = F(), j(r.$$.fragment), o = F(), I && I.c(), c = F(), M && M.c(), d = F(), j(p.$$.fragment), m = F(), g = E("section"), h = Q(
        /*rollFormula*/
        i[6]
      ), _ = F(), y = E("section"), v = E("button"), v.textContent = "Roll Initiative", b(g, "class", "roll-formula-preview svelte-8gi69h"), b(e, "class", "svelte-8gi69h");
    },
    m(L, B) {
      T(L, e, B), R(t, e, null), A(e, s), R(n, e, null), A(e, l), R(r, e, null), A(e, o), I && I.m(e, null), A(e, c), M && M.m(e, null), A(e, d), R(p, e, null), A(e, m), A(e, g), A(g, h), A(e, _), A(e, y), A(y, v), k = !0, S || (D = W(v, "click", st(
        /*onSubmit*/
        i[12]
      )), S = !0);
    },
    p(L, [B]) {
      const z = {};
      B & /*selectedRollMode*/
      128 && (z.selected = /*selectedRollMode*/
      L[7]), t.$set(z);
      const q = {};
      B & /*abilityKey*/
      1 && (q.selected = /*abilityKey*/
      L[0]), n.$set(q);
      const U = {};
      B & /*expertiseDie*/
      2 && (U.selected = /*expertiseDie*/
      L[1]), B & /*$actor*/
      32 && (U.type = /*$actor*/
      L[5].type), r.$set(U), B & /*abilityBonuses*/
      512 && (a = Object.values(
        /*abilityBonuses*/
        L[9]
      ).flat().length), a ? I ? (I.p(L, B), B & /*abilityBonuses*/
      512 && w(I, 1)) : (I = xj(L), I.c(), w(I, 1), I.m(e, c)) : I && (ae(), O(I, 1, 1, () => {
        I = null;
      }), ce()), B & /*initiativeBonuses*/
      256 && (f = Object.values(
        /*initiativeBonuses*/
        L[8]
      ).flat().length), f ? M ? (M.p(L, B), B & /*initiativeBonuses*/
      256 && w(M, 1)) : (M = e7(L), M.c(), w(M, 1), M.m(e, d)) : M && (ae(), O(M, 1, 1, () => {
        M = null;
      }), ce());
      const H = {};
      B & /*$$scope, situationalMods*/
      134217732 && (H.$$scope = { dirty: B, ctx: L }), p.$set(H), (!k || B & /*rollFormula*/
      64) && be(
        h,
        /*rollFormula*/
        L[6]
      );
    },
    i(L) {
      k || (w(t.$$.fragment, L), w(n.$$.fragment, L), w(r.$$.fragment, L), w(I), w(M), w(p.$$.fragment, L), k = !0);
    },
    o(L) {
      O(t.$$.fragment, L), O(n.$$.fragment, L), O(r.$$.fragment, L), O(I), O(M), O(p.$$.fragment, L), k = !1;
    },
    d(L) {
      L && C(e), N(t), N(n), N(r), I && I.d(), M && M.d(), N(p), S = !1, D();
    }
  };
}
u(t0e, "create_fragment$k");
const t7 = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel], "func"), s7 = /* @__PURE__ */ u(([i, e]) => [i, e.label || e.defaultLabel], "func_1");
function s0e(i, e, t) {
  let s, n, l, r, o, { document: a, dialog: c, options: f } = de("#external").application, { document: d = a, dialog: p = c, options: m = f } = e;
  function g() {
    return y ? 0 : m.expertiseDice ?? o.system.attributes.initiative.expertiseDice;
  }
  u(g, "getInitialExpertiseDieSelection");
  const h = new Zt(d.actor);
  pe(i, h, (J) => t(5, o = J)), p.id;
  const _ = CONFIG.A5E.abilities, y = game.settings.get("a5e", "hideExpertiseDice");
  function v() {
    p.submit({ rollFormula: D });
  }
  u(v, "onSubmit");
  let k = m.abilityKey ?? o.system.attributes.initiative.ability ?? "dex", S = g(), D, I = m.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL, M = m.situationalMods ?? "", L = o.RollOverrideManager.getRollOverride("initiative", I, { ability: k }), B = o.RollOverrideManager.getRollOverridesSource("initiative", I, { ability: k });
  const z = /* @__PURE__ */ u(({ detail: J }) => t(7, I = J), "updateSelection_handler"), q = /* @__PURE__ */ u(({ detail: J }) => t(0, k = J), "updateSelection_handler_1"), U = /* @__PURE__ */ u((J) => {
    t(1, S = J.detail);
  }, "updateSelection_handler_2"), H = /* @__PURE__ */ u(({ detail: J }) => t(4, l = J), "updateSelection_handler_3"), V = /* @__PURE__ */ u(({ detail: J }) => t(3, r = J), "updateSelection_handler_4");
  function Y() {
    M = this.value, t(2, M);
  }
  return u(Y, "input_input_handler"), i.$$set = (J) => {
    "document" in J && t(14, d = J.document), "dialog" in J && t(15, p = J.dialog), "options" in J && t(16, m = J.options);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, abilityKey*/
    33 && t(9, s = o.BonusesManager.prepareAbilityBonuses(k, "check")), i.$$.dirty & /*$actor, abilityKey*/
    33 && t(8, n = o.BonusesManager.prepareInitiativeBonuses({ abilityKey: k })), i.$$.dirty & /*$actor, abilityKey*/
    33 && t(4, l = o.BonusesManager.getDefaultSelections("abilities", { abilityKey: k, abilityType: "check" })), i.$$.dirty & /*$actor, abilityKey*/
    33 && t(3, r = o.BonusesManager.getDefaultSelections("initiative", { abilityKey: k })), i.$$.dirty & /*$actor, abilityKey, expertiseDie, situationalMods, selectedAbilityBonuses, selectedInitiativeBonuses*/
    63 && t(6, D = ll(o, {
      ability: k,
      expertiseDie: S,
      rollMode: L,
      situationalMods: M,
      selectedAbilityBonuses: l,
      selectedInitiativeBonuses: r,
      type: "initiative"
    }));
  }, [
    k,
    S,
    M,
    r,
    l,
    o,
    D,
    I,
    n,
    s,
    h,
    _,
    v,
    B,
    d,
    p,
    m,
    z,
    q,
    U,
    H,
    V,
    Y
  ];
}
u(s0e, "instance$i");
const a3 = class a3 extends re {
  constructor(e) {
    super(), oe(this, e, s0e, t0e, le, { document: 14, dialog: 15, options: 16 });
  }
};
u(a3, "SimpleInitiativeRollDialog");
let Qk = a3;
async function n0e(i) {
  if (i != null && i.skipRollDialog)
    return Jye(this.actor, i);
  const e = game.i18n.format("A5E.InitiativePromptTitle", { name: this.name }), t = game.settings.get("a5e", "simpleInitiative") ? Qk : Zk, s = new Ko(this, e, t, {}, i, { width: 530 });
  await s.render(!0);
  const { rollFormula: n } = await s.promise;
  return n;
}
u(n0e, "getInitiativeFormula");
async function i0e(i) {
  const e = await this._getInitiativeFormula(i);
  return await Roll.create(e).evaluate();
}
u(i0e, "getInitiativeRoll");
const l0e = /* @__PURE__ */ u(async () => loadTemplates([
  // Settings
  "systems/a5e/templates/conditionAutomationMenu.hbs",
  // Hud
  "systems/a5e/templates/hud/token-hud.hbs"
]), "preloadHandlebarsTemplates");
function r0e(i) {
  Object.entries(i).forEach(([e, t]) => {
    typeof t == "string" && (i[e] = K(t));
  });
}
u(r0e, "localizeObject");
function o0e(i) {
  i.PRELOCALIZED_KEYS.forEach((t) => {
    const s = foundry.utils.getProperty(i, t);
    r0e(s);
  });
}
u(o0e, "performPreLocalization");
async function a0e(i = {}) {
  const e = await this.getInitiativeRoll(i);
  return this.update({ initiative: e.total });
}
u(a0e, "rollInitiative$1");
async function c0e(i, { updateTurn: e = !0, messageOptions: t = {}, rollOptions: s = {} } = {}) {
  var c, f, d;
  const n = typeof i == "string" ? [i] : i, l = (c = this.combatant) == null ? void 0 : c.id, r = t.rollMode || game.settings.get("core", "rollMode"), o = [], a = [];
  for (const [p, m] of n.entries()) {
    let g;
    const h = this.combatants.get(m);
    if (!(h != null && h.isOwner)) return results;
    try {
      g = await h.getInitiativeRoll(s);
    } catch {
      continue;
    }
    o.push({ _id: m, initiative: g.total });
    const _ = foundry.utils.mergeObject(
      {
        speaker: {
          scene: this.scene.id,
          actor: (f = h.actor) == null ? void 0 : f.id,
          token: (d = h.token) == null ? void 0 : d.id,
          alias: h.name
        },
        flavor: game.i18n.format("COMBAT.RollsInitiative", { name: h.name }),
        flags: { "core.initiativeRoll": !0 }
      },
      t
    ), y = await g.toMessage(_, {
      create: !1,
      rollMode: h.hidden && r === "roll" ? "gmroll" : r
    });
    p > 0 && (y.sound = null), a.push(y);
  }
  return o.length ? (await this.updateEmbeddedDocuments("Combatant", o), e && await this.update({ turn: this.turns.findIndex((p) => p.id === l) }), await ChatMessage.implementation.create(a), this) : this;
}
u(c0e, "rollInitiative");
const Pc = {
  bar: ["attributes.hp"],
  value: [
    ...Object.keys(Il.skills).map((i) => `skills.${i}.passive`),
    ...Object.keys(Il.abilities).map((i) => `abilities.${i}.value`),
    "attributes.hp.temp",
    "attributes.exertion.current"
  ]
}, u0e = {
  base: Pc,
  character: {
    bar: [
      ...Pc.bar,
      "resources.primary",
      "resources.secondary",
      "resources.tertiary",
      "resources.quaternary"
    ],
    value: [...Pc.value]
  },
  npc: {
    bar: [...Pc.bar],
    value: [...Pc.value, "details.cr"]
  }
};
function f0e(i, e) {
  const t = ChatMessage.getSpeaker();
  let s;
  t.token && (s = game.actors.tokens[t.token]), s || (s = game.actors.get(t.actor));
  const n = s ? s.items.filter((o) => o.name === i) : [];
  if (n.length > 1)
    ui.notifications.warn(
      `Your controlled Actor ${s.name} has more than one Item with name ${i}. The first matched item will be chosen.`
    );
  else if (n.length === 0)
    return ui.notifications.warn(`Your controlled Actor does not have an item named ${i}`);
  const l = n[0];
  return l.actions.get(e) ? l.activate(e) : ui.notifications.warn(`Your selected Item does not have an action with id ${e}`);
}
u(f0e, "activateActionMacro");
function d0e(i) {
  const e = ChatMessage.getSpeaker();
  let t;
  e.token && (t = game.actors.tokens[e.token]), t || (t = game.actors.get(e.actor));
  const s = t ? t.items.filter((l) => l.name === i) : [];
  if (s.length > 1)
    ui.notifications.warn(
      `Your controlled Actor ${t.name} has more than one Item with name ${i}. The first matched item will be chosen.`
    );
  else if (s.length === 0)
    return ui.notifications.warn(`Your controlled Actor does not have an item named ${i}`);
  return s[0].activate();
}
u(d0e, "activateItemMacro");
async function p0e(i, e) {
  const t = await fromUuid(i.uuid), s = t.actions.get(i.actionId);
  if (foundry.utils.isEmpty(t) || t.parent === null)
    return ui.notifications.warn(game.i18n.localize("A5E.ActionWarningNoMacrosForUnownedItems"));
  let n;
  i.actionId ? n = `game.a5e.macros.activateActionMacro("${t.name}", "${i.actionId}");` : n = `game.a5e.macros.activateItemMacro("${t.name}");`;
  let l = game.macros.find((r) => {
    var c, f;
    const o = r.name === t.name && r.command === n, a = ((c = r.ownership) == null ? void 0 : c.default) === 3 || ((f = r.ownership) == null ? void 0 : f[game.user.id]) === 3;
    return o && a;
  });
  l || (l = await Macro.create({
    name: `${t.name} ${s ? `(${s.name})` : ""}`,
    type: "script",
    scope: "actor",
    img: s && (s != null && s.img) ? s.img : t.img,
    command: n,
    flags: { "a5e.itemMacro": !0 }
  })), await game.user.assignHotbarMacro(l, e);
}
u(p0e, "createMacro");
var is, gq, e5, Vc, bq, _q, yq, vq, Wc, m0e;
const c3 = class c3 {
  constructor() {
    x(this, is);
  }
  /**
   * Pushes enrichers to config and adds
   */
  registerCustomEnrichers() {
    CONFIG.TextEditor.enrichers.push(
      {
        // [[/check args=d|"d"|'d']]
        pattern: /\[\[\/(?<enricherType>check|save|condition)(?<argString> [^\]]+)?]]/gi,
        enricher: this.parseEnricherInput.bind(this)
      }
      // {
      // 	// [[/choose label="Some label" argString]]
      // 	pattern: /\[\[\/choose flavor=(?:"([^"]+)"|([^"\s]+))(.*)\]\]/gi,
      // 	enricher: this.parseChooseInput.bind(this),
      // },
    ), document.body.addEventListener("click", this.onRoll.bind(this)), document.body.addEventListener("click", this.onEffect.bind(this));
  }
  /* -------------------------------------------- */
  /*  Parsers                                     */
  /* -------------------------------------------- */
  /**
   * Parse the enriched string and provide the appropriate content.
   * @param match      The regular expression match result.
   * @param options    Options provided to customize text enrichment. Unused
   * @returns An HTML element to insert in place of the matched text or
   *          null to indicate that no replacement should be made.
   */
  async parseEnricherInput(e, t) {
    const { enricherType: s, argString: n } = e.groups, l = X(this, is, gq).call(this, n);
    return l.enricherType = s.toLowerCase(), s === "check" ? X(this, is, _q).call(this, l, t) : s === "save" ? X(this, is, yq).call(this, l, t) : s === "condition" ? X(this, is, bq).call(this, l, t) : null;
  }
  /**
   * Parse the enriched string and provide the appropriate content.
   * @param match      The regular expression match result.
   * @param options    Options provided to customize text enrichment. Unused
   * @returns An HTML element to insert in place of the matched text or
   *          null to indicate that no replacement should be made.
   */
  async parseChooseInput(e, t) {
    const { flavor: s, argString: n } = e.groups;
    console.log("here"), console.log(s, n);
    const l = /(\[\d+-\d+\])?\"?([^\"]+?)\"?/gi, r = [...n.matchAll(l)];
    return console.log(r), document.createElement("span");
  }
  async createInvalidTag(e) {
    const t = document.createElement("span");
    return t.classList.add("a5e-enricher"), t.classList.add("a5e-enricher--invalid"), t.dataset.tooltip = e, t.innerHTML = "Invalid Enricher", t;
  }
  /* -------------------------------------------- */
  /*  Click Handlers                              */
  /* -------------------------------------------- */
  /**
   * Parses information based on button clicked and calls appropriate roll function.
   * @param event   Triggering click event.
   */
  onRoll(e) {
    var r, o, a, c, f, d, p, m;
    const t = (r = e.target) == null ? void 0 : r.closest(
      ".a5e-enricher--roll"
    );
    if (!t) return;
    e.stopPropagation();
    const s = (o = canvas == null ? void 0 : canvas.tokens) == null ? void 0 : o.controlled;
    if (!(s != null && s.length)) {
      (a = ui.notifications) == null || a.error("No tokens selected.");
      return;
    }
    const { dataset: n } = t, l = {
      dc: { name: "dc", type: "number" },
      expertisedice: { name: "expertiseDice", type: "number" },
      rollmode: { name: "rollMode", type: "number" },
      situationalmods: { name: "situationalMods", type: "string" },
      skiprolldialog: { name: "skipRollDialog", type: "boolean" },
      visibilitymode: { name: "visibilityMode", type: "string" }
    };
    if (n.enricherType === "check") {
      if (n.skill) {
        const g = {
          ability: { name: "abilityKey", type: "string" },
          minroll: { name: "minRoll", type: "number" },
          ...l
        }, h = X(this, is, Vc).call(this, t, g);
        for (const _ of s) {
          const { actor: y } = _;
          if (!y) {
            (c = ui.notifications) == null || c.error(`No actor found on given token "${_.name}"`);
            continue;
          }
          y.rollSkillCheck(n.skill, h);
        }
        return;
      }
      if (n.ability) {
        const g = X(this, is, Vc).call(this, t, l);
        for (const h of s) {
          const { actor: _ } = h;
          if (!_) {
            (f = ui.notifications) == null || f.error(`No actor found on given token "${h.name}"`);
            continue;
          }
          _.rollAbilityCheck(n.ability, g);
        }
        return;
      }
    }
    if (n.enricherType === "save") {
      const g = {
        type: { name: "saveType", type: "string" },
        ...l
      }, h = X(this, is, Vc).call(this, t, g);
      if (n.type === "death") {
        for (const _ of s) {
          const { actor: y } = _;
          if (!y) {
            (d = ui.notifications) == null || d.error(`No actor found on given token "${_.name}"`);
            continue;
          }
          y.rollDeathSavingThrow(h);
        }
        return;
      }
      if (n.type === "concentration") {
        for (const _ of s) {
          const { actor: y } = _;
          if (!y) {
            (p = ui.notifications) == null || p.error(`No actor found on given token "${_.name}"`);
            continue;
          }
          y.rollSavingThrow("con", h);
        }
        return;
      }
      if (n.ability)
        for (const _ of s) {
          const { actor: y } = _;
          if (!y) {
            (m = ui.notifications) == null || m.error(`No actor found on given token "${_.name}"`);
            continue;
          }
          y.rollSavingThrow(n.ability, h);
        }
    }
  }
  /**
   * Parses information based on button clicked and calls appropriate effect function.
   * @param event   Triggering click event.
   */
  onEffect(e) {
    var o, a, c, f;
    const t = (o = e.target) == null ? void 0 : o.closest(
      ".a5e-enricher--effect"
    );
    if (!t) return;
    e.stopPropagation();
    const s = (a = canvas == null ? void 0 : canvas.tokens) == null ? void 0 : a.controlled;
    if (!(s != null && s.length)) {
      (c = ui.notifications) == null || c.error("No tokens selected.");
      return;
    }
    const { dataset: n } = t;
    if (n.enricherType !== "condition") return;
    const l = {
      id: { name: "id", type: "string" }
    }, { id: r } = X(this, is, Vc).call(this, t, l);
    for (const d of s) {
      const { actor: p } = d;
      if (!p) {
        (f = ui.notifications) == null || f.error(`No actor found on given token "${d.name}"`);
        continue;
      }
      p.toggleStatusEffect(r);
    }
  }
  async onChoose(e) {
    var a, c, f, d;
    const t = (a = e.target) == null ? void 0 : a.closest(
      ".a5e-enricher--choose"
    );
    if (!t) return;
    e.stopPropagation();
    const { dataset: s } = t, n = (c = s.results) == null ? void 0 : c.split("|");
    if ((f = s.icons) == null || f.split("|"), !n) return;
    const l = new Roll(`1d${n.length}`);
    await l.evaluate();
    const r = n[l.total - 1];
    await l.toMessage();
    const o = {
      author: (d = game.user) == null ? void 0 : d.id,
      // speaker: ChatMessage.getSpeaker(),
      // sound: CONFIG.sounds.dice,
      content: `${r}`
    };
    await ChatMessage.create(o);
  }
};
is = new WeakSet(), /* -------------------------------------------- */
/*  Helpers                                     */
/* -------------------------------------------- */
/**
 * Parses the arguments into record format and parses into int if possible.
 * @param argString   The raw arguments string
 * @returns An indexed array of config item tuples [arg, val]
 */
gq = /* @__PURE__ */ u(function(e) {
  const t = /(\w+)=(["']?)([^"'\s]+(?:\s[^"'\s]+)*?)\2/gi, s = [...e.matchAll(t)], n = {};
  return s == null || s.forEach((l) => {
    var a;
    const r = (a = l.at(1)) == null ? void 0 : a.toLowerCase(), o = l.at(3);
    !r || !o || (n[r] = o);
  }), n;
}, "#parseArguments"), /**
 * Copies the entries of a record onto the dataset of an HTML element.
 * @param element    HTML element to contain entries.
 * @param args       Record of entries to be stored in element.
 */
e5 = /* @__PURE__ */ u(function(e, t) {
  for (const [s, n] of Object.entries(t))
    n && (e.dataset[s] = n);
}, "#addToDataset"), /**
 * Creates a record containing the entries of an HTML element's dataset.
 * If validOptions is provided, only copies records listed in validOptions
 * and maps to mapped keys.
 * @param element        HTML element containing entries.
 * @param validOptions   Optional record of valid options and key mappings.
 *                       Key is key to search for in dataset.
 *                       Value is what key in destination to map value to.
 * @returns A record containing entries from element dataset.
 */
Vc = /* @__PURE__ */ u(function(e, t) {
  const s = {};
  return Object.entries(e.dataset).forEach(([n, l]) => {
    if (!l) return;
    if (!t) {
      s[n] = l;
      return;
    }
    if (!(n in t)) return;
    const { name: r, type: o } = t[n];
    o === "number" ? s[r] = Number.parseInt(l, 10) : o === "boolean" ? s[r] = !!l : s[r] = l;
  }), s;
}, "#getOptions"), bq = /* @__PURE__ */ u(async function(e, t) {
  const { id: s } = e;
  if (!s) return this.createInvalidTag("No id provided.");
  if (!Object.keys(CONFIG.A5E.conditions).includes(s))
    return this.createInvalidTag(`Invalid condition: ${s}.`);
  const n = e.label || CONFIG.A5E.conditions[s];
  return X(this, is, vq).call(this, e, n);
}, "#enrichCondition"), _q = /* @__PURE__ */ u(async function(e, t) {
  let s = e.label || "Check";
  const { ability: n, skill: l } = e;
  return !l && !n ? this.createInvalidTag("No ability or skill provided.") : n && !Object.keys(CONFIG.A5E.abilities).includes(n) ? this.createInvalidTag(`Invalid ability: ${n}.`) : l ? Object.keys(CONFIG.A5E.skills).includes(l) ? (e.label || (s = `${CONFIG.A5E.skills[l]} ${s}`), X(this, is, Wc).call(this, e, t, s)) : this.createInvalidTag(`Invalid skill: ${l}.`) : n ? (e.label || (s = `${CONFIG.A5E.abilities[n]} ${s}`), X(this, is, Wc).call(this, e, t, s)) : this.createInvalidTag("No ability provided.");
}, "#enrichCheck"), yq = /* @__PURE__ */ u(async function(e, t) {
  const s = ["death", "concentration"], { type: n, ability: l } = e;
  let r = e.label || "Saving Throw";
  return !n && !l ? this.createInvalidTag("No type or ability provided.") : n ? s.includes(n) ? (e.label || (r = `${e.type.capitalize()} ${r}`), X(this, is, Wc).call(this, e, t, r)) : this.createInvalidTag(`Invalid save type ${n}.`) : l ? l && !Object.keys(CONFIG.A5E.abilities).includes(l) ? this.createInvalidTag(`Invalid ability: ${l}.`) : (e.label || (r = `${CONFIG.A5E.abilities[l]} ${r}`), X(this, is, Wc).call(this, e, t, r)) : this.createInvalidTag("No ability provided.");
}, "#enrichSave"), vq = /* @__PURE__ */ u(async function(e, t) {
  const s = document.createElement("span");
  s.classList.add("a5e-enricher"), s.classList.add("a5e-enricher--effect"), X(this, is, e5).call(this, s, e);
  const n = CONFIG.statusEffects.find((o) => o.id === e.id), l = n == null ? void 0 : n.description, r = n == null ? void 0 : n.img;
  return s.innerHTML = `<img src="${r}"></i>${t}`, s.dataset.tooltip = l, s;
}, "#createEffectButton"), Wc = /* @__PURE__ */ u(async function(e, t, s) {
  var o;
  const n = document.createElement("span");
  n.classList.add("a5e-enricher"), n.classList.add("a5e-enricher--roll"), X(this, is, e5).call(this, n, e);
  let l = null;
  return e.dc && (l = (await new Roll(e.dc, t.rollData).evaluate()).total), (((o = game.user) == null ? void 0 : o.isGM) || (t == null ? void 0 : t.secrets)) && l ? n.innerHTML = `<i class="fa-solid fa-dice-d20"></i><span class="a5e-enricher__dc">DC ${l}</span>${s}` : n.innerHTML = `<i class="fa-solid fa-dice-d20"></i>${s}`, n;
}, "#createRollButton"), m0e = /* @__PURE__ */ u(async function(e, t, s) {
  var o, a, c, f, d;
  const n = [], l = [];
  for (const p of t) {
    let m = "";
    if (((o = p.groups) == null ? void 0 : o.type) === "uuid") {
      m = `@UUID[${(a = p.groups) == null ? void 0 : a.value}]`;
      const h = await fromUuid((c = p.groups) == null ? void 0 : c.value);
      l.push(h == null ? void 0 : h.img);
    } else
      m = `${(f = p.groups) == null ? void 0 : f.value}`, l.push("");
    const g = (d = p.groups) != null && d.weight ? Number.parseInt(p.groups.weight, 10) : 1;
    for (let h = 0; h < g; h += 1)
      n.push(m);
  }
  const r = document.createElement("span");
  return r.classList.add("a5e-enricher"), r.classList.add("a5e-enricher--choose"), r.dataset.results = n.join("|"), r.dataset.icons = l.join("|"), r.innerHTML = `<i class="fas fa-th-list"></i>${e}`, r;
}, "#enrichChoose"), u(c3, "A5eEnricherManager");
let xk = c3;
const u3 = class u3 {
  constructor(e) {
    return new Proxy(this, {
      get(t, s, n) {
        return s in t ? Reflect.get(t, s, n) : e[s];
      }
    });
  }
};
u(u3, "DataProxy");
let t5 = u3;
var Qi, xi, ec, xf, ed;
const f3 = class f3 extends t5 {
  constructor(t, s, n) {
    if (!(t instanceof Item))
      throw Error("ForeignDocumentManager: Document must be an instance of Item!");
    if (typeof s != "string")
      throw Error("ForeignDocumentManager: Attribute is required!");
    if (typeof t.system[s] != "object")
      throw Error(`ForeignDocumentManager: Document must have 'system.${s}'`);
    super(foundry.utils.getProperty(t, `system.${s}`));
    x(this, Qi);
    x(this, xi);
    x(this, ec);
    x(this, xf, "A5E.validations.warnings.duplicateForeignDocument");
    x(this, ed, "A5E.validations.warnings.invalidForeignDocument");
    if (Ae(this, Qi, t), Ae(this, xi, s), n) {
      const { validate: l, duplicateWarning: r, validateWarning: o } = n;
      typeof l == "function" && Ae(this, ec, l), typeof r == "string" && Ae(this, xf, r), typeof o == "string" && Ae(this, ed, o);
    }
  }
  /** ************************************************
   * Iterator Returns
   * ************************************************ */
  get documents() {
    return P(this, Qi).system[P(this, xi)];
  }
  getUuid(t) {
    const s = Object.entries(this.documents).find(
      ([, n]) => n.uuid === t
    );
    return s ? s[1] : void 0;
  }
  getIdByUuid(t) {
    const s = Object.entries(this.documents).find(
      ([, n]) => n.uuid === t
    );
    return s ? s[0] : void 0;
  }
  /** ************************************************
   * Internal Methods
   * ************************************************ */
  async add(t, s = {}) {
    var o;
    const n = this.getIdByUuid(t);
    if (n)
      return ui.notifications.warn(P(this, xf)), !1;
    const l = await fromUuid(t);
    if (P(this, ec) && !P(this, ec).call(this, l))
      return ui.notifications.warn(P(this, ed)), !1;
    foundry.utils.mergeObject(s, { uuid: t }), (l == null ? void 0 : l.type) === "object" && (s.quantity = ((o = l == null ? void 0 : l.system) == null ? void 0 : o.quantity) ?? 1);
    const r = n || foundry.utils.randomID();
    return await P(this, Qi).update({ [`system.${P(this, xi)}.${r}`]: s }), !0;
  }
  async delete(t) {
    const s = this.getIdByUuid(t);
    return s ? (await P(this, Qi).update({ [`system.${P(this, xi)}.-=${s}`]: null }), !0) : !1;
  }
  async deleteDocuments(t) {
    const s = t.map((l) => this.getIdByUuid(l)).filter((l) => l);
    if (s.length === 0) return !1;
    const n = {};
    return s.forEach((l) => {
      n[`system.${P(this, xi)}.-=${l}`] = null;
    }), await P(this, Qi).update(n), !0;
  }
  async clean() {
    const t = {};
    for await (const [s, n] of Object.entries(P(this, Qi).system[P(this, xi)]))
      await fromUuid(n == null ? void 0 : n.uuid) || (t[`system.${P(this, xi)}.-=${s}`] = null);
    await P(this, Qi).update(t);
  }
};
Qi = new WeakMap(), xi = new WeakMap(), ec = new WeakMap(), xf = new WeakMap(), ed = new WeakMap(), u(f3, "ForeignDocumentManager");
let s5 = f3;
async function kq() {
  if (!game.user.isGM) return;
  let i = game.settings.get("a5e", "worldSchemaVersion");
  if (!game.settings.storage.get("world").getItem("a5e.worldSchemaVersion")) {
    const n = tn.RECOMMENDED_SAFE_VERSION;
    i = game.actors.size === 0 ? game.settings.get("a5e", "worldSchemaVersion") : Math.max(
      Math.min(
        ...new Set(
          game.actors.map((l) => l.schemaVersion ?? n)
        )
      ),
      n
    ), await game.settings.set("a5e", "worldSchemaVersion", i);
  }
  const t = kr.constructFromVersion(i);
  console.debug("A5E | Migration List", t);
  const s = new tn(t);
  s.needsMigration() && (i && i < tn.MINIMUM_SAFE_VERSION && ui.notifications.error(
    "Your A5E system data is from too old a Foundry version and cannot be reliably migrated to the latest version. The process will be attempted, but errors may occur.",
    { permanent: !0 }
  ), await s.runMigration());
}
u(kq, "handleMigration");
async function wq(i, e = !1) {
  if (!game.user.isGM) return;
  ui.notifications.info(`Migrating ${i.metadata.label} to the latest version.`, {
    permanent: !0
  }), await i.getDocuments();
  const t = i.contents.reduce((l, r) => {
    var f, d, p, m;
    const o = tn.MINIMUM_SAFE_VERSION, a = ((d = (f = r.system) == null ? void 0 : f.migrationData) == null ? void 0 : d.version) ?? ((m = (p = r.system) == null ? void 0 : p.schemaVersion) == null ? void 0 : m.version) ?? o, c = Math.min(l, a);
    return Math.max(c, o);
  }, tn.LATEST_MIGRATION_VERSION);
  console.log(`Migrating from a minimum Version of ${t}.`);
  const s = e ? kr.constructFromVersion(tn.RECOMMENDED_SAFE_VERSION) : kr.constructFromVersion(t), n = new tn(s);
  await n.runCompendiumMigration(n.migrations, i), ui.notifications.info(`Migrated ${i.metadata.label} to the latest version.`, {
    permanent: !0
  });
}
u(wq, "handlePackMigration");
const h0e = Mt({
  classes: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  featureType: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  source: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  }
}), d3 = class d3 extends Gs {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(
      foundry.utils.mergeObject(t, {
        id: "collection.metadata.package",
        title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
        width: 560,
        height: "auto",
        resizable: !0,
        svelte: {
          class: Ul,
          props: {
            compendiumType: "classFeature",
            customImporter: t.importer ?? null,
            document: null,
            filterStore: h0e
          }
        }
      })
    ), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
u(d3, "ClassFeatureCompendiumSheet");
let n5 = d3;
const g0e = Mt({
  class: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  source: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  }
}), p3 = class p3 extends Gs {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(
      foundry.utils.mergeObject(t, {
        id: "collection.metadata.package",
        title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
        width: 560,
        height: "auto",
        resizable: !0,
        svelte: {
          class: Ul,
          props: {
            compendiumType: "archetype",
            customImporter: t.importer ?? null,
            document: null,
            filterStore: g0e
          }
        }
      })
    ), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
u(p3, "ArchetypeCompendiumSheet");
let i5 = p3;
async function U5(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: ["system.description", "system.class", "system.source"]
  }), e.applicationClass = i5;
}
u(U5, "createArchetypeLikeIndex");
async function V5(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.description",
      "system.classes",
      "system.concentration",
      "system.featureType",
      "system.prerequisite",
      "system.source"
    ]
  }), e.applicationClass = n5;
}
u(V5, "createClassFeatureLikeIndex");
async function $q(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.description",
      "system.exertionCost",
      "system.concentration",
      "system.degree",
      "system.isStance",
      "system.source",
      "system.tradition"
    ]
  }), e.applicationClass = Ou;
}
u($q, "createManeuverLikeIndex");
async function W5(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.description",
      "system.details.cr",
      "system.details.creatureTypes",
      "system.details.elite",
      "system.details.isSquad",
      "system.details.isSwarm",
      "system.details.terrain",
      "system.traits.size",
      "system.source"
    ]
  }), e.applicationClass = Du;
}
u(W5, "createMonsterLikeIndex");
async function Aq(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.description",
      "system.details.cr",
      "system.details.creatureTypes",
      "system.details.elite",
      "system.details.isSwarm",
      "system.traits.size",
      "system.source"
    ]
  }), e.applicationClass = Du;
}
u(Aq, "create5eMonsterLikeIndex");
async function K5(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.requiresAttunement",
      "system.bulky",
      "system.objectType",
      "system.price",
      "system.quantity",
      "system.rarity",
      "system.source"
    ]
  }), e.applicationClass = Tu;
}
u(K5, "createObjectLikeIndex");
async function Y5(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.concentration",
      "system.components",
      "system.classes",
      "system.description",
      "system.level",
      "system.rare",
      "system.ritual",
      "system.schools",
      "system.source"
    ]
  }), e.applicationClass = Iu;
}
u(Y5, "createSpellLikeIndex");
async function Eq(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.concentration",
      "system.components",
      "system.description",
      "system.level",
      "system.ritual",
      "system.schools",
      "system.source"
    ]
  }), e.applicationClass = Qp;
}
u(Eq, "create5eSpellLikeIndex");
const b0e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create5eMonsterLikeIndex: Aq,
  create5eSpellLikeIndex: Eq,
  createArchetypeLikeIndex: U5,
  createClassFeatureLikeIndex: V5,
  createManeuverLikeIndex: $q,
  createMonsterLikeIndex: W5,
  createObjectLikeIndex: K5,
  createSpellLikeIndex: Y5
}, Symbol.toStringTag, { value: "Module" }));
function _0e(i) {
  let e, t;
  return e = new Ke({
    props: {
      options: (
        /*selections*/
        i[2]
      ),
      selected: (
        /*selected*/
        i[0]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(_0e, "create_default_slot$4");
function y0e(i) {
  let e, t, s, n, l, r, o;
  return t = new ie({
    props: {
      hint: "Select which compendium to access",
      $$slots: { default: [_0e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("article"), j(t.$$.fragment), s = F(), n = E("button"), n.textContent = "Submit", b(e, "class", "svelte-pjgcz1");
    },
    m(a, c) {
      T(a, e, c), R(t, e, null), A(e, s), A(e, n), l = !0, r || (o = W(n, "click", st(
        /*onSubmit*/
        i[1]
      )), r = !0);
    },
    p(a, [c]) {
      const f = {};
      c & /*$$scope, selected*/
      129 && (f.$$scope = { dirty: c, ctx: a }), t.$set(f);
    },
    i(a) {
      l || (w(t.$$.fragment, a), l = !0);
    },
    o(a) {
      O(t.$$.fragment, a), l = !1;
    },
    d(a) {
      a && C(e), N(t), r = !1, o();
    }
  };
}
u(y0e, "create_fragment$j");
function v0e(i, e, t) {
  let { dialog: s, packOptions: n, defaultSelection: l } = (
    // @ts-ignore
    de("#external").application
  ), { dialog: r = s, packOptions: o = n, defaultSelection: a = l } = e;
  function c() {
    r.submit({ pack: d });
  }
  u(c, "onSubmit");
  const f = o;
  let d = a;
  const p = /* @__PURE__ */ u(({ detail: m }) => t(0, d = m), "updateSelection_handler");
  return i.$$set = (m) => {
    "dialog" in m && t(3, r = m.dialog), "packOptions" in m && t(4, o = m.packOptions), "defaultSelection" in m && t(5, a = m.defaultSelection);
  }, [
    d,
    c,
    f,
    r,
    o,
    a,
    p
  ];
}
u(v0e, "instance$h");
const m3 = class m3 extends re {
  constructor(e) {
    super(), oe(this, e, v0e, y0e, le, {
      dialog: 3,
      packOptions: 4,
      defaultSelection: 5
    });
  }
  get dialog() {
    return this.$$.ctx[3];
  }
  set dialog(e) {
    this.$$set({ dialog: e }), Xe();
  }
  get packOptions() {
    return this.$$.ctx[4];
  }
  set packOptions(e) {
    this.$$set({ packOptions: e }), Xe();
  }
  get defaultSelection() {
    return this.$$.ctx[5];
  }
  set defaultSelection(e) {
    this.$$set({ defaultSelection: e }), Xe();
  }
};
u(m3, "ImportCompendiumSelectionDialog");
let l5 = m3;
const k0e = {
  inventory: Tu,
  maneuvers: Ou,
  spells: Iu
}, w0e = {
  inventory: "object",
  maneuvers: "maneuver",
  spells: "spell"
};
async function $0e(i, e, t = {}) {
  const { importFunction: s } = t;
  let { pack: n } = t;
  const l = w0e[e], r = game.packs.reduce((d, p) => {
    const m = p.metadata.id || p.collection;
    return !m || p.metadata.type !== "Item" || !p.testUserPermission(game.user, CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER) || ![...p.index].map((_) => _.type).filter(Boolean).every((_) => _ === l) || d.push([m, p.metadata.label]), d;
  }, []);
  if (!(game.settings.get("a5e", "hideActorCompendiumSelectionDialog") ?? !1) && r.length > 1) {
    const d = new ac("Select Compendium", l5, {
      packOptions: r,
      defaultSelection: CONFIG.A5E.defaultActorImportCompendia[e]
    });
    await d.render(!0);
    const p = await d.promise;
    if (!(p != null && p.pack)) return;
    n = p.pack;
  }
  const a = n ? game.packs.get(n) : game.packs.get(CONFIG.A5E.defaultActorImportCompendia[e]);
  if (!a) {
    ui.notifications.error(`No compendium found for ${e}`);
    return;
  }
  const c = s ?? ((d) => i.createEmbeddedDocuments("Item", d));
  new k0e[e]({ collection: a }, { importer: c }).render(!0);
}
u($0e, "openCompendium");
function A0e() {
  return CONFIG.A5E = Il, CONFIG.ActiveEffect.documentClass = lc, CONFIG.Actor.documentClass = hhe, CONFIG.Actor.trackableAttributes = u0e, CONFIG.Item.documentClass = ghe, CONFIG.Token.documentClass = Up, CONFIG.Token.objectClass = Hp, CONFIG.Dice.D20Roll = Qc, CONFIG.Dice.rolls.push(Qc), CONFIG.MeasuredTemplate.defaults.angle = 60, CONFIG.Actor.dataModels = _1e, CONFIG.ActiveEffect.dataModels = v1e, CONFIG.ChatMessage.dataModels = $1e, CONFIG.Item.dataModels = N1e, game.a5e = {
    applications: {
      ActorSheetA5e: Bg,
      ItemSheetA5e: e8
    },
    activeEffects: {
      EffectOption: Zo,
      options: {},
      effectsPanel: null
    },
    compendiumSheets: {
      DND5ESpellCompendiumSheet: Qp,
      ItemCompendiumSheet: Tu,
      ManeuverCompendiumSheet: Ou,
      MonsterCompendiumSheet: Du,
      SpellCompendiumSheet: Iu
    },
    config: Il,
    dice: {
      D20Roll: Qc
    },
    documentClasses: {
      ...Il.Actor.documentClasses,
      ...Il.Item.documentClasses,
      TokenDocumentA5e: Up,
      TokenA5e: Hp
    },
    dialogs: {
      bonuses: {
        abilities: {},
        damage: {},
        healing: {},
        skills: {}
      },
      partyViewer: null
    },
    macros: {
      activateActionMacro: f0e,
      activateItemMacro: d0e,
      createMacro: p0e
    },
    managers: {
      ActionsManager: cl,
      ContainerManager: qr,
      ForeignDocumentManager: s5,
      HitDiceManager: vu,
      ItemGrantsManager: dc,
      ModifierManager: yu,
      ResourceConsumptionManager: ai,
      RestManager: cp,
      RollPreparationManager: ns,
      TemplatePreparationManager: gc
    },
    migrations: {
      MigrationList: kr,
      MigrationRunner: tn,
      handleMigration: kq,
      handlePackMigration: wq
    },
    settings: {
      store: _c
    },
    utils: {
      getDeterministicBonus: mt,
      compendiaIndexFunctions: b0e,
      openCompendium: $0e
    }
  }, Actors.unregisterSheet("core", ActorSheet), Actors.registerSheet("a5e", Bg, {
    types: ["character"],
    makeDefault: !0,
    label: "A5E.SheetClassCharacter"
  }), Actors.registerSheet("a5e", Bg, {
    types: ["npc"],
    makeDefault: !0,
    label: "A5E.SheetClassNPC"
  }), Items.unregisterSheet("core", ItemSheet), Items.registerSheet("a5e", e8, {
    makeDefault: !0,
    label: "A5E.SheetClassItem"
  }), DocumentSheetConfig.unregisterSheet(ActiveEffect, "core", ActiveEffectConfig), DocumentSheetConfig.registerSheet(ActiveEffect, "a5e", Av, {
    makeDefault: !0,
    label: "A5E.SheetClassActiveEffectConfig"
  }), Combatant.prototype._getInitiativeFormula = n0e, Combatant.prototype.getInitiativeRoll = i0e, Combatant.prototype.rollInitiative = a0e, Combat.prototype.rollInitiative = c0e, CombatTracker.prototype._onCombatantControl = Xye, CombatTracker.prototype._onCombatControl = Yye, bhe(), TooltipManager.TOOLTIP_ACTIVATION_MS = 100, Hooks.once("i18nInit", () => {
    o0e(CONFIG.A5E), game.a5e.activeEffects.options = K1e();
  }), Kye(), new xk().registerCustomEnrichers(), l0e();
}
u(A0e, "init");
function X5(i, e, t, s) {
  if (!game.user.isGM) return;
  const n = {
    name: K("A5E.migration.migrateDocument", { type: s }),
    icon: '<i class="fa-solid fa-crow"></i>',
    callback: /* @__PURE__ */ u((l) => E0e(l, s), "callback")
  };
  e.push(n);
}
u(X5, "getDocumentDirectoryContext");
function E0e(i, e) {
  if (e === "Pack") {
    const t = game.packs.get(i.data("pack"));
    t && wq(t);
  } else {
    const t = e === "Actor" ? "actors" : "items", s = game[t].get(i.data("document-id"));
    s && VW(s);
  }
}
u(E0e, "callMigration");
function S0e(i) {
  var e;
  typeof ((e = i == null ? void 0 : i._svelteComponent) == null ? void 0 : e.$destroy) == "function" && i._svelteComponent.$destroy();
}
u(S0e, "preDeleteChatMessage");
function C0e(i, e, t, s) {
  game.user.id === s && i.updateSource({
    "flags.core.canPopout": !0
  });
}
u(C0e, "preCreateChatMessage");
function T0e(i, e, t) {
  if (e.type === "Item")
    return game.a5e.macros.createMacro(e, t), !1;
}
u(T0e, "hotbarDrop");
function O0e(i) {
  let e;
  return {
    c() {
      e = E("article"), e.innerHTML = `<h2 class="announcement-section-heading">New Content Bundles!</h2> <p class="svelte-844wib">For those of you looking to dip your toes into some of A5e&#39;s excellent third-party
        content, there are now <a href="https://www.drivethrurpg.com/en/browse?ruleSystem=1000104&amp;format=45305&amp;affiliate_id=1388381" target="_blank" class="svelte-844wib">four discounted bundles</a> available on DriveThruRPG for a limited time, each of which contains a selection
        of the community&#39;s favourite releases.</p> <p class="svelte-844wib">If you already have some of the excellent titles included in these compilations,
        you won&#39;t be charged for any books you already own, so these bundles are still a
        great way to round out your collection.</p> <section class="product-cards svelte-844wib"><a class="product-card svelte-844wib" href="https://www.drivethrurpg.com/en/product/479335/a5e-archetypes-and-accessories-bundle?affiliate_id=1388381" target="_blank"><img src="systems/a5e/assets/announcements/archetypes-bundle.webp" alt="Archetypes Bundle"/> <p class="price svelte-844wib">$15.99 <span class="price__old svelte-844wib">$19.99</span></p></a> <a class="product-card svelte-844wib" href="https://www.drivethrurpg.com/en/product/479366/a5e-new-classes-bundle-bundle?affiliate_id=1388381" target="_blank"><img src="systems/a5e/assets/announcements/classes-bundle.webp" alt="Classes Bundle"/> <p class="price svelte-844wib">$72.00 <span class="price__old svelte-844wib">$89.99</span></p></a> <a class="product-card svelte-844wib" href="https://www.drivethrurpg.com/en/product/479369/a5e-premium-heritages-bundle?affiliate_id=1388381" target="_blank"><img src="systems/a5e/assets/announcements/heritages-bundle.webp" alt="Heritages Bundle"/> <p class="price svelte-844wib">$35.60 <span class="price__old svelte-844wib">$43.00</span></p></a> <a class="product-card svelte-844wib" href="https://www.drivethrurpg.com/en/product/479367/a5e-rules-expansions-bundle?affiliate_id=1388381" target="_blank"><img src="systems/a5e/assets/announcements/rules-bundle.webp" alt="Archetypes Bundle"/> <p class="price svelte-844wib">$53.99 <span class="price__old svelte-844wib">$64.99</span></p></a></section> <p class="svelte-844wib">One final note: if you&#39;ve made any purchases recently on DriveThru, make sure to
        leave a rating or a review. It really helps our wonderful third-party publishers
        out. You can quickly leave a rating on all of your unrated products by going to <a href="https://www.drivethrurpg.com/account_orders_uncommented.php" target="_blank" class="svelte-844wib">this page</a>.</p> <aside class="disclaimer svelte-844wib"><strong>Disclaimer.</strong> This post contains affiliate links. If you choose to purchase
        any of the products listed here, we may receive a small amount of kick back from DriveThru
        RPG that will help fund further system and module development. This cut is taken from
        DriveThru&#39;s share, not the money that goes to the authors.</aside>`, b(e, "class", "main-announcement-container svelte-844wib");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    i: se,
    o: se,
    d(t) {
      t && C(e);
    }
  };
}
u(O0e, "create_fragment$i");
var tc;
let D0e = (tc = class extends re {
  constructor(e) {
    super(), oe(this, e, null, O0e, le, {});
  }
}, u(tc, "AnnouncementDialog"), tc);
var td, r5;
const h3 = class h3 extends Un {
  constructor(t) {
    super(
      {
        title: t,
        content: {
          class: D0e,
          props: {}
        }
      },
      {
        classes: ["a5e-sheet a5e-sheet--announcement"],
        width: 680
      }
    );
    x(this, td);
    this.data.content.props.dialog = this, this.promise = new Promise((s) => {
      this.resolve = s;
    });
  }
  /** @inheritdoc */
  close(t) {
    return X(this, td, r5).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return X(this, td, r5).call(this, t), super.close();
  }
};
td = new WeakSet(), r5 = /* @__PURE__ */ u(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), u(h3, "AnnouncementDialog");
let sm = h3;
function I0e(i) {
  let e, t;
  return {
    c: se,
    m(s, n) {
      e || (t = [
        W(
          window,
          "keydown",
          /*keydown_handler*/
          i[2]
        ),
        W(
          window,
          "keyup",
          /*keyup_handler*/
          i[3]
        ),
        W(
          window,
          "blur",
          /*blur_handler*/
          i[4]
        )
      ], e = !0);
    },
    p: se,
    i: se,
    o: se,
    d(s) {
      e = !1, Me(t);
    }
  };
}
u(I0e, "create_fragment$h");
function P0e(i) {
  let e;
  const t = Ml.subscribe((a) => e = a);
  function s(a) {
    e.Alt = a.altKey, e.Control = a.metaKey || a.ctrlKey, e.Shift = a.shiftKey, Ml.update(() => ({ ...e }));
  }
  u(s, "logKey");
  function n() {
    Object.keys(e).forEach((a) => e[a] = !1), Ml.update(() => ({ ...e }));
  }
  return u(n, "resetKeys"), Qt(t), [s, n, /* @__PURE__ */ u((a) => s(a), "keydown_handler"), /* @__PURE__ */ u((a) => s(a), "keyup_handler"), /* @__PURE__ */ u(() => n(), "blur_handler")];
}
u(P0e, "instance$g");
const g3 = class g3 extends re {
  constructor(e) {
    super(), oe(this, e, P0e, I0e, le, {});
  }
};
u(g3, "KeyPressHandler");
let o5 = g3;
function n7(i, e, t) {
  const s = i.slice();
  return s[4] = e[t][0], s[5] = e[t][1], s[6] = e[t][2], s;
}
u(n7, "get_each_context$6");
function i7(i) {
  let e, t, s, n = (
    /*moduleTitle*/
    i[4] + ""
  ), l, r, o, a, c, f, d = (
    /*reason*/
    i[5] + ""
  ), p, m;
  return {
    c() {
      e = E("li"), t = E("header"), s = E("h3"), l = Q(n), r = F(), o = E("i"), f = F(), p = Q(d), m = F(), b(s, "class", "module__title svelte-170etks"), b(o, "class", "module__priority-icon fa-solid fa-circle svelte-170etks"), b(o, "style", a = l7(
        /*priority*/
        i[6]
      )), b(o, "data-tooltip", c = r7(
        /*priority*/
        i[6]
      )), b(o, "data-tooltip-direction", "UP"), b(t, "class", "module__header svelte-170etks");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(t, s), A(s, l), A(t, r), A(t, o), A(e, f), A(e, p), A(e, m);
    },
    p(g, h) {
      h & /*modules*/
      1 && n !== (n = /*moduleTitle*/
      g[4] + "") && be(l, n), h & /*modules*/
      1 && a !== (a = l7(
        /*priority*/
        g[6]
      )) && b(o, "style", a), h & /*modules*/
      1 && c !== (c = r7(
        /*priority*/
        g[6]
      )) && b(o, "data-tooltip", c), h & /*modules*/
      1 && d !== (d = /*reason*/
      g[5] + "") && be(p, d);
    },
    d(g) {
      g && C(e);
    }
  };
}
u(i7, "create_each_block$6");
function M0e(i) {
  let e, t, s, n, l, r, o = ue(
    /*modules*/
    i[0]
  ), a = [];
  for (let c = 0; c < o.length; c += 1)
    a[c] = i7(n7(i, o, c));
  return {
    c() {
      e = E("article"), t = E("ul");
      for (let c = 0; c < a.length; c += 1)
        a[c].c();
      s = F(), n = E("button"), n.textContent = "Deactivate All", b(t, "class", "module-list svelte-170etks"), b(e, "class", "main-announcement-container svelte-170etks");
    },
    m(c, f) {
      T(c, e, f), A(e, t);
      for (let d = 0; d < a.length; d += 1)
        a[d] && a[d].m(t, null);
      A(e, s), A(e, n), l || (r = W(
        n,
        "click",
        /*click_handler*/
        i[3]
      ), l = !0);
    },
    p(c, [f]) {
      if (f & /*modules, getPriorityColor, getPriorityTooltipLabel*/
      1) {
        o = ue(
          /*modules*/
          c[0]
        );
        let d;
        for (d = 0; d < o.length; d += 1) {
          const p = n7(c, o, d);
          a[d] ? a[d].p(p, f) : (a[d] = i7(p), a[d].c(), a[d].m(t, null));
        }
        for (; d < a.length; d += 1)
          a[d].d(1);
        a.length = o.length;
      }
    },
    i: se,
    o: se,
    d(c) {
      c && C(e), Le(a, c), l = !1, r();
    }
  };
}
u(M0e, "create_fragment$g");
function l7(i) {
  switch (i) {
    case "low":
      return "color: #ffb404;";
    case "medium":
      return "color: #fe8006;";
    case "high":
      return "color: #fe3901;";
  }
}
u(l7, "getPriorityColor");
function r7(i) {
  switch (i) {
    case "low":
      return "Low Priority: No Adverse Effects";
    case "medium":
      return "Medium Priority: Limited Adverse Effects on System Functionality";
    case "high":
      return "High Priority: Adverse Effects on System Functionality";
  }
}
u(r7, "getPriorityTooltipLabel");
function F0e(i, e, t) {
  let s;
  async function n() {
    const a = game.settings.get("core", "moduleConfiguration"), c = r.reduce(
      (f, [d]) => (f[d] = !1, f),
      {}
    );
    await game.settings.set("core", "moduleConfiguration", foundry.utils.mergeObject(a, c)), window.location.reload();
  }
  u(n, "deactivateIncompatibleModules");
  let { activeIncompatibleModules: l } = de("#external").application, { activeIncompatibleModules: r = l } = e;
  const o = /* @__PURE__ */ u(() => n(), "click_handler");
  return i.$$set = (a) => {
    "activeIncompatibleModules" in a && t(2, r = a.activeIncompatibleModules);
  }, i.$$.update = () => {
    i.$$.dirty & /*activeIncompatibleModules*/
    4 && t(0, s = r.map(([a, { reason: c, priority: f }]) => {
      var d;
      return [(d = game.modules.get(a)) == null ? void 0 : d.title, c, f];
    }));
  }, [
    s,
    n,
    r,
    o
  ];
}
u(F0e, "instance$f");
var sc;
let R0e = (sc = class extends re {
  constructor(e) {
    super(), oe(this, e, F0e, M0e, le, { activeIncompatibleModules: 2 });
  }
  get activeIncompatibleModules() {
    return this.$$.ctx[2];
  }
  set activeIncompatibleModules(e) {
    this.$$set({ activeIncompatibleModules: e }), Xe();
  }
}, u(sc, "ModuleIncompatibilityDialog"), sc);
var sd, c5;
const b3 = class b3 extends Un {
  constructor(t) {
    super(
      {
        title: "Module Notices",
        content: {
          class: R0e,
          props: { activeIncompatibleModules: t }
        },
        zIndex: null
      },
      {
        classes: ["a5e-sheet a5e-sheet--announcement"],
        width: 540
      }
    );
    x(this, sd);
    this.data.content.props.dialog = this, this.promise = new Promise((s) => {
      this.resolve = s;
    });
  }
  /** @inheritdoc */
  close(t) {
    return X(this, sd, c5).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return X(this, sd, c5).call(this, t), super.close();
  }
};
sd = new WeakSet(), c5 = /* @__PURE__ */ u(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), u(b3, "ModuleIncompatibilityDialog");
let a5 = b3;
async function N0e() {
  var n, l;
  const i = "0.18.14", e = (n = game.user) == null ? void 0 : n.getFlag("a5e", "latestAnnouncement");
  if (!((!e || foundry.utils.isNewerVersion(i, e)) && Date.now() < 1718600413e3)) return;
  new sm("3PP Content Bundles").render(!0), (l = game.user) == null || l.setFlag("a5e", "latestAnnouncement", game.system.version);
}
u(N0e, "handleAnnouncement");
async function j0e() {
  var t;
  if (!((t = game.user) != null && t.isGM)) return;
  const i = Object.entries(CONFIG.A5E.moduleIncompatibilities).filter(
    ([s]) => {
      var n;
      return (n = game.modules.get(s)) == null ? void 0 : n.active;
    }
  );
  if (!i.length) return;
  new a5(i).render(!0);
}
u(j0e, "handleIncompatibilityWarning");
async function L0e() {
  new o5({ target: document.body });
}
u(L0e, "addKeyPressLogger");
async function B0e() {
  Hooks.on("hotbarDrop", T0e), kq(), N0e(), j0e(), L0e();
}
u(B0e, "ready");
function q0e(i) {
  if (i.constructor.name !== "SceneControls" || !game.settings.get("a5e", "playersCanAccessPartyViewer") && !game.user.isGM)
    return;
  const e = document.querySelector("nav#controls .main-controls"), t = document.createElement("li"), s = document.createElement("i");
  s.classList.add("fa-solid", "fa-users"), t.id = "a5e-js-toggle-party-viewer-visibility", t.classList.add("scene-control"), t.setAttribute("data-tooltip", "Party Viewer"), t.addEventListener("click", mq), t.append(s), e.append(t);
}
u(q0e, "renderApplication");
function G0e(i) {
  const { abilities: e } = CONFIG.A5E;
  return K("A5E.AbilityCheckPrompt", {
    ability: e[i.ability]
  });
}
u(G0e, "getAbilityCheckPromptTitle");
function z0e(i) {
  return fromUuidSync(i.effectUuid).name;
}
u(z0e, "getEffectPromptTitle");
function H0e(i, e) {
  const { abilities: t } = CONFIG.A5E;
  if (game.settings.get("a5e", "protectRolls") ?? !1) {
    const s = fromUuidSync(e);
    if (s && s.type !== "character" && s.permission < 2)
      return K("A5E.RollPromptSavingThrow", {
        ability: t[i.ability]
      });
  }
  return K("A5E.RollPromptSavingThrowWithDC", {
    ability: t[i.ability],
    dc: i.dc
  });
}
u(H0e, "getSavingThrowPromptTitle");
function U0e(i) {
  const { skills: e } = CONFIG.A5E;
  return K("A5E.SkillCheckPrompt", {
    skill: e[i.skill]
  });
}
u(U0e, "getSkillCheckPromptTitle");
function o7(i, e) {
  switch (i.type) {
    case "abilityCheck":
      return G0e(i);
    case "effect":
      return z0e(i);
    case "savingThrow":
      return H0e(i, e);
    case "skillCheck":
      return U0e(i);
    default:
      return (i == null ? void 0 : i.label) || K("A5E.Other");
  }
}
u(o7, "getPromptTitle");
function V0e(i) {
  switch (i.type) {
    case "effect":
      return "Apply effect";
    case "savingThrow":
      return i.onSave;
    default:
      return null;
  }
}
u(V0e, "getPromptSubtitle");
function W0e(i) {
  var e;
  return ((e = i.system.prompts) == null ? void 0 : e.reduce((t, s) => {
    var n;
    return t[n = s.type] ?? (t[n] = []), t[s.type].push(s), t;
  }, {})) ?? {};
}
u(W0e, "preparePrompts");
function K0e(i) {
  const { abilities: e, skills: t } = CONFIG.A5E, { abilityKey: s, saveType: n, skillKey: l } = i, r = K(e[s]), o = t[l];
  switch (i.cardType) {
    case "abilityCheck":
      return K("A5E.AbilityCheckSpecific", { ability: r });
    case "hitDice":
      return i.title;
    case "savingThrow":
      switch (n) {
        case "concentration":
          return K("A5E.ConcentrationCheck");
        case "death":
          return K("A5E.DeathSavingThrow");
        default:
          return K("A5E.SavingThrowSpecific", { ability: r });
      }
    case "skillCheck":
      return r ? K("A5E.SkillCheckAbility", { skill: o, ability: r }) : K("A5E.SkillCheck", { skill: o });
    default:
      return null;
  }
}
u(K0e, "getCheckLabel");
function Y0e(i) {
  return {
    label: K0e(i),
    expertiseDice: i.expertiseDice,
    rollMode: i.rollMode,
    type: i.cardType
  };
}
u(Y0e, "prepareCheckRollData");
const nm = /* @__PURE__ */ u((...i) => [...i[0]].map((e, t) => i.map((s) => s[t])), "zip"), a7 = {
  attack: 0,
  damage: 1,
  healing: 2,
  abilityCheck: 3,
  skillCheck: 4,
  savingThrow: 5,
  toolCheck: 6,
  generic: 7
};
function J5(i) {
  const { rolls: e } = i, t = i.system ?? {};
  return t.rollData ? nm(e, t.rollData).sort(
    (s, n) => {
      var l, r;
      return a7[(l = s[1]) == null ? void 0 : l.type] - a7[(r = n[1]) == null ? void 0 : r.type];
    }
  ) : e != null && e.length ? [[e[0], Y0e(t)]] : [];
}
u(J5, "prepareRolls");
function c7() {
  var t;
  const i = (t = canvas == null ? void 0 : canvas.tokens) == null ? void 0 : t.controlled;
  return i != null && i.length ? i.map((s) => s.document.actor) : [];
}
u(c7, "prepareSelectedTokenActors");
async function Sq(i, e, t, s) {
  var d, p, m, g, h, _;
  const { rollData: n } = (i == null ? void 0 : i.system) ?? {}, [l, r] = e[t], o = r.expertiseDice;
  if (o === s) return;
  const a = new Roll(
    l.formula,
    { ...l.data },
    { ...l.options }
  );
  a.terms = [...l.terms];
  const c = a.terms.findIndex(
    (y) => {
      var v;
      return ((v = y.options) == null ? void 0 : v.flavor) === "Expertise Die";
    }
  );
  if ((c !== -1 ? a.terms[c] : null) && ((d = n[t]).expertiseDiceResults ?? (d.expertiseDiceResults = {}), (g = n[t].expertiseDiceResults)[o] ?? (g[o] = (m = (p = a.terms[c]) == null ? void 0 : p.results[0]) == null ? void 0 : m.result)), !s)
    a.terms.splice(c - 1, 2);
  else {
    const y = new foundry.dice.terms.Die({
      number: 1,
      faces: parseInt(_u(s).slice(2), 10),
      options: {
        flavor: "Expertise Die"
      }
    }), v = n[t].expertiseDiceResults ?? {};
    v[s] ? (y.results.push({
      active: !0,
      result: v[s]
    }), y._evaluated = !0) : await y.evaluate(), o ? a.terms.splice(c, 1, y) : a.terms.push(
      new foundry.dice.terms.OperatorTerm({ operator: "+" }),
      y
    ), (_ = (h = game.modules) == null ? void 0 : h.get("dice-so-nice")) != null && _.active && game.dice3d.showForRoll(
      Roll.fromTerms([y]),
      game.users.get(i.user.id),
      !0,
      i.whisper,
      i.blind,
      null,
      i.speaker
    );
  }
  a._formula = Roll.getFormula(a.terms), a._total = a._evaluateTotal(), await a.evaluate(), i.rolls.splice(t, 1, a), n[t].expertiseDice = s, await i.update({
    rolls: i.rolls,
    "system.rollData": n
  });
}
u(Sq, "toggleExpertiseDice");
async function Cq(i, e, t, s) {
  var f, d, p, m;
  const [n, l] = e[t], r = l.rollMode;
  if (r === s) return;
  const o = new Roll(
    n.formula,
    { ...n.data },
    { ...n.options }
  );
  o.terms = [...n.terms];
  const a = o.terms[0], c = a.results.length;
  if (a.number === 2) {
    const g = a.results[1].result;
    (f = i.system.rollData[t]).secondDieResult ?? (f.secondDieResult = g);
  }
  if (a.modifiers = a.modifiers.filter((g) => !["kh", "kl"].includes(g)), !s)
    a.number = 1, a.results = [a.results.shift()];
  else if (a.modifiers.push(s === 1 ? "kh" : "kl"), !r) {
    a.number = 2;
    const { secondDieResult: g } = ((p = (d = i == null ? void 0 : i.system) == null ? void 0 : d.rollData) == null ? void 0 : p[t]) ?? void 0;
    g ? a.results.push({ result: g }) : await a.roll();
  }
  if (a.results.forEach((g) => {
    g.active = !0, delete g.discarded, delete g.indexThrow;
  }), a._evaluateModifiers(), o._formula = Roll.getFormula(o.terms), o._total = o._evaluateTotal(), await o.evaluate(), (m = game.modules.get("dice-so-nice")) != null && m.active && a.results.length > c) {
    const g = Roll.fromTerms([foundry.dice.terms.RollTerm.fromData(a.toJSON())]);
    g.terms[0].number = g.terms[0].results.length, g.terms[0].results = g.terms[0].results.filter((h, _) => _ > 0), game.dice3d.showForRoll(
      g,
      game.users.get(i.user.id),
      !0,
      i.whisper,
      i.blind,
      null,
      i.speaker
    );
  }
  i.rolls.splice(t, 1, o), i.system.rollData[t].rollMode = s, await i.update({
    rolls: i.rolls,
    "system.rollData": i.system.rollData
  });
}
u(Cq, "toggleRollMode");
function Z5(i) {
  const { r: e, g: t, b: s } = i;
  return e * 0.2126 + t * 0.7152 + s * 0.0722 >= 0.6 ? "hsl(50, 14%, 9%)" : "hsl(38, 38%, 94%)";
}
u(Z5, "calculateHeaderTextColor");
function u7(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = Q(
        /*subtitle*/
        i[3]
      ), b(e, "class", "a5e-chat-card__header__subtitle");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n & /*subtitle*/
      8 && be(
        t,
        /*subtitle*/
        s[3]
      );
    },
    d(s) {
      s && C(e);
    }
  };
}
u(u7, "create_if_block_1$4");
function f7(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-chat-card__header__button--crit-toggle fa-solid fa-bullseye"), b(e, "data-tooltip", "Toggle Critical Damage"), b(e, "data-tooltip-direction", "LEFT"), Z(
        e,
        "a5e-chat-card__header__button--crit-toggle--crit",
        /*critDamageEnabled*/
        i[4]
      );
    },
    m(n, l) {
      T(n, e, l), t || (s = W(e, "click", Ve(
        /*click_handler_1*/
        i[13]
      )), t = !0);
    },
    p(n, l) {
      l & /*critDamageEnabled*/
      16 && Z(
        e,
        "a5e-chat-card__header__button--crit-toggle--crit",
        /*critDamageEnabled*/
        n[4]
      );
    },
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(f7, "create_if_block$4");
function X0e(i) {
  let e, t, s, n, l, r, o, a, c, f = (
    /*timeSince*/
    i[9](
      /*messageDocument*/
      i[2].timestamp
    ) + ""
  ), d, p, m, g, h, _, y, v, k, S = (
    /*subtitle*/
    i[3] && u7(i)
  ), D = (
    /*showCritDamageToggle*/
    i[5] && f7(i)
  );
  return {
    c() {
      e = E("header"), t = E("img"), n = F(), l = E("span"), r = Q(
        /*actorName*/
        i[0]
      ), o = F(), S && S.c(), a = F(), c = E("time"), d = Q(f), p = F(), m = E("span"), D && D.c(), g = F(), h = E("button"), _ = F(), y = E("a"), y.innerHTML = '<i class="fas fa-trash"></i>', b(t, "class", "a5e-chat-card__header__img"), ze(t.src, s = /*img*/
      i[1]) || b(t, "src", s), b(
        t,
        "alt",
        /*actorName*/
        i[0]
      ), b(l, "class", "a5e-chat-card__header__title"), b(l, "role", "button"), b(l, "tabindex", "0"), b(c, "class", "message-timestamp a5e-chat-card__header__time"), b(h, "class", "a5e-chat-card__header__button--repeat fas fa-undo"), b(h, "data-tooltip", "Repeat Roll"), b(h, "data-tooltip-direction", "LEFT"), b(y, "aria-label", "Delete"), b(y, "class", "message-delete a5e-chat-card__header__button--delete svelte-1p6si2m"), b(m, "class", "a5e-chat-card__header__buttons"), b(e, "class", "a5e-chat-card__header a5e-chat-card__header--item"), G(
        e,
        "--a5e-user-background-color",
        /*headerBackgroundColor*/
        i[7]
      ), G(
        e,
        "--a5e-user-text-color",
        /*headerTextColor*/
        i[8]
      ), Z(e, "a5e-chat-card__header--item-subtitle", !!/*subtitle*/
      i[3]);
    },
    m(I, M) {
      T(I, e, M), A(e, t), A(e, n), A(e, l), A(l, r), A(e, o), S && S.m(e, null), A(e, a), A(e, c), A(c, d), A(e, p), A(e, m), D && D.m(m, null), A(m, g), A(m, h), A(m, _), A(m, y), v || (k = [
        W(
          l,
          "click",
          /*click_handler*/
          i[12]
        ),
        W(
          h,
          "click",
          /*click_handler_2*/
          i[14]
        )
      ], v = !0);
    },
    p(I, [M]) {
      M & /*img*/
      2 && !ze(t.src, s = /*img*/
      I[1]) && b(t, "src", s), M & /*actorName*/
      1 && b(
        t,
        "alt",
        /*actorName*/
        I[0]
      ), M & /*actorName*/
      1 && be(
        r,
        /*actorName*/
        I[0]
      ), /*subtitle*/
      I[3] ? S ? S.p(I, M) : (S = u7(I), S.c(), S.m(e, a)) : S && (S.d(1), S = null), M & /*messageDocument*/
      4 && f !== (f = /*timeSince*/
      I[9](
        /*messageDocument*/
        I[2].timestamp
      ) + "") && be(d, f), /*showCritDamageToggle*/
      I[5] ? D ? D.p(I, M) : (D = f7(I), D.c(), D.m(m, g)) : D && (D.d(1), D = null), M & /*subtitle*/
      8 && Z(e, "a5e-chat-card__header--item-subtitle", !!/*subtitle*/
      I[3]);
    },
    i: se,
    o: se,
    d(I) {
      I && C(e), S && S.d(), D && D.d(), v = !1, Me(k);
    }
  };
}
u(X0e, "create_fragment$f");
function J0e(i, e, t) {
  let s, n, l, { actorName: r } = e, { img: o } = e, { messageDocument: a } = e, { subtitle: c = null } = e;
  const f = de("message");
  pe(i, f, (v) => t(11, l = v));
  const d = a.author.color, p = Z5(d), { timeSince: m } = foundry.utils, g = ft(), h = /* @__PURE__ */ u(() => g("toggleDescription"), "click_handler"), _ = /* @__PURE__ */ u(() => g("toggleCriticalDamage"), "click_handler_1"), y = /* @__PURE__ */ u(() => g("repeatCard"), "click_handler_2");
  return i.$$set = (v) => {
    "actorName" in v && t(0, r = v.actorName), "img" in v && t(1, o = v.img), "messageDocument" in v && t(2, a = v.messageDocument), "subtitle" in v && t(3, c = v.subtitle);
  }, i.$$.update = () => {
    var v, k;
    i.$$.dirty & /*$message*/
    2048 && t(5, s = (((v = l == null ? void 0 : l.system) == null ? void 0 : v.rollData) ?? []).some((S) => S.type === "damage" && (S.canCrit ?? !0) && S.critRoll && S.baseRoll)), i.$$.dirty & /*$message*/
    2048 && t(4, n = nm(l.rolls ?? [], ((k = l == null ? void 0 : l.system) == null ? void 0 : k.rollData) ?? []).some(([S, D]) => !(D.type !== "damage" || !D.canCrit || !D.critRoll || !D.baseRoll || D.baseRoll.formula === S.formula)));
  }, [
    r,
    o,
    a,
    c,
    n,
    s,
    f,
    d,
    p,
    m,
    g,
    l,
    h,
    _,
    y
  ];
}
u(J0e, "instance$e");
const _3 = class _3 extends re {
  constructor(e) {
    super(), oe(this, e, J0e, X0e, le, {
      actorName: 0,
      img: 1,
      messageDocument: 2,
      subtitle: 3
    });
  }
};
u(_3, "ItemCardHeader");
let u5 = _3;
function Z0e(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "die fa-solid fa-dice-d20 svelte-99pkcm"), Z(
        e,
        "die--generic-prompt",
        /*prompt*/
        i[1].type === "generic"
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*prompt*/
      2 && Z(
        e,
        "die--generic-prompt",
        /*prompt*/
        t[1].type === "generic"
      );
    },
    d(t) {
      t && C(e);
    }
  };
}
u(Z0e, "create_else_block$1");
function Q0e(i) {
  let e, t;
  return {
    c() {
      e = E("img"), b(e, "class", "effect-icon svelte-99pkcm"), ze(e.src, t = /*icon*/
      i[0]) || b(e, "src", t), b(e, "alt", "title");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*icon*/
      1 && !ze(e.src, t = /*icon*/
      s[0]) && b(e, "src", t);
    },
    d(s) {
      s && C(e);
    }
  };
}
u(Q0e, "create_if_block_1$3");
function d7(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = Q(
        /*subtitle*/
        i[3]
      ), b(e, "class", "subtitle svelte-99pkcm");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n & /*subtitle*/
      8 && be(
        t,
        /*subtitle*/
        s[3]
      );
    },
    d(s) {
      s && C(e);
    }
  };
}
u(d7, "create_if_block$3");
function x0e(i) {
  let e, t, s, n, l, r, o, a, c;
  function f(g, h) {
    return (
      /*prompt*/
      g[1].type === "effect" ? Q0e : Z0e
    );
  }
  u(f, "select_block_type");
  let d = f(i), p = d(i), m = (
    /*subtitle*/
    i[3] && d7(i)
  );
  return {
    c() {
      e = E("button"), t = E("div"), p.c(), s = F(), n = E("header"), l = E("span"), r = Q(
        /*title*/
        i[2]
      ), o = F(), m && m.c(), b(t, "class", "icon-wrapper svelte-99pkcm"), Z(
        t,
        "icon-wrapper--effect",
        /*prompt*/
        i[1].type === "effect"
      ), b(l, "class", "title svelte-99pkcm"), b(n, "class", "title-wrapper svelte-99pkcm"), b(e, "class", "save-prompt svelte-99pkcm");
    },
    m(g, h) {
      T(g, e, h), A(e, t), p.m(t, null), A(e, s), A(e, n), A(n, l), A(l, r), A(n, o), m && m.m(n, null), a || (c = W(
        e,
        "click",
        /*click_handler*/
        i[5]
      ), a = !0);
    },
    p(g, [h]) {
      d === (d = f(g)) && p ? p.p(g, h) : (p.d(1), p = d(g), p && (p.c(), p.m(t, null))), h & /*prompt*/
      2 && Z(
        t,
        "icon-wrapper--effect",
        /*prompt*/
        g[1].type === "effect"
      ), h & /*title*/
      4 && be(
        r,
        /*title*/
        g[2]
      ), /*subtitle*/
      g[3] ? m ? m.p(g, h) : (m = d7(g), m.c(), m.m(n, null)) : m && (m.d(1), m = null);
    },
    i: se,
    o: se,
    d(g) {
      g && C(e), p.d(), m && m.d(), a = !1, c();
    }
  };
}
u(x0e, "create_fragment$e");
function eve(i, e, t) {
  let { icon: s = null } = e, { prompt: n } = e, { title: l } = e, { subtitle: r = null } = e;
  const o = ft(), a = /* @__PURE__ */ u(() => o("triggerPrompt"), "click_handler");
  return i.$$set = (c) => {
    "icon" in c && t(0, s = c.icon), "prompt" in c && t(1, n = c.prompt), "title" in c && t(2, l = c.title), "subtitle" in c && t(3, r = c.subtitle);
  }, [s, n, l, r, o, a];
}
u(eve, "instance$d");
const y3 = class y3 extends re {
  constructor(e) {
    super(), oe(this, e, eve, x0e, le, {
      icon: 0,
      prompt: 1,
      title: 2,
      subtitle: 3
    });
  }
};
u(y3, "PromptButton");
let im = y3;
function tve(i) {
  var s;
  if (!game.settings.get("a5e", "protectRolls")) return !0;
  const e = (s = i == null ? void 0 : i.system) == null ? void 0 : s.actorId, t = fromUuidSync(e);
  return !t || t.type === "character" ? !0 : t.permission >= 2;
}
u(tve, "getTooltipPermissions");
function sve(i) {
  const e = game.settings.get("a5e", "terseRollFormulae");
  return `<div class="a5e-roll-formula">${i.terms.reduce((s, n) => {
    let l = `<span class="a5e-roll-formula__term">${n.expression}`;
    return n.flavor && !e && (l += ` [${n.flavor}]`), l += "</span>", s + l;
  }, "")}</div>`;
}
u(sve, "prepareRollTooltipFormula");
function nve({ faces: i, results: e }, t) {
  return e.reduce((s, { rerolled: n, discarded: l, result: r }) => {
    const o = i === 20 && r >= t.critThreshold || r === i, a = l || n, c = r === 1;
    let f = `a5e-die a5e-die--${i}`;
    return a ? f += " a5e-die--discarded" : c ? f += " a5e-die--min" : o && (f += " a5e-die--max"), `${s}<li class="${f}">${r}</li>`;
  }, "");
}
u(nve, "prepareRollTooltipDiceResults");
function ive(i, e) {
  return i.dice.reduce((t, s) => {
    let n = `<section class="u-mb-md">
          <header class="u-align-center u-flex u-justify-space-between u-text-bold">
              <div class="a5e-dice-tooltip__formula">
                  ${s.expression}
                  <span class="a5e-dice-tooltip__flavor">`;
    return s.flavor && (n += ` [${s.flavor}]`), n += `</span></div>
              <span class="a5e-dice-tooltip__total">${s.total}</span>
          </header>

      <ol class="u-align-center u-flex u-flex-wrap u-gap-xs u-list-style-none u-my-xs u-p-0">`, n += nve(s, e), n += "</ol></section>", t + n;
  }, "");
}
u(ive, "prepareRollTooltipRollParts");
function p7(i, e, t) {
  return tve(i) ? [ive(e, t), sve(e)].join("") : null;
}
u(p7, "prepareRollTooltip");
function m7(i, e, t) {
  const s = i.slice();
  return s[8] = e[t].label, s[9] = e[t].multiplier, s[10] = e[t].temp, s[11] = e[t].icon, s;
}
u(m7, "get_each_context$5");
function lve(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = '<i class="fa-solid fa-heart-circle-plus button__icon"></i>', b(e, "class", "healing-button svelte-kdimxq"), b(e, "data-tooltip", "Apply Healing"), b(e, "data-tooltip-direction", "LEFT");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(e, "click", Ve(
        /*click_handler_2*/
        i[7]
      )), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(lve, "create_if_block_2$2");
function rve(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = '<i class="fa-solid fa-heart-circle-bolt button__icon"></i>', b(e, "class", "healing-button svelte-kdimxq"), b(e, "data-tooltip", "Apply Temporary Healing"), b(e, "data-tooltip-direction", "LEFT");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(e, "click", Ve(
        /*click_handler_1*/
        i[6]
      )), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(rve, "create_if_block_1$2");
function ove(i) {
  let e, t, s, n, l = ue(
    /*damageButtons*/
    i[3]
  ), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = h7(m7(i, l, o));
  return {
    c() {
      e = E("div"), t = E("i"), s = F(), n = E("ol");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      b(t, "class", "damage-menu__button fa-heart-circle-minus fa-solid svelte-kdimxq"), b(n, "class", "damage-buttons svelte-kdimxq"), b(e, "class", "damage-menu svelte-kdimxq");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(e, n);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(n, null);
    },
    p(o, a) {
      if (a & /*applyDamage, rollData, damageButtons*/
      11) {
        l = ue(
          /*damageButtons*/
          o[3]
        );
        let c;
        for (c = 0; c < l.length; c += 1) {
          const f = m7(o, l, c);
          r[c] ? r[c].p(f, a) : (r[c] = h7(f), r[c].c(), r[c].m(n, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
    },
    d(o) {
      o && C(e), Le(r, o);
    }
  };
}
u(ove, "create_if_block$2");
function h7(i) {
  let e, t, s, n, l, r, o;
  function a() {
    return (
      /*click_handler*/
      i[5](
        /*multiplier*/
        i[9],
        /*temp*/
        i[10]
      )
    );
  }
  return u(a, "click_handler"), {
    c() {
      e = E("li"), t = E("span"), t.textContent = `${/*label*/
      i[8]}`, s = F(), n = E("i"), l = F(), b(n, "class", "fa-solid " + /*icon*/
      i[11] + " button__icon svelte-kdimxq"), b(e, "class", "damage-buttons__item svelte-kdimxq"), b(e, "role", "button");
    },
    m(c, f) {
      T(c, e, f), A(e, t), A(e, s), A(e, n), A(e, l), r || (o = W(e, "click", Ve(a)), r = !0);
    },
    p(c, f) {
      i = c;
    },
    d(c) {
      c && C(e), r = !1, o();
    }
  };
}
u(h7, "create_each_block$5");
function ave(i) {
  let e;
  function t(l, r) {
    if (
      /*rollData*/
      l[0].type === "damage"
    ) return ove;
    if (
      /*rollData*/
      l[0].healingType === "temporaryHealing"
    ) return rve;
    if (
      /*rollData*/
      l[0].healingType === "healing"
    ) return lve;
  }
  u(t, "select_block_type");
  let s = t(i), n = s && s(i);
  return {
    c() {
      n && n.c(), e = $e();
    },
    m(l, r) {
      n && n.m(l, r), T(l, e, r);
    },
    p(l, [r]) {
      s === (s = t(l)) && n ? n.p(l, r) : (n && n.d(1), n = s && s(l), n && (n.c(), n.m(e.parentNode, e)));
    },
    i: se,
    o: se,
    d(l) {
      l && C(e), n && n.d(l);
    }
  };
}
u(ave, "create_fragment$d");
function cve(i, e, t) {
  function s(d = null, p = 1, m = !1) {
    if (p < 0) {
      n(m ? "temporaryHealing" : "healing");
      return;
    }
    const { character: g } = game.user, h = canvas.tokens.controlled, _ = l.total * p;
    h.length ? h.forEach((y) => y.actor.applyDamage(_, d)) : g ? g.applyDamage(_, d) : ui.notifications.warn("No tokens selected");
  }
  u(s, "applyDamage");
  async function n(d) {
    const { character: p } = game.user, m = canvas.tokens.controlled;
    m.length ? m.forEach((g) => {
      g.actor.applyHealing(l.total, d);
    }) : p ? p.applyHealing(l.total, d) : ui.notifications.warn("No tokens selected");
  }
  u(n, "applyHealing");
  let { roll: l } = e, { rollData: r } = e;
  const o = [
    {
      label: "Grant Temporary Hit Points",
      multiplier: -1,
      temp: !0,
      icon: "fa-heart-circle-bolt"
    },
    {
      label: "Apply Damage as Healing",
      multiplier: -1,
      icon: "fa-heart-circle-plus"
    },
    {
      label: "Apply Double Damage",
      multiplier: 2,
      icon: "fa-skull"
    },
    {
      label: "Apply Quarter Damage",
      multiplier: 0.25,
      icon: "fa-shield"
    },
    {
      label: "Apply Half Damage",
      multiplier: 0.5,
      icon: "fa-shield-halved"
    },
    {
      label: "Apply Damage",
      multiplier: 1,
      icon: "fa-heart-crack"
    }
  ], a = /* @__PURE__ */ u((d, p) => s(r.damageType, d, p), "click_handler"), c = /* @__PURE__ */ u(() => n(r.healingType), "click_handler_1"), f = /* @__PURE__ */ u(() => n(r.healingType), "click_handler_2");
  return i.$$set = (d) => {
    "roll" in d && t(4, l = d.roll), "rollData" in d && t(0, r = d.rollData);
  }, [
    r,
    s,
    n,
    o,
    l,
    a,
    c,
    f
  ];
}
u(cve, "instance$c");
const v3 = class v3 extends re {
  constructor(e) {
    super(), oe(this, e, cve, ave, le, { roll: 4, rollData: 0 });
  }
};
u(v3, "DamageButtons");
let f5 = v3;
function uve(i) {
  let e, t, s, n;
  return e = new Ke({
    props: {
      heading: "Configure Roll Mode",
      options: (
        /*damageButtons*/
        i[1]
      ),
      selected: (
        /*rollData*/
        i[0].rollMode ?? 0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), s = new Ke({
    props: {
      heading: "Configure Expertise Die",
      options: (
        /*expertiseDice*/
        i[2]
      ),
      selected: (
        /*rollData*/
        i[0].expertiseDice ?? 0
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[5]
  ), {
    c() {
      j(e.$$.fragment), t = F(), j(s.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), T(l, t, r), R(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*rollData*/
      1 && (o.selected = /*rollData*/
      l[0].rollMode ?? 0), e.$set(o);
      const a = {};
      r & /*rollData*/
      1 && (a.selected = /*rollData*/
      l[0].expertiseDice ?? 0), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      O(e.$$.fragment, l), O(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && C(t), N(e, l), N(s, l);
    }
  };
}
u(uve, "create_default_slot$3");
function fve(i) {
  let e, t, s;
  return e = new De({
    props: {
      $$slots: { default: [uve] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(t, "--a5e-section-body-gap", "0.75rem"), G(t, "--a5e-section-margin", "0.5rem 0");
    },
    m(n, l) {
      T(n, t, l), R(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, rollData*/
      65 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      O(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && C(t), N(e, n);
    }
  };
}
u(fve, "create_fragment$c");
function dve(i, e, t) {
  let { rollData: s = {} } = e;
  const n = [[1, "Advantage"], [0, "Normal"], [-1, "Disadvantage"]], l = [[0, "None"], [1, "1d4"], [2, "1d6"], [3, "1d8"], [4, "1d10"], [5, "1d12"]], r = ft(), o = /* @__PURE__ */ u(({ detail: c }) => r("toggleRollMode", c), "updateSelection_handler"), a = /* @__PURE__ */ u(({ detail: c }) => r("toggleExpertiseDice", c), "updateSelection_handler_1");
  return i.$$set = (c) => {
    "rollData" in c && t(0, s = c.rollData);
  }, [
    s,
    n,
    l,
    r,
    o,
    a
  ];
}
u(dve, "instance$b");
const k3 = class k3 extends re {
  constructor(e) {
    super(), oe(this, e, dve, fve, le, { rollData: 0 });
  }
};
u(k3, "RollConfigurationOptions");
let d5 = k3;
function g7(i) {
  let e, t, s, n = (
    /*rollData*/
    i[1].rollMode && b7(i)
  ), l = (
    /*rollData*/
    i[1].expertiseDice && _7(i)
  ), r = (
    /*rollData*/
    i[1].userLabel && y7(i)
  );
  return {
    c() {
      e = E("div"), n && n.c(), t = F(), l && l.c(), s = F(), r && r.c(), b(e, "class", "subtitle-wrapper svelte-1pubd7z");
    },
    m(o, a) {
      T(o, e, a), n && n.m(e, null), A(e, t), l && l.m(e, null), A(e, s), r && r.m(e, null);
    },
    p(o, a) {
      /*rollData*/
      o[1].rollMode ? n ? n.p(o, a) : (n = b7(o), n.c(), n.m(e, t)) : n && (n.d(1), n = null), /*rollData*/
      o[1].expertiseDice ? l ? l.p(o, a) : (l = _7(o), l.c(), l.m(e, s)) : l && (l.d(1), l = null), /*rollData*/
      o[1].userLabel ? r ? r.p(o, a) : (r = y7(o), r.c(), r.m(e, null)) : r && (r.d(1), r = null);
    },
    d(o) {
      o && C(e), n && n.d(), l && l.d(), r && r.d();
    }
  };
}
u(g7, "create_if_block_6$1");
function b7(i) {
  let e, t = (
    /*getRollModeLabel*/
    i[7](
      /*rollData*/
      i[1]
    ) + ""
  ), s;
  return {
    c() {
      e = E("span"), s = Q(t), b(e, "class", "roll-mode svelte-1pubd7z"), Z(
        e,
        "roll-mode--disadvantage",
        /*rollData*/
        i[1].rollMode === -1
      );
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*rollData*/
      2 && t !== (t = /*getRollModeLabel*/
      n[7](
        /*rollData*/
        n[1]
      ) + "") && be(s, t), l & /*rollData*/
      2 && Z(
        e,
        "roll-mode--disadvantage",
        /*rollData*/
        n[1].rollMode === -1
      );
    },
    d(n) {
      n && C(e);
    }
  };
}
u(b7, "create_if_block_9$1");
function _7(i) {
  let e, t = (
    /*getExpertiseLabel*/
    i[8](
      /*rollData*/
      i[1]
    ) + ""
  ), s;
  return {
    c() {
      e = E("span"), s = Q(t), b(e, "class", "expertise-label svelte-1pubd7z");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*rollData*/
      2 && t !== (t = /*getExpertiseLabel*/
      n[8](
        /*rollData*/
        n[1]
      ) + "") && be(s, t);
    },
    d(n) {
      n && C(e);
    }
  };
}
u(_7, "create_if_block_8$1");
function y7(i) {
  let e, t = (
    /*rollData*/
    i[1].userLabel + ""
  ), s;
  return {
    c() {
      e = E("span"), s = Q(t), b(e, "class", "roll-sublabel svelte-1pubd7z");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*rollData*/
      2 && t !== (t = /*rollData*/
      n[1].userLabel + "") && be(s, t);
    },
    d(n) {
      n && C(e);
    }
  };
}
u(y7, "create_if_block_7$1");
function pve(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "roll-mode-button fa-dice fa-solid svelte-1pubd7z"), b(e, "data-tooltip", "Modify Roll"), b(e, "data-tooltip-direction", "LEFT");
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*toggleRollConfig*/
        i[10]
      ), t = !0);
    },
    p: se,
    i: se,
    o: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(pve, "create_if_block_5$1");
function mve(i) {
  let e, t;
  return e = new f5({
    props: {
      roll: (
        /*roll*/
        i[0]
      ),
      rollData: (
        /*rollData*/
        i[1]
      )
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*roll*/
      1 && (l.roll = /*roll*/
      s[0]), n & /*rollData*/
      2 && (l.rollData = /*rollData*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(mve, "create_if_block_4$1");
function v7(i) {
  let e, t, s = (
    /*isCriticalSuccess*/
    i[4] && k7(i)
  ), n = (
    /*isCriticalFailure*/
    i[5] && w7(i)
  );
  return {
    c() {
      s && s.c(), e = F(), n && n.c(), t = $e();
    },
    m(l, r) {
      s && s.m(l, r), T(l, e, r), n && n.m(l, r), T(l, t, r);
    },
    p(l, r) {
      /*isCriticalSuccess*/
      l[4] ? s ? s.p(l, r) : (s = k7(l), s.c(), s.m(e.parentNode, e)) : s && (s.d(1), s = null), /*isCriticalFailure*/
      l[5] ? n ? n.p(l, r) : (n = w7(l), n.c(), n.m(t.parentNode, t)) : n && (n.d(1), n = null);
    },
    d(l) {
      l && (C(e), C(t)), s && s.d(l), n && n.d(l);
    }
  };
}
u(v7, "create_if_block_1$1");
function k7(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = `<i class="fa-solid fa-dice-d20"></i>
            Roll on the skill critical success table`;
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler*/
        i[15]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(k7, "create_if_block_3$1");
function w7(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = `<i class="fa-solid fa-dice-d20"></i>
            Roll on the skill critical failure table`;
    },
    m(n, l) {
      T(n, e, l), t || (s = W(
        e,
        "click",
        /*click_handler_1*/
        i[16]
      ), t = !0);
    },
    p: se,
    d(n) {
      n && C(e), t = !1, s();
    }
  };
}
u(w7, "create_if_block_2$1");
function $7(i) {
  let e, t;
  return e = new d5({ props: { rollData: (
    /*rollData*/
    i[1]
  ) } }), e.$on(
    "toggleRollMode",
    /*toggleRollMode_handler*/
    i[17]
  ), e.$on(
    "toggleExpertiseDice",
    /*toggleExpertiseDice_handler*/
    i[18]
  ), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*rollData*/
      2 && (l.rollData = /*rollData*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u($7, "create_if_block$1");
function hve(i) {
  let e, t, s = (
    /*roll*/
    i[0].total + ""
  ), n, l, r, o, a, c = (
    /*rollData*/
    (i[1].label || "Result") + ""
  ), f, d, p, m, g, h, _, y, v, k, S = !/*showRollConfig*/
  i[3] && /*rollData*/
  (i[1].expertiseDice || /*rollData*/
  i[1].rollMode || /*rollData*/
  i[1].userLabel) && g7(i);
  const D = [mve, pve], I = [];
  function M(z, q) {
    var U;
    return q & /*rollData*/
    2 && (m = null), /*rollData*/
    z[1].type === "damage" || /*rollData*/
    z[1].type === "healing" ? 0 : (m == null && (m = !!/*user*/
    ((z[14].isGM || /*actor*/
    (U = z[13]) != null && U.testUserPermission(
      /*user*/
      z[14],
      2
    )) && ["abilityCheck", "attack", "savingThrow", "skillCheck", "toolCheck"].includes(
      /*rollData*/
      z[1].type
    ))), m ? 1 : -1);
  }
  u(M, "select_block_type"), ~(g = M(i, -1)) && (h = I[g] = D[g](i));
  let L = !/*hideSkillCriticalPrompt*/
  i[11] && /*rollData*/
  i[1].type === "skillCheck" && /*rollData*/
  i[1].skillKey && v7(i), B = (
    /*showRollConfig*/
    i[3] && $7(i)
  );
  return {
    c() {
      e = E("div"), t = E("div"), n = Q(s), r = F(), o = E("header"), a = E("h3"), f = Q(c), d = F(), S && S.c(), p = F(), h && h.c(), _ = F(), L && L.c(), y = F(), B && B.c(), v = $e(), b(t, "class", "roll svelte-1pubd7z"), b(t, "data-tooltip", l = p7(
        /*$message*/
        i[6],
        /*roll*/
        i[0],
        /*rollData*/
        i[1]
      )), b(t, "data-tooltip-class", "a5e-tooltip a5e-tooltip--roll"), b(t, "data-tooltip-direction", "LEFT"), Z(
        t,
        "roll--max",
        /*isCriticalSuccess*/
        i[4]
      ), Z(
        t,
        "roll--min",
        /*isCriticalFailure*/
        i[5]
      ), Z(t, "roll--wide", !/*isAction*/
      i[2]), b(a, "class", "roll-label svelte-1pubd7z"), b(o, "class", "roll-header svelte-1pubd7z"), b(e, "class", "roll-container svelte-1pubd7z");
    },
    m(z, q) {
      T(z, e, q), A(e, t), A(t, n), A(e, r), A(e, o), A(o, a), A(a, f), A(o, d), S && S.m(o, null), A(e, p), ~g && I[g].m(e, null), T(z, _, q), L && L.m(z, q), T(z, y, q), B && B.m(z, q), T(z, v, q), k = !0;
    },
    p(z, [q]) {
      (!k || q & /*roll*/
      1) && s !== (s = /*roll*/
      z[0].total + "") && be(n, s), (!k || q & /*$message, roll, rollData*/
      67 && l !== (l = p7(
        /*$message*/
        z[6],
        /*roll*/
        z[0],
        /*rollData*/
        z[1]
      ))) && b(t, "data-tooltip", l), (!k || q & /*isCriticalSuccess*/
      16) && Z(
        t,
        "roll--max",
        /*isCriticalSuccess*/
        z[4]
      ), (!k || q & /*isCriticalFailure*/
      32) && Z(
        t,
        "roll--min",
        /*isCriticalFailure*/
        z[5]
      ), (!k || q & /*isAction*/
      4) && Z(t, "roll--wide", !/*isAction*/
      z[2]), (!k || q & /*rollData*/
      2) && c !== (c = /*rollData*/
      (z[1].label || "Result") + "") && be(f, c), !/*showRollConfig*/
      z[3] && /*rollData*/
      (z[1].expertiseDice || /*rollData*/
      z[1].rollMode || /*rollData*/
      z[1].userLabel) ? S ? S.p(z, q) : (S = g7(z), S.c(), S.m(o, null)) : S && (S.d(1), S = null);
      let U = g;
      g = M(z, q), g === U ? ~g && I[g].p(z, q) : (h && (ae(), O(I[U], 1, 1, () => {
        I[U] = null;
      }), ce()), ~g ? (h = I[g], h ? h.p(z, q) : (h = I[g] = D[g](z), h.c()), w(h, 1), h.m(e, null)) : h = null), !/*hideSkillCriticalPrompt*/
      z[11] && /*rollData*/
      z[1].type === "skillCheck" && /*rollData*/
      z[1].skillKey ? L ? L.p(z, q) : (L = v7(z), L.c(), L.m(y.parentNode, y)) : L && (L.d(1), L = null), /*showRollConfig*/
      z[3] ? B ? (B.p(z, q), q & /*showRollConfig*/
      8 && w(B, 1)) : (B = $7(z), B.c(), w(B, 1), B.m(v.parentNode, v)) : B && (ae(), O(B, 1, 1, () => {
        B = null;
      }), ce());
    },
    i(z) {
      k || (w(h), w(B), k = !0);
    },
    o(z) {
      O(h), O(B), k = !1;
    },
    d(z) {
      z && (C(e), C(_), C(y), C(v)), S && S.d(), ~g && I[g].d(), L && L.d(z), B && B.d(z);
    }
  };
}
u(hve, "create_fragment$b");
function gve(i) {
  const e = i.terms.find((t) => t.faces === 20);
  return e ? e.results.some(({ result: t, active: s }) => s && t === 1) : !1;
}
u(gve, "determineIfCriticalFailure");
function bve(i, e, t) {
  let s, n, l, { roll: r } = e, { rollData: o = {} } = e, { isAction: a = !0 } = e;
  function c(M) {
    const L = M.terms.find((B) => B.faces === 20);
    return L ? L.results.some(({ result: B, active: z }) => z && B >= (o.critThreshold ?? 20)) : !1;
  }
  u(c, "determineIfCriticalSuccess");
  function f({ rollMode: M }) {
    return M ? K(M === 1 ? "A5E.RollModeAdvantage" : "A5E.RollModeDisadvantage") : null;
  }
  u(f, "getRollModeLabel");
  function d({ expertiseDice: M }) {
    return M ? K("A5E.ExpertiseDieSpecific", {
      dieSize: _u(M)
    }) : null;
  }
  u(d, "getExpertiseLabel");
  async function p(M, L) {
    var Y, J, fe, ke;
    console.log("Here");
    const B = L === "critical" ? "skillCriticalTables" : "skillFumbleTables", z = (Y = CONFIG.A5E[B]) == null ? void 0 : Y[M], q = await fromUuid(z);
    if (!q) return;
    const U = await q.roll(), H = (J = U == null ? void 0 : U.results) == null ? void 0 : J[0], V = {
      author: (fe = game.user) == null ? void 0 : fe.id,
      speaker: ChatMessage.getSpeaker({ actor: y }),
      rolls: [U.roll],
      system: {
        actorId: y.uuid,
        actorName: y.name,
        description: H == null ? void 0 : H.text,
        img: q == null ? void 0 : q.img,
        tableName: q == null ? void 0 : q.name,
        tableId: q.uuid,
        resultTitle: (ke = H == null ? void 0 : H.flags) == null ? void 0 : ke.title
      },
      type: "rollTableOutput"
    };
    return ChatMessage.applyRollMode(V, game.settings.get("core", "rollMode")), ChatMessage.create(V);
  }
  u(p, "rollOnSkillTable");
  async function m() {
    if (t(3, h = !h), h) {
      const M = [...game.messages ?? []], L = M[M.length - 1];
      l.id === (L == null ? void 0 : L.id) && setTimeout(() => ui.chat.scrollBottom(), 0);
    }
  }
  u(m, "toggleRollConfig");
  let g = game.settings.get("a5e", "hideSkillCriticalPrompt"), h = !1;
  const _ = de("message");
  pe(i, _, (M) => t(6, l = M));
  const y = fromUuidSync(l == null ? void 0 : l.system.actorId), { user: v } = game, k = /* @__PURE__ */ u(() => p(o.skillKey, "critical"), "click_handler"), S = /* @__PURE__ */ u(() => p(o.skillKey, "fumble"), "click_handler_1");
  function D(M) {
    bt.call(this, i, M);
  }
  u(D, "toggleRollMode_handler");
  function I(M) {
    bt.call(this, i, M);
  }
  return u(I, "toggleExpertiseDice_handler"), i.$$set = (M) => {
    "roll" in M && t(0, r = M.roll), "rollData" in M && t(1, o = M.rollData), "isAction" in M && t(2, a = M.isAction);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    1 && t(5, s = gve(r)), i.$$.dirty & /*roll*/
    1 && t(4, n = c(r));
  }, [
    r,
    o,
    a,
    h,
    n,
    s,
    l,
    f,
    d,
    p,
    m,
    g,
    _,
    y,
    v,
    k,
    S,
    D,
    I
  ];
}
u(bve, "instance$a");
const w3 = class w3 extends re {
  constructor(e) {
    super(), oe(this, e, bve, hve, le, { roll: 0, rollData: 1, isAction: 2 });
  }
};
u(w3, "RollSummary");
let Pu = w3;
const { Boolean: wg } = x7;
function A7(i, e, t) {
  const s = i.slice();
  return s[36] = e[t], s;
}
u(A7, "get_each_context$4");
function E7(i, e, t) {
  const s = i.slice();
  return s[39] = e[t], s;
}
u(E7, "get_each_context_1$2");
function S7(i, e, t) {
  const s = i.slice();
  return s[42] = e[t], s;
}
u(S7, "get_each_context_2");
function C7(i, e, t) {
  const s = i.slice();
  return s[45] = e[t][0], s[46] = e[t][1], s[48] = t, s;
}
u(C7, "get_each_context_3");
function T7(i) {
  let e, t;
  return e = new pc({
    props: { summaryData: (
      /*summaryData*/
      i[2]
    ) }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*summaryData*/
      4 && (l.summaryData = /*summaryData*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(T7, "create_if_block_10");
function O7(i) {
  let e, t, s, n, l, r = (
    /*itemDescription*/
    (i[16] || /*unidentifiedDescription*/
    i[17]) && _ve(i)
  ), o = (
    /*actionDescription*/
    i[15] && kve(i)
  );
  return {
    c() {
      e = E("section"), r && r.c(), t = F(), o && o.c(), b(e, "class", "description-block svelte-fab8vp");
    },
    m(a, c) {
      T(a, e, c), r && r.m(e, null), A(e, t), o && o.m(e, null), l = !0;
    },
    p(a, c) {
      /*itemDescription*/
      (a[16] || /*unidentifiedDescription*/
      a[17]) && r.p(a, c), /*actionDescription*/
      a[15] && o.p(a, c);
    },
    i(a) {
      l || (a && ks(() => {
        l && (n && n.end(1), s = og(e, hu, { duration: 150 }), s.start());
      }), l = !0);
    },
    o(a) {
      s && s.invalidate(), a && (n = ag(e, hu, { duration: 150 })), l = !1;
    },
    d(a) {
      a && C(e), r && r.d(), o && o.d(), a && n && n.end();
    }
  };
}
u(O7, "create_if_block_6");
function _ve(i) {
  let e, t, s;
  function n(o, a) {
    var c, f, d;
    return !/*isGM*/
    o[18] && /*item*/
    ((c = o[19]) == null ? void 0 : c.type) === "object" && /*item*/
    ((d = (f = o[19]) == null ? void 0 : f.system) != null && d.unidentified) ? vve : yve;
  }
  u(n, "select_block_type");
  let r = n(i)(i);
  return {
    c() {
      e = E("hr"), t = F(), s = E("div"), r.c(), b(e, "class", "a5e-rule a5e-rule--card");
    },
    m(o, a) {
      T(o, e, a), T(o, t, a), T(o, s, a), r.m(s, null);
    },
    p(o, a) {
      r.p(o, a);
    },
    d(o) {
      o && (C(e), C(t), C(s)), r.d();
    }
  };
}
u(_ve, "create_if_block_8");
function yve(i) {
  let e, t;
  return {
    c() {
      e = new bn(!1), t = $e(), e.a = t;
    },
    m(s, n) {
      e.m(
        /*itemDescription*/
        i[16],
        s,
        n
      ), T(s, t, n);
    },
    p: se,
    d(s) {
      s && (C(t), e.d());
    }
  };
}
u(yve, "create_else_block_1");
function vve(i) {
  let e, t;
  return {
    c() {
      e = new bn(!1), t = $e(), e.a = t;
    },
    m(s, n) {
      e.m(
        /*unidentifiedDescription*/
        i[17],
        s,
        n
      ), T(s, t, n);
    },
    p: se,
    d(s) {
      s && (C(t), e.d());
    }
  };
}
u(vve, "create_if_block_9");
function kve(i) {
  let e, t, s;
  return {
    c() {
      e = E("hr"), t = F(), s = E("div"), b(e, "class", "a5e-rule a5e-rule--card");
    },
    m(n, l) {
      T(n, e, l), T(n, t, l), T(n, s, l), s.innerHTML = /*actionDescription*/
      i[15];
    },
    p: se,
    d(n) {
      n && (C(e), C(t), C(s));
    }
  };
}
u(kve, "create_if_block_7");
function wve(i) {
  let e, t, s, n, l = ue(
    /*rolls*/
    i[22] ?? []
  ), r = [];
  for (let a = 0; a < l.length; a += 1)
    r[a] = D7(C7(i, l, a));
  const o = /* @__PURE__ */ u((a) => O(r[a], 1, 1, () => {
    r[a] = null;
  }), "out");
  return {
    c() {
      e = E("hr"), t = F(), s = E("section");
      for (let a = 0; a < r.length; a += 1)
        r[a].c();
      b(e, "class", "a5e-rule a5e-rule--card"), b(s, "class", "rolls svelte-fab8vp");
    },
    m(a, c) {
      T(a, e, c), T(a, t, c), T(a, s, c);
      for (let f = 0; f < r.length; f += 1)
        r[f] && r[f].m(s, null);
      n = !0;
    },
    p(a, c) {
      if (c[0] & /*rolls, _toggleRollMode, _toggleExpertiseDice*/
      4194352) {
        l = ue(
          /*rolls*/
          a[22] ?? []
        );
        let f;
        for (f = 0; f < l.length; f += 1) {
          const d = C7(a, l, f);
          r[f] ? (r[f].p(d, c), w(r[f], 1)) : (r[f] = D7(d), r[f].c(), w(r[f], 1), r[f].m(s, null));
        }
        for (ae(), f = l.length; f < r.length; f += 1)
          o(f);
        ce();
      }
    },
    i(a) {
      if (!n) {
        for (let c = 0; c < l.length; c += 1)
          w(r[c]);
        n = !0;
      }
    },
    o(a) {
      r = r.filter(wg);
      for (let c = 0; c < r.length; c += 1)
        O(r[c]);
      n = !1;
    },
    d(a) {
      a && (C(e), C(t), C(s)), Le(r, a);
    }
  };
}
u(wve, "create_if_block_3");
function $ve(i) {
  let e, t, s, n, l;
  function r(...c) {
    return (
      /*toggleRollMode_handler*/
      i[29](
        /*i*/
        i[48],
        ...c
      )
    );
  }
  u(r, "toggleRollMode_handler");
  function o(...c) {
    return (
      /*toggleExpertiseDice_handler*/
      i[30](
        /*i*/
        i[48],
        ...c
      )
    );
  }
  u(o, "toggleExpertiseDice_handler"), e = new Pu({
    props: {
      roll: (
        /*roll*/
        i[45]
      ),
      rollData: (
        /*rollData*/
        i[46]
      )
    }
  }), e.$on("toggleRollMode", r), e.$on("toggleExpertiseDice", o);
  let a = (
    /*rolls*/
    i[22].length > 1 && /*rollData*/
    i[46].type === "attack" && Eve()
  );
  return {
    c() {
      t = E("div"), j(e.$$.fragment), s = F(), a && a.c(), n = $e(), G(t, "display", "contents"), G(t, "--a5e-roll-color", Mve(
        /*rollData*/
        i[46]
      ));
    },
    m(c, f) {
      T(c, t, f), R(e, t, null), T(c, s, f), a && a.m(c, f), T(c, n, f), l = !0;
    },
    p(c, f) {
      i = c;
    },
    i(c) {
      l || (w(e.$$.fragment, c), l = !0);
    },
    o(c) {
      O(e.$$.fragment, c), l = !1;
    },
    d(c) {
      c && (C(s), C(n)), c && e && C(t), N(e, c), a && a.d(c);
    }
  };
}
u($ve, "create_else_block");
function Ave(i) {
  return {
    c: se,
    m: se,
    p: se,
    i: se,
    o: se,
    d: se
  };
}
u(Ave, "create_if_block_4");
function Eve(i) {
  let e;
  return {
    c() {
      e = E("hr"), b(e, "class", "a5e-rule");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && C(e);
    }
  };
}
u(Eve, "create_if_block_5");
function D7(i) {
  let e, t, s, n;
  const l = [Ave, $ve], r = [];
  function o(a, c) {
    var f, d;
    return (
      /*rollData*/
      ((d = (f = a[46]) == null ? void 0 : f.baseRoll) == null ? void 0 : d.formula) === "0" && /*roll*/
      a[45]._formula === "0" ? 0 : 1
    );
  }
  return u(o, "select_block_type_1"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      t.p(a, c);
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      O(t), n = !1;
    },
    d(a) {
      a && C(s), r[e].d(a);
    }
  };
}
u(D7, "create_each_block_3");
function Sve(i) {
  let e, t, s, n, l = ue(
    /*promptTypes*/
    i[11]
  ), r = [];
  for (let a = 0; a < l.length; a += 1)
    r[a] = P7(E7(i, l, a));
  const o = /* @__PURE__ */ u((a) => O(r[a], 1, 1, () => {
    r[a] = null;
  }), "out");
  return {
    c() {
      e = E("hr"), t = F(), s = E("section");
      for (let a = 0; a < r.length; a += 1)
        r[a].c();
      b(e, "class", "a5e-rule a5e-rule--card"), b(s, "class", "prompts svelte-fab8vp");
    },
    m(a, c) {
      T(a, e, c), T(a, t, c), T(a, s, c);
      for (let f = 0; f < r.length; f += 1)
        r[f] && r[f].m(s, null);
      n = !0;
    },
    p(a, c) {
      if (c[0] & /*prompts, promptTypes, $message, triggerPrompt, hoverColor*/
      1050697) {
        l = ue(
          /*promptTypes*/
          a[11]
        );
        let f;
        for (f = 0; f < l.length; f += 1) {
          const d = E7(a, l, f);
          r[f] ? (r[f].p(d, c), w(r[f], 1)) : (r[f] = P7(d), r[f].c(), w(r[f], 1), r[f].m(s, null));
        }
        for (ae(), f = l.length; f < r.length; f += 1)
          o(f);
        ce();
      }
    },
    i(a) {
      if (!n) {
        for (let c = 0; c < l.length; c += 1)
          w(r[c]);
        n = !0;
      }
    },
    o(a) {
      r = r.filter(wg);
      for (let c = 0; c < r.length; c += 1)
        O(r[c]);
      n = !1;
    },
    d(a) {
      a && (C(e), C(t), C(s)), Le(r, a);
    }
  };
}
u(Sve, "create_if_block_1");
function Cve(i) {
  let e, t, s, n = ue(
    /*prompts*/
    i[20][
      /*promptType*/
      i[39]
    ]
  ), l = [];
  for (let o = 0; o < n.length; o += 1)
    l[o] = I7(S7(i, n, o));
  const r = /* @__PURE__ */ u((o) => O(l[o], 1, 1, () => {
    l[o] = null;
  }), "out");
  return {
    c() {
      e = E("section");
      for (let o = 0; o < l.length; o += 1)
        l[o].c();
      t = F(), b(e, "class", "prompt-button-wrapper svelte-fab8vp");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < l.length; c += 1)
        l[c] && l[c].m(e, null);
      A(e, t), s = !0;
    },
    p(o, a) {
      if (a[0] & /*prompts, promptTypes, $message, triggerPrompt, hoverColor*/
      1050697) {
        n = ue(
          /*prompts*/
          o[20][
            /*promptType*/
            o[39]
          ]
        );
        let c;
        for (c = 0; c < n.length; c += 1) {
          const f = S7(o, n, c);
          l[c] ? (l[c].p(f, a), w(l[c], 1)) : (l[c] = I7(f), l[c].c(), w(l[c], 1), l[c].m(e, t));
        }
        for (ae(), c = n.length; c < l.length; c += 1)
          r(c);
        ce();
      }
    },
    i(o) {
      if (!s) {
        for (let a = 0; a < n.length; a += 1)
          w(l[a]);
        s = !0;
      }
    },
    o(o) {
      l = l.filter(wg);
      for (let a = 0; a < l.length; a += 1)
        O(l[a]);
      s = !1;
    },
    d(o) {
      o && C(e), Le(l, o);
    }
  };
}
u(Cve, "create_if_block_2");
function I7(i) {
  var l;
  let e, t, s;
  function n() {
    return (
      /*triggerPrompt_handler*/
      i[31](
        /*prompt*/
        i[42]
      )
    );
  }
  return u(n, "triggerPrompt_handler"), e = new im({
    props: {
      prompt: (
        /*prompt*/
        i[42]
      ),
      title: o7(
        /*prompt*/
        i[42],
        /*$message*/
        (l = i[0]) == null ? void 0 : l.system.actorId
      ),
      subtitle: V0e(
        /*prompt*/
        i[42]
      )
    }
  }), e.$on("triggerPrompt", n), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(
        t,
        "--hover-color",
        /*hoverColor*/
        i[3]
      );
    },
    m(r, o) {
      T(r, t, o), R(e, t, null), s = !0;
    },
    p(r, o) {
      var c;
      i = r, o[0] & /*hoverColor*/
      8 && G(
        t,
        "--hover-color",
        /*hoverColor*/
        i[3]
      );
      const a = {};
      o[0] & /*$message*/
      1 && (a.title = o7(
        /*prompt*/
        i[42],
        /*$message*/
        (c = i[0]) == null ? void 0 : c.system.actorId
      )), e.$set(a);
    },
    i(r) {
      s || (w(e.$$.fragment, r), s = !0);
    },
    o(r) {
      O(e.$$.fragment, r), s = !1;
    },
    d(r) {
      r && e && C(t), N(e, r);
    }
  };
}
u(I7, "create_each_block_2");
function P7(i) {
  var n;
  let e, t, s = (
    /*prompts*/
    ((n = i[20][
      /*promptType*/
      i[39]
    ]) == null ? void 0 : n.length) && Cve(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(l, r) {
      s && s.m(l, r), T(l, e, r), t = !0;
    },
    p(l, r) {
      var o;
      /*prompts*/
      (o = l[20][
        /*promptType*/
        l[39]
      ]) != null && o.length && s.p(l, r);
    },
    i(l) {
      t || (w(s), t = !0);
    },
    o(l) {
      O(s), t = !1;
    },
    d(l) {
      l && C(e), s && s.d(l);
    }
  };
}
u(P7, "create_each_block_1$2");
function Tve(i) {
  let e, t, s = ue(
    /*effects*/
    i[24]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = M7(A7(i, s, r));
  const l = /* @__PURE__ */ u((r) => O(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o[0] & /*effects, triggerEffect, hoverColor*/
      16777352) {
        s = ue(
          /*effects*/
          r[24]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = A7(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = M7(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ae(), a = s.length; a < n.length; a += 1)
          l(a);
        ce();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(wg);
      for (let o = 0; o < n.length; o += 1)
        O(n[o]);
      t = !1;
    },
    d(r) {
      r && C(e), Le(n, r);
    }
  };
}
u(Tve, "create_if_block");
function M7(i) {
  let e, t, s;
  function n() {
    return (
      /*triggerPrompt_handler_1*/
      i[32](
        /*effect*/
        i[36]
      )
    );
  }
  return u(n, "triggerPrompt_handler_1"), e = new im({
    props: {
      prompt: { type: "effect" },
      icon: Ive(
        /*effect*/
        i[36]
      ),
      title: (
        /*effect*/
        i[36].name
      ),
      subtitle: "Apply Effect"
    }
  }), e.$on("triggerPrompt", n), {
    c() {
      t = E("div"), j(e.$$.fragment), G(t, "display", "contents"), G(
        t,
        "--hover-color",
        /*hoverColor*/
        i[3]
      );
    },
    m(l, r) {
      T(l, t, r), R(e, t, null), s = !0;
    },
    p(l, r) {
      i = l, r[0] & /*hoverColor*/
      8 && G(
        t,
        "--hover-color",
        /*hoverColor*/
        i[3]
      );
    },
    i(l) {
      s || (w(e.$$.fragment, l), s = !0);
    },
    o(l) {
      O(e.$$.fragment, l), s = !1;
    },
    d(l) {
      l && e && C(t), N(e, l);
    }
  };
}
u(M7, "create_each_block$4");
function Ove(i) {
  let e, t, s, n = Object.values(
    /*summaryData*/
    i[2] ?? {}
  ).some(Boolean), l, r, o, a, c;
  e = new u5({
    props: {
      actorName: (
        /*actorName*/
        i[13]
      ),
      img: (
        /*img*/
        i[14]
      ),
      messageDocument: (
        /*$message*/
        i[0]
      ),
      subtitle: Dve(
        /*actorName*/
        i[13],
        /*actionName*/
        i[12]
      )
    }
  }), e.$on(
    "repeatCard",
    /*repeatRoll*/
    i[9]
  ), e.$on(
    "toggleDescription",
    /*toggleDescription_handler*/
    i[28]
  ), e.$on(
    "toggleCriticalDamage",
    /*toggleCriticalDamage*/
    i[8]
  );
  let f = n && T7(i), d = (
    /*itemDescription*/
    (i[16] || /*unidentifiedDescription*/
    i[17] || /*actionDescription*/
    i[15]) && !/*hideDescription*/
    i[1] && O7(i)
  ), p = (
    /*hasRolls*/
    i[23] && wve(i)
  ), m = (
    /*hasPrompts*/
    i[21] && Sve(i)
  ), g = (
    /*hasEffects*/
    i[25] && Tve(i)
  );
  return {
    c() {
      j(e.$$.fragment), t = F(), s = E("article"), f && f.c(), l = F(), d && d.c(), r = F(), p && p.c(), o = F(), m && m.c(), a = F(), g && g.c(), b(s, "class", "a5e-chat-card__body svelte-fab8vp");
    },
    m(h, _) {
      R(e, h, _), T(h, t, _), T(h, s, _), f && f.m(s, null), A(s, l), d && d.m(s, null), A(s, r), p && p.m(s, null), A(s, o), m && m.m(s, null), A(s, a), g && g.m(s, null), c = !0;
    },
    p(h, _) {
      const y = {};
      _[0] & /*$message*/
      1 && (y.messageDocument = /*$message*/
      h[0]), e.$set(y), _[0] & /*summaryData*/
      4 && (n = Object.values(
        /*summaryData*/
        h[2] ?? {}
      ).some(Boolean)), n ? f ? (f.p(h, _), _[0] & /*summaryData*/
      4 && w(f, 1)) : (f = T7(h), f.c(), w(f, 1), f.m(s, l)) : f && (ae(), O(f, 1, 1, () => {
        f = null;
      }), ce()), /*itemDescription*/
      (h[16] || /*unidentifiedDescription*/
      h[17] || /*actionDescription*/
      h[15]) && !/*hideDescription*/
      h[1] ? d ? (d.p(h, _), _[0] & /*hideDescription*/
      2 && w(d, 1)) : (d = O7(h), d.c(), w(d, 1), d.m(s, r)) : d && (ae(), O(d, 1, 1, () => {
        d = null;
      }), ce()), /*hasRolls*/
      h[23] && p.p(h, _), /*hasPrompts*/
      h[21] && m.p(h, _), /*hasEffects*/
      h[25] && g.p(h, _);
    },
    i(h) {
      c || (w(e.$$.fragment, h), w(f), w(d), w(p), w(m), w(g), c = !0);
    },
    o(h) {
      O(e.$$.fragment, h), O(f), O(d), O(p), O(m), O(g), c = !1;
    },
    d(h) {
      h && (C(t), C(s)), N(e, h), f && f.d(), d && d.d(), p && p.d(), m && m.d(), g && g.d();
    }
  };
}
u(Ove, "create_fragment$a");
function Dve(i, e) {
  return !e || typeof e != "string" || i.trim() === e.trim() ? null : e;
}
u(Dve, "getSubtitle");
function Ive(i) {
  return (i == null ? void 0 : i.img) ?? "icons/svg/hazard.svg";
}
u(Ive, "getEffectIcon");
function Pve(i) {
  return i.Shift ? "#2b6537" : i.Control ? "var(--a5e-color-error)" : "var(--a5e-color-text-dark)";
}
u(Pve, "getHoverColor");
function Mve(i) {
  var s;
  if (!((s = game.settings) != null && s.get("a5e", "enableDamageRollColors"))) return null;
  const { damageColors: e, healingColors: t } = CONFIG.A5E;
  return i.type === "damage" ? e[i.damageType] : i.type === "healing" ? t[i.healingType] : null;
}
u(Mve, "prepareRollColor");
async function Fve(i, e, t) {
  i.forEach((s) => {
    s.rollAbilityCheck(e.ability, t);
  });
}
u(Fve, "triggerAbilityCheckPrompt");
async function Rve(i, e, t) {
  i.forEach((s) => {
    s.rollSavingThrow(e.ability, t);
  });
}
u(Rve, "triggerSavingThrowPrompt");
async function Nve(i, e, t) {
  i.forEach((s) => {
    s.rollSkillCheck(e.skill, { abilityKey: e.ability, ...t });
  });
}
u(Nve, "triggerSkillCheckPrompt");
function jve(i, e, t) {
  let s, n, l, r;
  pe(i, Ml, (ye) => t(27, r = ye));
  let { messageDocument: o } = e;
  async function a(ye, me) {
    Sq(l, H, ye, me);
  }
  u(a, "_toggleExpertiseDice");
  async function c(ye, me) {
    const [, Ce] = H[ye];
    Cq(l, H, ye, me), Ce.type === "attack" && m();
  }
  u(c, "_toggleRollMode");
  async function f(ye) {
    const me = c7(), Ce = ql(r);
    if (!me.length) {
      ui.notifications.warn("No tokens selected");
      return;
    }
    ye.type === "abilityCheck" ? await Fve(me, ye, Ce) : ye.type === "savingThrow" ? await Rve(me, ye, Ce) : ye.type === "skillCheck" ? await Nve(me, ye, Ce) : ye.type === "generic" && await p(me, ye);
  }
  u(f, "triggerPrompt");
  async function d(ye) {
    const me = c7();
    if (!me.length) {
      ui.notifications.warn("No tokens selected");
      return;
    }
    me.forEach((Ce) => {
      ye.transferEffect(Ce);
    });
  }
  u(d, "triggerEffect");
  async function p(ye, me) {
    for (const Ce of ye) {
      const { rollFormula: Je } = Gc({
        actor: Ce,
        formula: me.formula,
        item: z
      });
      await new Roll(Je).toMessage({ async: !0 });
    }
  }
  u(p, "triggerGenericRollPrompt");
  function m() {
    const ye = nm(l.rolls, l.system.rollData).some(([me, Ce]) => {
      if (Ce.type !== "attack") return !1;
      const Je = me.terms.find((Ne) => Ne.faces === 20);
      return Je ? Je.results.some(({ result: Ne, active: Re }) => Re && Ne >= (Ce.critThreshold ?? 20)) : !1;
    });
    ye != null && g(ye ? 1 : 0);
  }
  u(m, "reevaluateCritMode");
  function g(ye) {
    const me = nm(l.rolls, l.system.rollData).map(([Ce, Je]) => Je.type !== "damage" || !Je.canCrit || !Je.critRoll || !Je.baseRoll ? Ce : ye === 1 ? Roll.fromData(Je.critRoll) : ye === 0 ? Roll.fromData(Je.baseRoll) : Je.baseRoll.formula === Ce.formula ? Roll.fromData(Je.critRoll) : Roll.fromData(Je.baseRoll));
    l.update({ rolls: me });
  }
  u(g, "toggleCriticalDamage");
  function h() {
    const ye = fromUuidSync(l.system.itemId), me = l.system.actionId ?? null;
    ye.activate(me);
  }
  u(h, "repeatRoll");
  const _ = new Zt(o);
  pe(i, _, (ye) => t(0, l = ye));
  const { system: y } = l, v = ["abilityCheck", "savingThrow", "skillCheck", "generic", "effect"], { actionName: k, actorName: S, img: D } = y, { actionDescription: I, itemDescription: M, unidentifiedDescription: L } = y, { isGM: B } = game.user, z = fromUuidSync(l.system.itemId ?? ""), q = W0e(l), U = Object.values(q).flat().length, H = J5(l), V = H.length, Y = y.effects.map((ye) => z.effects.get(ye)), J = !!Y.length;
  let fe = game.settings.get("a5e", "hideChatDescriptionsByDefault") ?? !1;
  lt("message", _);
  const ke = /* @__PURE__ */ u(() => t(1, fe = !fe), "toggleDescription_handler"), ee = /* @__PURE__ */ u((ye, { detail: me }) => c(ye, me), "toggleRollMode_handler"), ne = /* @__PURE__ */ u((ye, { detail: me }) => a(ye, me), "toggleExpertiseDice_handler"), Ee = /* @__PURE__ */ u((ye) => f(ye), "triggerPrompt_handler"), Pe = /* @__PURE__ */ u((ye) => d(ye), "triggerPrompt_handler_1");
  return i.$$set = (ye) => {
    "messageDocument" in ye && t(26, o = ye.messageDocument);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*$pressedKeysStore*/
    134217728 && t(3, s = Pve(r)), i.$$.dirty[0] & /*$message*/
    1 && t(2, n = l.system.summaryData);
  }, [
    l,
    fe,
    n,
    s,
    a,
    c,
    f,
    d,
    g,
    h,
    _,
    v,
    k,
    S,
    D,
    I,
    M,
    L,
    B,
    z,
    q,
    U,
    H,
    V,
    Y,
    J,
    o,
    r,
    ke,
    ee,
    ne,
    Ee,
    Pe
  ];
}
u(jve, "instance$9");
const $3 = class $3 extends re {
  constructor(e) {
    super(), oe(this, e, jve, Ove, le, { messageDocument: 26 }, null, [-1, -1]);
  }
  get messageDocument() {
    return this.$$.ctx[26];
  }
  set messageDocument(e) {
    this.$$set({ messageDocument: e }), Xe();
  }
};
u($3, "ItemCard");
let p5 = $3;
function Lve(i) {
  let e, t, s, n, l, r, o, a, c = (
    /*timeSince*/
    i[5](
      /*messageDocument*/
      i[2].timestamp
    ) + ""
  ), f, d, p, m, g, h, _, y;
  return {
    c() {
      e = E("header"), t = E("img"), n = F(), l = E("span"), r = Q(
        /*actorName*/
        i[0]
      ), o = F(), a = E("time"), f = Q(c), d = F(), p = E("span"), m = E("button"), g = F(), h = E("a"), h.innerHTML = '<i class="fas fa-trash"></i>', b(t, "class", "a5e-chat-card__header__img"), ze(t.src, s = /*img*/
      i[1]) || b(t, "src", s), b(
        t,
        "alt",
        /*actorName*/
        i[0]
      ), b(l, "class", "a5e-chat-card__header__title"), b(a, "class", "message-timestamp a5e-chat-card__header__time"), b(m, "class", "a5e-chat-card__header__button--repeat fas fa-undo"), b(m, "data-tooltip", "Repeat Roll"), b(m, "data-tooltip-direction", "LEFT"), b(h, "aria-label", "Delete"), b(h, "class", "message-delete a5e-chat-card__header__button--delete svelte-1p6si2m"), b(p, "class", "a5e-chat-card__header__buttons"), b(e, "class", "a5e-chat-card__header a5e-chat-card__header--roll"), G(
        e,
        "--a5e-user-background-color",
        /*headerBackgroundColor*/
        i[3]
      ), G(
        e,
        "--a5e-user-text-color",
        /*headerTextColor*/
        i[4]
      );
    },
    m(v, k) {
      T(v, e, k), A(e, t), A(e, n), A(e, l), A(l, r), A(e, o), A(e, a), A(a, f), A(e, d), A(e, p), A(p, m), A(p, g), A(p, h), _ || (y = W(
        m,
        "click",
        /*click_handler*/
        i[7]
      ), _ = !0);
    },
    p(v, [k]) {
      k & /*img*/
      2 && !ze(t.src, s = /*img*/
      v[1]) && b(t, "src", s), k & /*actorName*/
      1 && b(
        t,
        "alt",
        /*actorName*/
        v[0]
      ), k & /*actorName*/
      1 && be(
        r,
        /*actorName*/
        v[0]
      ), k & /*messageDocument*/
      4 && c !== (c = /*timeSince*/
      v[5](
        /*messageDocument*/
        v[2].timestamp
      ) + "") && be(f, c);
    },
    i: se,
    o: se,
    d(v) {
      v && C(e), _ = !1, y();
    }
  };
}
u(Lve, "create_fragment$9");
function Bve(i, e, t) {
  let { actorName: s } = e, { img: n } = e, { messageDocument: l } = e;
  const r = l.author.color, o = Z5(r), { timeSince: a } = foundry.utils, c = ft(), f = /* @__PURE__ */ u(() => c("repeatCard"), "click_handler");
  return i.$$set = (d) => {
    "actorName" in d && t(0, s = d.actorName), "img" in d && t(1, n = d.img), "messageDocument" in d && t(2, l = d.messageDocument);
  }, [
    s,
    n,
    l,
    r,
    o,
    a,
    c,
    f
  ];
}
u(Bve, "instance$8");
const A3 = class A3 extends re {
  constructor(e) {
    super(), oe(this, e, Bve, Lve, le, { actorName: 0, img: 1, messageDocument: 2 });
  }
};
u(A3, "RollCardHeader");
let m5 = A3;
function F7(i, e, t) {
  const s = i.slice();
  return s[12] = e[t][0], s[13] = e[t][1], s[15] = t, s;
}
u(F7, "get_each_context$3");
function R7(i) {
  let e, t;
  function s(...l) {
    return (
      /*toggleRollMode_handler*/
      i[9](
        /*i*/
        i[15],
        ...l
      )
    );
  }
  u(s, "toggleRollMode_handler");
  function n(...l) {
    return (
      /*toggleExpertiseDice_handler*/
      i[10](
        /*i*/
        i[15],
        ...l
      )
    );
  }
  return u(n, "toggleExpertiseDice_handler"), e = new Pu({
    props: {
      roll: (
        /*roll*/
        i[12]
      ),
      rollData: (
        /*rollData*/
        i[13]
      )
    }
  }), e.$on("toggleRollMode", s), e.$on("toggleExpertiseDice", n), {
    c() {
      j(e.$$.fragment);
    },
    m(l, r) {
      R(e, l, r), t = !0;
    },
    p(l, r) {
      i = l;
    },
    i(l) {
      t || (w(e.$$.fragment, l), t = !0);
    },
    o(l) {
      O(e.$$.fragment, l), t = !1;
    },
    d(l) {
      N(e, l);
    }
  };
}
u(R7, "create_each_block$3");
function qve(i) {
  let e, t, s, n, l;
  e = new m5({
    props: {
      actorName: (
        /*actorName*/
        i[5]
      ),
      img: (
        /*img*/
        i[6]
      ),
      messageDocument: (
        /*$message*/
        i[0]
      )
    }
  }), e.$on(
    "repeatCard",
    /*repeatRoll*/
    i[1]
  );
  let r = ue(
    /*rolls*/
    i[7] ?? []
  ), o = [];
  for (let c = 0; c < r.length; c += 1)
    o[c] = R7(F7(i, r, c));
  const a = /* @__PURE__ */ u((c) => O(o[c], 1, 1, () => {
    o[c] = null;
  }), "out");
  return {
    c() {
      j(e.$$.fragment), t = F(), s = E("article"), n = E("section");
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      b(n, "class", "rolls"), b(s, "class", "a5e-chat-card__body");
    },
    m(c, f) {
      R(e, c, f), T(c, t, f), T(c, s, f), A(s, n);
      for (let d = 0; d < o.length; d += 1)
        o[d] && o[d].m(n, null);
      l = !0;
    },
    p(c, [f]) {
      const d = {};
      if (f & /*$message*/
      1 && (d.messageDocument = /*$message*/
      c[0]), e.$set(d), f & /*rolls, _toggleRollMode, _toggleExpertiseDice*/
      140) {
        r = ue(
          /*rolls*/
          c[7] ?? []
        );
        let p;
        for (p = 0; p < r.length; p += 1) {
          const m = F7(c, r, p);
          o[p] ? (o[p].p(m, f), w(o[p], 1)) : (o[p] = R7(m), o[p].c(), w(o[p], 1), o[p].m(n, null));
        }
        for (ae(), p = r.length; p < o.length; p += 1)
          a(p);
        ce();
      }
    },
    i(c) {
      if (!l) {
        w(e.$$.fragment, c);
        for (let f = 0; f < r.length; f += 1)
          w(o[f]);
        l = !0;
      }
    },
    o(c) {
      O(e.$$.fragment, c), o = o.filter(Boolean);
      for (let f = 0; f < o.length; f += 1)
        O(o[f]);
      l = !1;
    },
    d(c) {
      c && (C(t), C(s)), N(e, c), Le(o, c);
    }
  };
}
u(qve, "create_fragment$8");
function Gve(i, e, t) {
  let s, { messageDocument: n } = e;
  async function l() {
    const h = await Promise.all(s.rolls.map((y) => new Roll(y.formula).roll())), _ = {
      author: s == null ? void 0 : s.author,
      speaker: s.speaker,
      sound: s.sound,
      rolls: h,
      rollMode: s.rollMode,
      system: {
        actorId: s.system.actorId,
        actorName: s.system.actorName,
        img: s.system.img,
        rollData: foundry.utils.duplicate(s.system.rollData),
        rollType: s.system.rollType
      },
      type: "roll"
    };
    ChatMessage.applyRollMode(_, s.rollMode), await ChatMessage.create(_);
  }
  u(l, "repeatRoll");
  function r(h, _) {
    Sq(s, p, h, _);
  }
  u(r, "_toggleExpertiseDice");
  async function o(h, _) {
    Cq(s, p, h, _);
  }
  u(o, "_toggleRollMode");
  const a = new Zt(n);
  pe(i, a, (h) => t(0, s = h));
  const { system: c } = s, { actorName: f, img: d } = c, p = J5(s);
  lt("message", a);
  const m = /* @__PURE__ */ u((h, { detail: _ }) => o(h, _), "toggleRollMode_handler"), g = /* @__PURE__ */ u((h, { detail: _ }) => r(h, _), "toggleExpertiseDice_handler");
  return i.$$set = (h) => {
    "messageDocument" in h && t(8, n = h.messageDocument);
  }, [
    s,
    l,
    r,
    o,
    a,
    f,
    d,
    p,
    n,
    m,
    g
  ];
}
u(Gve, "instance$7");
const E3 = class E3 extends re {
  constructor(e) {
    super(), oe(this, e, Gve, qve, le, { messageDocument: 8 });
  }
  get messageDocument() {
    return this.$$.ctx[8];
  }
  set messageDocument(e) {
    this.$$set({ messageDocument: e }), Xe();
  }
};
u(E3, "RollCard");
let h5 = E3;
function zve(i) {
  let e, t, s, n, l, r, o, a, c = (
    /*timeSince*/
    i[5](
      /*messageDocument*/
      i[2].timestamp
    ) + ""
  ), f, d, p;
  return {
    c() {
      e = E("header"), t = E("img"), n = F(), l = E("span"), r = Q(
        /*tableName*/
        i[0]
      ), o = F(), a = E("time"), f = Q(c), d = F(), p = E("span"), p.innerHTML = '<a aria-label="Delete" class="message-delete a5e-chat-card__header__button--delete svelte-1p6si2m"><i class="fas fa-trash"></i></a>', b(t, "class", "a5e-chat-card__header__img"), ze(t.src, s = /*img*/
      i[1]) || b(t, "src", s), b(
        t,
        "alt",
        /*tableName*/
        i[0]
      ), b(l, "class", "a5e-chat-card__header__title"), b(a, "class", "message-timestamp a5e-chat-card__header__time"), b(p, "class", "a5e-chat-card__header__buttons"), b(e, "class", "a5e-chat-card__header a5e-chat-card__header--roll"), G(
        e,
        "--a5e-user-background-color",
        /*headerBackgroundColor*/
        i[3]
      ), G(
        e,
        "--a5e-user-text-color",
        /*headerTextColor*/
        i[4]
      );
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(e, n), A(e, l), A(l, r), A(e, o), A(e, a), A(a, f), A(e, d), A(e, p);
    },
    p(m, [g]) {
      g & /*img*/
      2 && !ze(t.src, s = /*img*/
      m[1]) && b(t, "src", s), g & /*tableName*/
      1 && b(
        t,
        "alt",
        /*tableName*/
        m[0]
      ), g & /*tableName*/
      1 && be(
        r,
        /*tableName*/
        m[0]
      ), g & /*messageDocument*/
      4 && c !== (c = /*timeSince*/
      m[5](
        /*messageDocument*/
        m[2].timestamp
      ) + "") && be(f, c);
    },
    i: se,
    o: se,
    d(m) {
      m && C(e);
    }
  };
}
u(zve, "create_fragment$7");
function Hve(i, e, t) {
  let { tableName: s } = e, { img: n } = e, { messageDocument: l } = e;
  const r = l.author.color, o = Z5(r), { timeSince: a } = foundry.utils;
  return i.$$set = (c) => {
    "tableName" in c && t(0, s = c.tableName), "img" in c && t(1, n = c.img), "messageDocument" in c && t(2, l = c.messageDocument);
  }, [
    s,
    n,
    l,
    r,
    o,
    a
  ];
}
u(Hve, "instance$6");
const S3 = class S3 extends re {
  constructor(e) {
    super(), oe(this, e, Hve, zve, le, { tableName: 0, img: 1, messageDocument: 2 });
  }
};
u(S3, "RollTableCardHeader");
let g5 = S3;
function N7(i, e, t) {
  const s = i.slice();
  return s[10] = e[t][0], s[11] = e[t][1], s[13] = t, s;
}
u(N7, "get_each_context$2");
function j7(i) {
  let e, t;
  return e = new Pu({
    props: {
      roll: (
        /*roll*/
        i[10]
      ),
      rollData: (
        /*rollData*/
        i[11]
      )
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p: se,
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(j7, "create_each_block$2");
function Uve(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m;
  e = new g5({
    props: {
      tableName: (
        /*tableName*/
        i[2]
      ),
      img: (
        /*img*/
        i[4]
      ),
      messageDocument: (
        /*$message*/
        i[0]
      )
    }
  });
  let g = ue(
    /*rolls*/
    i[6] ?? []
  ), h = [];
  for (let y = 0; y < g.length; y += 1)
    h[y] = j7(N7(i, g, y));
  const _ = /* @__PURE__ */ u((y) => O(h[y], 1, 1, () => {
    h[y] = null;
  }), "out");
  return {
    c() {
      j(e.$$.fragment), t = F(), s = E("article"), n = E("h3"), n.textContent = `${/*resultTitle*/
      i[3]}`, l = F(), r = E("hr"), o = F(), a = E("section"), c = F(), f = E("hr"), d = F(), p = E("section");
      for (let y = 0; y < h.length; y += 1)
        h[y].c();
      b(n, "class", " svelte-6qd4vi"), b(r, "class", "a5e-rule a5e-rule--card"), b(a, "class", "description-block svelte-6qd4vi"), b(f, "class", "a5e-rule a5e-rule--card"), b(p, "class", "rolls svelte-6qd4vi"), b(s, "class", "a5e-chat-card__body");
    },
    m(y, v) {
      R(e, y, v), T(y, t, v), T(y, s, v), A(s, n), A(s, l), A(s, r), A(s, o), A(s, a), a.innerHTML = /*description*/
      i[5], A(s, c), A(s, f), A(s, d), A(s, p);
      for (let k = 0; k < h.length; k += 1)
        h[k] && h[k].m(p, null);
      m = !0;
    },
    p(y, [v]) {
      const k = {};
      if (v & /*$message*/
      1 && (k.messageDocument = /*$message*/
      y[0]), e.$set(k), v & /*rolls*/
      64) {
        g = ue(
          /*rolls*/
          y[6] ?? []
        );
        let S;
        for (S = 0; S < g.length; S += 1) {
          const D = N7(y, g, S);
          h[S] ? (h[S].p(D, v), w(h[S], 1)) : (h[S] = j7(D), h[S].c(), w(h[S], 1), h[S].m(p, null));
        }
        for (ae(), S = g.length; S < h.length; S += 1)
          _(S);
        ce();
      }
    },
    i(y) {
      if (!m) {
        w(e.$$.fragment, y);
        for (let v = 0; v < g.length; v += 1)
          w(h[v]);
        m = !0;
      }
    },
    o(y) {
      O(e.$$.fragment, y), h = h.filter(Boolean);
      for (let v = 0; v < h.length; v += 1)
        O(h[v]);
      m = !1;
    },
    d(y) {
      y && (C(t), C(s)), N(e, y), Le(h, y);
    }
  };
}
u(Uve, "create_fragment$6");
function Vve(i, e, t) {
  let s, { messageDocument: n } = e;
  const l = new Zt(n);
  pe(i, l, (m) => t(0, s = m));
  const { system: r } = s, { tableName: o, tableId: a, resultTitle: c, img: f, description: d } = r, p = J5(s);
  return lt("message", l), i.$$set = (m) => {
    "messageDocument" in m && t(7, n = m.messageDocument);
  }, [
    s,
    l,
    o,
    c,
    f,
    d,
    p,
    n
  ];
}
u(Vve, "instance$5");
const C3 = class C3 extends re {
  constructor(e) {
    super(), oe(this, e, Vve, Uve, le, { messageDocument: 7 });
  }
  get messageDocument() {
    return this.$$.ctx[7];
  }
  set messageDocument(e) {
    this.$$set({ messageDocument: e }), Xe();
  }
};
u(C3, "RollTableCard");
let b5 = C3;
function Wve(i, e) {
  var n, l;
  let t;
  const s = $(e)[0];
  if (s) {
    switch (i.type) {
      case "item":
        t = p5;
        break;
      case "roll":
        t = h5;
        break;
      case "rollTableOutput":
        t = b5;
        break;
      default:
        return;
    }
    s.classList.add("a5e-chat-card"), (n = $(e).find(".message-header")[0]) == null || n.remove(), (l = $(e).find(".message-content")[0]) == null || l.remove(), i._svelteComponent = new t({
      target: s,
      props: { messageDocument: i }
    });
  }
}
u(Wve, "renderChatMessage");
function Kve(i) {
  let e;
  return {
    c() {
      e = E("article"), e.innerHTML = `<h3>Community Discord Server</h3> <p>The best way to get support is to <a href="https://discord.gg/XtkZ6RkN9E" target="_blank">join our Discord server</a>. We have a very friendly community with lots of experienced users who can
            provide live support should you need any help. We also have dedicated channels
            for filing issue reports or submitting feature requests.</p> <p>Our Discord server is also home to most of the Level Up third-party
            publishers, and we make regular posts showcasing new official and third-party
            releases in the announcements channel.</p> <h3>GitHub</h3> <p>If you&#39;re not into Discord, you can also submit issue reports and feature
            requests on <a href="https://github.com/Pjb518/FoundryVTT-Level-Up-Official" target="_blank">the system&#39;s GitHub repository</a>. We check these tickets very frequently, but you&#39;re not typically going to
            get a response as quickly as you would on Discord.</p>`, b(e, "class", "svelte-13s087w");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: se,
    d(t) {
      t && C(e);
    }
  };
}
u(Kve, "create_default_slot$2");
function Yve(i) {
  let e, t, s;
  function n(r) {
    i[1](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Kve] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope*/
        4 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(Yve, "create_fragment$5");
function Xve(i, e, t) {
  let { elementRoot: s } = e;
  function n(l) {
    s = l, t(0, s);
  }
  return u(n, "applicationshell_elementRoot_binding"), i.$$set = (l) => {
    "elementRoot" in l && t(0, s = l.elementRoot);
  }, [s, n];
}
u(Xve, "instance$4");
var nc;
let Jve = (nc = class extends re {
  constructor(e) {
    super(), oe(this, e, Xve, Yve, le, { elementRoot: 0 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
}, u(nc, "HelpAndSupportDialog"), nc);
const T3 = class T3 extends Gs {
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/Application.html#options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: "Help and Support",
      height: "auto",
      width: 400,
      classes: ["a5e-help-and-support-dialog"],
      resizable: !0,
      svelte: {
        class: Jve,
        target: document.body
      }
    });
  }
};
u(T3, "HelpAndSupportDialog");
let _5 = T3;
function Zve(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h;
  return {
    c() {
      e = E("p"), e.innerHTML = `There is a <a href="https://preview.drivethrurpg.com/en/browse?ruleSystem=1000104&amp;?affiliate_id=1388381" target="_blank">huge amount of 3PP material available for A5e</a>, and we&#39;ve worked hard to forge relationships with third-party publishers
    to ensure that all of this great content is supported in the A5e system.
    Much of it is even included in the system by default.`, t = F(), s = E("p"), n = Q(`For content that isn't integrated into the system, we provide modules that
    are either sold by the publisher as standalone products or included for free
    when you purchase the original content. We've provided a handy list of these
    products in the `), l = E("button"), l.textContent = "Premium Content", r = Q(`
    tab. You can also find a list of all the modules available for A5e, both free
    and premium, on
    `), o = E("a"), o.textContent = "our GitHub repository", a = Q("."), c = F(), f = E("p"), d = Q(`We've also started producing exclusive modules for our Patreon supporters.
    You can find more information about this in the `), p = E("button"), p.textContent = "Patreon Exclusive", m = Q(" tab."), b(l, "class", "false-link svelte-h429by"), b(o, "href", "https://github.com/Pjb518/FoundryVTT-Level-Up-Official/wiki/Modules"), b(o, "target", "_blank"), b(p, "class", "false-link svelte-h429by");
    },
    m(_, y) {
      T(_, e, y), T(_, t, y), T(_, s, y), A(s, n), A(s, l), A(s, r), A(s, o), A(s, a), T(_, c, y), T(_, f, y), A(f, d), A(f, p), A(f, m), g || (h = [
        W(
          l,
          "click",
          /*click_handler*/
          i[1]
        ),
        W(
          p,
          "click",
          /*click_handler_1*/
          i[2]
        )
      ], g = !0);
    },
    p: se,
    i: se,
    o: se,
    d(_) {
      _ && (C(e), C(t), C(s), C(c), C(f)), g = !1, Me(h);
    }
  };
}
u(Zve, "create_fragment$4");
function Qve(i) {
  const e = ft();
  return [e, /* @__PURE__ */ u(() => e("change-tab", 1), "click_handler"), /* @__PURE__ */ u(() => e("change-tab", 2), "click_handler_1")];
}
u(Qve, "instance$3");
const O3 = class O3 extends re {
  constructor(e) {
    super(), oe(this, e, Qve, Zve, le, {});
  }
};
u(O3, "PremiumContentListIntroduction");
let lm = O3;
function xve(i) {
  let e, t, s, n, l, r, o, a, c, f, d, p, m, g, h, _, y, v, k, S, D;
  return {
    c() {
      e = E("p"), e.textContent = `In addition to helping with all the great content published for A5e, we've
    recently begun publishing exclusive tools on Patreon as a thank you to those
    that help support the system's development. Many of these tools are destined
    to one day be included in the core system software, with patrons getting
    early access.`, t = F(), s = E("p"), s.innerHTML = `If you want to help support the development of new system features or you
    want access to these exclusive tools, please consider visiting our <a href="https://www.patreon.com/ForgemasterModules" target="_blank">Patreon page</a>. You can find a summary of these tools below.`, n = F(), l = E("h3"), l.innerHTML = '<a class="patreon-link svelte-n9i9ws" href="https://www.patreon.com/posts/5e-a5e-tools-89802245" target="_blank"><i class="tier-indicator tier-indicator--bronze fa-solid fa-circle svelte-n9i9ws" data-tooltip="This tool is available to bronze tier patrons"></i> 5e → A5e Converter</a>', r = F(), o = E("p"), o.textContent = `The first of our Patreon release is a much requested converter that takes
    content for the 5e Foundry system and makes it usable in an A5e world. The
    application contains a number of handy instructions pages to help you
    prepare your 5e content for conversion.`, a = F(), c = E("p"), c.innerHTML = 'You can see the conversion tools in action <a href="https://www.patreon.com/posts/5e-a5e-tools-89802245" target="_blank">here</a>.', f = F(), d = E("h3"), d.innerHTML = '<a class="patreon-link svelte-n9i9ws" href="https://www.patreon.com/posts/preview-builder-92995236" target="_blank"><i class="tier-indicator tier-indicator--bronze fa-solid fa-circle svelte-n9i9ws" data-tooltip="This tool is available to bronze tier patrons"></i> Encounter Builder</a>', p = F(), m = E("p"), m.textContent = `The encounter builder is an combat encounter planning utility that allows
    you to quickly an easily evaluate the difficulty of a combat encounter
    against your current party.`, g = F(), h = E("p"), h.textContent = `Future versions of this tool will see it transform into a full encounter
    management suite, with helpful summaries for tracking combats, handy
    import/export functionality, xp management, and module integration to
    automatically set up encounters for published adventures.`, _ = F(), y = E("h3"), y.innerHTML = `<a class="patreon-link svelte-n9i9ws" href="https://www.patreon.com/posts/preview-flanking-99659434" target="_blank"><i class="tier-indicator tier-indicator--silver fa-solid fa-circle svelte-n9i9ws" data-tooltip="This tool is available to silver tier patrons"></i>
        Flanking Automation</a>`, v = F(), k = E("p"), k.textContent = `Our new Flanking Automation module automatically detects flanking conditions
    against targeted tokens and preselects an additional expertise die in the
    roll dialog when you make attack rolls.`, S = F(), D = E("p"), D.textContent = `If you're using the A5e Foundry system to play standard D&D 5e, you can
    instead configure the module to grant advantage in the module settings.`, G(s, "margin-bottom", "1rem"), b(l, "class", "svelte-n9i9ws"), b(d, "class", "svelte-n9i9ws"), b(y, "class", "svelte-n9i9ws");
    },
    m(I, M) {
      T(I, e, M), T(I, t, M), T(I, s, M), T(I, n, M), T(I, l, M), T(I, r, M), T(I, o, M), T(I, a, M), T(I, c, M), T(I, f, M), T(I, d, M), T(I, p, M), T(I, m, M), T(I, g, M), T(I, h, M), T(I, _, M), T(I, y, M), T(I, v, M), T(I, k, M), T(I, S, M), T(I, D, M);
    },
    p: se,
    i: se,
    o: se,
    d(I) {
      I && (C(e), C(t), C(s), C(n), C(l), C(r), C(o), C(a), C(c), C(f), C(d), C(p), C(m), C(g), C(h), C(_), C(y), C(v), C(k), C(S), C(D));
    }
  };
}
u(xve, "create_fragment$3");
const D3 = class D3 extends re {
  constructor(e) {
    super(), oe(this, e, null, xve, le, {});
  }
};
u(D3, "PremiumContentListPatreon");
let y5 = D3;
function L7(i, e, t) {
  const s = i.slice();
  return s[1] = e[t].name, s[2] = e[t].releases, s;
}
u(L7, "get_each_context$1");
function B7(i, e, t) {
  const s = i.slice();
  return s[5] = e[t].title, s[6] = e[t].url, s;
}
u(B7, "get_each_context_1$1");
function q7(i) {
  let e, t, s = (
    /*title*/
    i[5] + ""
  ), n, l;
  return {
    c() {
      e = E("li"), t = E("a"), n = Q(s), l = F(), b(
        t,
        "href",
        /*url*/
        i[6]
      ), b(t, "target", "_blank"), b(t, "class", "svelte-1uj9tse"), b(e, "class", "content-list__item svelte-1uj9tse");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(t, n), A(e, l);
    },
    p: se,
    d(r) {
      r && C(e);
    }
  };
}
u(q7, "create_each_block_1$1");
function eke(i) {
  let e, t, s = ue(
    /*releases*/
    i[2]
  ), n = [];
  for (let l = 0; l < s.length; l += 1)
    n[l] = q7(B7(i, s, l));
  return {
    c() {
      e = E("ul");
      for (let l = 0; l < n.length; l += 1)
        n[l].c();
      t = F(), b(e, "class", "content-list svelte-1uj9tse");
    },
    m(l, r) {
      T(l, e, r);
      for (let o = 0; o < n.length; o += 1)
        n[o] && n[o].m(e, null);
      T(l, t, r);
    },
    p(l, r) {
      if (r & /*Object, premiumContent*/
      1) {
        s = ue(
          /*releases*/
          l[2]
        );
        let o;
        for (o = 0; o < s.length; o += 1) {
          const a = B7(l, s, o);
          n[o] ? n[o].p(a, r) : (n[o] = q7(a), n[o].c(), n[o].m(e, null));
        }
        for (; o < n.length; o += 1)
          n[o].d(1);
        n.length = s.length;
      }
    },
    d(l) {
      l && (C(e), C(t)), Le(n, l);
    }
  };
}
u(eke, "create_default_slot$1");
function G7(i) {
  let e, t;
  return e = new De({
    props: {
      heading: (
        /*name*/
        i[1]
      ),
      $$slots: { default: [eke] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      j(e.$$.fragment);
    },
    m(s, n) {
      R(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope*/
      512 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      O(e.$$.fragment, s), t = !1;
    },
    d(s) {
      N(e, s);
    }
  };
}
u(G7, "create_each_block$1");
function tke(i) {
  let e, t, s, n, l, r, o = ue(Object.values(
    /*premiumContent*/
    i[0]
  )), a = [];
  for (let f = 0; f < o.length; f += 1)
    a[f] = G7(L7(i, o, f));
  const c = /* @__PURE__ */ u((f) => O(a[f], 1, 1, () => {
    a[f] = null;
  }), "out");
  return {
    c() {
      e = E("p"), e.textContent = `Below you'll find a list of premium content modules organized by publisher. Some of
    these modules are included for free when you purchase the a PDF or physical book.
    Others modules are sold as standalone products.`, t = F(), s = E("p"), s.innerHTML = `<b>Disclaimer.</b> This page contains affiliate links. If you choose to make a purchase
    after clicking a link, we may receive a small amount of kickback from DriveThruRPG that
    will go towards developing and maintaining the A5e Foundry system and its modules.`, n = F();
      for (let f = 0; f < a.length; f += 1)
        a[f].c();
      l = $e(), b(s, "class", "a5e-content-disclaimer svelte-1uj9tse");
    },
    m(f, d) {
      T(f, e, d), T(f, t, d), T(f, s, d), T(f, n, d);
      for (let p = 0; p < a.length; p += 1)
        a[p] && a[p].m(f, d);
      T(f, l, d), r = !0;
    },
    p(f, [d]) {
      if (d & /*Object, premiumContent*/
      1) {
        o = ue(Object.values(
          /*premiumContent*/
          f[0]
        ));
        let p;
        for (p = 0; p < o.length; p += 1) {
          const m = L7(f, o, p);
          a[p] ? (a[p].p(m, d), w(a[p], 1)) : (a[p] = G7(m), a[p].c(), w(a[p], 1), a[p].m(l.parentNode, l));
        }
        for (ae(), p = o.length; p < a.length; p += 1)
          c(p);
        ce();
      }
    },
    i(f) {
      if (!r) {
        for (let d = 0; d < o.length; d += 1)
          w(a[d]);
        r = !0;
      }
    },
    o(f) {
      a = a.filter(Boolean);
      for (let d = 0; d < a.length; d += 1)
        O(a[d]);
      r = !1;
    },
    d(f) {
      f && (C(e), C(t), C(s), C(n), C(l)), Le(a, f);
    }
  };
}
u(tke, "create_fragment$2");
function ske(i) {
  const { premiumContent: e } = CONFIG.A5E;
  return [e];
}
u(ske, "instance$2");
const I3 = class I3 extends re {
  constructor(e) {
    super(), oe(this, e, ske, tke, le, {});
  }
};
u(I3, "PremiumContentListPremium");
let v5 = I3;
function nke(i) {
  let e, t, s, n, l;
  e = new Wn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[3]
      )
    }
  }), e.$on(
    "tab-change",
    /*tab_change_handler*/
    i[4]
  );
  var r = (
    /*getCurrentTabComponent*/
    i[2](
      /*currentTab*/
      i[1]
    )
  );
  function o(a, c) {
    return {};
  }
  return u(o, "switch_props"), r && (n = et(r, o()), n.$on(
    "change-tab",
    /*change_tab_handler*/
    i[5]
  )), {
    c() {
      j(e.$$.fragment), t = F(), s = E("article"), n && j(n.$$.fragment), b(s, "class", "svelte-3mbpiq");
    },
    m(a, c) {
      R(e, a, c), T(a, t, c), T(a, s, c), n && R(n, s, null), l = !0;
    },
    p(a, c) {
      const f = {};
      if (c & /*currentTab*/
      2 && (f.currentTab = /*currentTab*/
      a[1]), e.$set(f), c & /*currentTab*/
      2 && r !== (r = /*getCurrentTabComponent*/
      a[2](
        /*currentTab*/
        a[1]
      ))) {
        if (n) {
          ae();
          const d = n;
          O(d.$$.fragment, 1, 0, () => {
            N(d, 1);
          }), ce();
        }
        r ? (n = et(r, o()), n.$on(
          "change-tab",
          /*change_tab_handler*/
          a[5]
        ), j(n.$$.fragment), w(n.$$.fragment, 1), R(n, s, null)) : n = null;
      }
    },
    i(a) {
      l || (w(e.$$.fragment, a), n && w(n.$$.fragment, a), l = !0);
    },
    o(a) {
      O(e.$$.fragment, a), n && O(n.$$.fragment, a), l = !1;
    },
    d(a) {
      a && (C(t), C(s)), N(e, a), n && N(n);
    }
  };
}
u(nke, "create_default_slot");
function ike(i) {
  let e, t, s;
  function n(r) {
    i[6](r);
  }
  u(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [nke] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Js({ props: l }), rt.push(() => Ot(e, "elementRoot", n)), {
      c() {
        j(e.$$.fragment);
      },
      m(r, o) {
        R(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        130 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], It(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        O(e.$$.fragment, r), s = !1;
      },
      d(r) {
        N(e, r);
      }
    }
  );
}
u(ike, "create_fragment$1");
function lke(i, e, t) {
  let { elementRoot: s } = e;
  function n({ name: f }) {
    switch (f) {
      case "intro":
        return lm;
      case "premiumContent":
        return v5;
      case "patreon":
        return y5;
      default:
        return lm;
    }
  }
  u(n, "getCurrentTabComponent");
  const l = [
    { name: "intro", label: "Introduction" },
    {
      name: "premiumContent",
      label: "Premium Content"
    },
    {
      name: "patreon",
      label: "Patreon Exclusive"
    }
  ];
  let r = l[0];
  const o = /* @__PURE__ */ u(({ detail: f }) => t(1, r = l[f]), "tab_change_handler"), a = /* @__PURE__ */ u(({ detail: f }) => t(1, r = l[f]), "change_tab_handler");
  function c(f) {
    s = f, t(0, s);
  }
  return u(c, "applicationshell_elementRoot_binding"), i.$$set = (f) => {
    "elementRoot" in f && t(0, s = f.elementRoot);
  }, [
    s,
    r,
    n,
    l,
    o,
    a,
    c
  ];
}
u(lke, "instance$1");
var ic;
let rke = (ic = class extends re {
  constructor(e) {
    super(), oe(this, e, lke, ike, le, { elementRoot: 0 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Xe();
  }
}, u(ic, "PremiumContentListDialog"), ic);
const P3 = class P3 extends Gs {
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/Application.html#options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: "Premium Content",
      height: "auto",
      width: 500,
      classes: ["a5e-premium-content-list-dialog"],
      resizable: !0,
      svelte: {
        class: rke,
        target: document.body
      }
    });
  }
};
u(P3, "PremiumContentListDialog");
let k5 = P3;
function oke(i, e) {
  var f;
  const t = e[0], s = t.querySelector(".settings-sidebar .system-title");
  s.innerText = "Level Up: Advanced 5th Edition";
  const n = t.querySelector(".settings-sidebar li.system"), l = n == null ? void 0 : n.cloneNode(!1);
  l.classList.remove("system"), l.classList.add("a5e-community-links");
  const r = [
    {
      classes: ["a5e-community-link", "a5e-community-link--discord"],
      icon: '<i class="fa-brands fa-discord"></i>',
      label: "Discord",
      tooltip: "Join the community Discord server",
      url: "https://discord.gg/XtkZ6RkN9E"
    },
    {
      classes: ["a5e-community-link", "a5e-community-link--patreon"],
      icon: '<i class="fa-brands fa-patreon"></i>',
      label: "Patreon",
      tooltip: "Support the system",
      url: "https://www.patreon.com/ForgemasterModules"
    }
  ].map(({ classes: d, icon: p, label: m, tooltip: g, url: h }) => {
    const _ = document.createElement("a");
    return _.href = h, _.innerHTML = `${p} ${m}`, _.target = "_blank", _.setAttribute("data-tooltip", g), _.classList.add(...d), _;
  });
  l.append(...r), n == null || n.after(l);
  const o = document.createElement("h2");
  o.innerText = "Level Up: Advanced 5th Edition";
  const a = document.createElement("div");
  (f = t.querySelector("#settings-game")) == null || f.after(o, a);
  const c = [
    {
      DialogApplication: _5,
      dialogName: "helpAndSupport",
      iconClasses: ["fa-solid", "fa-life-ring"],
      label: "Help and Support"
    },
    {
      DialogApplication: sm,
      dialogName: "latestAnnouncements",
      iconClasses: ["fa-solid", "fa-bullhorn"],
      label: "Latest Announcements"
    },
    {
      DialogApplication: k5,
      dialogName: "premiumContentList",
      iconClasses: ["fa-solid", "fa-wallet"],
      label: "Premium Content"
    }
  ].map(({ DialogApplication: d, dialogName: p, iconClasses: m, label: g }) => {
    const h = document.createElement("button");
    h.type = "button";
    const _ = document.createElement("i");
    return _.classList.add(...m), h.append(_, g), h.addEventListener("click", () => {
      var y;
      (y = game.a5e.dialogs)[p] ?? (y[p] = new d()), game.a5e.dialogs[p].render(!0);
    }), h;
  });
  a.append(...c);
}
u(oke, "renderSettings");
function z7(i, e, t) {
  const s = i.slice();
  return s[19] = e[t], s;
}
u(z7, "get_each_context");
function H7(i, e, t) {
  var l;
  const s = i.slice();
  s[19] = e[t];
  const n = (
    /*subConditions*/
    (l = s[12][
      /*effect*/
      s[19].id
    ]) == null ? void 0 : l.some((r) => (
      /*activeConditions*/
      s[11].includes(r)
    ))
  );
  return s[22] = n, s;
}
u(H7, "get_each_context_1");
function U7(i) {
  let e, t, s, n, l, r = (
    /*effect*/
    i[19].title + ""
  ), o, a, c, f, d;
  function p() {
    return (
      /*click_handler*/
      i[14](
        /*linked*/
        i[22],
        /*effect*/
        i[19]
      )
    );
  }
  u(p, "click_handler");
  function m() {
    return (
      /*auxclick_handler*/
      i[15](
        /*linked*/
        i[22],
        /*effect*/
        i[19]
      )
    );
  }
  return u(m, "auxclick_handler"), {
    c() {
      e = E("button"), t = E("img"), n = F(), l = E("h3"), o = Q(r), a = F(), b(t, "class", di(
        /*effect*/
        i[19].cssClass
      ) + " svelte-u43z6k"), ze(t.src, s = /*effect*/
      i[19].src) || b(t, "src", s), b(
        t,
        "alt",
        /*effect*/
        i[19].title ?? ""
      ), b(
        t,
        "title",
        /*effect*/
        i[19].title ?? ""
      ), b(
        t,
        "data-status-id",
        /*effect*/
        i[19].id
      ), b(l, "class", "condition-title svelte-u43z6k"), G(l, "--strife", "'" + /*strife*/
      i[1] + "'"), G(l, "--fatigue", "'" + /*fatigue*/
      i[3] + "'"), G(
        l,
        "--fatigue-col",
        /*colors*/
        i[13][
          /*fatigue*/
          i[3]
        ]
      ), G(
        l,
        "--strife-col",
        /*colors*/
        i[13][
          /*strife*/
          i[1]
        ]
      ), G(l, "--corruption", "'" + /*corruption*/
      i[4] + "'"), G(
        l,
        "--corruption-col",
        /*colors*/
        i[13][
          /*corruption*/
          i[4]
        ]
      ), G(l, "--inebriated", "'" + /*inebriated*/
      i[2] + "'"), G(
        l,
        "--inebriated-col",
        /*colors*/
        i[13][
          /*inebriated*/
          i[2]
        ]
      ), b(e, "class", "condition-container " + /*effect*/
      i[19].cssClass + " svelte-u43z6k"), b(
        e,
        "title",
        /*effect*/
        i[19].title ?? ""
      ), b(
        e,
        "data-status-id",
        /*effect*/
        i[19].id
      ), e.disabled = c = /*conditionImmunities*/
      i[6].includes(
        /*effect*/
        i[19].id
      ) || /*linked*/
      i[22], Z(
        e,
        "linked",
        /*linked*/
        i[22]
      ), Z(
        e,
        "locked",
        /*conditionImmunities*/
        i[6].includes(
          /*effect*/
          i[19].id
        )
      ), Z(
        e,
        "corruption-counter",
        /*effect*/
        i[19].id === "corruption" && /*corruption*/
        i[4] > 0
      ), Z(
        e,
        "fatigue-counter",
        /*effect*/
        i[19].id === "fatigue" && /*fatigue*/
        i[3] > 0
      ), Z(
        e,
        "inebriated-counter",
        /*effect*/
        i[19].id === "inebriated" && /*inebriated*/
        i[2] > 0
      ), Z(
        e,
        "strife-counter",
        /*effect*/
        i[19].id === "strife" && /*strife*/
        i[1] > 0
      );
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(e, n), A(e, l), A(l, o), A(e, a), f || (d = [
        W(e, "click", Ve(st(p))),
        W(e, "auxclick", Ve(st(m)))
      ], f = !0);
    },
    p(g, h) {
      i = g, h & /*strife*/
      2 && G(l, "--strife", "'" + /*strife*/
      i[1] + "'"), h & /*fatigue*/
      8 && G(l, "--fatigue", "'" + /*fatigue*/
      i[3] + "'"), h & /*fatigue*/
      8 && G(
        l,
        "--fatigue-col",
        /*colors*/
        i[13][
          /*fatigue*/
          i[3]
        ]
      ), h & /*strife*/
      2 && G(
        l,
        "--strife-col",
        /*colors*/
        i[13][
          /*strife*/
          i[1]
        ]
      ), h & /*corruption*/
      16 && G(l, "--corruption", "'" + /*corruption*/
      i[4] + "'"), h & /*corruption*/
      16 && G(
        l,
        "--corruption-col",
        /*colors*/
        i[13][
          /*corruption*/
          i[4]
        ]
      ), h & /*inebriated*/
      4 && G(l, "--inebriated", "'" + /*inebriated*/
      i[2] + "'"), h & /*inebriated*/
      4 && G(
        l,
        "--inebriated-col",
        /*colors*/
        i[13][
          /*inebriated*/
          i[2]
        ]
      ), h & /*conditionImmunities*/
      64 && c !== (c = /*conditionImmunities*/
      i[6].includes(
        /*effect*/
        i[19].id
      ) || /*linked*/
      i[22]) && (e.disabled = c), h & /*conditionImmunities, statusEffects*/
      576 && Z(
        e,
        "locked",
        /*conditionImmunities*/
        i[6].includes(
          /*effect*/
          i[19].id
        )
      ), h & /*statusEffects, corruption*/
      528 && Z(
        e,
        "corruption-counter",
        /*effect*/
        i[19].id === "corruption" && /*corruption*/
        i[4] > 0
      ), h & /*statusEffects, fatigue*/
      520 && Z(
        e,
        "fatigue-counter",
        /*effect*/
        i[19].id === "fatigue" && /*fatigue*/
        i[3] > 0
      ), h & /*statusEffects, inebriated*/
      516 && Z(
        e,
        "inebriated-counter",
        /*effect*/
        i[19].id === "inebriated" && /*inebriated*/
        i[2] > 0
      ), h & /*statusEffects, strife*/
      514 && Z(
        e,
        "strife-counter",
        /*effect*/
        i[19].id === "strife" && /*strife*/
        i[1] > 0
      );
    },
    d(g) {
      g && C(e), f = !1, Me(d);
    }
  };
}
u(U7, "create_each_block_1");
function V7(i) {
  let e, t, s, n, l, r;
  function o() {
    return (
      /*click_handler_1*/
      i[16](
        /*effect*/
        i[19]
      )
    );
  }
  u(o, "click_handler_1");
  function a() {
    return (
      /*auxclick_handler_1*/
      i[17](
        /*effect*/
        i[19]
      )
    );
  }
  return u(a, "auxclick_handler_1"), {
    c() {
      e = E("button"), t = E("img"), n = F(), b(t, "class", di(
        /*effect*/
        i[19].cssClass
      ) + " svelte-u43z6k"), ze(t.src, s = /*effect*/
      i[19].src) || b(t, "src", s), b(
        t,
        "alt",
        /*effect*/
        i[19].title ?? ""
      ), b(
        t,
        "title",
        /*effect*/
        i[19].title ?? ""
      ), b(
        t,
        "data-status-id",
        /*effect*/
        i[19].id
      ), b(e, "class", "condition-container " + /*effect*/
      i[19].cssClass + " svelte-u43z6k"), b(
        e,
        "title",
        /*effect*/
        i[19].title ?? ""
      ), b(
        e,
        "data-status-id",
        /*effect*/
        i[19].id
      );
    },
    m(c, f) {
      T(c, e, f), A(e, t), A(e, n), l || (r = [
        W(e, "click", Ve(st(o))),
        W(e, "auxclick", Ve(st(a)))
      ], l = !0);
    },
    p(c, f) {
      i = c;
    },
    d(c) {
      c && C(e), l = !1, Me(r);
    }
  };
}
u(V7, "create_each_block");
function ake(i) {
  let e, t, s, n, l, r, o, a, c, f = K("A5E.UIClearAll") + "", d, p, m, g = ue(
    /*statusEffects*/
    i[9]
  ), h = [];
  for (let v = 0; v < g.length; v += 1)
    h[v] = U7(H7(i, g, v));
  let _ = ue(
    /*genericEffects*/
    i[10]
  ), y = [];
  for (let v = 0; v < _.length; v += 1)
    y[v] = V7(z7(i, _, v));
  return {
    c() {
      e = E("div");
      for (let v = 0; v < h.length; v += 1)
        h[v].c();
      t = F(), s = E("hr"), n = F(), l = E("div");
      for (let v = 0; v < y.length; v += 1)
        y[v].c();
      r = F(), o = E("button"), a = E("i"), c = F(), d = Q(f), b(e, "class", "status-effects-container svelte-u43z6k"), Z(
        e,
        "status-effects-container--column-flow",
        /*conditionsFlowDirection*/
        i[5] === "column"
      ), b(s, "class", "a5e-rule"), b(l, "class", "generic-effects-container svelte-u43z6k"), b(a, "class", "fa-solid fa-octagon-xmark"), b(o, "class", "clear-all-conditions svelte-u43z6k");
    },
    m(v, k) {
      T(v, e, k);
      for (let S = 0; S < h.length; S += 1)
        h[S] && h[S].m(e, null);
      T(v, t, k), T(v, s, k), T(v, n, k), T(v, l, k);
      for (let S = 0; S < y.length; S += 1)
        y[S] && y[S].m(l, null);
      T(v, r, k), T(v, o, k), A(o, a), A(o, c), A(o, d), p || (m = W(o, "click", function() {
        var S, D;
        $t(
          /*HUD*/
          (S = i[0]) == null ? void 0 : S._clearAllConditions.bind(
            /*HUD*/
            i[0]
          )
        ) && ((D = i[0]) == null || D._clearAllConditions.bind(
          /*HUD*/
          i[0]
        ).apply(this, arguments));
      }), p = !0);
    },
    p(v, [k]) {
      if (i = v, k & /*statusEffects, conditionImmunities, subConditions, activeConditions, corruption, fatigue, inebriated, strife, handleStatusEffectAdd, handleStatusEffectRemove, colors*/
      15326) {
        g = ue(
          /*statusEffects*/
          i[9]
        );
        let S;
        for (S = 0; S < g.length; S += 1) {
          const D = H7(i, g, S);
          h[S] ? h[S].p(D, k) : (h[S] = U7(D), h[S].c(), h[S].m(e, null));
        }
        for (; S < h.length; S += 1)
          h[S].d(1);
        h.length = g.length;
      }
      if (k & /*conditionsFlowDirection*/
      32 && Z(
        e,
        "status-effects-container--column-flow",
        /*conditionsFlowDirection*/
        i[5] === "column"
      ), k & /*genericEffects, handleStatusEffectAdd, handleStatusEffectRemove*/
      1408) {
        _ = ue(
          /*genericEffects*/
          i[10]
        );
        let S;
        for (S = 0; S < _.length; S += 1) {
          const D = z7(i, _, S);
          y[S] ? y[S].p(D, k) : (y[S] = V7(D), y[S].c(), y[S].m(l, null));
        }
        for (; S < y.length; S += 1)
          y[S].d(1);
        y.length = _.length;
      }
    },
    i: se,
    o: se,
    d(v) {
      v && (C(e), C(t), C(s), C(n), C(l), C(r), C(o)), Le(h, v), Le(y, v), p = !1, m();
    }
  };
}
u(ake, "create_fragment");
function cke(i, e, t) {
  let s, n, l, r, o, a, { HUD: c } = e;
  function f({ id: I, src: M }, L = {}) {
    c.object._addStatusEffect({ id: I, src: M }, L);
  }
  u(f, "handleStatusEffectAdd");
  function d({ id: I, src: M }, L = {}) {
    c.object._removeStatusEffect({ id: I, src: M }, L);
  }
  u(d, "handleStatusEffectRemove");
  const p = c.getData(), m = Object.values(p.statusEffects), g = Object.values(p.genericConditions), h = c.object._getActiveConditions(), _ = CONFIG.statusEffects.reduce(
    (I, M) => {
      var L;
      return (L = M == null ? void 0 : M.statuses) != null && L.length && M.statuses.forEach((B) => {
        I[B] ?? (I[B] = []), I[B].push(M.id);
      }), I;
    },
    {}
  ), y = {
    1: "#919f00",
    2: "#a09200",
    3: "#af8300",
    4: "#bd7100",
    5: "#cb5c00",
    6: "#d63f00",
    7: "#e00006"
  }, v = /* @__PURE__ */ u((I, M) => {
    I || f(M, { overlay: M.isOverlay });
  }, "click_handler"), k = /* @__PURE__ */ u((I, M) => {
    I || d(M, { overlay: M.isOverlay });
  }, "auxclick_handler"), S = /* @__PURE__ */ u((I) => f(I), "click_handler_1"), D = /* @__PURE__ */ u((I) => d(I), "auxclick_handler_1");
  return i.$$set = (I) => {
    "HUD" in I && t(0, c = I.HUD);
  }, i.$$.update = () => {
    var I, M, L, B, z, q, U, H, V, Y, J, fe, ke, ee, ne, Ee, Pe, ye, me, Ce;
    i.$$.dirty & /*HUD*/
    1 && t(6, s = ((B = (L = (M = (I = c == null ? void 0 : c.object) == null ? void 0 : I.actor) == null ? void 0 : M.system) == null ? void 0 : L.traits) == null ? void 0 : B.conditionImmunities) ?? []), i.$$.dirty & /*HUD*/
    1 && t(4, l = ((H = (U = (q = (z = c == null ? void 0 : c.object) == null ? void 0 : z.actor) == null ? void 0 : q.system) == null ? void 0 : U.attributes) == null ? void 0 : H.corruption) ?? 0), i.$$.dirty & /*HUD*/
    1 && t(3, r = ((fe = (J = (Y = (V = c == null ? void 0 : c.object) == null ? void 0 : V.actor) == null ? void 0 : Y.system) == null ? void 0 : J.attributes) == null ? void 0 : fe.fatigue) ?? 0), i.$$.dirty & /*HUD*/
    1 && t(2, o = ((Ee = (ne = (ee = (ke = c == null ? void 0 : c.object) == null ? void 0 : ke.actor) == null ? void 0 : ee.system) == null ? void 0 : ne.attributes) == null ? void 0 : Ee.inebriated) ?? 0), i.$$.dirty & /*HUD*/
    1 && t(1, a = ((Ce = (me = (ye = (Pe = c == null ? void 0 : c.object) == null ? void 0 : Pe.actor) == null ? void 0 : ye.system) == null ? void 0 : me.attributes) == null ? void 0 : Ce.strife) ?? 0);
  }, t(5, n = game.settings.get("a5e", "conditionFlowDirection")), [
    c,
    a,
    o,
    r,
    l,
    n,
    s,
    f,
    d,
    m,
    g,
    h,
    _,
    y,
    v,
    k,
    S,
    D
  ];
}
u(cke, "instance");
const M3 = class M3 extends re {
  constructor(e) {
    super(), oe(this, e, cke, ake, le, { HUD: 0 });
  }
  get HUD() {
    return this.$$.ctx[0];
  }
  set HUD(e) {
    this.$$set({ HUD: e }), Xe();
  }
};
u(M3, "A5ETokenHUD");
let w5 = M3;
function uke(i, e, t) {
  const s = $(e).find(".status-effects")[0];
  s && (s.innerHTML = "", i._svelteComponent = new w5({
    target: s,
    props: { HUD: i }
  }));
}
u(uke, "renderTokenHUDA5E");
const F3 = class F3 extends FormApplication {
  constructor() {
    super({}), tm.show();
  }
  async _updateObject() {
  }
  render() {
    this.close();
  }
};
u(F3, "SettingsShim");
let $5 = F3;
function fke() {
  _c.init(), game.settings.registerMenu("a5e", "SystemSettings", {
    name: "System Settings",
    label: "Configure System Settings",
    icon: "fas fa bars",
    type: $5,
    restricted: !1
  });
}
u(fke, "registerSystemSettings");
function dke(i) {
  const e = i.ACTIVE_EFFECT_MODES;
  return {
    blinded: [
      {
        key: "flags.a5e.effects.rollMode.attack.all",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionBlinded"
      },
      {
        key: "flags.a5e.effects.grants.rollMode.attack.all",
        value: 1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionBlinded"
      }
    ],
    bloodied: [],
    charmed: [],
    concentration: [],
    confused: [],
    corruption: [],
    dazzled: [],
    deafened: [],
    dead: [],
    doomed: [],
    encumbered: [
      ...Object.keys(i.movement).map((t) => ({
        key: `system.attributes.movement.${t}.distance`,
        value: '{"comparisonOperator":"==","comparisonValue":"0","positiveValue":"0","negativeValue":"5"}',
        mode: e.CONDITIONAL,
        priority: e.CONDITIONAL * 10,
        label: "A5E.ConditionGrappled"
      }))
    ],
    enervated: [],
    fatigue: [],
    fixated: [],
    frightened: [],
    grappled: [
      ...Object.keys(i.movement).map((t) => ({
        key: `system.attributes.movement.${t}.distance`,
        value: "0",
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionGrappled"
      }))
    ],
    hungover: [
      {
        key: "system.abilities.con.save.bonus",
        value: "-2",
        mode: e.ADD,
        priority: e.ADD * 10,
        label: "A5E.ConditionHungover"
      },
      {
        key: "flags.a5e.effects.rollMode.skillCheck.prc",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionHungover"
      }
    ],
    incapacitated: [],
    inebriated: [],
    invisible: [
      {
        key: "flags.a5e.effects.rollMode.attack.all",
        value: 1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionInvisible"
      },
      {
        key: "flags.a5e.effects.grants.rollMode.attack.all",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionInvisible"
      }
    ],
    paralyzed: [
      {
        key: "flags.a5e.effects.grants.rollMode.attack.all",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionParalyzed"
      }
    ],
    petrified: [
      ...Object.keys(i.damageTypes).map((t) => ({
        key: "system.traits.damageResistances",
        value: t,
        mode: e.ADD,
        priority: e.ADD * 10,
        label: "A5E.ConditionPetrified"
      }))
      // TODO: Possible immunity to poisoned?
    ],
    poisoned: [
      {
        key: "flags.a5e.effects.rollMode.attack.all",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionPoisoned"
      },
      {
        key: "flags.a5e.effects.rollMode.abilityCheck.all",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionPoisoned"
      }
    ],
    prone: [
      {
        key: "flags.a5e.effects.rollMode.attack.meleeWeapon",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionProne"
      }
    ],
    rattled: [
      {
        key: "flags.a5e.effects.expertiseDice",
        value: 0,
        mode: e.OVERRIDE,
        priority: 200,
        label: "A5E.ConditionRattled"
      }
    ],
    restrained: [
      {
        key: "flags.a5e.effects.grants.rollMode.attack.all",
        value: 1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionRestrained"
      },
      {
        key: "flags.a5e.effects.rollMode.attack.all",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionRestrained"
      },
      {
        key: "flags.a5e.effects.rollMode.abilitySave.dex",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionRestrained"
      },
      ...Object.keys(i.movement).map((t) => ({
        key: `system.attributes.movement.${t}.distance`,
        value: "0",
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionGrappled"
      }))
    ],
    slowed: [
      {
        key: "system.attributes.ac.changes.bonuses.value",
        value: "-2",
        mode: e.ADD,
        priority: e.ADD * 10,
        label: "A5E.ConditionSlowed"
      },
      {
        key: "system.abilities.dex.save.bonus",
        value: "-2",
        mode: e.ADD,
        priority: e.ADD * 10,
        label: "A5E.ConditionSlowed"
      },
      ...Object.keys(i.movement).map((t) => ({
        key: `system.attributes.movement.${t}.distance`,
        value: "0.5",
        mode: e.MULTIPLY,
        priority: e.MULTIPLY * 10,
        label: "A5E.ConditionSlowed"
      }))
    ],
    strife: [],
    stunned: [
      {
        key: "flags.a5e.effects.grants.rollMode.attack.all",
        value: 1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionStunned"
      }
    ],
    unconscious: [
      {
        key: "flags.a5e.effects.grants.rollMode.attack.all",
        value: 1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionStunned"
      }
    ]
  };
}
u(dke, "generateChanges");
function pke() {
  var o;
  const { A5E: i } = CONFIG, e = i.ACTIVE_EFFECT_MODES, t = new Set(
    (o = game.settings.storage.get("world")) == null ? void 0 : o.getItem("a5e.automatedConditions")
  ), s = game.settings.get("a5e", "replaceFatigueAndStrife"), n = game.settings.get("a5e", "customConditionIcons"), l = dke(i);
  i.multiLevelConditionsMaxLevel = {
    corruption: 7,
    fatigue: s ? 6 : 7,
    inebriated: 5,
    strife: 7
  }, i.multiLevelConditions = {
    corruption: {
      1: [],
      2: [
        {
          key: "system.abilities.str.check.bonus",
          value: "-2",
          mode: e.ADD,
          priority: e.ADD * 10,
          label: "Corruption 2"
        }
      ],
      3: [],
      4: [
        {
          key: "flags.a5e.effects.rollMode.abilitySave.con",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Corruption 4"
        }
      ],
      5: [
        {
          key: "flags.a5e.effects.rollMode.abilitySave.wis",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Corruption 5"
        }
      ],
      6: [
        {
          key: "system.abilities.cha.value",
          value: "-2",
          mode: e.ADD,
          priority: e.ADD * 10,
          label: "Corruption 6"
        },
        {
          key: "system.traits.damageImmunities",
          value: "poison",
          mode: e.ADD,
          priority: e.ADD * 10,
          label: "Corruption 6"
        },
        {
          key: "system.traits.damageImmunities",
          value: "necrotic",
          mode: e.ADD,
          priority: e.ADD * 10,
          label: "Corruption 6"
        }
      ],
      7: [
        {
          key: "system.traits.alignment.0",
          value: "evil",
          mode: e.ADD,
          priority: e.ADD * 10,
          label: "Corruption 7"
        }
      ]
    },
    fatigue: {
      1: [],
      2: [
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.con",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Fatigue 2"
        },
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.dex",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Fatigue 2"
        },
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.str",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Fatigue 2"
        }
      ],
      3: [
        ...Object.keys(i.movement).map((a) => ({
          key: `system.attributes.movement.${a}.distance`,
          value: "0.5",
          mode: e.MULTIPLY,
          priority: e.MULTIPLY * 10,
          label: "Fatigue 3"
        }))
      ],
      4: [],
      5: [],
      6: [
        ...Object.keys(i.movement).map((a) => ({
          key: `system.attributes.movement.${a}.distance`,
          value: '{"comparisonOperator":"==","comparisonValue":"0","positiveValue":"0","negativeValue":"5"}',
          mode: e.CONDITIONAL,
          priority: e.CONDITIONAL * 10,
          label: "Fatigue 6"
        }))
      ]
    },
    exhaustion: {
      1: [
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.all",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Exhaustion 1"
        }
      ],
      2: [
        ...Object.keys(i.movement).map((a) => ({
          key: `system.attributes.movement.${a}.distance`,
          value: "0.5",
          mode: e.MULTIPLY,
          priority: e.MULTIPLY * 10,
          label: "Exhaustion 2"
        }))
      ],
      3: [
        {
          key: "flags.a5e.effects.rollMode.savingThrow.all",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Exhaustion 3"
        },
        {
          key: "flags.a5e.effects.rollMode.attack.all",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Exhaustion 3"
        }
      ],
      4: [
        {
          key: "system.attributes.hp.max",
          value: "0.5",
          mode: e.MULTIPLY,
          priority: e.MULTIPLY * 10,
          label: "Exhaustion 4"
        }
      ],
      5: [
        ...Object.keys(i.movement).map((a) => ({
          key: `system.attributes.movement.${a}.distance`,
          value: "0",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Exhaustion 5"
        }))
      ],
      6: []
    },
    inebriated: {
      1: [],
      2: [],
      3: [
        {
          key: "system.abilities.dex.value",
          value: "-2",
          mode: e.ADD,
          priority: e.ADD * 10,
          label: "Inebriated 3"
        }
      ],
      4: [
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.cha",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Inebriated 4"
        }
      ],
      5: []
    },
    strife: {
      1: [
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.cha",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Strife 1"
        },
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.int",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Strife 1"
        },
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.wis",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Strife 1"
        }
      ],
      2: [
        {
          key: "flags.a5e.effects.rollMode.concentration",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Strife 2"
        }
      ],
      3: [],
      4: [],
      5: [],
      6: [],
      7: []
    }
  };
  let r = [
    // Blinded
    {
      id: "blinded",
      description: `<ul class="a5e-tooltip__list"><li>A blinded creature can't see and it automatically fails ability checks that require sight.</li><li>Attack rolls against a blinded creature are made with advantage, and the creature's attack rolls are made with disadvantage.</li></ul>`,
      name: "A5E.ConditionBlinded",
      img: "icons/svg/blind.svg",
      changes: l.blinded,
      duration: {}
    },
    // Bloodied
    {
      id: "bloodied",
      description: '<ul class="a5e-tooltip__list"><li>A creature is bloodied when reduced to half its hit points or less.</li></ul>',
      name: "A5E.ConditionBloodied",
      img: "icons/svg/blood.svg",
      changes: l.bloodied,
      duration: {}
    },
    // Charmed
    {
      id: "charmed",
      description: `<ul class="a5e-tooltip__list"><li>A charmed creature can't take any hostile action against the charmer.</li><li>Ability checks the charmer makes to socially interact with the charmed creature have advantage.</li></ul>`,
      name: "A5E.ConditionCharmed",
      img: "systems/a5e/assets/icons/charmed.svg",
      changes: l.charmed,
      duration: {}
    },
    // Concentration
    {
      id: "concentration",
      description: "<p>A spellcaster's concentration can be ended by any of the following:</p><ul><li>The spellcaster chooses to end concentration at any time.</li><li>The spellcaster is incapacitated or killed.</li><li>The spellcaster successfully casts another spell that requires concentration.</li><li>The GM may rule that a sudden interruption, such as a push, may force the spellcaster to make a DC 10 Constitution check. On a failure, the spell ends.</li><li>If the spellcaster takes damage while concentrating on a spell, they must make a Constitution saving throw; on a failure, the spell ends.The DC is 10 or half the damage taken, whichever is higher.</li></ul>",
      name: "A5E.ConditionConcentration",
      img: "systems/a5e/assets/icons/concentration.svg",
      changes: l.concentration,
      duration: {}
    },
    // Confused
    {
      id: "confused",
      description: `<ul class="a5e-tooltip__list"><li>A confused creature can't take reactions.</li><li>On its turn a confused creature rolls a d8 to determine what it does.</li><ul><li>On a 1 to 4, a confused creature does nothing.</li><li>On a 5 or 6, a confused creature takes no action or bonus action and uses all its movement to move in a randomly determined direction.</li><li>On a 7 or 8, a confused creature makes a melee attack against a randomly determined creature within its reach or does nothing if it can't make such an attack.</li></ul ></ul >`,
      name: "A5E.ConditionConfused",
      img: "systems/a5e/assets/icons/confused.svg",
      changes: l.confused,
      duration: {}
    },
    // Corruption
    {
      id: "corruption",
      _id: "corruption000000",
      name: "A5E.ConditionCorruption",
      img: "systems/a5e/assets/icons/corruption.svg",
      changes: l.corruption,
      duration: {}
    },
    // Dazzled
    {
      id: "dazzled",
      description: '<ul class="a5e-tooltip__list"><li>A dazzled creature has disadvantage on ability checks that require sight.</li><li>A dazzled creature cannot take reactions.</li><li>Creatures that are immune to being blinded are immune to being dazzled.</li><li>If this condition is inflicted by nonmagical environmental means (such as initial exposure to sunlight after being underground for an extended period of time), it persists for 1 round before dissipating.</li></ul>',
      name: "A5E.ConditionDazzled",
      img: "systems/a5e/assets/icons/dazzled.svg",
      changes: l.dazzled,
      duration: {}
    },
    // Deafened
    {
      id: "deafened",
      description: `<ul class="a5e-tooltip__list"><li>A deafened creature can't hear and automatically fails ability checks that require hearing.</li></ul>`,
      name: "A5E.ConditionDeafened",
      img: "icons/svg/deaf.svg",
      changes: l.deafened,
      duration: {}
    },
    // Dead
    {
      id: "dead",
      name: "EFFECT.StatusDead",
      img: "icons/svg/skull.svg",
      changes: l.dead,
      duration: {},
      flags: { core: { overlay: !0 } }
    },
    // Doomed
    {
      id: "doomed",
      description: '<ul class="a5e-tooltip__list"><li>A doomed creature dies at a time determined by the Narrator, or within 13 (2d12) hours.</li><li>A doomed creature continues to be doomed even after it dies. Magic equivalent to a 7th-level or higher spell can remove the doomed condition (such as regenerate cast on a living creature, resurrection, true resurrection, or wish).</li></ul >',
      name: "A5E.ConditionDoomed",
      img: "systems/a5e/assets/icons/doomed.svg",
      changes: l.doomed,
      duration: {}
    },
    // Encumbered
    {
      id: "encumbered",
      description: `<ul class="a5e-tooltip__list"><li>An encumbered creature's Speed is reduced to 5 ft.</li></ul>`,
      name: "A5E.ConditionEncumbered",
      img: "systems/a5e/assets/icons/encumbered.svg",
      changes: l.encumbered,
      duration: {}
    },
    // Enervated
    {
      id: "enervated",
      description: '<ul class="a5e-tooltip__list"><li>An enervated creature can’t use psionic powers or features that require psionic points.</li><li>An enervated creature suffers a –2 penalty on all ability checks, saving throws, and attacks.</li></ul>',
      name: "A5E.ConditionEnervated",
      img: "systems/a5e/assets/icons/enervated.svg",
      changes: l.enervated,
      duration: {}
    },
    // Fatigue
    {
      id: "fatigue",
      _id: "fatigue000000000",
      name: "A5E.ConditionFatigue",
      img: "systems/a5e/assets/icons/fatigue.svg",
      changes: l.fatigue,
      duration: {}
    },
    // Fixated
    {
      id: "fixated",
      description: '<ul class="a5e-tooltip__list"><li>A fixated creature has disadvantage on Investigation and Perception checks to perceive or examine creatures or objects other than the source of its fixation.</li><li>A fixated creature must spend 2 feet of movement for every 1 foot of movement away from the source of its fixation.</li><li>A creature that is immune to being charmed is also immune to being fixated.</li></ul>',
      name: "A5E.ConditionFixated",
      img: "systems/a5e/assets/icons/fixated.svg",
      changes: l.fixated,
      duration: {}
    },
    // Frightened
    {
      id: "frightened",
      description: `<ul class="a5e-tooltip__list"><li>A frightened creature has disadvantage on ability checks and attack rolls while it is able to see the source of its fear.</li><li>A frightened creature can't willingly move closer to the source of its fear.</li></ul>`,
      name: "A5E.ConditionFrightened",
      img: "icons/svg/terror.svg",
      changes: l.frightened,
      duration: {}
    },
    // Grappled
    {
      id: "grappled",
      description: `<ul class="a5e-tooltip__list"><li>A grappled creature's Speed becomes 0, and it can't benefit from bonuses to movement speeds.</li><li>If the grappler becomes incapacitated the condition ends.</li><li>If an effect removes the grappled creature from the reach of the grappler or grappling effect (such as when a creature is shoved away by the Doubleteam combat maneuver) the condition ends.</li></ul>`,
      name: "A5E.ConditionGrappled",
      img: "systems/a5e/assets/icons/grappled.svg",
      changes: l.grappled,
      duration: {}
    },
    // Hungover
    {
      id: "hungover",
      description: '<ul class="a5e-tooltip__list"><li>Hungover creatures have a –2 penalty to Constitution saving throws until they complete a short or long rest.</li><li>A hungover creature cannot take reactions.</li><li>A hungover creature has disadvantage on Perception checks.</li><li>Creatures that are immune to poison or the poisoned condition cannot be hungover.</li></ul>',
      name: "A5E.ConditionHungover",
      img: "systems/a5e/assets/icons/hungover.svg",
      changes: l.hungover,
      duration: {}
    },
    // Incapacitated
    {
      id: "incapacitated",
      description: `<ul class="a5e-tooltip__list"><li>An incapacitated creature can't take actions, bonus actions, or reactions.</li></ul>`,
      name: "A5E.ConditionIncapacitated",
      img: "systems/a5e/assets/icons/incapacitated.svg",
      changes: l.incapacitated,
      duration: {}
    },
    // Inebriated
    {
      id: "inebriated",
      _id: "inebriated000000",
      name: "A5E.ConditionInebriated",
      img: "systems/a5e/assets/icons/inebriated.svg",
      changes: l.inebriated,
      duration: {}
    },
    // Invisible
    {
      id: "invisible",
      description: `<ul class="a5e-tooltip__list"><li>An invisible creature is impossible to see without the aid of magic or a special sense (it gains no benefits from this condition against creatures still able to see it).</li><li>An invisible creature is heavily obscured for the purpose of hiding.</li><li>An invisible creature's location can be detected by noises it makes or tracks it leaves.</li><li>Attack rolls against an invisible creature are made with disadvantage.</li><li>An invisible creature makes attack rolls with advantage.</li></ul>`,
      name: "A5E.ConditionInvisible",
      img: "icons/svg/invisible.svg",
      changes: l.invisible,
      duration: {}
    },
    // Paralyzed
    {
      id: "paralyzed",
      _id: "paralyzed0000000",
      description: `<ul class="a5e-tooltip__list"><li>A paralyzed creature is incapacitated and can't move or speak.</li><li>A paralyzed creature automatically fails Strength and Dexterity saving throws.</li><li>Attack rolls against a paralyzed creature have advantage.</li><li>Any attack that hits a paralyzed creature is a critical hit if the attacker is within 5 feet.</li></ul>`,
      name: "A5E.ConditionParalyzed",
      img: "icons/svg/paralysis.svg",
      changes: l.paralyzed,
      duration: {},
      statuses: ["incapacitated"]
    },
    // Petrified
    {
      id: "petrified",
      _id: "petrified0000000",
      description: `<ul class="a5e-tooltip__list"><li>A petrified creature (and all of its mundane possessions) is transformed into a solid inanimate substance (usually stone).</li><li>A petrified creature's weight is increased by a factor of ten and it ceases aging.</li><li>A petrified creature is incapacitated, can't move or speak, and is unaware of its surroundings.</li><li>A petrified creature automatically fails Strength and Dexterity saving throws.</li><li>A petrified creature has resistance to all damage.</li><li>A petrified creature is immune to poison and disease (time spent petrified does not affect the duration of a poison or disease already in its system).</li></ul>`,
      name: "A5E.ConditionPetrified",
      img: "systems/a5e/assets/icons/petrified.svg",
      changes: l.petrified,
      duration: {},
      statuses: ["incapacitated"]
    },
    // Poisoned
    {
      id: "poisoned",
      description: '<ul class="a5e-tooltip__list"><li>A poisoned creature has disadvantage on attack rolls and ability checks.</li></ul>',
      name: "A5E.ConditionPoisoned",
      img: "icons/svg/poison.svg",
      changes: l.poisoned,
      duration: {}
    },
    // Prone
    {
      id: "prone",
      description: `<ul class="a5e-tooltip__list"><li>A prone creature's only movement option is to crawl (every 1 foot of movement while crawling costs 1 extra foot) until it stands up.</li><li>Standing up requires half a creature's movement.</li><li>A prone creature makes melee attack rolls with disadvantage.</li><li>An attack roll against a prone creature is made with advantage if the attacker is within 5 feet. Otherwise, the attack roll is made with disadvantage.</li></ul>`,
      name: "A5E.ConditionProne",
      img: "icons/svg/falling.svg",
      changes: l.prone,
      duration: {}
    },
    // Rattled
    {
      id: "rattled",
      description: '<ul class="a5e-tooltip__list"><li>A rattled creature cannot benefit from expertise dice.</li><li>A creature that is immune to being stunned is immune to being rattled.</li><li>A rattled creature cannot take reactions.</li></ul>',
      name: "A5E.ConditionRattled",
      img: "systems/a5e/assets/icons/rattled.svg",
      changes: l.rattled,
      duration: {}
    },
    // Restrained
    {
      id: "restrained",
      description: `<ul class="a5e-tooltip__list"><li>A restrained creature's Speed becomes 0, and it can't benefit from bonuses to speed.</li><li>Attack rolls against a restrained creature are made with advantage.</li><li>A restrained creature makes attack rolls with disadvantage.</li><li>The restrained creature has disadvantage on Dexterity saving throws.</li></ul>`,
      name: "A5E.ConditionRestrained",
      img: "icons/svg/net.svg",
      changes: l.restrained,
      duration: {}
    },
    // Slowed
    {
      id: "slowed",
      description: `<ul class="a5e-tooltip__list"><li>A slowed creature's Speed is halved.</li><li>A slowed creature takes a −2 penalty to AC and Dexterity saving throws.</li><li>A slowed creature cannot take reactions.</li><li>On its turn, a slowed creature can take either an action or a bonus action, not both. In addition, it can't make more than one melee or ranged attack during its turn.</li></ul>`,
      name: "A5E.ConditionSlowed",
      img: "systems/a5e/assets/icons/slowed.svg",
      changes: l.slowed,
      duration: {}
    },
    // Strife
    {
      id: "strife",
      _id: "strife0000000000",
      name: "A5E.ConditionStrife",
      img: "systems/a5e/assets/icons/strife.svg",
      changes: l.strife,
      duration: {}
    },
    // Stunned
    {
      id: "stunned",
      _id: "stunned000000000",
      description: `<ul class="a5e-tooltip__list"><li>A stunned creature is incapacitated (see the condition), can't move, and can speak only falteringly.</li><li>The creature automatically fails Strength and Dexterity saving throws.</li><li>Attack rolls against the creature have advantage.</li><li>A creature that is immune to being stunned is immune to being rattled.</li></ul>`,
      name: "A5E.ConditionStunned",
      img: "icons/svg/daze.svg",
      changes: l.stunned,
      duration: {},
      statuses: ["incapacitated"]
    },
    // Unconscious
    {
      id: "unconscious",
      _id: "unconscious00000",
      description: `<ul class="a5e-tooltip__list"><li>An unconscious creature is incapacitated, can't move or speak, and is unaware of its surroundings.</li><li>An unconscious creature drops whatever it's holding and falls prone.</li><li>An unconscious creature automatically fails Strength and Dexterity saving throws.</li><li>Attack rolls against an unconscious creature are made with advantage.</li><li>Any attack that hits an unconscious creature is a critical hit if the attacker is within 5 feet.</li></ul>`,
      name: "A5E.ConditionUnconscious",
      img: "icons/svg/unconscious.svg",
      changes: l.unconscious,
      duration: {},
      flags: {
        core: { overlay: !0 }
      },
      statuses: ["incapacitated"]
    },
    ...Array.from({ length: 10 }, (a, c) => ({
      id: `generic${c + 1}`,
      name: `Generic ${c + 1}`,
      img: `systems/a5e/assets/icons/circle${c + 1}.svg`,
      changes: [],
      duration: {}
    }))
  ];
  r = r.reduce((a, c) => {
    var f;
    return s && c.id === "strife" || (c.img = n[c.id] || i.conditionIconsDefault[c.id] || c.img, !t.has(c.id) && c.changes.length && (c.changes = []), s && c.id === "fatigue" && (c.changes = ((f = i.multiLevelConditions) == null ? void 0 : f.exhaustion) ?? [], c.name = "Exhaustion"), a.push(c)), a;
  }, []), CONFIG.statusEffects = r, CONFIG.A5E.linkedStatusEffects = r.reduce((a, c) => {
    var f;
    return (f = c.statuses) != null && f.length && c.statuses.forEach((d) => {
      a[d] ?? (a[d] = []), a[d].push(c.id);
    }), a;
  }, {});
}
u(pke, "registerConditionsConfig");
function mke() {
  game.settings.get("a5e", "showVRCSpecialties") || (delete CONFIG.A5E.skillSpecialties.arc.psionics, delete CONFIG.A5E.skillSpecialties.arc.psionicItems, delete CONFIG.A5E.skillSpecialties.arc.psionicCreatures, delete CONFIG.A5E.skillSpecialties.ath.zeroG, delete CONFIG.A5E.skillSpecialties.eng.robotics, delete CONFIG.A5E.skillSpecialties.eng.starships, delete CONFIG.A5E.skillSpecialties.eng.starshipEngines, delete CONFIG.A5E.skillSpecialties.eng.starshipShields, delete CONFIG.A5E.skillSpecialties.inv.sensors, delete CONFIG.A5E.skillSpecialties.med.xenobiology, delete CONFIG.A5E.skillSpecialties.sur.astrogation), game.settings.get("a5e", "showVRCProficiencies") || (delete CONFIG.A5E.maneuverTraditions.aceStarfighter, delete CONFIG.A5E.maneuverTraditions.blazingStarglaive, delete CONFIG.A5E.maneuverTraditions.mindfulBody, delete CONFIG.A5E.languages.machine, delete CONFIG.A5E.tools.vehicles.spaceVehicles, delete CONFIG.A5E.tools.miscellaneous.computers, delete CONFIG.A5E.tools.musicalInstruments.acousticGuitar, delete CONFIG.A5E.tools.musicalInstruments.electricGuitar, delete CONFIG.A5E.tools.musicalInstruments.harmonica, delete CONFIG.A5E.tools.musicalInstruments.keytar, delete CONFIG.A5E.tools.musicalInstruments.saxophone, delete CONFIG.A5E.tools.musicalInstruments.theremin, delete CONFIG.A5E.tools.specialist, delete CONFIG.A5E.weapons.simple.blaster, delete CONFIG.A5E.weapons.simple.joltPistol, delete CONFIG.A5E.weapons.simple.laserPistol, delete CONFIG.A5E.weapons.simple.slugger, delete CONFIG.A5E.weapons.simple.shockMace, delete CONFIG.A5E.weapons.simple.sonicMaul, delete CONFIG.A5E.weapons.simple.stunStick, delete CONFIG.A5E.weapons.simple.tacticalBaton, delete CONFIG.A5E.weapons.martial.battleGauntlet, delete CONFIG.A5E.weapons.martial.bioChakram, delete CONFIG.A5E.weapons.martial.combatChainsaw, delete CONFIG.A5E.weapons.martial.combatKnife, delete CONFIG.A5E.weapons.martial.duelingSword, delete CONFIG.A5E.weapons.martial.electroHalberd, delete CONFIG.A5E.weapons.martial.electroHalberd, delete CONFIG.A5E.weapons.martial.energyCrossbow, delete CONFIG.A5E.weapons.martial.flameBracer, delete CONFIG.A5E.weapons.martial.flamethrower, delete CONFIG.A5E.weapons.martial.grenadeLauncher, delete CONFIG.A5E.weapons.martial.hypodermicPistol, delete CONFIG.A5E.weapons.martial.ionCannon, delete CONFIG.A5E.weapons.martial.longspear, delete CONFIG.A5E.weapons.martial.monoWhip, delete CONFIG.A5E.weapons.martial.netcaster, delete CONFIG.A5E.weapons.martial.plasmaSword, delete CONFIG.A5E.weapons.martial.polaronGatlingGun, delete CONFIG.A5E.weapons.martial.pulseRifle, delete CONFIG.A5E.weapons.martial.shotgun, delete CONFIG.A5E.weapons.martial.slugRifle, delete CONFIG.A5E.weapons.martial.sniperRifle, delete CONFIG.A5E.weapons.martial.tkGauntlet, delete CONFIG.A5E.weapons.martial.vibroknife, delete CONFIG.A5E.weapons.martial.viperRetainer, delete CONFIG.A5E.weapons.miscellaneous.starship);
}
u(mke, "registerExtraContentConfig");
const hke = {
  archetypes: {
    packs: ["a5e.a5e-archetypes"],
    func: U5
  },
  classFeatures: {
    packs: ["a5e.a5e-class-features"],
    func: V5
  },
  manuevers: {
    packs: ["a5e.a5e-maneuvers"],
    func: $q
  },
  monsters: {
    packs: ["a5e.a5e-monsters"],
    func: W5
  },
  spells: {
    packs: ["a5e.a5e-spells"],
    func: Y5
  },
  dnd5eMonsters: {
    packs: ["a5e.dnd5e-monsters"],
    func: Aq
  },
  dnd5eSpells: {
    packs: ["a5e.dnd5e-spells"],
    func: Eq
  },
  objects: {
    packs: ["a5e.a5e-adventuring-gear", "a5e.dnd5e-items"],
    func: K5
  }
}, gke = {
  npc: W5,
  spell: Y5,
  object: K5,
  feature: V5,
  archetype: U5
};
function bke() {
  const i = /* @__PURE__ */ new Set();
  if (Object.values(hke).forEach(({ packs: e, func: t }) => {
    e.forEach((s) => {
      t(s), i.add(s);
    });
  }), !!game.settings.storage.get("world").getItem("a5e.autoApplyFancySheets"))
    for (const e of game.packs) {
      const t = e.metadata.id || e.collection;
      if (!t || !e.metadata.type) continue;
      const n = [...e.index].map((o) => o.type).filter(Boolean);
      if (!n.every((o) => n[0] === o)) continue;
      const l = n[0], r = gke[l];
      r && r(t);
    }
}
u(bke, "setupFancySheets");
function _ke() {
  const i = game.settings.get("a5e", "gamemasterTitle") || "Narrator";
  game.i18n.translations.USER.GM = i, game.i18n.translations.GM = i;
}
u(_ke, "updateGMTitle");
function yke() {
  fke(), pke(), mke(), bke(), _ke();
}
u(yke, "setup");
function vke(i, e, t, s) {
  const n = Object.keys(e).filter((r) => r !== "_id");
  new Set(n).has("ownership") && (i._sheet = void 0, i.getActiveTokens().forEach((o) => {
    o.actor._sheet = void 0;
  }));
}
u(vke, "updateActor");
Hooks.once("init", A0e);
Hooks.once("setup", yke);
Hooks.once("ready", B0e);
Hooks.on("canvasInit", aG);
Hooks.on("canvasReady", ele);
Hooks.on(
  "getActorDirectoryEntryContext",
  (i, e, t) => X5(i, e, t, "Actor")
);
Hooks.on(
  "getItemDirectoryEntryContext",
  (i, e, t) => X5(i, e, t, "Item")
);
Hooks.on(
  "getCompendiumDirectoryEntryContext",
  (i, e, t) => X5(i, e, t, "Pack")
);
Hooks.on("createActor", tle);
Hooks.on("createToken", ile);
Hooks.on("updateActor", vke);
Hooks.on("renderApplication", q0e);
Hooks.on("renderChatMessage", Wve);
Hooks.on("preCreateChatMessage", C0e);
Hooks.on("preDeleteChatMessage", S0e);
Hooks.on("renderSettings", oke);
Hooks.on("renderTokenHUDA5e", uke);
//# sourceMappingURL=a5e.js.map
